shadow$provide.module$node_modules$$supabase$auth_js$dist$main$GoTrueClient = function(global, require, module, exports) {
  async function lockNoOp(name, acquireTimeout, fn) {
    return await fn();
  }
  global = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {"default":mod};
  };
  Object.defineProperty(exports, "__esModule", {value:!0});
  const GoTrueAdminApi_1 = global(require("module$node_modules$$supabase$auth_js$dist$main$GoTrueAdminApi")), constants_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$constants"), errors_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$errors"), fetch_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$fetch"), helpers_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$helpers"), local_storage_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$local_storage");
  global = require("module$node_modules$$supabase$auth_js$dist$main$lib$polyfills");
  const version_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$version"), locks_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$locks");
  (0,global.polyfillGlobalThis)();
  const DEFAULT_OPTIONS = {url:constants_1.GOTRUE_URL, storageKey:constants_1.STORAGE_KEY, autoRefreshToken:!0, persistSession:!0, detectSessionInUrl:!0, headers:constants_1.DEFAULT_HEADERS, flowType:"implicit", debug:!1, hasCustomAuthorizationHeader:!1};
  class GoTrueClient {
    constructor(options) {
      var _a, _b;
      this.memoryStorage = null;
      this.stateChangeEmitters = new Map();
      this.initializePromise = this.refreshingDeferred = this.visibilityChangedCallback = this.autoRefreshTicker = null;
      this.detectSessionInUrl = !0;
      this.lockAcquired = this.suppressGetSessionWarning = this.hasCustomAuthorizationHeader = !1;
      this.pendingInLock = [];
      this.broadcastChannel = null;
      this.logger = console.log;
      this.instanceID = GoTrueClient.nextInstanceID;
      GoTrueClient.nextInstanceID += 1;
      0 < this.instanceID && (0,helpers_1.isBrowser)() && console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
      options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
      this.logDebugMessages = !!options.debug;
      "function" === typeof options.debug && (this.logger = options.debug);
      this.persistSession = options.persistSession;
      this.storageKey = options.storageKey;
      this.autoRefreshToken = options.autoRefreshToken;
      this.admin = new GoTrueAdminApi_1.default({url:options.url, headers:options.headers, fetch:options.fetch});
      this.url = options.url;
      this.headers = options.headers;
      this.fetch = (0,helpers_1.resolveFetch)(options.fetch);
      this.lock = options.lock || lockNoOp;
      this.detectSessionInUrl = options.detectSessionInUrl;
      this.flowType = options.flowType;
      this.hasCustomAuthorizationHeader = options.hasCustomAuthorizationHeader;
      options.lock ? this.lock = options.lock : (0,helpers_1.isBrowser)() && (null === (_a = null === globalThis || void 0 === globalThis ? void 0 : globalThis.navigator) || void 0 === _a ? 0 : _a.locks) ? this.lock = locks_1.navigatorLock : this.lock = lockNoOp;
      this.mfa = {verify:this._verify.bind(this), enroll:this._enroll.bind(this), unenroll:this._unenroll.bind(this), challenge:this._challenge.bind(this), listFactors:this._listFactors.bind(this), challengeAndVerify:this._challengeAndVerify.bind(this), getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this)};
      this.persistSession ? options.storage ? this.storage = options.storage : (0,helpers_1.supportsLocalStorage)() ? this.storage = local_storage_1.localStorageAdapter : (this.memoryStorage = {}, this.storage = (0,local_storage_1.memoryLocalStorageAdapter)(this.memoryStorage)) : (this.memoryStorage = {}, this.storage = (0,local_storage_1.memoryLocalStorageAdapter)(this.memoryStorage));
      if ((0,helpers_1.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
        try {
          this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
        } catch (e) {
          console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e);
        }
        null === (_b = this.broadcastChannel) || void 0 === _b || _b.addEventListener("message", async event => {
          this._debug("received broadcast notification from other tab or client", event);
          await this._notifyAllSubscribers(event.data.event, event.data.session, !1);
        });
      }
      this.initialize();
    }
    _debug(...args) {
      this.logDebugMessages && this.logger(`GoTrueClient@${this.instanceID} (${version_1.version}) ${(new Date()).toISOString()}`, ...args);
      return this;
    }
    async initialize() {
      if (this.initializePromise) {
        return await this.initializePromise;
      }
      this.initializePromise = (async() => await this._acquireLock(-1, async() => await this._initialize()))();
      return await this.initializePromise;
    }
    async _initialize() {
      var _a;
      try {
        const params = (0,helpers_1.parseParametersFromURL)(window.location.href);
        let callbackUrlType = "none";
        this._isImplicitGrantCallback(params) ? callbackUrlType = "implicit" : await this._isPKCECallback(params) && (callbackUrlType = "pkce");
        if ((0,helpers_1.isBrowser)() && this.detectSessionInUrl && "none" !== callbackUrlType) {
          const {data, error} = await this._getSessionFromURL(params, callbackUrlType);
          if (error) {
            this._debug("#_initialize()", "error detecting session from URL", error);
            if ((0,errors_1.isAuthImplicitGrantRedirectError)(error)) {
              const errorCode = null === (_a = error.details) || void 0 === _a ? void 0 : _a.code;
              if ("identity_already_exists" === errorCode || "identity_not_found" === errorCode || "single_identity_not_deletable" === errorCode) {
                return {error};
              }
            }
            await this._removeSession();
            return {error};
          }
          const {session, redirectType} = data;
          this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
          await this._saveSession(session);
          setTimeout(async() => {
            "recovery" === redirectType ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", session) : await this._notifyAllSubscribers("SIGNED_IN", session);
          }, 0);
          return {error:null};
        }
        await this._recoverAndRefresh();
        return {error:null};
      } catch (error) {
        return (0,errors_1.isAuthError)(error) ? {error} : {error:new errors_1.AuthUnknownError("Unexpected error during initialization", error)};
      } finally {
        await this._handleVisibilityChange(), this._debug("#_initialize()", "end");
      }
    }
    async signInAnonymously(credentials) {
      var _a, _b, _c;
      try {
        const res = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/signup`, {headers:this.headers, body:{data:null !== (_b = null === (_a = null === credentials || void 0 === credentials ? void 0 : credentials.options) || void 0 === _a ? void 0 : _a.data) && void 0 !== _b ? _b : {}, gotrue_meta_security:{captcha_token:null === (_c = null === credentials || void 0 === credentials ? void 0 : credentials.options) || void 0 === _c ? void 0 : _c.captchaToken}}, xform:fetch_1._sessionResponse}), 
        {data, error} = res;
        if (error || !data) {
          return {data:{user:null, session:null}, error};
        }
        const session = data.session, user = data.user;
        data.session && (await this._saveSession(data.session), await this._notifyAllSubscribers("SIGNED_IN", session));
        return {data:{user, session}, error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null, session:null}, error};
        }
        throw error;
      }
    }
    async signUp(credentials) {
      var _a, _c;
      try {
        let res;
        if ("email" in credentials) {
          const {email, password, options} = credentials;
          var _b = credentials = null;
          "pkce" === this.flowType && ([credentials, _b] = await (0,helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey));
          res = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/signup`, {headers:this.headers, redirectTo:null === options || void 0 === options ? void 0 : options.emailRedirectTo, body:{email, password, data:null !== (_a = null === options || void 0 === options ? void 0 : options.data) && void 0 !== _a ? _a : {}, gotrue_meta_security:{captcha_token:null === options || void 0 === options ? void 0 : options.captchaToken}, code_challenge:credentials, code_challenge_method:_b}, xform:fetch_1._sessionResponse});
        } else if ("phone" in credentials) {
          const {phone, password, options} = credentials;
          res = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/signup`, {headers:this.headers, body:{phone, password, data:null !== (_b = null === options || void 0 === options ? void 0 : options.data) && void 0 !== _b ? _b : {}, channel:null !== (_c = null === options || void 0 === options ? void 0 : options.channel) && void 0 !== _c ? _c : "sms", gotrue_meta_security:{captcha_token:null === options || void 0 === options ? void 0 : options.captchaToken}}, xform:fetch_1._sessionResponse});
        } else {
          throw new errors_1.AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
        }
        const {data, error} = res;
        if (error || !data) {
          return {data:{user:null, session:null}, error};
        }
        const session = data.session, user = data.user;
        data.session && (await this._saveSession(data.session), await this._notifyAllSubscribers("SIGNED_IN", session));
        return {data:{user, session}, error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null, session:null}, error};
        }
        throw error;
      }
    }
    async signInWithPassword(credentials) {
      try {
        let res;
        if ("email" in credentials) {
          const {email, password, options} = credentials;
          res = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=password`, {headers:this.headers, body:{email, password, gotrue_meta_security:{captcha_token:null === options || void 0 === options ? void 0 : options.captchaToken}}, xform:fetch_1._sessionResponsePassword});
        } else if ("phone" in credentials) {
          const {phone, password, options} = credentials;
          res = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=password`, {headers:this.headers, body:{phone, password, gotrue_meta_security:{captcha_token:null === options || void 0 === options ? void 0 : options.captchaToken}}, xform:fetch_1._sessionResponsePassword});
        } else {
          throw new errors_1.AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
        }
        const {data, error} = res;
        if (error) {
          return {data:{user:null, session:null}, error};
        }
        if (!data || !data.session || !data.user) {
          return {data:{user:null, session:null}, error:new errors_1.AuthInvalidTokenResponseError()};
        }
        data.session && (await this._saveSession(data.session), await this._notifyAllSubscribers("SIGNED_IN", data.session));
        return {data:Object.assign({user:data.user, session:data.session}, data.weak_password ? {weakPassword:data.weak_password} : null), error};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null, session:null}, error};
        }
        throw error;
      }
    }
    async signInWithOAuth(credentials) {
      var _a, _b, _c, _d;
      return await this._handleProviderSignIn(credentials.provider, {redirectTo:null === (_a = credentials.options) || void 0 === _a ? void 0 : _a.redirectTo, scopes:null === (_b = credentials.options) || void 0 === _b ? void 0 : _b.scopes, queryParams:null === (_c = credentials.options) || void 0 === _c ? void 0 : _c.queryParams, skipBrowserRedirect:null === (_d = credentials.options) || void 0 === _d ? void 0 : _d.skipBrowserRedirect});
    }
    async exchangeCodeForSession(authCode) {
      await this.initializePromise;
      return this._acquireLock(-1, async() => this._exchangeCodeForSession(authCode));
    }
    async _exchangeCodeForSession(authCode) {
      const storageItem = await (0,helpers_1.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`), [codeVerifier, redirectType] = (null !== storageItem && void 0 !== storageItem ? storageItem : "").split("/");
      try {
        const {data, error} = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {headers:this.headers, body:{auth_code:authCode, code_verifier:codeVerifier}, xform:fetch_1._sessionResponse});
        await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        if (error) {
          throw error;
        }
        if (!data || !data.session || !data.user) {
          return {data:{user:null, session:null, redirectType:null}, error:new errors_1.AuthInvalidTokenResponseError()};
        }
        data.session && (await this._saveSession(data.session), await this._notifyAllSubscribers("SIGNED_IN", data.session));
        return {data:Object.assign(Object.assign({}, data), {redirectType:null !== redirectType && void 0 !== redirectType ? redirectType : null}), error};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null, session:null, redirectType:null}, error};
        }
        throw error;
      }
    }
    async signInWithIdToken(credentials) {
      try {
        const {options, provider, token, access_token, nonce} = credentials, res = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {headers:this.headers, body:{provider, id_token:token, access_token, nonce, gotrue_meta_security:{captcha_token:null === options || void 0 === options ? void 0 : options.captchaToken}}, xform:fetch_1._sessionResponse}), {data, error} = res;
        if (error) {
          return {data:{user:null, session:null}, error};
        }
        if (!data || !data.session || !data.user) {
          return {data:{user:null, session:null}, error:new errors_1.AuthInvalidTokenResponseError()};
        }
        data.session && (await this._saveSession(data.session), await this._notifyAllSubscribers("SIGNED_IN", data.session));
        return {data, error};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null, session:null}, error};
        }
        throw error;
      }
    }
    async signInWithOtp(credentials) {
      var _a, _b, _d, _e;
      try {
        if ("email" in credentials) {
          const {email, options} = credentials;
          var _c = credentials = null;
          "pkce" === this.flowType && ([credentials, _c] = await (0,helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey));
          const {error} = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/otp`, {headers:this.headers, body:{email, data:null !== (_a = null === options || void 0 === options ? void 0 : options.data) && void 0 !== _a ? _a : {}, create_user:null !== (_b = null === options || void 0 === options ? void 0 : options.shouldCreateUser) && void 0 !== _b ? _b : !0, gotrue_meta_security:{captcha_token:null === options || void 0 === options ? void 0 : options.captchaToken}, code_challenge:credentials, 
          code_challenge_method:_c}, redirectTo:null === options || void 0 === options ? void 0 : options.emailRedirectTo});
          return {data:{user:null, session:null}, error};
        }
        if ("phone" in credentials) {
          const {phone, options} = credentials, {data, error} = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/otp`, {headers:this.headers, body:{phone, data:null !== (_c = null === options || void 0 === options ? void 0 : options.data) && void 0 !== _c ? _c : {}, create_user:null !== (_d = null === options || void 0 === options ? void 0 : options.shouldCreateUser) && void 0 !== _d ? _d : !0, gotrue_meta_security:{captcha_token:null === options || void 0 === options ? void 0 : options.captchaToken}, 
          channel:null !== (_e = null === options || void 0 === options ? void 0 : options.channel) && void 0 !== _e ? _e : "sms"}});
          return {data:{user:null, session:null, messageId:null === data || void 0 === data ? void 0 : data.message_id}, error};
        }
        throw new errors_1.AuthInvalidCredentialsError("You must provide either an email or phone number.");
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null, session:null}, error};
        }
        throw error;
      }
    }
    async verifyOtp(params) {
      var _a, _b;
      try {
        let redirectTo = void 0, captchaToken = void 0;
        "options" in params && (redirectTo = null === (_a = params.options) || void 0 === _a ? void 0 : _a.redirectTo, captchaToken = null === (_b = params.options) || void 0 === _b ? void 0 : _b.captchaToken);
        const {data, error} = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/verify`, {headers:this.headers, body:Object.assign(Object.assign({}, params), {gotrue_meta_security:{captcha_token:captchaToken}}), redirectTo, xform:fetch_1._sessionResponse});
        if (error) {
          throw error;
        }
        if (!data) {
          throw Error("An error occurred on token verification.");
        }
        const session = data.session, user = data.user;
        if (null === session || void 0 === session ? 0 : session.access_token) {
          await this._saveSession(session), await this._notifyAllSubscribers("recovery" == params.type ? "PASSWORD_RECOVERY" : "SIGNED_IN", session);
        }
        return {data:{user, session}, error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null, session:null}, error};
        }
        throw error;
      }
    }
    async signInWithSSO(params) {
      var _a, _b, _c;
      try {
        let codeChallenge = null, codeChallengeMethod = null;
        "pkce" === this.flowType && ([codeChallenge, codeChallengeMethod] = await (0,helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey));
        return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/sso`, {body:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params ? {provider_id:params.providerId} : null), "domain" in params ? {domain:params.domain} : null), {redirect_to:null !== (_b = null === (_a = params.options) || void 0 === _a ? void 0 : _a.redirectTo) && void 0 !== _b ? _b : void 0}), (null === (_c = null === params || void 0 === params ? void 0 : params.options) || void 0 === 
        _c ? 0 : _c.captchaToken) ? {gotrue_meta_security:{captcha_token:params.options.captchaToken}} : null), {skip_http_redirect:!0, code_challenge:codeChallenge, code_challenge_method:codeChallengeMethod}), headers:this.headers, xform:fetch_1._ssoResponse});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async reauthenticate() {
      await this.initializePromise;
      return await this._acquireLock(-1, async() => await this._reauthenticate());
    }
    async _reauthenticate() {
      try {
        return await this._useSession(async result => {
          const {data:{session}, error:sessionError} = result;
          if (sessionError) {
            throw sessionError;
          }
          if (!session) {
            throw new errors_1.AuthSessionMissingError();
          }
          ({error:result} = await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/reauthenticate`, {headers:this.headers, jwt:session.access_token}));
          return {data:{user:null, session:null}, error:result};
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null, session:null}, error};
        }
        throw error;
      }
    }
    async resend(credentials) {
      try {
        const endpoint = `${this.url}/resend`;
        if ("email" in credentials) {
          const {email, type, options} = credentials, {error} = await (0,fetch_1._request)(this.fetch, "POST", endpoint, {headers:this.headers, body:{email, type, gotrue_meta_security:{captcha_token:null === options || void 0 === options ? void 0 : options.captchaToken}}, redirectTo:null === options || void 0 === options ? void 0 : options.emailRedirectTo});
          return {data:{user:null, session:null}, error};
        }
        if ("phone" in credentials) {
          const {phone, type, options} = credentials, {data, error} = await (0,fetch_1._request)(this.fetch, "POST", endpoint, {headers:this.headers, body:{phone, type, gotrue_meta_security:{captcha_token:null === options || void 0 === options ? void 0 : options.captchaToken}}});
          return {data:{user:null, session:null, messageId:null === data || void 0 === data ? void 0 : data.message_id}, error};
        }
        throw new errors_1.AuthInvalidCredentialsError("You must provide either an email or phone number and a type");
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null, session:null}, error};
        }
        throw error;
      }
    }
    async getSession() {
      await this.initializePromise;
      return await this._acquireLock(-1, async() => this._useSession(async result => result));
    }
    async _acquireLock(acquireTimeout, fn) {
      this._debug("#_acquireLock", "begin", acquireTimeout);
      try {
        if (this.lockAcquired) {
          const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve(), result = (async() => {
            await last;
            return await fn();
          })();
          this.pendingInLock.push((async() => {
            try {
              await result;
            } catch (e) {
            }
          })());
          return result;
        }
        return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async() => {
          this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
          try {
            this.lockAcquired = !0;
            const result = fn();
            this.pendingInLock.push((async() => {
              try {
                await result;
              } catch (e) {
              }
            })());
            for (await result; this.pendingInLock.length;) {
              const waitOn = [...this.pendingInLock];
              await Promise.all(waitOn);
              this.pendingInLock.splice(0, waitOn.length);
            }
            return await result;
          } finally {
            this._debug("#_acquireLock", "lock released for storage key", this.storageKey), this.lockAcquired = !1;
          }
        });
      } finally {
        this._debug("#_acquireLock", "end");
      }
    }
    async _useSession(fn) {
      this._debug("#_useSession", "begin");
      try {
        const result = await this.__loadSession();
        return await fn(result);
      } finally {
        this._debug("#_useSession", "end");
      }
    }
    async __loadSession() {
      this._debug("#__loadSession()", "begin");
      this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", Error().stack);
      try {
        let currentSession = null;
        const maybeSession = await (0,helpers_1.getItemAsync)(this.storage, this.storageKey);
        this._debug("#getSession()", "session from storage", maybeSession);
        null !== maybeSession && (this._isValidSession(maybeSession) ? currentSession = maybeSession : (this._debug("#getSession()", "session from storage is not valid"), await this._removeSession()));
        if (!currentSession) {
          return {data:{session:null}, error:null};
        }
        const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : !1;
        this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
        if (!hasExpired) {
          if (this.storage.isServer) {
            let suppressWarning = this.suppressGetSessionWarning;
            currentSession = new Proxy(currentSession, {get:(target, prop, receiver) => {
              suppressWarning || "user" !== prop || (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."), this.suppressGetSessionWarning = suppressWarning = !0);
              return Reflect.get(target, prop, receiver);
            }});
          }
          return {data:{session:currentSession}, error:null};
        }
        const {session, error} = await this._callRefreshToken(currentSession.refresh_token);
        return error ? {data:{session:null}, error} : {data:{session}, error:null};
      } finally {
        this._debug("#__loadSession()", "end");
      }
    }
    async getUser(jwt) {
      if (jwt) {
        return await this._getUser(jwt);
      }
      await this.initializePromise;
      return await this._acquireLock(-1, async() => await this._getUser());
    }
    async _getUser(jwt) {
      try {
        return jwt ? await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/user`, {headers:this.headers, jwt, xform:fetch_1._userResponse}) : await this._useSession(async result => {
          var _a, _b, _c;
          const {data, error} = result;
          if (error) {
            throw error;
          }
          return null !== (_a = data.session) && void 0 !== _a && _a.access_token || this.hasCustomAuthorizationHeader ? await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/user`, {headers:this.headers, jwt:null !== (_c = null === (_b = data.session) || void 0 === _b ? void 0 : _b.access_token) && void 0 !== _c ? _c : void 0, xform:fetch_1._userResponse}) : {data:{user:null}, error:new errors_1.AuthSessionMissingError()};
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return (0,errors_1.isAuthSessionMissingError)(error) && (await this._removeSession(), await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`)), {data:{user:null}, error};
        }
        throw error;
      }
    }
    async updateUser(attributes, options = {}) {
      await this.initializePromise;
      return await this._acquireLock(-1, async() => await this._updateUser(attributes, options));
    }
    async _updateUser(attributes, options = {}) {
      try {
        return await this._useSession(async result => {
          const {data:sessionData, error:sessionError} = result;
          if (sessionError) {
            throw sessionError;
          }
          if (!sessionData.session) {
            throw new errors_1.AuthSessionMissingError();
          }
          result = sessionData.session;
          let codeChallenge = null, codeChallengeMethod = null;
          "pkce" === this.flowType && null != attributes.email && ([codeChallenge, codeChallengeMethod] = await (0,helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey));
          const {data, error:userError} = await (0,fetch_1._request)(this.fetch, "PUT", `${this.url}/user`, {headers:this.headers, redirectTo:null === options || void 0 === options ? void 0 : options.emailRedirectTo, body:Object.assign(Object.assign({}, attributes), {code_challenge:codeChallenge, code_challenge_method:codeChallengeMethod}), jwt:result.access_token, xform:fetch_1._userResponse});
          if (userError) {
            throw userError;
          }
          result.user = data.user;
          await this._saveSession(result);
          await this._notifyAllSubscribers("USER_UPDATED", result);
          return {data:{user:result.user}, error:null};
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null}, error};
        }
        throw error;
      }
    }
    _decodeJWT(jwt) {
      return (0,helpers_1.decodeJWTPayload)(jwt);
    }
    async setSession(currentSession) {
      await this.initializePromise;
      return await this._acquireLock(-1, async() => await this._setSession(currentSession));
    }
    async _setSession(currentSession) {
      try {
        if (!currentSession.access_token || !currentSession.refresh_token) {
          throw new errors_1.AuthSessionMissingError();
        }
        const timeNow = Date.now() / 1000;
        let expiresAt = timeNow, hasExpired = !0, session = null;
        const payload = (0,helpers_1.decodeJWTPayload)(currentSession.access_token);
        payload.exp && (expiresAt = payload.exp, hasExpired = expiresAt <= timeNow);
        if (hasExpired) {
          const {session:refreshedSession, error} = await this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            return {data:{user:null, session:null}, error};
          }
          if (!refreshedSession) {
            return {data:{user:null, session:null}, error:null};
          }
          session = refreshedSession;
        } else {
          const {data, error} = await this._getUser(currentSession.access_token);
          if (error) {
            throw error;
          }
          session = {access_token:currentSession.access_token, refresh_token:currentSession.refresh_token, user:data.user, token_type:"bearer", expires_in:expiresAt - timeNow, expires_at:expiresAt};
          await this._saveSession(session);
          await this._notifyAllSubscribers("SIGNED_IN", session);
        }
        return {data:{user:session.user, session}, error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{session:null, user:null}, error};
        }
        throw error;
      }
    }
    async refreshSession(currentSession) {
      await this.initializePromise;
      return await this._acquireLock(-1, async() => await this._refreshSession(currentSession));
    }
    async _refreshSession(currentSession) {
      try {
        return await this._useSession(async result => {
          var _a;
          if (!currentSession) {
            const {data, error} = result;
            if (error) {
              throw error;
            }
            currentSession = null !== (_a = data.session) && void 0 !== _a ? _a : void 0;
          }
          if (null === currentSession || void 0 === currentSession || !currentSession.refresh_token) {
            throw new errors_1.AuthSessionMissingError();
          }
          const {session, error} = await this._callRefreshToken(currentSession.refresh_token);
          return error ? {data:{user:null, session:null}, error} : session ? {data:{user:session.user, session}, error:null} : {data:{user:null, session:null}, error:null};
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null, session:null}, error};
        }
        throw error;
      }
    }
    async _getSessionFromURL(params, callbackUrlType) {
      try {
        if (!(0,helpers_1.isBrowser)()) {
          throw new errors_1.AuthImplicitGrantRedirectError("No browser detected.");
        }
        if (params.error || params.error_description || params.error_code) {
          throw new errors_1.AuthImplicitGrantRedirectError(params.error_description || "Error in URL with unspecified error_description", {error:params.error || "unspecified_error", code:params.error_code || "unspecified_code"});
        }
        switch(callbackUrlType) {
          case "implicit":
            if ("pkce" === this.flowType) {
              throw new errors_1.AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");
            }
            break;
          case "pkce":
            if ("implicit" === this.flowType) {
              throw new errors_1.AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.");
            }
        }
        if ("pkce" === callbackUrlType) {
          this._debug("#_initialize()", "begin", "is PKCE flow", !0);
          if (!params.code) {
            throw new errors_1.AuthPKCEGrantCodeExchangeError("No code detected.");
          }
          const {data, error} = await this._exchangeCodeForSession(params.code);
          if (error) {
            throw error;
          }
          var url = new URL(window.location.href);
          url.searchParams.delete("code");
          window.history.replaceState(window.history.state, "", url.toString());
          return {data:{session:data.session, redirectType:null}, error:null};
        }
        const {provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type} = params;
        if (!(access_token && expires_in && refresh_token && token_type)) {
          throw new errors_1.AuthImplicitGrantRedirectError("No session defined in URL");
        }
        const timeNow = Math.round(Date.now() / 1000), expiresIn = parseInt(expires_in);
        callbackUrlType = timeNow + expiresIn;
        expires_at && (callbackUrlType = parseInt(expires_at));
        url = callbackUrlType - timeNow;
        3E4 >= 1000 * url && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${url}s, should have been closer to ${expiresIn}s`);
        url = callbackUrlType - expiresIn;
        120 <= timeNow - url ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", url, callbackUrlType, timeNow) : 0 > timeNow - url && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", url, callbackUrlType, timeNow);
        const {data, error} = await this._getUser(access_token);
        if (error) {
          throw error;
        }
        const session = {provider_token, provider_refresh_token, access_token, expires_in:expiresIn, expires_at:callbackUrlType, refresh_token, token_type, user:data.user};
        window.location.hash = "";
        this._debug("#_getSessionFromURL()", "clearing window.location.hash");
        return {data:{session, redirectType:params.type}, error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{session:null, redirectType:null}, error};
        }
        throw error;
      }
    }
    _isImplicitGrantCallback(params) {
      return !(!params.access_token && !params.error_description);
    }
    async _isPKCECallback(params) {
      const currentStorageContent = await (0,helpers_1.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
      return !(!params.code || !currentStorageContent);
    }
    async signOut(options = {scope:"global"}) {
      await this.initializePromise;
      return await this._acquireLock(-1, async() => await this._signOut(options));
    }
    async _signOut({scope} = {scope:"global"}) {
      return await this._useSession(async result => {
        var _a;
        const {data, error:sessionError} = result;
        if (sessionError) {
          return {error:sessionError};
        }
        if (result = null === (_a = data.session) || void 0 === _a ? void 0 : _a.access_token) {
          if ({error:_a} = await this.admin.signOut(result, scope), _a && (!(0,errors_1.isAuthApiError)(_a) || 404 !== _a.status && 401 !== _a.status && 403 !== _a.status)) {
            return {error:_a};
          }
        }
        "others" !== scope && (await this._removeSession(), await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`));
        return {error:null};
      });
    }
    onAuthStateChange(callback) {
      const id = (0,helpers_1.uuid)();
      callback = {id, callback, unsubscribe:() => {
        this._debug("#unsubscribe()", "state change callback with id removed", id);
        this.stateChangeEmitters.delete(id);
      }};
      this._debug("#onAuthStateChange()", "registered callback with id", id);
      this.stateChangeEmitters.set(id, callback);
      (async() => {
        await this.initializePromise;
        await this._acquireLock(-1, async() => {
          this._emitInitialSession(id);
        });
      })();
      return {data:{subscription:callback}};
    }
    async _emitInitialSession(id) {
      return await this._useSession(async result => {
        var _a, _b;
        try {
          const {data:{session}, error} = result;
          if (error) {
            throw error;
          }
          await (null === (_a = this.stateChangeEmitters.get(id)) || void 0 === _a ? void 0 : _a.callback("INITIAL_SESSION", session));
          this._debug("INITIAL_SESSION", "callback id", id, "session", session);
        } catch (err) {
          await (null === (_b = this.stateChangeEmitters.get(id)) || void 0 === _b ? void 0 : _b.callback("INITIAL_SESSION", null)), this._debug("INITIAL_SESSION", "callback id", id, "error", err), console.error(err);
        }
      });
    }
    async resetPasswordForEmail(email, options = {}) {
      let codeChallenge = null, codeChallengeMethod = null;
      "pkce" === this.flowType && ([codeChallenge, codeChallengeMethod] = await (0,helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey, !0));
      try {
        return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/recover`, {body:{email, code_challenge:codeChallenge, code_challenge_method:codeChallengeMethod, gotrue_meta_security:{captcha_token:options.captchaToken}}, headers:this.headers, redirectTo:options.redirectTo});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async getUserIdentities() {
      var _a;
      try {
        const {data, error} = await this.getUser();
        if (error) {
          throw error;
        }
        return {data:{identities:null !== (_a = data.user.identities) && void 0 !== _a ? _a : []}, error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async linkIdentity(credentials) {
      var _a;
      try {
        const {data, error} = await this._useSession(async result => {
          var _a, _b, _c, _d, _e;
          const {data, error} = result;
          if (error) {
            throw error;
          }
          result = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {redirectTo:null === (_a = credentials.options) || void 0 === _a ? void 0 : _a.redirectTo, scopes:null === (_b = credentials.options) || void 0 === _b ? void 0 : _b.scopes, queryParams:null === (_c = credentials.options) || void 0 === _c ? void 0 : _c.queryParams, skipBrowserRedirect:!0});
          return await (0,fetch_1._request)(this.fetch, "GET", result, {headers:this.headers, jwt:null !== (_e = null === (_d = data.session) || void 0 === _d ? void 0 : _d.access_token) && void 0 !== _e ? _e : void 0});
        });
        if (error) {
          throw error;
        }
        !(0,helpers_1.isBrowser)() || (null === (_a = credentials.options) || void 0 === _a ? 0 : _a.skipBrowserRedirect) || window.location.assign(null === data || void 0 === data ? void 0 : data.url);
        return {data:{provider:credentials.provider, url:null === data || void 0 === data ? void 0 : data.url}, error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{provider:credentials.provider, url:null}, error};
        }
        throw error;
      }
    }
    async unlinkIdentity(identity) {
      try {
        return await this._useSession(async result => {
          var _a, _b;
          const {data, error} = result;
          if (error) {
            throw error;
          }
          return await (0,fetch_1._request)(this.fetch, "DELETE", `${this.url}/user/identities/${identity.identity_id}`, {headers:this.headers, jwt:null !== (_b = null === (_a = data.session) || void 0 === _a ? void 0 : _a.access_token) && void 0 !== _b ? _b : void 0});
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async _refreshAccessToken(refreshToken) {
      const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
      this._debug(debugName, "begin");
      try {
        const startedAt = Date.now();
        return await (0,helpers_1.retryable)(async attempt => {
          0 < attempt && await (0,helpers_1.sleep)(200 * Math.pow(2, attempt - 1));
          this._debug(debugName, "refreshing attempt", attempt);
          return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {body:{refresh_token:refreshToken}, headers:this.headers, xform:fetch_1._sessionResponse});
        }, (attempt, error) => {
          attempt = 200 * Math.pow(2, attempt);
          return error && (0,errors_1.isAuthRetryableFetchError)(error) && 3E4 > Date.now() + attempt - startedAt;
        });
      } catch (error) {
        this._debug(debugName, "error", error);
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{session:null, user:null}, error};
        }
        throw error;
      } finally {
        this._debug(debugName, "end");
      }
    }
    _isValidSession(maybeSession) {
      return "object" === typeof maybeSession && null !== maybeSession && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
    }
    async _handleProviderSignIn(provider, options) {
      const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {redirectTo:options.redirectTo, scopes:options.scopes, queryParams:options.queryParams});
      this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
      (0,helpers_1.isBrowser)() && !options.skipBrowserRedirect && window.location.assign(url);
      return {data:{provider, url}, error:null};
    }
    async _recoverAndRefresh() {
      var _a;
      this._debug("#_recoverAndRefresh()", "begin");
      try {
        const currentSession = await (0,helpers_1.getItemAsync)(this.storage, this.storageKey);
        this._debug("#_recoverAndRefresh()", "session from storage", currentSession);
        if (this._isValidSession(currentSession)) {
          var timeNow = Math.round(Date.now() / 1000), expiresWithMargin = (null !== (_a = currentSession.expires_at) && void 0 !== _a ? _a : Infinity) < timeNow + constants_1.EXPIRY_MARGIN;
          this._debug("#_recoverAndRefresh()", `session has${expiresWithMargin ? "" : " not"} expired with margin of ${constants_1.EXPIRY_MARGIN}s`);
          if (expiresWithMargin) {
            if (this.autoRefreshToken && currentSession.refresh_token) {
              const {error} = await this._callRefreshToken(currentSession.refresh_token);
              error && (console.error(error), (0,errors_1.isAuthRetryableFetchError)(error) || (this._debug("#_recoverAndRefresh()", "refresh failed with a non-retryable error, removing the session", error), await this._removeSession()));
            }
          } else {
            await this._notifyAllSubscribers("SIGNED_IN", currentSession);
          }
        } else {
          this._debug("#_recoverAndRefresh()", "session is not valid"), null !== currentSession && await this._removeSession();
        }
      } catch (err) {
        this._debug("#_recoverAndRefresh()", "error", err), console.error(err);
      } finally {
        this._debug("#_recoverAndRefresh()", "end");
      }
    }
    async _callRefreshToken(refreshToken) {
      var _a, _b;
      if (!refreshToken) {
        throw new errors_1.AuthSessionMissingError();
      }
      if (this.refreshingDeferred) {
        return this.refreshingDeferred.promise;
      }
      const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
      this._debug(debugName, "begin");
      try {
        this.refreshingDeferred = new helpers_1.Deferred();
        const {data, error} = await this._refreshAccessToken(refreshToken);
        if (error) {
          throw error;
        }
        if (!data.session) {
          throw new errors_1.AuthSessionMissingError();
        }
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
        const result = {session:data.session, error:null};
        this.refreshingDeferred.resolve(result);
        return result;
      } catch (error) {
        this._debug(debugName, "error", error);
        if ((0,errors_1.isAuthError)(error)) {
          return refreshToken = {session:null, error}, (0,errors_1.isAuthRetryableFetchError)(error) || await this._removeSession(), null === (_a = this.refreshingDeferred) || void 0 === _a || _a.resolve(refreshToken), refreshToken;
        }
        null === (_b = this.refreshingDeferred) || void 0 === _b || _b.reject(error);
        throw error;
      } finally {
        this.refreshingDeferred = null, this._debug(debugName, "end");
      }
    }
    async _notifyAllSubscribers(event, session, broadcast = !0) {
      const debugName = `#_notifyAllSubscribers(${event})`;
      this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
      try {
        this.broadcastChannel && broadcast && this.broadcastChannel.postMessage({event, session});
        const errors = [], promises = Array.from(this.stateChangeEmitters.values()).map(async x => {
          try {
            await x.callback(event, session);
          } catch (e) {
            errors.push(e);
          }
        });
        await Promise.all(promises);
        if (0 < errors.length) {
          for (broadcast = 0; broadcast < errors.length; broadcast += 1) {
            console.error(errors[broadcast]);
          }
          throw errors[0];
        }
      } finally {
        this._debug(debugName, "end");
      }
    }
    async _saveSession(session) {
      this._debug("#_saveSession()", session);
      this.suppressGetSessionWarning = !0;
      await (0,helpers_1.setItemAsync)(this.storage, this.storageKey, session);
    }
    async _removeSession() {
      this._debug("#_removeSession()");
      await (0,helpers_1.removeItemAsync)(this.storage, this.storageKey);
      await this._notifyAllSubscribers("SIGNED_OUT", null);
    }
    _removeVisibilityChangedCallback() {
      this._debug("#_removeVisibilityChangedCallback()");
      const callback = this.visibilityChangedCallback;
      this.visibilityChangedCallback = null;
      try {
        callback && (0,helpers_1.isBrowser)() && (null === window || void 0 === window ? 0 : window.removeEventListener) && window.removeEventListener("visibilitychange", callback);
      } catch (e) {
        console.error("removing visibilitychange callback failed", e);
      }
    }
    async _startAutoRefresh() {
      await this._stopAutoRefresh();
      this._debug("#_startAutoRefresh()");
      const ticker = setInterval(() => this._autoRefreshTokenTick(), 3E4);
      (this.autoRefreshTicker = ticker) && "object" === typeof ticker && "function" === typeof ticker.unref ? ticker.unref() : "undefined" !== typeof Deno && "function" === typeof Deno.unrefTimer && Deno.unrefTimer(ticker);
      setTimeout(async() => {
        await this.initializePromise;
        await this._autoRefreshTokenTick();
      }, 0);
    }
    async _stopAutoRefresh() {
      this._debug("#_stopAutoRefresh()");
      const ticker = this.autoRefreshTicker;
      this.autoRefreshTicker = null;
      ticker && clearInterval(ticker);
    }
    async startAutoRefresh() {
      this._removeVisibilityChangedCallback();
      await this._startAutoRefresh();
    }
    async stopAutoRefresh() {
      this._removeVisibilityChangedCallback();
      await this._stopAutoRefresh();
    }
    async _autoRefreshTokenTick() {
      this._debug("#_autoRefreshTokenTick()", "begin");
      try {
        await this._acquireLock(0, async() => {
          try {
            const now = Date.now();
            try {
              return await this._useSession(async result => {
                ({data:{session:result}} = result);
                if (result && result.refresh_token && result.expires_at) {
                  var expiresInTicks = Math.floor((1000 * result.expires_at - now) / 3E4);
                  this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${3E4}ms, refresh threshold is ${3} ticks`);
                  3 >= expiresInTicks && await this._callRefreshToken(result.refresh_token);
                } else {
                  this._debug("#_autoRefreshTokenTick()", "no session");
                }
              });
            } catch (e) {
              console.error("Auto refresh tick failed with error. This is likely a transient error.", e);
            }
          } finally {
            this._debug("#_autoRefreshTokenTick()", "end");
          }
        });
      } catch (e) {
        if (e.isAcquireTimeout || e instanceof locks_1.LockAcquireTimeoutError) {
          this._debug("auto refresh token tick lock not available");
        } else {
          throw e;
        }
      }
    }
    async _handleVisibilityChange() {
      this._debug("#_handleVisibilityChange()");
      if (!(0,helpers_1.isBrowser)() || null === window || void 0 === window || !window.addEventListener) {
        return this.autoRefreshToken && this.startAutoRefresh(), !1;
      }
      try {
        this.visibilityChangedCallback = async() => await this._onVisibilityChanged(!1), null === window || void 0 === window || window.addEventListener("visibilitychange", this.visibilityChangedCallback), await this._onVisibilityChanged(!0);
      } catch (error) {
        console.error("_handleVisibilityChange", error);
      }
    }
    async _onVisibilityChanged(calledFromInitialize) {
      const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
      this._debug(methodName, "visibilityState", document.visibilityState);
      "visible" === document.visibilityState ? (this.autoRefreshToken && this._startAutoRefresh(), calledFromInitialize || (await this.initializePromise, await this._acquireLock(-1, async() => {
        "visible" !== document.visibilityState ? this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting") : await this._recoverAndRefresh();
      }))) : "hidden" === document.visibilityState && this.autoRefreshToken && this._stopAutoRefresh();
    }
    async _getUrlForProvider(url, provider, options) {
      provider = [`provider=${encodeURIComponent(provider)}`];
      (null === options || void 0 === options ? 0 : options.redirectTo) && provider.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
      (null === options || void 0 === options ? 0 : options.scopes) && provider.push(`scopes=${encodeURIComponent(options.scopes)}`);
      if ("pkce" === this.flowType) {
        const [codeChallenge, codeChallengeMethod] = await (0,helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey);
        var flowParams = new URLSearchParams({code_challenge:`${encodeURIComponent(codeChallenge)}`, code_challenge_method:`${encodeURIComponent(codeChallengeMethod)}`});
        provider.push(flowParams.toString());
      }
      if (null === options || void 0 === options ? 0 : options.queryParams) {
        flowParams = new URLSearchParams(options.queryParams), provider.push(flowParams.toString());
      }
      (null === options || void 0 === options ? 0 : options.skipBrowserRedirect) && provider.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
      return `${url}?${provider.join("\x26")}`;
    }
    async _unenroll(params) {
      try {
        return await this._useSession(async result => {
          var _a;
          const {data:sessionData, error:sessionError} = result;
          return sessionError ? {data:null, error:sessionError} : await (0,fetch_1._request)(this.fetch, "DELETE", `${this.url}/factors/${params.factorId}`, {headers:this.headers, jwt:null === (_a = null === sessionData || void 0 === sessionData ? void 0 : sessionData.session) || void 0 === _a ? void 0 : _a.access_token});
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async _enroll(params) {
      try {
        return await this._useSession(async result => {
          var _a, _b;
          const {data:sessionData, error:sessionError} = result;
          if (sessionError) {
            return {data:null, error:sessionError};
          }
          result = Object.assign({friendly_name:params.friendlyName, factor_type:params.factorType}, "phone" === params.factorType ? {phone:params.phone} : {issuer:params.issuer});
          const {data, error} = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/factors`, {body:result, headers:this.headers, jwt:null === (_a = null === sessionData || void 0 === sessionData ? void 0 : sessionData.session) || void 0 === _a ? void 0 : _a.access_token});
          if (error) {
            return {data:null, error};
          }
          "totp" === params.factorType && (null === (_b = null === data || void 0 === data ? void 0 : data.totp) || void 0 === _b ? 0 : _b.qr_code) && (data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`);
          return {data, error:null};
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async _verify(params) {
      return this._acquireLock(-1, async() => {
        try {
          return await this._useSession(async result => {
            var _a;
            const {data:sessionData, error:sessionError} = result;
            if (sessionError) {
              return {data:null, error:sessionError};
            }
            const {data, error} = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/factors/${params.factorId}/verify`, {body:{code:params.code, challenge_id:params.challengeId}, headers:this.headers, jwt:null === (_a = null === sessionData || void 0 === sessionData ? void 0 : sessionData.session) || void 0 === _a ? void 0 : _a.access_token});
            if (error) {
              return {data:null, error};
            }
            await this._saveSession(Object.assign({expires_at:Math.round(Date.now() / 1000) + data.expires_in}, data));
            await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
            return {data, error};
          });
        } catch (error) {
          if ((0,errors_1.isAuthError)(error)) {
            return {data:null, error};
          }
          throw error;
        }
      });
    }
    async _challenge(params) {
      return this._acquireLock(-1, async() => {
        try {
          return await this._useSession(async result => {
            var _a;
            const {data:sessionData, error:sessionError} = result;
            return sessionError ? {data:null, error:sessionError} : await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/factors/${params.factorId}/challenge`, {body:{channel:params.channel}, headers:this.headers, jwt:null === (_a = null === sessionData || void 0 === sessionData ? void 0 : sessionData.session) || void 0 === _a ? void 0 : _a.access_token});
          });
        } catch (error) {
          if ((0,errors_1.isAuthError)(error)) {
            return {data:null, error};
          }
          throw error;
        }
      });
    }
    async _challengeAndVerify(params) {
      const {data:challengeData, error:challengeError} = await this._challenge({factorId:params.factorId});
      return challengeError ? {data:null, error:challengeError} : await this._verify({factorId:params.factorId, challengeId:challengeData.id, code:params.code});
    }
    async _listFactors() {
      const {data:{user}, error:userError} = await this.getUser();
      if (userError) {
        return {data:null, error:userError};
      }
      const factors = (null === user || void 0 === user ? void 0 : user.factors) || [], totp = factors.filter(factor => "totp" === factor.factor_type && "verified" === factor.status), phone = factors.filter(factor => "phone" === factor.factor_type && "verified" === factor.status);
      return {data:{all:factors, totp, phone}, error:null};
    }
    async _getAuthenticatorAssuranceLevel() {
      return this._acquireLock(-1, async() => await this._useSession(async result => {
        var _a, _b;
        const {data:{session}, error:sessionError} = result;
        if (sessionError) {
          return {data:null, error:sessionError};
        }
        if (!session) {
          return {data:{currentLevel:null, nextLevel:null, currentAuthenticationMethods:[]}, error:null};
        }
        result = this._decodeJWT(session.access_token);
        let currentLevel = null;
        result.aal && (currentLevel = result.aal);
        let nextLevel = currentLevel;
        0 < (null !== (_b = null === (_a = session.user.factors) || void 0 === _a ? void 0 : _a.filter(factor => "verified" === factor.status)) && void 0 !== _b ? _b : []).length && (nextLevel = "aal2");
        return {data:{currentLevel, nextLevel, currentAuthenticationMethods:result.amr || []}, error:null};
      }));
    }
  }
  exports.default = GoTrueClient;
  GoTrueClient.nextInstanceID = 0;
};

//# sourceMappingURL=module$node_modules$$supabase$auth_js$dist$main$GoTrueClient.js.map
