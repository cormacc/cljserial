{"version":3,"sources":["statecharts/impl.cljc"],"mappings":"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","names":["statecharts.impl/canon-one-transition","x","cljs.core/map?","statecharts.impl/canon-transitions","and__5000__auto__","cljs.core/vector?","cljs.core/some","cljs.core.mapv","statecharts.impl/canon-actions","statecharts.impl/canon-event","statecharts.impl/T_Actions","cljs.core/ifn?","statecharts.impl/T_Target","cljs.core/keyword?","statecharts.impl/T_Transition","statecharts.impl/T_Entry","statecharts.impl/T_Exit","statecharts.impl/T_DelayExpression","cljs.core/int?","statecharts.impl/T_DelayedEvent","statecharts.impl/T_Event","statecharts.impl/T_Transitions","statecharts.impl/T_Initial","statecharts.impl/decode-delayed-map","m","cljs.core.mapcat","p__94775","vec__94777","cljs.core.nth","ms","target","p1__94771#","cljs.core.map","cljs.core.assoc","cljs.core.into","statecharts.impl/decode-delayed-transitions","statecharts.impl/T_DelayedTransition","statecharts.impl/T_DelayedTransitions","statecharts.impl/T_After","statecharts.impl/T_EventlessTransitions","statecharts.impl/insert-eventless-transitions","node","always","cljs.core/not","cljs.core.update","cljs.core/assoc","statecharts.impl/T_Type","statecharts.impl/T_States","cljs.core.comp","statecharts.delayed/insert-delayed-transitions","statecharts.impl/T_Integrations","cljs.core/any?","statecharts.impl/T_Machine","statecharts.delayed/replace-delayed-place-holder","statecharts.delayed/scheduler?","statecharts.impl/machine","orig","conformed","malli.core.decode","malli.transform.transformer","malli.transform/default-value-transformer","malli.core.validate","reason","malli.error.humanize","malli.core.explain","machine-id","msg","G__94793","js/console.warn","cljs.core/clj->js","js/JSON.stringify","cljs.core.ex_info","statecharts.impl/validate-targets","this__5300__auto__","k__5301__auto__","this__5302__auto__","k94797","else__5303__auto__","G__94806","cljs.core/Keyword","v","cljs.core.get","__extmap","this__5320__auto__","f__5321__auto__","init__5322__auto__","cljs.core.reduce","ret__5323__auto__","p__94810","vec__94812","k__5324__auto__","v__5325__auto__","this__5315__auto__","writer__5316__auto__","opts__5317__auto__","pr-pair__5318__auto__","keyval__5319__auto__","cljs.core/pr-sequential-writer","cljs.core.concat","cljs.core/PersistentVector","G__94796","cljs.core/RecordIter","cljs.core/-iterator","cljs.core/nil-iter","this__5298__auto__","__meta","this__5295__auto__","__hash","this__5304__auto__","cljs.core/count","this__5296__auto__","h__5111__auto__","coll__5297__auto__","cljs.core/hash-unordered-coll","this94798","other94799","cljs.core._EQ_","this__5310__auto__","k__5311__auto__","cljs.core/contains?","cljs.core.dissoc","cljs.core/-with-meta","cljs.core/not-empty","this__5307__auto__","G__94839","this__5308__auto__","k__5309__auto__","pred__94842","cljs.core/keyword-identical?","expr__94843","this__5313__auto__","cljs.core/seq","cljs.core/MapEntry","this__5299__auto__","this__5305__auto__","entry__5306__auto__","cljs.core/-nth","cljs.core/-conj","statecharts.impl/ContextAssignment","this__5346__auto__","cljs.core/List","writer__5347__auto__","cljs.core/-write","G__94804","extmap__5342__auto__","G__94859","cljs.core/record?","statecharts.impl/->ContextAssignment","statecharts.impl/map->ContextAssignment","statecharts.impl/assign","f","args","cljs.core.apply","statecharts.impl/internal-action?","action","G__94879","cljs.core/namespace","p__94894","p__94895","map__94898","cljs.core/--destructure-map","map__94899","statecharts.impl/execute-internal-action","fsm","scheduler","state","transition-event","internal-action","event","event-delay","statecharts.delayed/schedule","statecharts.delayed/unschedule","var_args","G__94918","statecharts.impl/execute","js/Error","p__94933","map__94934","statecharts.impl.execute","debug","*clock*-orig-val__94935","*clock*-temp-val__94936","statecharts.clock/*clock*","G__94937","new-state","retval","G__94943","statecharts.impl/PathElement","statecharts.impl/parallel?","G__94946","statecharts.impl/compound?","statecharts.impl/atomic?","statecharts.impl/path->_state","xs","indexed-xs","statecharts.utils/with-index","cljs.core/rest","ret","p__94957","vec__94960","accu","i","para-state","statecharts.utils/map-vals","id","cljs.core.conj","statecharts.utils/devectorize","args__5732__auto__","len__5726__auto__","i__5727__auto__","argseq__5733__auto__","cljs.core/IndexedSeq","statecharts.impl/check-or-throw","p__94971","map__94972","seq94966","G__94967","cljs.core/first","cljs.core/next","G__94968","G__94969","self__5711__auto__","k","map","cljs.core/name","statecharts.impl/resolve-target","base","statecharts.utils/ensure-vector","parent","cljs.core/vec","cljs.core.drop_last","cljs.core/sequential?","cljs.core.drop","statecharts.impl/absolute-target?","statecharts.impl/is-prefix?","short","long","n","cljs.core.take","statecharts.impl/external-self-transition-actions","handler","nodes","statecharts.impl/has-eventless-transition?","cljs.core/boolean","p1__94999#","cljs.core.get_in","statecharts.impl/updatev-last","seq95001","G__95002","G__95003","cljs.core/update","statecharts.impl/RT_NodePath","statecharts.impl/RT_Node","statecharts.impl/RT_TX","statecharts.impl/T_Configuration","statecharts.impl/add-node-type","type","G__95020","statecharts.impl/resolve-node","root","path","statecharts.impl.resolve_node","full?","current-root","cljs.core/reduced","G__95039","G__95043","cljs.core/select-keys","statecharts.impl/_state->nodes","_state","G__95073","vec__95076","seq__95077","first__95078","vec__95122","seq__95123","first__95124","head","more","prefix","cljs.core/sorted-set","current","cljs.core/empty?","p__95133","vec__95134","cljs.core/cons","p1__95054#","statecharts.impl/_state->configuration","p__95153","map__95154","seq95144","G__95145","G__95146","no-resolve?","_opt","paths","p1__95142#","statecharts.impl/backtrack-ancestors-as-paths","cljs.core.reductions","_","cljs.core.range","statecharts.impl/backtrack-ancestors-as-nodes","p1__95169#","statecharts.impl/find-least-common-compound-ancessor","path1","path2","statecharts.utils/find-first","anc","p__95183","map__95185","statecharts.impl/get-tx-domain","source","tx","p__95197","p__95198","map__95199","map__95200","statecharts.impl/select-one-tx","input-event","cljs.core/deref","first-satisfied-tx","txs","p__95209","map__95210","guard","or__5002__auto__","found","cljs.core/volatile!","temp__5823__auto__","map__95221","p__95214","map__95215","cljs.core/vreset!","target-resolved","p__95232","map__95233","statecharts.impl/get-initial-path","initial","_node","statecharts.impl/add-ancestors-to-entry-set","domain","external?","cljs.core.take_while","cljs.core.not_EQ_","statecharts.impl/compute-entry-set","get-tx-entry-set","p__95255","map__95256","_tx","entry-set","seeds","p1__95248#","exist?","new","p1__95249#","p__95266","map__95267","cljs.core.remove","G__95271","regions","cljs.core/keys","p1__95250#","cljs.core/concat","clojure.set.difference","cljs.core/set","cljs.core/into","statecharts.impl/get-actions","statecharts.impl/get-entry-actions","p1__95288#","statecharts.impl/simple-state","statecharts.impl/configuration->_state","configuration","parent-compound?","children","groups","cljs.core/group-by","parallel-state","statecharts.utils/map-kv-vals","region","G__95319","G__95320","ks","cljs.core/ffirst","p__95338","map__95339","statecharts.impl/-do-transition","ignore-unknown-event?","atomic-nodes","p1__95330#","cljs.core.filter","p1__95331#","cljs.core/identity","cljs.core/second","cljs.core/nil?","cljs.core/seq?","exit-set","p__95345","map__95346","p__95347","map__95348","exit-actions","cljs.core/reverse","p1__95335#","entry-actions","tx-actions","actions","new-configuration","clojure.set.union","new-value","p1__95337#","statecharts.impl/-do-init","_pending-eventless-tx?","p1__95362#","G__95372","statecharts.impl/initialize","p__95376","p__95377","map__95378","map__95379","statecharts.impl.initialize","exec","context","_opts","vec__95383","G__95389","G__95390","G__95391","G__95392","statecharts.impl/transition","p__95394","map__95395","statecharts.impl/-transition-once","vec__95396","statecharts.impl/-transition-impl","opts","map__95412","_actions","G__95423","p__95429","map__95430","statecharts.impl.transition","vec__95431","G__95434","statecharts.impl/valid-target?","e95436","e","cljs.core/ex-data","G__95438","statecharts.impl.validate_targets","current-path","transitions","cljs.core/vals","targets","seq__95443","chunk__95445","count__95446","i__95447","cljs.core/chunked-seq?","c__5525__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","initial-node","seq__95481","chunk__95482","count__95483","i__95484","vec__95495","vec__95502","name","child","seq__95511","chunk__95512","count__95513","i__95514","vec__95528","vec__95531","statecharts.impl/matches","value","v1","v2"],"sourcesContent":["(ns statecharts.impl\n  (:require [malli.core :as ma]\n            [malli.transform :as mt]\n            [clojure.set]\n            [malli.error]\n            [statecharts.clock :refer [*clock*]]\n            [statecharts.delayed\n             :as fsm.d\n             :refer [insert-delayed-transitions\n                     replace-delayed-place-holder\n                     scheduler?]]\n            [statecharts.utils :as u]\n            [statecharts.macros :refer [prog1]])\n  (:refer-clojure :exclude [send]))\n\n(defn canon-one-transition [x]\n  (if (map? x)\n    x\n    {:target x}))\n\n(defn canon-transitions [x]\n  (cond\n    (and (vector? x)\n         (some map? x))\n    (mapv canon-one-transition x)\n\n    (map? x)\n    [x]\n\n    :else\n    [{:target x}]))\n\n(defn canon-actions [x]\n  (if (vector? x)\n    x\n    [x]))\n\n(defn canon-event [x]\n  (if (map? x)\n    x\n    {:type x}))\n\n(def T_Actions\n  [:vector {:decode/fsm canon-actions}\n   [:fn ifn?]])\n\n(def T_Target\n  \"See `resolve-target` for the synatx of target definition.\"\n  [:or\n   keyword?\n   [:vector keyword?]])\n\n(def T_Transition\n  [:vector {:decode/fsm canon-transitions}\n   [:map {:closed true}\n    [:target {:optional true} T_Target]\n    [:guard {:optional true} [:fn ifn?]]\n    [:actions {:optional true} T_Actions]]])\n\n(def T_Entry\n  [:entry {:optional true} T_Actions])\n\n(def T_Exit\n  [:exit {:optional true} T_Actions])\n\n(def T_DelayExpression\n  [:or\n   int?\n   ;; when replaced as a\n   [:fn ifn?]])\n\n(def T_DelayedEvent\n  \"Generated internal event for delayed transitions.\"\n  [:tuple keyword? T_Target [:or int?\n                             ;; See delayed/generate-delayed-events\n                             ;; for why we use string instead of\n                             ;; delayed fn as the event key.\n                             :string]])\n\n(def T_Event\n  [:or keyword? T_DelayedEvent])\n\n(def T_Transitions\n  [:on {:optional true}\n   [:map-of T_Event T_Transition]])\n\n(def T_Initial\n  [:initial {:optional true} T_Target])\n\n(defn decode-delayed-map [m]\n  ;; {1000 :s1 2000 :s2}\n  ;; =>\n  ;; [{delay: 1000 :target :s1} {:delay 2000 :target :s2}]\n  (->> m\n       (mapcat (fn [[ms target]]\n                 (->> target\n                      canon-transitions\n                      (map #(assoc % :delay ms)))))\n       (into [])))\n\n#_(decode-delayed-map {1000 :s1 2000 :s2})\n#_(decode-delayed-map {1000 [{:target :s1\n                              :cond :c1}\n                             {:target :s2}]\n                       2000 :s2})\n\n(defn decode-delayed-transitions [x]\n  (if (map? x)\n    (decode-delayed-map x)\n    x))\n\n(def T_DelayedTransition\n  [:map {:closed true}\n   [:delay T_DelayExpression]\n   [:target {:optional true} T_Target]\n   [:guard {:optional true} [:fn ifn?]]\n   [:actions {:optional true} T_Actions]])\n\n(def T_DelayedTransitions\n  [:vector {:decode/fsm decode-delayed-transitions}\n   T_DelayedTransition])\n\n(def T_After\n  [:after {:optional true} T_DelayedTransitions])\n\n(def T_EventlessTransitions\n  [:always {:optional true} T_Transition])\n\n(defn insert-eventless-transitions [node]\n  (let [always (:always node)]\n    (if-not always\n      node\n      (update node :on assoc :fsm/always always))))\n\n(def T_Type\n  [:type {:optional true} [:enum :parallel]])\n\n(def T_States\n  [:schema\n   {:registry\n            {::state [:map {:closed true\n                            :decode/fsm {:leave (comp\n                                                 insert-eventless-transitions\n                                                 insert-delayed-transitions)}}\n                      T_After\n                      T_Entry\n                      T_Exit\n                      T_EventlessTransitions\n                      T_Transitions\n                      T_Initial\n                      ;; TODO: dispatch on type\n                      T_Type\n                      [:states {:optional true}\n                       [:map-of keyword? [:ref ::state]]]\n                      [:regions {:optional true}\n                       [:map-of keyword? [:ref ::state]]]]}}\n   [:map-of keyword? [:ref ::state]]])\n\n#_(ma/validate T_States {:s1 {:on {:e1 {:target :s2}}}\n                       :s2 {:initial :s2.1\n                            :states {:s2.1 {:on {:e2.1_2.2 {:target :s2.2}}}}}})\n\n(def T_Integrations\n  [:integrations {:optional true}\n   [:map {:closed true}\n    [:re-frame {:optional true}\n     [:map\n      [:path any?]\n      [:transition-event {:optional true} keyword?]\n      [:initialize-event {:optional true} keyword?]]]]])\n\n(def T_Machine\n  [:map {:decode/fsm {:leave (comp\n                              replace-delayed-place-holder\n                              insert-delayed-transitions)}}\n   T_Integrations\n   [:id keyword?]\n   [:context {:optional true} any?]\n   [:scheduler {:optional true} [:fn scheduler?]]\n   T_Transitions\n   T_After\n   T_Entry\n   T_Exit\n   T_Initial\n   ;; TODO: dispatch on type\n   T_Type\n   [:states {:optional true} T_States]\n   [:regions {:optional true} T_States]])\n\n(declare validate-targets)\n\n(defn machine\n  \"Create a canonical presentation of the machine using malli.\"\n  [orig]\n  (let [conformed (ma/decode T_Machine orig\n                    (mt/transformer\n                     mt/default-value-transformer\n                     {:name :fsm}))]\n    (when-not (ma/validate T_Machine conformed)\n      ;; TODO: ensure the initial target exists\n      (let [reason (malli.error/humanize (ma/explain T_Machine conformed))\n            machine-id (:id conformed)\n            msg (cond-> \"Invalid fsm machine spec:\"\n                  machine-id\n                  (str \" machine-id=\" machine-id))]\n        #?(:cljs\n           (js/console.warn msg (-> reason\n                                    (clj->js)\n                                    (js/JSON.stringify))))\n        (throw (ex-info msg reason))))\n    (validate-targets conformed)\n    conformed))\n\n;; TODO: use deftype. We use defrecord because it has a handy\n;; toString.\n(defrecord ContextAssignment [v])\n\n(defn assign\n  \"Wrap a function into a context assignment function.\"\n  [f]\n  (fn [& args]\n    (ContextAssignment. (apply f args))))\n\n(defn- internal-action? [action]\n  (and (map? action)\n       (= (some-> (:action action) namespace) \"fsm\")))\n\n(defn- execute-internal-action\n  [{:as fsm :keys [scheduler]}\n   state\n   transition-event\n   {:as internal-action :keys [action event event-delay]}]\n  (when-not scheduler\n    (throw (ex-info\n               \"Delayed fsm without scheduler configured\"\n             {:action internal-action})))\n  (cond\n    (= action :fsm/schedule-event)\n    (let [event-delay (if (int? event-delay)\n                        event-delay\n                        (event-delay state transition-event))]\n      (fsm.d/schedule scheduler fsm state event event-delay))\n\n    (= action :fsm/unschedule-event)\n    (fsm.d/unschedule scheduler fsm state event)\n\n    :else\n    (throw (ex-info (str \"Unknown internal action \" action) internal-action))))\n\n(defn- execute\n  \"Execute the actions/entry/exit functions when transitioning.\"\n  ([fsm state event]\n   (execute fsm state event nil))\n  ([fsm state event {:keys [debug]}]\n   (binding [*clock* (some-> (:scheduler fsm)\n                             .-clock)]\n     (reduce (fn [new-state action]\n               (if (internal-action? action)\n                 (do\n                   (execute-internal-action fsm new-state event action)\n                   new-state)\n                 (let [retval (action new-state event)]\n                   (if (instance? ContextAssignment retval)\n                     (.-v retval)\n                     new-state))))\n             (cond-> state\n               (not debug)\n               (dissoc :_actions))\n             (:_actions state)))))\n\n(def PathElement\n  \"Schema of an element of a expanded path. We need the\n  transitions/exit/entry information to:\n  1. transitions: in a compound node, decide which level handles\n     the event\n  2. :id of each level to resolve the target state node.\n  3. entry/exit: collect the actions during a transtion transition.\"\n  [:map {:closed true}\n   [:id [:maybe keyword?]]\n   T_Transitions\n   T_Entry\n   T_Exit])\n\n(defn- parallel? [node]\n  (some-> (:type node)\n          (= :parallel)))\n\n(defn- compound? [node]\n  (contains? node :initial))\n\n(defn- atomic? [node]\n  (and (not (parallel? node))\n       (not (compound? node))))\n\n(defn path->_state\n  \"Calculate the _state value based on the node paths.\n\n  In our internal code, we need to represent the current state as a series of\n  nodes, but when presenting the current state to the user we need to extract the\n  simplest form.\"\n  [xs]\n  (let [indexed-xs (u/with-index (rest xs))\n        ret (->> indexed-xs\n                 (reduce\n                   (fn [accu [node i]]\n                     (if (parallel? node)\n                       (let [para-state (u/map-vals path->_state\n                                                    (:regions node))]\n                         (if (zero? i)\n                           ;; If the root is a para node: {:p1 :s1 :p2 :s2}\n                           [para-state]\n                           ;; If the non-root is a para node: {:p1 {:p2 :s2 :p3\n                           ;; :s3}}\n                           (update accu\n                                   (dec i)\n                                   (fn [id]\n                                     {id para-state}))))\n                       (conj accu (:id node))))\n                   []))]\n    (u/devectorize ret)))\n\n(defn check-or-throw [x k v & {:keys [] :as map}]\n  (when (nil? x)\n    (throw (ex-info (str \"Unknown fsm \" (name k) \" \" v) (assoc map k v)))))\n\n\n(defn resolve-target\n  \"Resolve the given transition target given the current state context.\n\n  Rules for resolving the target:\n  - If the target is nil, it's the same as the current state, a.k.a self-transition\n\n  - If the target is a vector and the first element is :>, it's an absolute path\n\n    (f :whatever [:> :s2]) => [:s2]\n\n  - If the target is a vector and the first element is not :>, it's an relative path\n\n    (f [:s1] [:s2]) => :s2\n    (f [:s1 :s1.1] [:s1.2]) => [:s1 :s1.2]\n\n  - If the target is a keyword, it's the same as an one-element vector\n\n    (f [:s1] :s2) => :s2\n    (f [:s1 :s1.1] :s1.2) => [:s1 :s1.2]\n\n  - If the target is a vector and the first element is :., it's a\n    child state of current node:\n\n    (f [:s1] [:. :s1.1]) => [:s1 :s1.1]\n\n  E.g. given current state [:s1 :s1.1] and a target of :s1.2, it\n  should resolve to [:s1 :s1.2]\"\n  [base target]\n  (let [base (u/ensure-vector base)\n        parent (vec (drop-last base))]\n    (cond\n      (nil? target)\n      base\n\n      (keyword? target)\n      (conj parent target)\n\n      (not (sequential? target))\n      (throw (ex-info \"Invalid fsm target\" {:target target}))\n\n      (= (first target) :>)\n      (vec (next target))\n\n      (= (first target) :.)\n      (vec (concat base (drop 1 target)))\n\n      :else\n      (vec (concat parent target)))))\n\n(defn absolute-target? [target]\n  (and (sequential? target)\n       (= (first target) :>)))\n\n(defn is-prefix? [short long]\n  (let [n (count short)]\n    (and (<= n (count long))\n         (= short (take n long)))))\n\n(defn external-self-transition-actions\n  \"Calculate the actions for an external self-transition.\n\n  if handler is on [:s1 :s1.1]\n  and current state is [:s1 :s1.1 :s1.1.1]\n  then we shall exit s1.1.1 s1.1 and entry s1.1 s1.1.1 again\n\n  if handler is on [:s1]\n  and current state is [:s1 :s1.1 :s1.1.1]\n  then we shall exit s1.1.1 s1.1 s1 and entry s1 s1.1 s1.1.1 again\n\n  if handler is on [:s2]\n  and current state is [:s2]\n  then we shall exit s2 and entry s2 again\n\n  if handler is on []\n  and current state is [:s2]\n  then we shall exit s2 Machine and entry Machine s2 again\n  \"\n  [handler nodes])\n\n(defn has-eventless-transition? [nodes]\n  (boolean (some #(get-in % [:on :fsm/always]) nodes)))\n\n(defn- updatev-last\n  \"Update the last element of a vector\"\n  [v f & args]\n  (apply update v (dec (count v)) f args))\n\n(def RT_NodePath\n  [:vector :keyword])\n\n(def RT_Node\n  [:map\n   [:path RT_NodePath]\n   [:on {:optional true} [:map-of :keyword :any]]\n   [:type :enum [:atomic :compound :parallel]]\n   [:entry {:optional true} :any]\n   [:exit {:optional true} :any]])\n\n(def RT_TX\n  [:map {:closed true}\n   [:source {:optional true} RT_NodePath]\n   [:target {:optional true} RT_NodePath]\n   [:domain {:optional true} RT_NodePath]\n   [:guard {:optional true} [:vector :fn]]\n   [:actions {:optional true} [:vector :fn]]])\n\n(def T_Configuration\n  [:set RT_NodePath])\n\n(defn add-node-type [node]\n  (let [type (cond\n               (parallel? node)\n               :parallel\n\n               (compound? node)\n               :compound\n\n               :else\n               :atomic)]\n    (assoc node :type type)))\n\n(defn resolve-node\n  ([root path]\n   (resolve-node root path false))\n  ([root path full?]\n   ;; [:s1 :s1.1]\n   (let [node (let [path (u/ensure-vector path)\n                    node (reduce\n                           (fn [current-root k]\n                             (cond\n                               (parallel? current-root)\n                               (get-in current-root [:regions k])\n\n                               (compound? current-root)\n                               (get-in current-root [:states k])\n\n                               :else\n                               (reduced nil)))\n                           root\n                           path)]\n                (some-> node\n                        (add-node-type)\n                        (assoc :path path)))]\n     (if full?\n       node\n       (some-> node\n               (select-keys [:on :entry :exit :type :path]))))))\n\n(defn _state->nodes [_state]\n  (loop [[head & more] (u/ensure-vector _state)\n         prefix []\n         ret (sorted-set)]\n    (cond\n      (keyword? head)\n      (let [current (conj prefix head)\n            ret (conj ret current)]\n        (if (seq more)\n          (recur more current ret)\n          ret))\n\n      (map? head)\n      (do\n        (assert (empty? more)\n          \"invalid _state, parallel state must be the last one\")\n        (into ret (mapcat (fn [[k v]]\n                            (let [prefix (conj prefix k)]\n                              (cons prefix\n                                    (map #(into prefix %) (_state->nodes v)))))\n                          head))))))\n\n(defn _state->configuration\n  ;; We always resolve the `_state` in a JIT manner, so the user has the\n  ;; flexibility to pass in a literal `_state` (and context) as data, instead of\n  ;; forcing the user to keep track of an opaque \"State\" object like xstate.\n  ;;\n  ;; E.g. the user pass in `[:s1 :s1.1]` then we would get a set of two nodes:\n  ;; - `[:s1]`\n  ;; - `[:s1 :s1.1]`\n  [fsm _state &\n   {:keys [no-resolve?]\n    :as _opt}]\n  (let [_state (u/ensure-vector _state)]\n    (let [paths (conj (_state->nodes _state) [])\n          ;; Always reslove to ensure all nodes are resolvable in the fsm. TODO:\n          ;; throw an exc here if resolve-node returns nil?\n          nodes (mapv #(resolve-node fsm %) paths)]\n      (if no-resolve?\n        paths\n        nodes))))\n\n(defn backtrack-ancestors-as-paths\n  \"Return a (maybe lazy) sequence of the node path with all its ancestors, starting from the\n  node and goes up.\"\n  [fsm path]\n  (reductions (fn [accu _]\n                (vec (drop-last accu)))\n              path\n              (range (count path))))\n\n(defn backtrack-ancestors-as-nodes\n  \"Like backtrack-ancestors-as-paths but resolves the paths into nodes.\"\n  [fsm path]\n  ;; [:s1 :s1.1 :s1.1.1]\n  (->> (backtrack-ancestors-as-paths fsm path)\n       (map #(resolve-node fsm %))))\n\n(defn find-least-common-compound-ancessor [fsm path1 path2]\n  (u/find-first (fn [anc]\n                  (is-prefix? anc path1))\n                (backtrack-ancestors-as-paths fsm path2)))\n\n(defn get-tx-domain\n  [fsm {:keys [source target] :as tx}]\n  (cond\n    ;; internal self transition\n    (nil? target)\n    nil\n\n    ;; external self transition\n    (= source target)\n    source\n\n    :else\n    (find-least-common-compound-ancessor fsm source target)))\n\n(defn select-one-tx\n  \"Given an atomic node and an event, find the first satistifed transition by\n  walking from the node and then its ancestors, until the root.\n\n  Return a two-tuple:\n  - The first element is the a boolean indicates whether any transition is found at\n    all (regarding it's satisfied or not)\n  - The second element is the found transition, if any.\n  \"\n  [fsm\n   {:keys [path]\n    :as node} state\n   {:keys [type]\n    :as event} input-event]\n  (let [first-satisfied-tx (fn [txs]\n                             (some (fn [{:keys [guard]\n                                         :as tx}]\n                                     (when (or (not guard)\n                                               (guard state input-event))\n                                       (dissoc tx :guard)))\n                                   txs))\n        found (volatile! false)\n        tx (when-let [{:keys [source target]\n                       :as tx}\n                      (some (fn [{:keys [path]\n                                  :as node}]\n                              (when-let [txs (seq (get-in node [:on type]))]\n                                (vreset! found true)\n                                (when-let [tx (first-satisfied-tx txs)]\n                                  (assoc tx :source path))))\n                            (backtrack-ancestors-as-nodes fsm (:path node)))]\n             (let [target-resolved (when target\n                                     (resolve-target source target))\n                   tx (-> tx\n                          (assoc :target target-resolved)\n                          (assoc :external? (or (absolute-target? target)\n                                                (= target-resolved source))))]\n               (assoc tx :domain (get-tx-domain fsm tx))))]\n    [@found tx]))\n\n(defn get-initial-path [{:keys [path initial] :as _node}]\n  (let [initial (u/ensure-vector initial)\n        initial (if (= (first initial) :.)\n                  (next initial)\n                  initial)]\n    (into path initial)))\n\n(defn add-ancestors-to-entry-set\n  [fsm domain path external?]\n  (->> (backtrack-ancestors-as-paths fsm path)\n       (take-while (fn [path]\n                     (and (not= path [])\n                          ;; exclude the domain node when not external,\n                          (or external?\n                              (not= domain path))\n                          (is-prefix? domain path))))))\n\n(defn compute-entry-set\n  [fsm txs]\n  (let [get-tx-entry-set\n        (fn [{:keys [target domain external?]\n              :as _tx}]\n          ;; target=nil means internal self-transtion, where no entry/exit would\n          ;; happen\n          (when target\n            (loop [entry-set #{target}\n                   seeds entry-set]\n              (let [exist? #(contains? entry-set %)\n                    new\n                    (->>\n                      seeds\n                      (map #(resolve-node fsm % true))\n                      (map\n                        (fn [{:keys [type path]\n                              :as node}]\n                          (remove exist?\n                            (concat\n                              (add-ancestors-to-entry-set fsm\n                                                          domain\n                                                          path\n                                                          external?)\n                              (case type\n                                :parallel\n                                (let [regions\n                                      (->> (:regions node)\n                                           keys\n                                           (map #(conj path %)))]\n                                  regions)\n\n                                :compound\n                                ;; for compound node that has no descedents in the\n                                ;; entry set, add its initial state to the next\n                                ;; seeds of next round of iteration.\n                                (when-not (some (fn [x]\n                                                  (and (not= path x)\n                                                       (is-prefix? path x)))\n                                                entry-set)\n                                  [(get-initial-path node)])\n\n                                ;; an atomic node, nothing to add for it.\n                                nil)))))\n                      (reduce concat))\n\n                    new (clojure.set/difference (set new) entry-set)]\n                (if-not (empty? new)\n                  (recur\n                    ;; include the new nodes\n                    (into entry-set new)\n                    ;; new the new nodes in this iteration as the new seeds\n                    new)\n                  entry-set)))))]\n    (->> (map get-tx-entry-set txs)\n         (reduce into (sorted-set)))))\n\n(defn get-actions [fsm path k]\n  (let [node (resolve-node fsm path)]\n    (k node)))\n\n(defn get-entry-actions [fsm entry-set]\n  (->> entry-set\n       (mapcat #(get-actions fsm % :entry))))\n\n(defn simple-state [x]\n  (if (and (sequential? x)\n           (= (count x) 1))\n    (first x)\n    x))\n\n(defn configuration->_state\n  \"Represent the current configuration in a user-friendly form. It's the reverse\n  operation of `_state->configuration`.\n  \"\n  [fsm configuration]\n   (-> (loop [paths configuration\n              node fsm\n              _state []\n              parent-compound? false]\n         (let [paths (into [] (remove empty? paths))]\n           (cond\n             (parallel? node)\n             (let [children (:regions node)\n                   groups (group-by first paths)\n                   parallel-state\n                   (u/map-kv-vals (fn [k region]\n                                    (configuration->_state region\n                                                           (map\n                                                             ;; remove the common\n                                                             ;; prefix\n                                                             next\n                                                             (get groups k))))\n                                  children)]\n               ;; If the parent node of the parallel node is a compound node (i.e.\n               ;; the parallel node is not the root), the notation is a\n               ;; single-valued map, e.g. [:s1 {:s1.1 {:p1 :x :p2 :y}}]\n               (if parent-compound?\n                 (updatev-last _state\n                               (fn [k]\n                                 {k parallel-state}))\n                 parallel-state))\n\n             (compound? node)\n             (do\n               (let [ks (set (map first paths))\n                     k (first ks)]\n                 (assert (= (count ks) 1) (str \"invalid paths: \" paths))\n                 (let [paths (remove empty? (map next paths))]\n                   (if (seq paths)\n                     (recur\n                       paths\n                       (get-in node [:states k])\n                       (conj _state k)\n                       true)\n                     (conj _state k)))))\n\n             :else\n             ;; some atomic node\n             (conj _state (ffirst paths)))))\n       simple-state))\n\n(defn -do-transition\n  [fsm\n   {:keys [_state]\n    :as state} event input-event\n   ignore-unknown-event?]\n  (let [configuration (_state->configuration fsm _state)\n        atomic-nodes (filter #(= (:type %) :atomic) configuration)\n        txs (->> atomic-nodes\n                 (map #(select-one-tx fsm % state event input-event)))\n        _ (when-not ignore-unknown-event?\n            (when-not (->> txs\n                         (map first)\n                         (some identity))\n              (throw (ex-info (str \"fsm \" (:id fsm) \" got unknown event \" (:type event) \" when in state \" _state)\n                              {:_state _state}))))\n        txs (->> txs\n                 (map second)\n                 (remove nil?))]\n    (if (not (seq? txs))\n      [_state [] false]\n      (let [exit-set (->> configuration\n                          ;; all active nodes that is covered by some tx domain\n                          ;; should\n                          ;; exit itself.\n                          (filter (fn [{:keys [path]\n                                        :as node}]\n                                    (some\n                                      (fn [{:keys [target domain external?]\n                                            :as tx}]\n                                        (cond\n                                          (= path [])\n                                          ;; only exit the root when the target is\n                                          ;; the root itself\n                                          (and external?\n                                               (= target []))\n\n                                          (= domain path)\n                                          ;; only include the domain itself\n                                          ;; when it's an external transition\n                                          external?\n\n                                          :else\n                                          (is-prefix? domain path)))\n                                      txs)))\n                          (map :path)\n                          (into (sorted-set)))\n            entry-set (compute-entry-set fsm txs)\n            exit-actions (->> exit-set\n                              reverse\n                              (mapcat #(get-actions fsm % :exit)))\n            entry-actions (get-entry-actions fsm entry-set)\n            tx-actions (->> txs\n                            (mapcat :actions))\n            actions (concat exit-actions tx-actions entry-actions)\n            ;; _ #p exit-set\n            ;; _ #p entry-set\n            new-configuration (-> (->> (map :path configuration)\n                                       (into #{}))\n                                  (clojure.set/difference exit-set)\n                                  (clojure.set/union entry-set))\n            new-value (configuration->_state fsm new-configuration)]\n        [new-value actions\n         (has-eventless-transition? (map #(resolve-node fsm %)\n                                      entry-set))]))))\n\n(defn -do-init\n  [fsm]\n  (let [tx                     {:source    []\n                                :target    []\n                                :external? true\n                                :domain    []}\n        entry-set              (compute-entry-set fsm [tx])\n        entry-actions          (get-entry-actions fsm entry-set)\n        _state                 (configuration->_state fsm entry-set)\n        _pending-eventless-tx? (has-eventless-transition?\n                                 (map #(resolve-node fsm %)\n                                      entry-set))]\n    [_state entry-actions _pending-eventless-tx?]))\n\n(declare transition)\n\n(defn initialize\n  ([fsm]\n   (initialize fsm nil))\n  ([{:keys [initial type]\n     :as fsm}\n    {:keys [exec debug context]\n     :or {exec true\n          context nil}\n     :as _opts}]\n   (let [context (if (some? context)\n                   context\n                   (:context fsm))\n         event {:type :fsm/init}\n         [_state actions _pending-eventless-tx?] (-do-init fsm)\n         state (assoc context\n                      :_state _state\n                      :_actions actions)\n         new-state (if exec\n                     (execute fsm state event {:debug debug})\n                     state)]\n     (if-not _pending-eventless-tx?\n       new-state\n       (transition fsm new-state :fsm/always {:exec exec :debug debug})))))\n\n(defn -transition-once\n  \"Do the transition, but would not follow new eventless transitions defined on\n  the target state.\"\n  [fsm state event\n   {:keys [exec debug input-event ignore-unknown-event?]\n    :or {exec true}}]\n  (let [;; input-event is set to the original event when event is :fsm/always for\n        ;; eventless transitions. We pass both along because even in eventless\n        ;; transitions, the actions function may want to access the original event\n        ;; instead of :fsm/always\n        input-event\n        (or input-event event)\n\n        [new-value actions _pending-eventless-tx?]\n        (-do-transition fsm\n                        state\n                        event\n                        input-event\n                        ignore-unknown-event?)\n\n        new-state (assoc state\n                    :_state new-value\n                    :_pending-eventless-tx? _pending-eventless-tx?\n                    :_prev-state (:_state state)\n                    :_actions actions)]\n    (if exec\n      (execute\n        fsm\n        new-state\n        input-event\n        {:debug debug})\n      new-state)))\n\n(defn -transition-impl\n  \"Return the new state and the actions to execute.\"\n  [fsm state input-event opts]\n  ;; The loop is used to execute eventless transitions.\n  (loop [i 0\n         state (dissoc state :_actions)\n         actions []]\n\n    (when (> i 10)\n      ;; Prevent bugs in application's code that two states uses eventless\n      ;; transitions and the states jumps back and forth between them.\n      (throw (ex-info (str \"Possible dead loop on event\" (:type input-event))\n                      {:state (:_state state)})))\n\n    (let [event\n          (if (zero? i)\n            input-event\n            ;; The first iteration of the loop is the real input event, while the\n            ;; following ones are eventless transitions.\n            {:type :fsm/always})\n\n          {:keys [_actions _pending-eventless-tx?]\n           :as state}\n          (-transition-once fsm state event opts)\n\n          actions\n          (if _actions\n            (into actions _actions)\n            actions)]\n      (if _pending-eventless-tx?\n        (recur (inc i) (dissoc state :_pending-eventless-tx?) actions)\n        [state actions]))))\n\n(defn transition\n  \"Given a machine with its current state, trigger a transition to the\n  next state based on the given event.\n\n  The nature and purpose of the transition impl is to get two outputs:\n  - the new state\n  - the actions to execute\n\n  By default it executes all actions, unless the `exec` opt is false,\n  in which case it is a pure function.\"\n  ([fsm state event]\n   (transition fsm state event nil))\n  ([fsm state event\n    {:as opts\n     :keys [exec debug]\n     :or {exec true}}]\n   (let\n     [input-event\n      (canon-event event)\n\n      opts\n      (assoc opts :input-event input-event)\n\n      [new-state actions]\n      (-transition-impl\n        fsm\n        (dissoc state :_actions)\n        input-event\n        opts)]\n     ;; get rid of the internal fields\n     (cond-> (dissoc new-state :_pending-eventless-tx? :_prev-state)\n       (or (not exec) debug)\n       (assoc :_actions actions)))))\n\n(defn- valid-target? [node path]\n  (try\n    (when-not (resolve-node node path)\n      (throw (ex-info \"node not found\" {:path path ::type :invalid-path})))\n    true\n    (catch #?(:clj clojure.lang.ExceptionInfo :cljs js/Error) e\n      (if (= (::type (ex-data e)) :invalid-path)\n        false\n        (throw e)))))\n\n(defn validate-targets\n  \"Walk the fsm and try to resolve all transition targets. Raise an\n  exception if any target is invalid.\"\n  ([root]\n   (validate-targets root root []))\n  ([root node current-path]\n   (do\n     (let [transitions (mapcat identity (-> node :on vals))\n           targets (->> transitions\n                        (map :target)\n                        ;; nil target target means self-transition,\n                        ;; which is always valid.\n                        (remove nil?))]\n       (when (seq targets)\n         (doseq [target targets\n                 :let [target (resolve-target current-path target)]]\n           (when-not (valid-target? root target)\n             (throw (ex-info (str \"Invalid target \" target)\n                      {:target target :state current-path}))))))\n     (when-let [initial (:initial node)]\n       (let [initial-node (get-in node [:states initial])]\n         (when-not initial-node\n           (throw (ex-info (str \"Invalid initial target \" initial)\n                    {:initial initial :state current-path})))))\n     (doseq [[name child] (:states node)]\n       (validate-targets root child (conj current-path name)))\n     (when (parallel? node)\n       (doseq [[name child] (:regions node)]\n         (validate-targets root child (conj current-path name)))))))\n\n(defn matches [state value]\n  (let [v1 (u/ensure-vector (:value state))\n        v2 (u/ensure-vector value)]\n    (is-prefix? v2 v1)))\n\n(comment\n  (ma/validate keyword? :a)\n\n  (def m1\n    {:id :foo\n     :initial :s1\n     :states {:s1 {:on {:e1 :s2\n                        :e12 {:target :s3\n                              :actions :a12}}}\n              :s2 {:on {:e2 {:target :s3\n                             :actions [:a31 :a32]}}}}})\n  (machine m1)\n  (ma/validate T_Machine m1)\n  (ma/explain T_Machine m1)\n  (ma/validate T_Machine (machine m1))\n  (ma/explain T_Machine (machine m1))\n\n  ())\n"],"x_google_ignoreList":[0]}