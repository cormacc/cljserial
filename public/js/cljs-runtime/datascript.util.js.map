{"version":3,"sources":["datascript/util.cljc"],"mappings":"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","names":["datascript.util/*debug*","datascript.util/rand-bits","pow","cljs.core/rand-int","datascript.util/to-hex-string","n","l","s","c","cljs.core/count","cljs.core.subs","cljs.core.apply","cljs.core/str","cljs.core.repeat","var_args","G__88494","datascript.util/squuid","js/Error","datascript.util.squuid","js/Date","msec","cljs.core/uuid","datascript.util/squuid-time-millis","uuid","js/parseInt","datascript.util/distinct-by","f","coll","cljs.core.reduce","p__88530","vec__88531","cljs.core.nth","seen","res","acc","el","key","cljs.core/contains?","cljs.core.conj_BANG_","cljs.core/transient","cljs.core/second","cljs.core/persistent!","datascript.util/find","pred","xs","_","x","cljs.core/reduced","datascript.util/single","cljs.core/next","cljs.core/first","args__5732__auto__","len__5726__auto__","i__5727__auto__","argseq__5733__auto__","cljs.core/IndexedSeq","datascript.util/concatv","seq88548","self__5712__auto__","cljs.core/seq","cljs.core.into","cljs.core/cat","G__88566","datascript.util/zip","args-arr__5751__auto__","argseq__5752__auto__","seq88562","G__88563","G__88564","self__5711__auto__","a","b","cljs.core.mapv","cljs.core/vector","rest","cljs.core/mapv","datascript.util/removem","key-pred","m","cljs.core/reduce-kv","k","v","cljs.core.assoc_BANG_","cljs.core/empty","datascript.util/conjv","cljs.core.fnil","cljs.core/conj","datascript.util/conjs","datascript.util/reduce-indexed","init","p__88596","vec__88599","idx","cljs.core/reduced?"],"sourcesContent":["(ns datascript.util\n  (:refer-clojure :exclude [find])\n  #?(:clj\n     (:import\n       [java.util UUID])))\n\n(def ^:dynamic *debug*\n  false)\n\n#?(:clj\n   (defmacro log [& body]\n     (when (System/getProperty \"datascript.debug\")\n       `(when *debug*\n          (println ~@body)))))\n\n#?(:clj\n   (defmacro raise [& fragments]\n     (let [msgs (butlast fragments)\n           data (last fragments)]\n       `(throw (ex-info (str ~@(map (fn [m#] (if (string? m#) m# (list 'pr-str m#))) msgs)) ~data)))))\n\n#?(:clj\n   (def ^:private ^:dynamic *if+-syms))\n  \n#?(:clj\n   (defn- if+-rewrite-cond-impl [cond]\n     (clojure.core/cond\n       (empty? cond)\n       true\n    \n       (and\n         (= :let (first cond))\n         (empty? (second cond)))\n       (if+-rewrite-cond-impl (nnext cond))\n    \n       (= :let (first cond))\n       (let [[var val & rest] (second cond)\n             sym                (gensym)]\n         (vswap! *if+-syms conj [var sym])\n         (list 'let [var (list 'clojure.core/vreset! sym val)]\n           (if+-rewrite-cond-impl\n             (cons \n               :let\n               (cons rest\n                 (nnext cond))))))\n    \n       :else\n       (list 'and\n         (first cond)\n         (if+-rewrite-cond-impl (next cond))))))\n\n#?(:clj\n   (defn- if+-rewrite-cond [cond]\n     (binding [*if+-syms (volatile! [])]\n       [(if+-rewrite-cond-impl cond) @*if+-syms])))\n\n#?(:clj\n   (defn- flatten-1 [xs]\n     (vec\n       (mapcat identity xs))))\n\n#?(:clj\n   (defmacro if+\n     \"Allows sharing local variables between condition and then clause.\n      \n      Use `:let [...]` form (not nested!) inside `and` condition and its bindings\n      will be visible in later `and` clauses and inside `then` branch:\n      \n        (if+ (and\n               (= 1 2)\n               ;; same :let syntax as in doseq/for\n               :let [x 3\n                     y (+ x 4)]\n               ;; x and y visible downstream\n               (> y x))\n          \n          ;; then: x and y visible here!\n          (+ x y 5)\n          \n          ;; else: no x or y\n          6)\"\n     [cond then else]\n     (if (and\n           (seq? cond)\n           (or\n             (= 'and (first cond))\n             (= 'clojure.core/and (first cond))))\n       (let [[cond' syms] (if+-rewrite-cond (next cond))]\n         `(let ~(flatten-1\n                  (for [[_ sym] syms]\n                    [sym '(volatile! nil)]))\n            (if ~cond'\n              (let ~(flatten-1\n                      (for [[binding sym] syms]\n                        [binding (list 'deref sym)]))\n                ~then)\n              ~else)))\n       (list 'if cond then else))))\n\n#?(:clj\n   (defmacro cond+ [& clauses]\n     (when-some [[test expr & rest] clauses]\n       (case test\n         :do   `(do ~expr (util/cond+ ~@rest))\n         :let  `(let ~expr (util/cond+ ~@rest))\n         :some `(or ~expr (util/cond+ ~@rest))\n         `(util/if+ ~test ~expr (util/cond+ ~@rest))))))\n\n#?(:clj\n   (defmacro some-of\n     ([] nil)\n     ([x] x)\n     ([x & more]\n      `(let [x# ~x] (if (nil? x#) (some-of ~@more) x#)))))\n\n(defn- rand-bits [pow]\n  (rand-int (bit-shift-left 1 pow)))\n\n#?(:cljs\n   (defn- to-hex-string [n l]\n     (let [s (.toString n 16)\n           c (count s)]\n       (cond\n         (> c l) (subs s 0 l)\n         (< c l) (str (apply str (repeat (- l c) \"0\")) s)\n         :else   s))))\n\n(defn squuid\n  ([]\n   (squuid #?(:clj  (System/currentTimeMillis)\n              :cljs (.getTime (js/Date.)))))\n  ([msec]\n   #?(:clj\n      (let [uuid     (UUID/randomUUID)\n            time     (int (/ msec 1000))\n            high     (.getMostSignificantBits uuid)\n            low      (.getLeastSignificantBits uuid)\n            new-high (bit-or (bit-and high 0x00000000FFFFFFFF)\n                       (bit-shift-left time 32))]\n        (UUID. new-high low))\n      :cljs\n      (uuid\n        (str\n          (-> (int (/ msec 1000))\n            (to-hex-string 8))\n          \"-\" (-> (rand-bits 16) (to-hex-string 4))\n          \"-\" (-> (rand-bits 16) (bit-and 0x0FFF) (bit-or 0x4000) (to-hex-string 4))\n          \"-\" (-> (rand-bits 16) (bit-and 0x3FFF) (bit-or 0x8000) (to-hex-string 4))\n          \"-\" (-> (rand-bits 16) (to-hex-string 4))\n          (-> (rand-bits 16) (to-hex-string 4))\n          (-> (rand-bits 16) (to-hex-string 4)))))))\n\n(defn squuid-time-millis\n  \"Returns time that was used in [[squuid]] call, in milliseconds, rounded to the closest second.\"\n  [uuid]\n  #?(:clj (-> (.getMostSignificantBits ^UUID uuid)\n            (bit-shift-right 32)\n            (* 1000))\n     :cljs (-> (subs (str uuid) 0 8)\n             (js/parseInt 16)\n             (* 1000))))\n\n(defn distinct-by [f coll]\n  (->>\n    (reduce\n      (fn [[seen res :as acc] el]\n        (let [key (f el)]\n          (if (contains? seen key)\n            acc\n            [(conj! seen key) (conj! res el)])))\n      [(transient #{}) (transient [])]\n      coll)\n    second\n    persistent!))\n\n(defn find [pred xs]\n  (reduce\n    (fn [_ x]\n      (when (pred x)\n        (reduced x)))\n    nil xs))\n\n(defn single [coll]\n  (assert (nil? (next coll)) \"Expected single element\")\n  (first coll))\n\n(defn concatv [& xs]\n  (into [] cat xs))\n\n(defn zip\n  ([a b]\n   (mapv vector a b))\n  ([a b & rest]\n   (apply mapv vector a b rest)))\n\n(defn removem [key-pred m]\n  (persistent!\n    (reduce-kv\n      (fn [m k v]\n        (if (key-pred k)\n          m\n          (assoc! m k v)))\n      (transient (empty m)) m)))\n\n(def conjv\n  (fnil conj []))\n\n(def conjs\n  (fnil conj #{}))\n\n(defn reduce-indexed\n  \"Same as reduce, but `f` takes [acc el idx]\"\n  [f init xs]\n  (first\n    (reduce\n      (fn [[acc idx] x]\n        (let [res (f acc x idx)]\n          (if (reduced? res)\n            (reduced [res idx])\n            [res (inc idx)])))\n      [init 0]\n      xs)))\n"],"x_google_ignoreList":[0]}