{"version":3,"sources":["cljserial/utils/icons.cljs"],"mappings":";AAcA,yCAAA,zCAAMA,0FAAeC;AAArB,AACE,GACE,AAACC,qBAAKD;AACN,OAACE,6CAAKH,uCAAcC;;AAFtB,GAIE,AAACG,wBAAQH;AACT,IAAMA,WAAK,2IAAA,zIACE,6CAAA,7CAACY,4FAAK,AAACJ,gBAAMR,QACb,AAACa,eAAKb,MAEAA;;IAJnBI,cAK6BJ;IAL7BK,cAAA,AAAAC,cAAAF;IAAAG,gBAAA,AAAAC,gBAAAH;IAAAA,kBAAA,AAAAI,eAAAJ;UAAAE,NAKOO;IALPP,oBAAA,AAAAC,gBAAAH;IAAAA,kBAAA,AAAAI,eAAAJ;YAAAE,RAKWQ;eALXV,XAKmBW;IALnBN,cAMuB,+BAAA,0GAAA,qCAAA,mFAAA,qKAAA,AAAA,mFAAA,vfACE,AAACO,qBAAKF,2FAAQA,MAAMC,mBACpB,6BAAA,5BAAG,AAACE,gBAAMlB,0GAAc,6CAAA,7CAACmB,gIAAMJ,cAAOC,0GAC3BA;;gBATpC,AAAAL,4CAAAD,YAAA,IAAA,xEAMOK;mBANP,AAAAJ,4CAAAD,YAAA,IAAA,3EAMaM;IAIPD,YAAM,iBAAAK,YAAQL;AAAR,AAAA,GACE,mDAAA,nDAACM,0BAAU,AAACC,eAAKtB;AACjB,qDAAAoB,UAAA,xDAACG,4GAAW,AAAA,kFAAM,AAACD,eAAKtB;;AAF1BoB;;;IAGNJ,eAAS,AAACQ,4CAAIzB,uCAAciB;AAblC,AAcE,oBAAID;AACF,OAAAU,yCAAA,AAAAC,mDAAA,vDAAGZ,4CAAIC,YAAMC;;AACb,OAAAS,yCAAA,AAAAC,sDAAA,1DAAGZ,4CAAIE;;;AArBb,AAuBQhB","names":["cljserial.utils.icons/hiccup->react","form","cljs.core/seq?","cljs.core.mapv","cljs.core/vector?","vec__117621","seq__117622","cljs.core/seq","first__117623","cljs.core/first","cljs.core/next","vec__117624","cljs.core.nth","cljs.core._EQ_","cljs.core/rest","tag","attrs","children","cljs.core/map?","cljs.core/count","cljs.core.into","G__117629","cljs.core/contains?","cljs.core/meta","cljs.core.assoc","cljs.core.map","uix.compiler.alpha/component-element","uix.compiler.attributes/interpret-props"],"sourcesContent":["(ns cljserial.utils.icons\n  (:require-macros [cljserial.utils.icons])\n  (:require\n   ; These two used by macros in icons.clj\n   [fontawesome.icons]\n   [phosphor.icons]\n   [uix.core :refer [$]]))\n\n\n;; This is adapted from the hiccup->uix function in as yet unreleased version\n;; of uix (>1.0.1), written by Roman Liutikov\n;; The original produces markup to paste as source, whereas this just\n;; removes some syntax quoting etc. in the last couple of lines to give\n;; js/react output instead.\n(defn hiccup->react [form]\n  (cond\n    (seq? form)\n    (mapv hiccup->react form)\n\n    (vector? form)\n    (let [form (cond\n                 (= :> (first form))\n                 (rest form)\n\n                 :else form)\n          [tag attrs & children] form\n          [attrs children] (cond\n                             (map? attrs) [attrs children]\n                             (> (count form) 1) [nil (into [attrs] children)]\n                             :else [nil children])\n          attrs (cond-> attrs\n                  (contains? (meta form) :key)\n                  (assoc :key (:key (meta form))))\n          children (map hiccup->react children)]\n      (if attrs\n        ($ tag attrs children)\n        ($ tag children)))\n\n    :else form))\n"]}