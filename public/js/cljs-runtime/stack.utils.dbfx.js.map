{"version":3,"sources":["stack/utils/dbfx.cljs"],"mappings":";AAcA,GAAA,QAAAA,kCAAAC,wCAAAC,6CAAAC;AAAA;AAAA,AAAA,wBAAA,xBAASC;;AAGT,GAAI,mEAAA,nEAACC,6CAAED;AACL,AACE,AAAKE,2BAAQC;;AACb,AAAKC,2BAAQC;;AACb,AAAKC,4BAASC;;AACd,AAAKC,iCAAcC;;AACnB,AAAKC,0BAAOC;;AACZ,AAAKC,4BAASC;;AACd,AAAKC,gCAAaC;;AAClB,AAAKC,gCAAaC;;AAClB,AAAKC,+BAAYC;;AAEjB,AAAKC,wBAAKC;;AACV,AAAKC,yBAAMC;;AACX,AAAKC,0BAAOC;;AAGZ,AAAKC,oCAAcC;;AAEnB,0CAAA,1CAAKC;;AACL,4BAAA,5BAAKC;;AAEP,AACE,AAAK3B,2BAAQ4B;;AAEb,AAAK1B,2BAAQ2B;;AACb,AAAKzB,4BAAS0B;;AACd,AAAKxB,iCAAcyB;;AACnB,AAAKvB,0BAAOwB;;AACZ,AAAKtB,4BAASuB;;AACd,AAAKrB,gCAAasB;;AAClB,AAAKpB,gCAAaqB;;AAClB,AAAKnB,+BAAYoB;;AAEjB,AAAKlB,wBAAKmB;;AACV,AAAKjB,yBAAMkB;;AACX,AAAKhB,0BAAOiB;;AAGZ,AAAKf,oCAAcgB;;AACnB,AAAKd,0CAAuBe;;AAC5B,AAAKd,4BAASe;;AAQlB,IAAAC,iBAAA;IAAAC,iBAEC,WAAKC,KAAKC;AAAV,AACE,0DAAA,nDAACC,8CAAMF,mEAAgB,AAAMG;;AAHhC,AAAA,mHAAAL,eAAAC,uDAAAD,eAAAC,vMAAClC,0DAAAA,yFAAAA;AAKD;;;4CAAA,5CAAMuC,gGAEHC;AAFH,AAGE,IAAAC,WAAO,AAACC,gDAAQC,mCAA6BH;AAA7C,AAAA,oHAAAC,8CAAAA,1JAAC/B,uDAAAA,iEAAAA","names":["js/stack","js/stack.utils","js/stack.utils.dbfx","js/stack.utils.dbfx.impl","stack.utils.dbfx/impl","cljs.core._EQ_","stack.utils.dbfx/reg-sub","refx.alpha/reg-sub","stack.utils.dbfx/use-sub","refx.alpha/use-sub","stack.utils.dbfx/dispatch","refx.alpha/dispatch","stack.utils.dbfx/dispatch-sync","refx.alpha/dispatch-sync","stack.utils.dbfx/reg-fx","refx.alpha/reg-fx","stack.utils.dbfx/reg-cofx","refx.alpha/reg-cofx","stack.utils.dbfx/reg-event-fx","refx.alpha/reg-event-fx","stack.utils.dbfx/reg-event-db","refx.alpha/reg-event-db","stack.utils.dbfx/inject-cofx","refx.alpha/inject-cofx","stack.utils.dbfx/path","refx.interceptors/path","stack.utils.dbfx/after","refx.interceptors/after","stack.utils.dbfx/unwrap","refx.interceptors/unwrap","stack.utils.dbfx/->interceptor","refx.interceptor/->interceptor","stack.utils.dbfx/reg-global-interceptor","stack.utils.dbfx/reg-flow","re-frame.core/reg-sub","uix.re-frame/use-subscribe","re-frame.core/dispatch","re-frame.core/dispatch-sync","re-frame.core/reg-fx","re-frame.core/reg-cofx","re-frame.core/reg-event-fx","re-frame.core/reg-event-db","re-frame.core/inject-cofx","re-frame.core/path","re-frame.core/after","re-frame.core/unwrap","re-frame.core/->interceptor","re-frame.core/reg-global-interceptor","re-frame.alpha/reg-flow","G__93983","G__93984","cofx","_","cljs.core.assoc","js/Date","stack.utils.dbfx/schema-check-interceptor","schema","G__93995","cljs.core.partial","stack.utils.schema/check-and-throw"],"sourcesContent":["(ns stack.utils.dbfx\n  \"Facade to allow switching between refx and re-frame for app state management.\n  Probably don't want to do this long term, but keeping options open for now.\n  Re-frame is more actively maintained and has some nice dev tooling (re-frame 10x etc).\n  refx is an adaptation to use more recent react conventions.\n  Might want to do comparative performance evaluation at some point (though likely a non-issue for our level of complexity). \"\n  (:require [refx.alpha :as refx]\n            [refx.interceptor]\n            [refx.interceptors]\n            [re-frame.core :as rf]\n            [re-frame.alpha :as ra]\n            [uix.re-frame :as urf]\n            [stack.utils.schema :as schema-utils]))\n\n(defonce impl :re-frame)\n\n\n(if (= impl :refx)\n  (do ;; refx aliases\n    (def reg-sub refx/reg-sub)\n    (def use-sub refx/use-sub)\n    (def dispatch refx/dispatch)\n    (def dispatch-sync refx/dispatch-sync)\n    (def reg-fx refx/reg-fx)\n    (def reg-cofx refx/reg-cofx)\n    (def reg-event-fx refx/reg-event-fx)\n    (def reg-event-db refx/reg-event-db)\n    (def inject-cofx refx/inject-cofx)\n\n    (def path refx.interceptors/path)\n    (def after refx.interceptors/after)\n    (def unwrap refx.interceptors/unwrap)\n\n    ;; The global interceptor -- instrument all published events\n    (def ->interceptor refx.interceptor/->interceptor)\n    ;;FIXME: Do these exist for refx?\n    (def reg-global-interceptor nil)\n    (def reg-flow nil))\n\n  (do ;; re-frame aliases\n    (def reg-sub rf/reg-sub)\n    ;; (def use-sub rf-utils/use-subscribe)\n    (def use-sub urf/use-subscribe)\n    (def dispatch rf/dispatch)\n    (def dispatch-sync rf/dispatch-sync)\n    (def reg-fx rf/reg-fx)\n    (def reg-cofx rf/reg-cofx)\n    (def reg-event-fx rf/reg-event-fx)\n    (def reg-event-db rf/reg-event-db)\n    (def inject-cofx rf/inject-cofx)\n\n    (def path rf/path)\n    (def after rf/after)\n    (def unwrap rf/unwrap)\n\n    ;; The global interceptor -- instrument all published events\n    (def ->interceptor rf/->interceptor)\n    (def reg-global-interceptor re-frame.core/reg-global-interceptor)\n    (def reg-flow ra/reg-flow)))\n\n;; -- cofx Registrations  -----------------------------------------------------\n\n;; now / timestamp coeffects\n;; this allows timestamp to be injected (or stubbed for testing), keeping event handler functions pure\n;; Should this be optional? I.e. wrapped in a (defn reg-timestamp-cofx ...) and\n;; called from the view model init?\n(reg-cofx\n :timestamp\n (fn [cofx _]\n   (assoc cofx :timestamp (.now js/Date))))\n\n(defn schema-check-interceptor\n  \"Defines a refx interceptor that validates updated db content against a given (malli) `schema`\"\n  [schema]\n  (after (partial schema-utils/check-and-throw schema)))\n"]}