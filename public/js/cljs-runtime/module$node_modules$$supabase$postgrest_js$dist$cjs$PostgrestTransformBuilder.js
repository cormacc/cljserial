shadow$provide.module$node_modules$$supabase$postgrest_js$dist$cjs$PostgrestTransformBuilder = function(global, require, module, exports) {
  global = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {"default":mod};
  };
  Object.defineProperty(exports, "__esModule", {value:!0});
  require = global(require("module$node_modules$$supabase$postgrest_js$dist$cjs$PostgrestBuilder"));
  class PostgrestTransformBuilder extends require.default {
    select(columns) {
      let quoted = !1;
      columns = (null !== columns && void 0 !== columns ? columns : "*").split("").map(c => {
        if (/\s/.test(c) && !quoted) {
          return "";
        }
        '"' === c && (quoted = !quoted);
        return c;
      }).join("");
      this.url.searchParams.set("select", columns);
      this.headers.Prefer && (this.headers.Prefer += ",");
      this.headers.Prefer += "return\x3drepresentation";
      return this;
    }
    order(column, {ascending = !0, nullsFirst, foreignTable, referencedTable = foreignTable} = {}) {
      foreignTable = referencedTable ? `${referencedTable}.order` : "order";
      referencedTable = this.url.searchParams.get(foreignTable);
      this.url.searchParams.set(foreignTable, `${referencedTable ? `${referencedTable},` : ""}${column}.${ascending ? "asc" : "desc"}${void 0 === nullsFirst ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
      return this;
    }
    limit(count, {foreignTable, referencedTable = foreignTable} = {}) {
      this.url.searchParams.set("undefined" === typeof referencedTable ? "limit" : `${referencedTable}.limit`, `${count}`);
      return this;
    }
    range(from, to, {foreignTable, referencedTable = foreignTable} = {}) {
      foreignTable = "undefined" === typeof referencedTable ? "limit" : `${referencedTable}.limit`;
      this.url.searchParams.set("undefined" === typeof referencedTable ? "offset" : `${referencedTable}.offset`, `${from}`);
      this.url.searchParams.set(foreignTable, `${to - from + 1}`);
      return this;
    }
    abortSignal(signal) {
      this.signal = signal;
      return this;
    }
    single() {
      this.headers.Accept = "application/vnd.pgrst.object+json";
      return this;
    }
    maybeSingle() {
      this.headers.Accept = "GET" === this.method ? "application/json" : "application/vnd.pgrst.object+json";
      this.isMaybeSingle = !0;
      return this;
    }
    csv() {
      this.headers.Accept = "text/csv";
      return this;
    }
    geojson() {
      this.headers.Accept = "application/geo+json";
      return this;
    }
    explain({analyze = !1, verbose = !1, settings = !1, buffers = !1, wal = !1, format = "text"} = {}) {
      var _a;
      analyze = [analyze ? "analyze" : null, verbose ? "verbose" : null, settings ? "settings" : null, buffers ? "buffers" : null, wal ? "wal" : null].filter(Boolean).join("|");
      verbose = null !== (_a = this.headers.Accept) && void 0 !== _a ? _a : "application/json";
      this.headers.Accept = `application/vnd.pgrst.plan+${format}; for="${verbose}"; options=${analyze};`;
      return this;
    }
    rollback() {
      var _a;
      0 < (null !== (_a = this.headers.Prefer) && void 0 !== _a ? _a : "").trim().length ? this.headers.Prefer += ",tx\x3drollback" : this.headers.Prefer = "tx\x3drollback";
      return this;
    }
    returns() {
      return this;
    }
  }
  exports.default = PostgrestTransformBuilder;
};

//# sourceMappingURL=module$node_modules$$supabase$postgrest_js$dist$cjs$PostgrestTransformBuilder.js.map
