shadow$provide.module$node_modules$$supabase$auth_js$dist$main$GoTrueAdminApi = function(global, require, module, exports) {
  var __rest = this && this.__rest || function(s, e) {
    var t = {}, p;
    for (p in s) {
      Object.prototype.hasOwnProperty.call(s, p) && 0 > e.indexOf(p) && (t[p] = s[p]);
    }
    if (null != s && "function" === typeof Object.getOwnPropertySymbols) {
      var i = 0;
      for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        0 > e.indexOf(p[i]) && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
      }
    }
    return t;
  };
  Object.defineProperty(exports, "__esModule", {value:!0});
  const fetch_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$fetch"), helpers_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$helpers"), errors_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$errors");
  class GoTrueAdminApi {
    constructor({url = "", headers = {}, fetch}) {
      this.url = url;
      this.headers = headers;
      this.fetch = (0,helpers_1.resolveFetch)(fetch);
      this.mfa = {listFactors:this._listFactors.bind(this), deleteFactor:this._deleteFactor.bind(this)};
    }
    async signOut(jwt, scope = "global") {
      try {
        return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {headers:this.headers, jwt, noResolveJson:!0}), {data:null, error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async inviteUserByEmail(email, options = {}) {
      try {
        return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/invite`, {body:{email, data:options.data}, headers:this.headers, redirectTo:options.redirectTo, xform:fetch_1._userResponse});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null}, error};
        }
        throw error;
      }
    }
    async generateLink(params) {
      try {
        const {options} = params, rest = __rest(params, ["options"]), body = Object.assign(Object.assign({}, rest), options);
        "newEmail" in rest && (body.new_email = null === rest || void 0 === rest ? void 0 : rest.newEmail, delete body.newEmail);
        return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/admin/generate_link`, {body, headers:this.headers, xform:fetch_1._generateLinkResponse, redirectTo:null === options || void 0 === options ? void 0 : options.redirectTo});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{properties:null, user:null}, error};
        }
        throw error;
      }
    }
    async createUser(attributes) {
      try {
        return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/admin/users`, {body:attributes, headers:this.headers, xform:fetch_1._userResponse});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null}, error};
        }
        throw error;
      }
    }
    async listUsers(params) {
      var _a, _b, _c, _d, _e, _f, _g;
      try {
        const pagination = {nextPage:null, lastPage:0, total:0}, response = await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/admin/users`, {headers:this.headers, noResolveJson:!0, query:{page:null !== (_b = null === (_a = null === params || void 0 === params ? void 0 : params.page) || void 0 === _a ? void 0 : _a.toString()) && void 0 !== _b ? _b : "", per_page:null !== (_d = null === (_c = null === params || void 0 === params ? void 0 : params.perPage) || void 0 === _c ? void 0 : _c.toString()) && 
        void 0 !== _d ? _d : ""}, xform:fetch_1._noResolveJsonResponse});
        if (response.error) {
          throw response.error;
        }
        const users = await response.json(), total = null !== (_e = response.headers.get("x-total-count")) && void 0 !== _e ? _e : 0, links = null !== (_g = null === (_f = response.headers.get("link")) || void 0 === _f ? void 0 : _f.split(",")) && void 0 !== _g ? _g : [];
        0 < links.length && (links.forEach(link => {
          const page = parseInt(link.split(";")[0].split("\x3d")[1].substring(0, 1));
          link = JSON.parse(link.split(";")[1].split("\x3d")[1]);
          pagination[`${link}Page`] = page;
        }), pagination.total = parseInt(total));
        return {data:Object.assign(Object.assign({}, users), pagination), error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{users:[]}, error};
        }
        throw error;
      }
    }
    async getUserById(uid) {
      try {
        return await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {headers:this.headers, xform:fetch_1._userResponse});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null}, error};
        }
        throw error;
      }
    }
    async updateUserById(uid, attributes) {
      try {
        return await (0,fetch_1._request)(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {body:attributes, headers:this.headers, xform:fetch_1._userResponse});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null}, error};
        }
        throw error;
      }
    }
    async deleteUser(id, shouldSoftDelete = !1) {
      try {
        return await (0,fetch_1._request)(this.fetch, "DELETE", `${this.url}/admin/users/${id}`, {headers:this.headers, body:{should_soft_delete:shouldSoftDelete}, xform:fetch_1._userResponse});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null}, error};
        }
        throw error;
      }
    }
    async _listFactors(params) {
      try {
        const {data, error} = await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/admin/users/${params.userId}/factors`, {headers:this.headers, xform:factors => ({data:{factors}, error:null})});
        return {data, error};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async _deleteFactor(params) {
      try {
        return {data:await (0,fetch_1._request)(this.fetch, "DELETE", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {headers:this.headers}), error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
  }
  exports.default = GoTrueAdminApi;
};

//# sourceMappingURL=module$node_modules$$supabase$auth_js$dist$main$GoTrueAdminApi.js.map
