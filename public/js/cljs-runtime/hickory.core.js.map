{"version":3,"sources":["hickory/core.cljs"],"mappings":"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","names":["hickory$core$HiccupRepresentable$as_hiccup$dyn","x__5350__auto__","m__5351__auto__","hickory.core/as-hiccup","goog/typeOf","m__5349__auto__","cljs.core/missing-protocol","hickory.core/HiccupRepresentable","this","hickory$core$HickoryRepresentable$as_hickory$dyn","hickory.core/as-hickory","hickory.core/HickoryRepresentable","hickory.core/node-type","type","G__96512","js/Error","hickory.core/Attribute","hickory.core/Comment","hickory.core/Document","hickory.core/DocumentType","hickory.core/Element","hickory.core/Text","hickory.core/as-seq","nodelist","cljs.core/seq?","cljs.core.array_seq","hickory.core/format-doctype","dt","name","publicId","systemId","cljs.core/seq","goog.string/format","pred__96525","expr__96526","cljs.core/=","hickory.utils/lower-case-keyword","cljs.core.map","tag","cljs.core.into","cljs.core.concat","hickory.utils/unescapable-content","js/goog.dom.getRawTextContent","hickory.utils/html-escape","pred__96537","expr__96538","cljs.core/not-empty","hickory.core/extract-doctype","s","temp__5823__auto__","doctype","cljs.core/second","or__5002__auto__","cljs.core/re-find","hickory.core/remove-el","el","hickory.core/parse-dom-with-domparser","js/DOMParser","hickory.core/parse-dom-with-write","doc","js/document.implementation","doctype-el","title-el","cljs.core/empty?","hickory.core/parse","hickory.core/parse-fragment"],"sourcesContent":["(ns hickory.core\n  (:require [hickory.utils :as utils]\n            [clojure.zip :as zip]\n            [goog.string :as gstring]\n            [goog.dom]\n            [goog.dom.NodeType]))\n\n;;\n;; Protocols\n;;\n\n(defprotocol HiccupRepresentable\n  \"Objects that can be represented as Hiccup nodes implement this protocol in\n   order to make the conversion.\"\n  (as-hiccup [this]\n    \"Converts the node given into a hiccup-format data structure. The\n     node must have an implementation of the HiccupRepresentable\n     protocol; nodes created by parse or parse-fragment already do.\"))\n\n(defprotocol HickoryRepresentable\n  \"Objects that can be represented as HTML DOM node maps, similar to\n   clojure.xml, implement this protocol to make the conversion.\n\n   Each DOM node will be a map or string (for Text/CDATASections). Nodes that\n   are maps have the appropriate subset of the keys\n\n     :type     - [:comment, :document, :document-type, :element]\n     :tag      - node's tag, check :type to see if applicable\n     :attrs    - node's attributes as a map, check :type to see if applicable\n     :content  - node's child nodes, in a vector, check :type to see if\n                 applicable\"\n  (as-hickory [this]\n    \"Converts the node given into a hickory-format data structure. The\n     node must have an implementation of the HickoryRepresentable protocol;\n     nodes created by parse or parse-fragment already do.\"))\n\n(defn node-type [type]\n  (case type\n    \"ELEMENT\" 1\n    \"ATTRIBUTE\" 2\n    \"TEXT\" 3\n    \"CDATA_SECTION\" 4\n    \"ENTITY_REFERENCE\" 5\n    \"ENTITY\" 6\n    \"PROCESSING_INSTRUCTION\" 7\n    \"COMMENT\" 8\n    \"DOCUMENT\" 9\n    \"DOCUMENT_TYPE\" 10\n    \"DOCUMENT_FRAGMENT\" 11\n    \"NOTATION\" 12))\n\n(def Attribute (node-type \"ATTRIBUTE\"))\n(def Comment (node-type \"COMMENT\"))\n(def Document (node-type \"DOCUMENT\"))\n(def DocumentType (node-type \"DOCUMENT_TYPE\"))\n(def Element (node-type \"ELEMENT\"))\n(def Text (node-type \"TEXT\"))\n\n(defn- as-seq [nodelist]\n  (if (seq? nodelist) nodelist (array-seq nodelist)))\n\n(defn format-doctype\n  [dt]\n  (let [name (.-name dt)\n        publicId (.-publicId dt)\n        systemId (.-systemId dt)]\n    (if (seq publicId)\n      (gstring/format \"<!DOCTYPE %s PUBLIC \\\"%s\\\" \\\"%s\\\">\" name publicId systemId)\n      (str \"<!DOCTYPE \" name \">\"))))\n\n(extend-protocol HiccupRepresentable\n  object\n  (as-hiccup [this] (condp = (.-nodeType this)\n                      Attribute [(utils/lower-case-keyword (.-name this))\n                                 (.-value this)]\n                      Comment (str \"<!--\" (.-data this) \"-->\")\n                      Document (map as-hiccup (as-seq (.-childNodes this)))\n                      DocumentType (format-doctype this)\n                      ;; There is an issue with the hiccup format, which is that it\n                      ;; can't quite cover all the pieces of HTML, so anything it\n                      ;; doesn't cover is thrown into a string containing the raw\n                      ;; HTML. This presents a problem because it is then never the case\n                      ;; that a string in a hiccup form should be html-escaped (except\n                      ;; in an attribute value) when rendering; it should already have\n                      ;; any escaping. Since the HTML parser quite properly un-escapes\n                      ;; HTML where it should, we have to go back and un-un-escape it\n                      ;; wherever text would have been un-escaped. We do this by\n                      ;; html-escaping the parsed contents of text nodes, and not\n                      ;; html-escaping comments, data-nodes, and the contents of\n                      ;; unescapable nodes.\n                      Element (let [tag (utils/lower-case-keyword (.-tagName this))]\n                                (into [] (concat [tag\n                                                  (into {} (map as-hiccup (as-seq (.-attributes this))))]\n                                                 (if (utils/unescapable-content tag)\n                                                   (map goog.dom.getRawTextContent (as-seq (.-childNodes this)))\n                                                   (map as-hiccup (as-seq (.-childNodes this)))))))\n                      Text (utils/html-escape (goog.dom.getRawTextContent this)))))\n\n(extend-protocol HickoryRepresentable\n  object\n  (as-hickory [this] (condp = (.-nodeType this)\n                       Attribute [(utils/lower-case-keyword (.-name this)) (.-value this)]\n                       Comment {:type :comment\n                                :content [(.-data this)]}\n                       Document {:type :document\n                                 :content (not-empty\n                                            (into [] (map as-hickory\n                                                          (as-seq (.-childNodes this)))))}\n                       DocumentType {:type :document-type\n                                     :attrs {:name (.-name this)\n                                             :publicid (.-publicId this)\n                                             :systemid (.-systemId this)}}\n                       Element {:type :element\n                                :attrs (not-empty (into {} (map as-hickory (as-seq (.-attributes this)))))\n                                :tag (utils/lower-case-keyword (.-tagName this))\n                                :content (not-empty\n                                           (into [] (map as-hickory\n                                                         (as-seq (.-childNodes this)))))}\n                       Text (goog.dom.getRawTextContent this))))\n\n(defn extract-doctype\n  [s]\n  ;;Starting HTML5 doctype definition can be uppercase\n  (when-let [doctype (second (or (re-find #\"<!DOCTYPE ([^>]*)>\" s)\n                                 (re-find #\"<!doctype ([^>]*)>\" s)))]\n    (re-find #\"([^\\s]*)(\\s+PUBLIC\\s+[\\\"]?([^\\\"]*)[\\\"]?\\s+[\\\"]?([^\\\"]*)[\\\"]?)?\" doctype)))\n\n(defn remove-el\n  [el]\n  (.removeChild (.-parentNode el) el))\n\n(defn parse-dom-with-domparser\n  [s]\n  (when (exists? js/DOMParser)\n    (.parseFromString (js/DOMParser.) s \"text/html\")))\n\n(defn parse-dom-with-write\n  \"Parse an HTML document (or fragment) as a DOM using document.implementation.createHTMLDocument and document.write.\"\n  [s]\n  ;;See http://www.w3.org/TR/domcore/#dom-domimplementation-createhtmldocument for more details.\n  (let [doc (.createHTMLDocument js/document.implementation \"\") ;;empty title for older implementation\n        doctype-el (.-doctype doc)]\n    (when-not (extract-doctype s);; Remove default doctype if parsed string does not define it.\n      (remove-el doctype-el))\n    (when-let [title-el (-> doc .-head .-firstChild)];; Remove default title if parsed string does not define it.\n      (when (empty? (.-text title-el))\n          (remove-el title-el)))\n    (.write doc s)\n    doc))\n\n(defn parse\n  \"Parse an entire HTML document into a DOM structure that can be\n   used as input to as-hiccup or as-hickory.\n\n```klipse\n  (-> (parse \\\"<a style=\\\\\\\"visibility:hidden\\\\\\\">foo</a><div style=\\\\\\\"color:green\\\\\\\"><p>Hello</p></div>\\\")\n    as-hiccup)\n```\n\n```klipse\n  (-> (parse \\\"<a style=\\\\\\\"visibility:hidden\\\\\\\">foo</a><div style=\\\\\\\"color:green\\\\\\\"><p>Hello</p></div>\\\")\n    as-hickory)\n```\n\n\n  \"\n  [s]\n  (or (parse-dom-with-domparser s) (parse-dom-with-write s)))\n\n(defn parse-fragment\n  \"Parse an HTML fragment (some group of tags that might be at home somewhere\n   in the tag hierarchy under <body>) into a list of DOM elements that can\n   each be passed as input to as-hiccup or as-hickory.\"\n  [s]\n  (as-seq (-> (parse s) .-body .-childNodes)))\n"],"x_google_ignoreList":[0]}