{
"version":3,
"file":"module$node_modules$$supabase$auth_js$dist$main$lib$locks.js",
"lineCount":74,
"mappings":"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",
"sources":["node_modules/@supabase/auth-js/dist/main/lib/locks.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$supabase$auth_js$dist$main$lib$locks\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.processLock = exports.navigatorLock = exports.ProcessLockAcquireTimeoutError = exports.NavigatorLockAcquireTimeoutError = exports.LockAcquireTimeoutError = exports.internals = void 0;\nconst helpers_1 = require(\"./helpers\");\n/**\n * @experimental\n */\nexports.internals = {\n    /**\n     * @experimental\n     */\n    debug: !!(globalThis &&\n        (0, helpers_1.supportsLocalStorage)() &&\n        globalThis.localStorage &&\n        globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'),\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */\nclass LockAcquireTimeoutError extends Error {\n    constructor(message) {\n        super(message);\n        this.isAcquireTimeout = true;\n    }\n}\nexports.LockAcquireTimeoutError = LockAcquireTimeoutError;\nclass NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nexports.NavigatorLockAcquireTimeoutError = NavigatorLockAcquireTimeoutError;\nclass ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nexports.ProcessLockAcquireTimeoutError = ProcessLockAcquireTimeoutError;\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nasync function navigatorLock(name, acquireTimeout, fn) {\n    if (exports.internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n        setTimeout(() => {\n            abortController.abort();\n            if (exports.internals.debug) {\n                console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\n            }\n        }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping navigator.locks.request() with a plain Promise is done as some\n    // libraries like zone.js patch the Promise object to track the execution\n    // context. However, it appears that most browsers use an internal promise\n    // implementation when using the navigator.locks.request() API causing them\n    // to lose context and emit confusing log messages or break certain features.\n    // This wrapping is believed to help zone.js track the execution context\n    // better.\n    return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0\n        ? {\n            mode: 'exclusive',\n            ifAvailable: true,\n        }\n        : {\n            mode: 'exclusive',\n            signal: abortController.signal,\n        }, async (lock) => {\n        if (lock) {\n            if (exports.internals.debug) {\n                console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\n            }\n            try {\n                return await fn();\n            }\n            finally {\n                if (exports.internals.debug) {\n                    console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\n                }\n            }\n        }\n        else {\n            if (acquireTimeout === 0) {\n                if (exports.internals.debug) {\n                    console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\n                }\n                throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n            }\n            else {\n                if (exports.internals.debug) {\n                    try {\n                        const result = await globalThis.navigator.locks.query();\n                        console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\n                    }\n                    catch (e) {\n                        console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\n                    }\n                }\n                // Browser is not following the Navigator LockManager spec, it\n                // returned a null lock when we didn't use ifAvailable. So we can\n                // pretend the lock is acquired in the name of backward compatibility\n                // and user experience and just run the function.\n                console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\n                return await fn();\n            }\n        }\n    }));\n}\nexports.navigatorLock = navigatorLock;\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nasync function processLock(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    const currentOperation = Promise.race([\n        previousOperation.catch(() => {\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n        }),\n        acquireTimeout >= 0\n            ? new Promise((_, reject) => {\n                setTimeout(() => {\n                    reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name \"${name}\" timed out`));\n                }, acquireTimeout);\n            })\n            : null,\n    ].filter((x) => x))\n        .catch((e) => {\n        if (e && e.isAcquireTimeout) {\n            throw e;\n        }\n        return null;\n    })\n        .then(async () => {\n        // previous operations finished and we didn't get a race on the acquire\n        // timeout, so the current operation can finally start\n        return await fn();\n    });\n    PROCESS_LOCKS[name] = currentOperation.catch(async (e) => {\n        if (e && e.isAcquireTimeout) {\n            // if the current operation timed out, it doesn't mean that the previous\n            // operation finished, so we need contnue waiting for it to finish\n            await previousOperation;\n            return null;\n        }\n        throw e;\n    });\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return await currentOperation;\n}\nexports.processLock = processLock;\n//# sourceMappingURL=locks.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","processLock","navigatorLock","ProcessLockAcquireTimeoutError","NavigatorLockAcquireTimeoutError","LockAcquireTimeoutError","internals","helpers_1","debug","globalThis","supportsLocalStorage","localStorage","getItem","Error","constructor","message","isAcquireTimeout","name","acquireTimeout","fn","console","log","abortController","AbortController","setTimeout","abort","Promise","resolve","then","navigator","locks","request","mode","ifAvailable","signal","lock","result","query","JSON","stringify","e","warn","PROCESS_LOCKS","_a","previousOperation","currentOperation","race","catch","_","reject","filter","x"]
}
