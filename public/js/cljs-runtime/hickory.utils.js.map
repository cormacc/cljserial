{"version":3,"sources":["hickory/utils.cljc"],"mappings":";AASA;;;6BAAA,kFAAA,sDAAA,0DAAA,uDAAA,gEAAA,8DAAA,4DAAA,2DAAA,yDAAA,yDAAA,qDAAA,2DAAA,yDAAA,6DAAA,8DAAA,wDAAA,z9BAAKA;AAKL;;;oCAAA,iFAAA,+DAAA,pLAAKC;AAQL;;;8CAAA,9CAAMC,oGAEKC;AAFX,AAkBW,OAACC,uBAAmBD;;AAE/B,4BAAA,5BAAME,gEACHF;AADH,AAGW,OAACC,uBAAmBD;;AAE/B,4BAAA,5BAAMG,gEACKH,EAAUI;AADrB,AAGW,OAACC,uBAAuBL,EAAEI;;AAErC;;;mCAAA,nCAAME,8EAEHN;AAFH,AAGE,uDAAA,0BAAIA,1BAAEO,hDAAkBC;;AAE1B;;;;+BAAA,/BAAMC,sEAGHC,KAAKC,SAASC;AAHjB,AAIE,QAAA,4UAAA,nRAAkBF,MACb,iDAAA,mFAAA,lHAAM,AAACG,oBAAUF,WACf,CAAA,mEAAA,VAAkBA,+BACpB,iDAAA,4EAAA,3GAAM,AAACE,oBAAUD,WACf,CAAA,4DAAA,VAAWA","names":["hickory.utils/void-element","hickory.utils/unescapable-content","hickory.utils/clj-html-escape-without-quoin","s","goog.string/htmlEscape","hickory.utils/html-escape","hickory.utils/starts-with","prefix","js/goog.string.startsWith","hickory.utils/lower-case-keyword","clojure.string/lower-case","cljs.core.keyword","hickory.utils/render-doctype","name","publicid","systemid","cljs.core/not-empty"],"sourcesContent":["(ns hickory.utils\n  \"Miscellaneous utilities used internally.\"\n  (:require [clojure.string :as string]\n            #?(:cljs [goog.string :as gstring])))\n\n;;\n;; Data\n;;\n\n(def void-element\n  \"Elements that don't have a meaningful <tag></tag> form.\"\n  #{:area :base :br :col :command :embed :hr :img :input :keygen :link :meta\n    :param :source :track :wbr})\n\n(def unescapable-content\n  \"Elements whose content should never have html-escape codes.\"\n  #{:script :style})\n\n;;\n;; String utils\n;;\n\n(defn clj-html-escape-without-quoin\n  \"Actually copy pasted from quoin: https://github.com/davidsantiago/quoin/blob/develop/src/quoin/text.clj\"\n  [^String s]\n  ;; This method is \"Java in Clojure\" for serious speedups.\n  #?(:clj (let [sb (StringBuilder.)\n                slength (long (count s))]\n            (loop [idx (long 0)]\n              (if (>= idx slength)\n                (.toString sb)\n                (let [c (char (.charAt s idx))]\n                  (case c\n                    \\& (.append sb \"&amp;\")\n                    \\< (.append sb \"&lt;\")\n                    \\> (.append sb \"&gt;\")\n                    \\\" (.append sb \"&quot;\")\n                    (.append sb c))\n                  (recur (inc idx))))))\n     ;; This shouldn't be called directly in cljs, but if it is, we use the same implementation as the html-escape function\n     :cljs (gstring/htmlEscape s)))\n\n(defn html-escape\n  [s]\n  #?(:clj  (clj-html-escape-without-quoin s)\n     :cljs (gstring/htmlEscape s)))\n\n(defn starts-with\n  [^String s ^String prefix]\n  #?(:clj  (.startsWith s prefix)\n     :cljs (goog.string.startsWith s prefix)))\n\n(defn lower-case-keyword\n  \"Converts its string argument into a lowercase keyword.\"\n  [s]\n  (-> s string/lower-case keyword))\n\n(defn render-doctype\n  \"Returns a string containing the HTML source for the doctype with given args.\n   The second and third arguments can be nil or empty strings.\"\n  [name publicid systemid]\n  (str \"<!DOCTYPE \" name\n       (when (not-empty publicid)\n         (str \" PUBLIC \\\"\" publicid \"\\\"\"))\n       (when (not-empty systemid)\n         (str \" \\\"\" systemid \"\\\"\"))\n       \">\"))\n"],"x_google_ignoreList":[0]}