{"version":3,"sources":["taoensso/encore/signals.cljc"],"mappings":"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","names":["taoensso.encore.signals/level-aliases","cljs.core.conj","expected","cljs.core/set","cljs.core/keys","taoensso.encore.signals/bad-level!","x","cljs.core.ex_info","cljs.core/type","taoensso.encore.signals/-valid-level-int","cljs.core/Keyword","or__5002__auto__","cljs.core.get","cljs.core/integer?","cljs.core/long","taoensso.encore.signals/-valid-level","nf-compile","nf-spec","taoensso.encore/name-filter","nf-match?","n","nf->min-level","ml-spec","nf-arg","cljs.core/vector?","taoensso.encore.rsome","p__60995","vec__61000","cljs.core.nth","min-level","taoensso.encore.signals/valid-nf-spec","temp__5821__auto__","t","e61005","cljs.core/fn?","taoensso.encore.signals/allow-name?","taoensso.encore.signals/parse-min-level","kind","cljs.core/map?","temp__5823__auto__","ml-spec*","parse-min-level","var_args","G__61026","taoensso.encore.signals/allow-level?","js/Error","level","taoensso.encore.signals.allow_level_QMARK_","taoensso.encore.signals/valid-min-level","taoensso.encore/run!","p__61040","vec__61041","taoensso.encore.signals/update-min-level","old","new","b2__38440__auto__","old-map","old-val","new-val","new-map","cljs.core/not-empty","cljs.core.dissoc","cljs.core.assoc","simplified","cljs.core._EQ_","cljs.core/count","old-vec","new-vec","exact-match?","cljs.core.pr_str","cljs.core.reduce","p__61068","vec__61076","acc","nf-spec*","_min-level","entry","G__61079","vec__61082","vec__61085","cljs.core/contains?","unused__11220__auto__","self__","G__61105","args61104","cljs.core/aclone","this__5287__auto__","writer__5288__auto__","opt__5289__auto__","cljs.core/-write","taoensso.encore.signals/SigFilter","taoensso.encore.signals/->SigFilter","kind-filter","ns-filter","id-filter","filter-fn","_","taoensso.encore.assoc_some","ns","id","ct-map","taoensso.encore.signals/sig-filter?","taoensso.encore.signals/sig-filter","get-cached","taoensso.encore/fmemoize","taoensso.encore/run-kv!","p__61151","map__61152","cljs.core/--destructure-map","and__5000__auto__","p__61162","map__61165","as","specs","taoensso$encore$signals$IFilterableSignal$allow_signal_QMARK_$dyn","x__5350__auto__","m__5351__auto__","taoensso.encore.signals/allow-signal?","goog/typeOf","m__5349__auto__","cljs.core/missing-protocol","taoensso$encore$signals$IFilterableSignal$signal_value$dyn","taoensso.encore.signals/signal-value","taoensso$encore$signals$IFilterableSignal$signal_debug$dyn","taoensso.encore.signals/signal-debug","taoensso.encore.signals/IFilterableSignal","sig-filter","handler-sample-rate","nil-sf","taoensso.encore.signals/update-sig-filter","base","cljs.core/empty?","old-min-level","e","cljs.core/find","cljs.core/val","f","basic-rate-limiters_","taoensso.encore/latom","full-rate-limiters_","G__61219","taoensso.encore.signals/expansion-limited!?","exp-id","spec","rl","G__61224","G__61225","p1__61210#","taoensso.encore.rate_limiter","req-id","G__61226","G__61227","p1__61212#","G__61239","taoensso.encore.signals/get-handlers-map","handlers-vec","taoensso.encore.signals.get_handlers_map","raw?","m","wrapped-handler-fn","whm","cljs.core/meta","info","cljs.core/select-keys","stats-fn","cljs.core/Delay","taoensso.encore.signals/get-handlers-stats","handlers-map","cljs.core/reduce-kv","p__61245","map__61246","handler-id","taoensso.encore.signals/call-handlers!","signal","cljs.core/run!","taoensso.encore.signals/stop-handlers!","results","p__61264","map__61265","taoensso.encore.signals/get-wrapped-handler-fn","p1__61269#","taoensso.encore.rfirst","taoensso.encore.signals/remove-handler","p1__61275#","cljs.core/filterv","cljs.core.not_EQ_","G__61295","taoensso.encore.signals/add-handler","pre-wrapped-handler-fn","cljs.core/not","p1__61285#","taoensso.encore.sortv","cljs.core.get_in","taoensso.encore.signals/default-handler-priority","taoensso.encore/rcompare","unwrapped-handler-fn","lib-dispatch-opts","dispatch-opts","taoensso.encore.signals.add_handler","taoensso.encore.signals/wrap-handler","js/taoensso","js/taoensso.encore","js/taoensso.encore.signals","js/taoensso.encore.signals.*default-handler-error-fn*","taoensso.encore.signals/*default-handler-error-fn*","js/taoensso.encore.signals.*default-handler-backp-fn*","taoensso.encore.signals/*default-handler-backp-fn*","taoensso.encore.signals/as-middleware-fn","fn-or-fns","taoensso.encore.comp_middleware","taoensso.encore.signals/default-handler-dispatch-opts","handler-fn","user-dispatch-opts","map__61319","vec__61320","vec__61323","taoensso.encore.nested_merge","priority","sample-rate","rate-limit","when-fn","middleware","rl-error","rl-backp","error-fn","backp-fn","track-stats?","sample-rate-fn","taoensso.encore/as-pnum!","rl-handler","sig-filter*","taoensso.encore/rate-limiter-once-per","taoensso.encore.ms","error-fn*","error","e61336","cljs.core/keyword-identical?","G__61337","G__61338","runner","stopped?_","stop-fn","cljs.core/compare-and-set!","drained?","handler-result","e61347","ssb","taoensso.encore.stats/summary-stats-buffered-fast","cnt-allowed","cnt-disallowed","cnt-handled","cnt-errors","cnt-backp","cnt-sampled","cnt-filtered","cnt-rate-limited","cnt-suppressed","cnt-dropped","cljs.core.repeatedly","taoensso.encore/counter","handle-signal!","sig-raw","ns0","taoensso.encore/now-nano","result","e61358","allow?","Math/random","sig-val","e61371","sig-val*","e61372","sig-dbg","e61361","G__61375","cljs.core/deref","action","sstats","cljs.core/with-meta","taoensso.encore.signals/update-ctx","old-ctx","update-map-or-fn","taoensso.encore.merge","cljs.core/ifn?","taoensso.encore.unexpected_arg_BANG_","taoensso.encore.signals/upper-qn","clojure.string/upper-case","taoensso.encore/as-qname","taoensso.encore.signals/format-level","taoensso.encore.signals/format-id","cljs.core/namespace","cljs.core/name","cached","line","column","taoensso.encore.signals/format-location","file","location","map__61470","taoensso.encore.signals/signal-with-combined-sample-rate"],"sourcesContent":["(ns ^:no-doc taoensso.encore.signals\n  \"Experimental, subject to change without notice!\n  Private signal toolkit for use by Telemere, Tufte, Timbre, etc.\n\n  \\\"Signal\\\" refers here to any abstract event/data/object (usu. map) that:\n    - Originates in an ns (created or received there, etc.)\n    - Has a level (priority/significance/etc.)\n    - May have a kind (type/taxonomy/etc.)\n    - May have an identifier\"\n\n  {:added \"Encore v3.68.0 (2023-09-25)\"}\n  (:refer-clojure :exclude [binding])\n  (:require\n   [clojure.string  :as str]\n   [taoensso.encore :as enc :refer [binding have have?]]\n   [taoensso.encore.stats :as stats])\n\n  #?(:cljs\n     (:require-macros\n      [taoensso.encore.signals :refer\n       [valid-level-int valid-level level>=]])))\n\n(comment\n  (remove-ns 'taoensso.encore.signals)\n  (:api (enc/interns-overview)))\n\n;;;; Levels\n\n(def ^:const level-aliases\n  \"Map of {<level-keyword> <level-integer>} aliases.\"\n  (conj\n    {          :trace 10 :debug 20         :info 50 :warn 60 :error 70 :fatal  80 :report  90\n     :low--- 0 :low-- 10 :low-  20 :low 30 :med  50 :high 60 :high+ 70 :high++ 80 :high+++ 90}\n    (enc/get-env {:as :edn} :taoensso.encore.signals/level-aliases<.platform><.edn>)))\n\n(let [expected (conj (set (keys level-aliases)) 'integer)]\n  (defn bad-level!\n    \"Throws an `ex-info` for given invalid level.\"\n    [x]\n    (throw\n      (ex-info \"[encore/signals] Invalid level\"\n        {:level    (enc/typed-val x)\n         :expected expected}))))\n\n(defn ^:no-doc -valid-level-int ^long [x]\n  (enc/cond\n    (keyword? x) (or (get level-aliases x) (bad-level! x))\n    (integer? x) (long x)\n    :else  (bad-level! x)))\n\n(defn ^:no-doc -valid-level [x]\n  (enc/cond\n    (keyword? x) (if (get level-aliases x) x (bad-level! x))\n    (integer? x)      x\n    :else (bad-level! x)))\n\n(comment (enc/qb 1e6 (-valid-level-int :info))) ; 52.88\n\n#?(:clj\n   (do\n     (defmacro valid-level-int \"Returns valid integer level, or throws.\"\n       [x] (if (enc/const-form? x) (-valid-level-int x) `(-valid-level-int ~x)))\n\n     (defmacro valid-level \"Returns valid level, or throws.\"\n       [x] (if (enc/const-form? x) (-valid-level x) `(-valid-level ~x)))\n\n     (defmacro level>=\n       \"Returns true if valid level `x` has value >= valid level `y`.\n       Throws if either level is invalid.\"\n       [x y]\n       (if (and (enc/const-form? x) (enc/const-form? y))\n         (>= (long (valid-level-int x)) (long (valid-level-int y)))\n         (let [x (if (enc/const-form? x) (valid-level-int x) `(-valid-level-int ~x))\n               y (if (enc/const-form? y) (valid-level-int y) `(-valid-level-int ~y))]\n           `(>= ~x ~y))))))\n\n(comment (macroexpand '(level>= :info x)))\n\n;;;; Basic filtering\n\n(let [nf-compile (fn [nf-spec  ] (enc/name-filter (or nf-spec :any)))\n      nf-match?  (fn [nf-spec n] ((nf-compile nf-spec) n))\n      nf->min-level\n      (fn [ml-spec nf-arg]\n        (if (vector? ml-spec)\n          ;; [[<nf-spec> <min-level>] ... [\\\"*\\\" <min-level>]]\n          (enc/rsome\n            (fn [[nf-spec min-level]]\n              (when (nf-match? nf-spec nf-arg)\n                min-level))\n            ml-spec)\n          ml-spec))]\n\n  (defn valid-nf-spec\n    \"Returns valid `encore/name-filter` spec, or throws.\"\n    [x]\n    (if-let [t (enc/try* (do (nf-compile x) nil) (catch :all t t))]\n      (throw\n        (ex-info\n          (if (fn? x)\n            \"[encore/signals] Invalid name filter (fn filters no longer supported)\"\n            \"[encore/signals] Invalid name filter\")\n          {:name-filter (enc/typed-val x)}\n          t))\n      x))\n\n  (defn allow-name?\n    \"Low-level name filter.\"\n    #?(:cljs {:tag 'boolean})\n    [nf-spec nf-arg]\n    (if ^boolean (nf-match? nf-spec nf-arg) true false))\n\n  (defn parse-min-level\n    \"Returns simple unvalidated ?min-level from {<kind> [[<nf-spec> <min-level>] ...]}, etc.\"\n    [ml-spec kind nf-arg]\n    (if (map? ml-spec) ; {<kind> <ml-spec*>}\n      (or\n        (when kind (when-let [ml-spec* (get ml-spec     kind)] (nf->min-level ml-spec* nf-arg)))\n        (do        (when-let [ml-spec* (get ml-spec :default)] (nf->min-level ml-spec* nf-arg))))\n      (do                                                      (nf->min-level ml-spec  nf-arg))))\n\n  (let [parse-min-level parse-min-level]\n    (defn allow-level?\n      \"Low-level level filter.\"\n      #?(:cljs {:tag 'boolean})\n      ([min-level      level] (if ^boolean (level>= level min-level) true false))\n      ([ml-spec nf-arg level]\n       (let [min-level (nf->min-level ml-spec nf-arg)]\n         (if  ^boolean (level>= level min-level) true false)))\n\n      ([ml-spec kind nf-arg level]\n       (if ml-spec\n         (allow-level? (parse-min-level ml-spec kind nf-arg) level)\n         true)))))\n\n(defn valid-min-level\n  \"Returns valid min level, or throws.\"\n  [x]\n  (if (vector? x)\n    (do\n      (enc/run!\n        (fn [[nf-spec min-level]]\n          (valid-nf-spec nf-spec)\n          (valid-level   min-level))\n        x)\n      x)\n    (valid-level x)))\n\n(defn update-min-level\n  \"Low-level util to update given min level.\"\n  [old kind nf-spec new]\n  (enc/cond\n    :if-let [old-map (when (map? old) old)] ; {<kind> <min-level*>}\n    (let [kind    (or kind :default)\n          old-val (get old-map kind)\n          new-val (update-min-level old-val nil nf-spec new)\n          new-map\n          (if (nil? new-val)\n            (not-empty (dissoc old-map kind))\n            (do        (assoc  old-map kind new-val)))]\n\n      (if-let [simplified ; {:default <x>} -> <x>\n               (when (= (count new-map) 1)\n                 (get new-map :default))]\n        simplified\n        new-map))\n\n    kind\n    (let [old-map (if old {:default old} {})]\n      (update-min-level old-map kind nf-spec new))\n\n    (nil? nf-spec) (when new (valid-min-level new))\n\n    :else ; Update name-specific min-level\n    (let [new     (when new (valid-level new))\n          nf-spec (valid-nf-spec nf-spec)\n\n          old-vec (if (vector? old) old (if old [[\"*\" (valid-level old)]] []))\n          new-vec\n          (not-empty\n            (let [exact-match? ; `pr-str` for re-patterns, etc.\n                  #{(pr-str   nf-spec)\n                    (pr-str #{nf-spec})}]\n\n              (reduce ; Remove any pre-existing [<nf-spec> _] or [#{<nf-spec>} _] entries\n                (fn [acc [nf-spec* _min-level :as entry]]\n                  (if (exact-match? (pr-str nf-spec*))\n                    (do   acc)       ; Remove entry\n                    (conj acc entry) ; Retain entry\n                    ))\n\n                (if new\n                  [[nf-spec new]] ; Insert new entry at head\n                  [])\n\n                old-vec)))]\n\n      (if-let [simplified ; [[\"*\" <x>]] -> <x>\n               (when (= (count new-vec) 1)\n                 (let [[[nf-spec min-level]] new-vec]\n                   (when (contains? #{\"*\" :any} nf-spec)\n                     min-level)))]\n        simplified\n        new-vec))))\n\n;;;; Signal filtering\n\n(comment (enc/defonce ^:dynamic *rt-sig-filter* \"`SigFilter`, or nil.\" nil))\n\n(deftype SigFilter [kind-filter ns-filter id-filter min-level filter-fn]\n  #?(:clj clojure.lang.IDeref :cljs IDeref)\n  (#?(:clj deref :cljs -deref) [_]\n    (enc/assoc-some nil\n      :kind-filter kind-filter :ns-filter ns-filter\n      :id-filter     id-filter :min-level min-level))\n\n  #?(:clj clojure.lang.IFn :cljs IFn)\n  (#?(:clj invoke :cljs -invoke) [_ kind ns id level] (filter-fn kind ns id level))\n  (#?(:clj invoke :cljs -invoke) [_      ns id level] (filter-fn      ns id level))\n  (#?(:clj invoke :cljs -invoke) [_      ns    level] (filter-fn      ns    level))\n  (#?(:clj invoke :cljs -invoke) [_           ct-map] (filter-fn ct-map)))\n\n(defn sig-filter?\n  \"Returns true iff given a `SigFilter`.\"\n  #?(:cljs {:tag 'boolean})\n  [x] (instance? SigFilter x))\n\n(enc/def* sig-filter\n  \"Returns nil, or a stateful (caching) `SigFilter` with the given specs.\"\n  {:arglists\n   '([{:keys [kind-filter ns-filter id-filter min-level]}]\n             [kind-filter ns-filter id-filter min-level])}\n\n  (let [get-cached\n        (enc/fmemoize ; Same specs -> share cache (ref. transparent)\n          (fn sig-filter\n            [         kind-filter ns-filter id-filter min-level]\n            (when (or kind-filter ns-filter id-filter min-level)\n              (do ; Validation\n                (when kind-filter (valid-nf-spec kind-filter))\n                (when   ns-filter (valid-nf-spec   ns-filter))\n                (when   id-filter (valid-nf-spec   id-filter))\n                (when   min-level\n                  (if (map? min-level)\n                    (enc/run-kv!\n                      (fn [kind min-level] (valid-min-level min-level))\n                      min-level)\n\n                    (valid-min-level min-level))))\n\n              (SigFilter. kind-filter ns-filter id-filter min-level\n                (enc/fmemoize\n                  (fn allow-signal?\n\n                    ([{:keys [kind ns id level]}]\n                     ;; Used for compile-time filtering (not perf sensitive, ignore nils)\n                     (and\n                       (if (and kind-filter kind)  (allow-name? kind-filter kind)         true)\n                       (if (and   ns-filter ns)    (allow-name?   ns-filter   ns)         true)\n                       (if (and   id-filter id)    (allow-name?   id-filter   id)         true)\n                       (if (and   min-level level) (allow-level? min-level kind ns level) true)))\n\n                    ([kind ns id level]\n                     (and\n                       (if kind-filter (allow-name? kind-filter kind)         true)\n                       (if   ns-filter (allow-name?   ns-filter   ns)         true)\n                       (if   id-filter (allow-name?   id-filter   id)         true)\n                       (if   min-level (allow-level? min-level kind ns level) true)))\n\n                    ([ns id level]\n                     (and\n                       (if ns-filter (allow-name?  ns-filter ns)       true)\n                       (if id-filter (allow-name?  id-filter id)       true)\n                       (if min-level (allow-level? min-level ns level) true)))\n\n                    ([ns level]\n                     (and\n                       (if ns-filter (allow-name?  ns-filter ns)       true)\n                       (if min-level (allow-level? min-level ns level) true)))))))))]\n\n    (fn sig-filter\n      ([        kind-filter ns-filter id-filter min-level]             (get-cached kind-filter ns-filter id-filter min-level))\n      ([{:keys [kind-filter ns-filter id-filter min-level :as specs]}] (get-cached kind-filter ns-filter id-filter min-level)))))\n\n(comment ; [188.41 189.56 188.09]\n  (let [sf (sig-filter nil \"*\" nil nil)]\n    (enc/qb 3e6\n      (sf :kind :ns     :info)\n      (sf       :ns :id :info)\n      (sf       :ns :id :info))))\n\n(defprotocol IFilterableSignal\n  \"Protocol that app/library signal-like types must implement to support signal API.\"\n  (allow-signal? [_ sig-filter]          \"Returns true iff given signal is allowed by given `SigFilter`.\")\n  (signal-value  [_ handler-sample-rate] \"Returns public signal value as given to handlers, etc.\")\n  (signal-debug  [_]                     \"Returns minimal signal representation for debug purposes\"))\n\n(let [nil-sf (SigFilter. nil nil nil nil nil)]\n  (defn update-sig-filter\n    \"Returns nil, or updated stateful (caching) `SigFilter`.\"\n    {:arglists '([old-sig-filter {:keys [kind-filter ns-filter id-filter min-level min-level-fn]}])}\n    [old specs]\n    (let [^SigFilter base (or old nil-sf)]\n      (if (empty? specs)\n        old\n        (sig-filter\n          (get specs :kind-filter (.-kind-filter base))\n          (get specs   :ns-filter   (.-ns-filter base))\n          (get specs   :id-filter   (.-id-filter base))\n          (let [old-min-level       (.-min-level base)]\n            (enc/cond\n              :if-let [e (find specs :min-level)]    (update-min-level old-min-level nil nil (val e))\n              :if-let [f (get  specs :min-level-fn)] (f                old-min-level)\n              :else                                                    old-min-level)))))))\n\n(comment (update-sig-filter nil {}))\n\n;;;; Filterable expansions\n\n#?(:clj (enc/defonce expansion-counter (enc/counter)))\n\n(let [basic-rate-limiters_ (enc/latom {})\n      full-rate-limiters_  (enc/latom {})]\n\n  (defn expansion-limited!?\n    \"Calls the identified stateful rate-limiter and returns true iff limited.\"\n    #?(:cljs {:tag 'boolean})\n\n    ([exp-id spec] ; Common case (no request ids)\n     (let [rl\n           (or\n             (get (basic-rate-limiters_) exp-id) ; Common case\n             (basic-rate-limiters_       exp-id #(or % (enc/rate-limiter {:allow-basic? true} spec))))]\n       (if (rl) true false)))\n\n    ([exp-id spec req-id]\n     (let [rl\n           (or\n             (get (full-rate-limiters_) exp-id) ; Common case\n             (full-rate-limiters_       exp-id #(or % (enc/rate-limiter {:allow-basic? false} spec))))]\n       (if (rl req-id) true false)))))\n\n(comment\n  (enc/qb 1e6 ; [56.45 104.38]\n    (expansion-limited!? :expansion1 [[1 4000]])\n    (expansion-limited!? :expansion1 [[1 4000]] :req-id1)))\n\n#?(:clj\n   (defn unexpected-sf-artity! [sf-arity context]\n     (enc/unexpected-arg! sf-arity\n       {:context  context\n        :param    'sf-arity\n        :expected #{2 3 4}})))\n\n#?(:clj\n   (defn- const-form! [param form]\n     (if (enc/const-form? form)\n       (do                form)\n       (throw\n         (ex-info \"[encore/signals] `filterable-expansion` arg must be a const (compile-time) value\"\n           {:param param, :form form})))))\n\n#?(:clj\n   (defn filterable-expansion\n     \"Low-level util for writing macros with compile-time and runtime filtering.\n     Returns {:keys [expansion-id location elide? allow?]}.\n\n     Caller is responsible for protecting against possible multiple eval of\n     forms in `opts`.\"\n\n     {:arglists\n      '([{:keys [sf-arity ct-sig-filter *rt-sig-filter*]}]\n        [{:keys\n          [elide? allow? expansion-id,\n           elidable? location location*,\n           sample-rate kind ns id level when rate-limit rate-limit-by]}])}\n\n     [{:as core-opts :keys [sf-arity ct-sig-filter *rt-sig-filter*]}\n      call-opts]\n\n     (const-form! 'call-opts      call-opts) ; Must be const map, though vals may be arb forms\n     (enc/have? [:or nil? map?]   call-opts)\n     (const-form! 'elide?    (get call-opts :elide?))\n     (const-form! 'elidable? (get call-opts :elidable?))\n\n     (enc/have? #(contains? core-opts %) :ct-sig-filter :*rt-sig-filter*)\n     (enc/have? #(contains? call-opts %) :location*)\n     (enc/have? [:or nil? sig-filter?] ct-sig-filter)\n     (enc/have? qualified-symbol?     *rt-sig-filter*)\n\n     (let [opts call-opts\n           location ; {:keys [ns line column file]} forms\n           (let [location-form (get opts :location (get opts :location*))\n                 location-map  (when (map?    location-form) location-form) ; At least keys const\n                 location-sym  (when (symbol? location-form) location-form)]\n\n             (enc/assoc-some nil\n               :ns     (get opts :ns     (get location-map :ns     (when location-sym `(get ~location-sym :ns))))      ;   Documented override\n               :line   (get opts :line   (get location-map :line   (when location-sym `(get ~location-sym :line))))    ; Undocumented override\n               :column (get opts :column (get location-map :column (when location-sym `(get ~location-sym :column))))  ; ''\n               :file   (get opts :file   (get location-map :file   (when location-sym `(get ~location-sym :file))))))  ; ''\n\n           kind-form*  (get opts     :kind)\n           ns-form*    (get location :ns)\n           id-form*    (get opts     :id)\n           level-form* (get opts     :level)\n\n           bound-forms (get opts :bound-forms) ; {:kind '__kind, etc.}\n           kind-form   (or (get bound-forms :kind)  kind-form*)\n           ns-form     (or (get bound-forms :ns)    ns-form*)\n           id-form     (or (get bound-forms :id)    id-form*)\n           level-form  (or (get bound-forms :level) level-form*)\n           _\n           (when (enc/const-form? level-form*)\n             (valid-level         level-form*))\n\n           elide?\n           (and\n             (get opts :elidable? true)\n             (get opts :elide?\n               (when-let [sf ct-sig-filter]\n                 (not (sf {:kind  (enc/const-form  kind-form*)\n                           :ns    (enc/const-form    ns-form*)\n                           :id    (enc/const-form    id-form*)\n                           :level (enc/const-form level-form*)})))))\n\n           ;; Unique id for this expansion, changes on every eval.\n           ;; So rate limiter will get reset on eval during REPL work, etc.\n           expansion-id (get opts :expansion-id (expansion-counter))\n           base-rv {:expansion-id  expansion-id, :location location}]\n\n       (if elide?\n         (assoc base-rv :elide? true)\n         (let [allow?-form\n               (get opts :allow?\n                 (let [sample-rate-form\n                       (when-let [sr-form (get opts :sample-rate)]\n                         (if (enc/const-form? sr-form)\n                           (do                     `(< ~'(Math/random) ~(enc/as-pnum! sr-form)))\n                           `(if-let [~'sr ~sr-form] (< ~'(Math/random)  (double     ~'sr)) true)))\n\n                       sf-form\n                       (case (int (or sf-arity -1))\n                         2 `(let [~'sf ~*rt-sig-filter*] (if ~'sf (~'sf            ~ns-form          ~level-form) true))\n                         3 `(let [~'sf ~*rt-sig-filter*] (if ~'sf (~'sf            ~ns-form ~id-form ~level-form) true))\n                         4 `(let [~'sf ~*rt-sig-filter*] (if ~'sf (~'sf ~kind-form ~ns-form ~id-form ~level-form) true))\n                         (unexpected-sf-artity! sf-arity `expansion-filter))\n\n                       when-form\n                       (when-let [when-form (get opts :when)]\n                         `(let [~'this-expansion-id ~expansion-id] ~when-form))\n\n                       rl-form ; Nb last (increments count)\n                       (when-let [spec-form     (get opts :rate-limit)]\n                         (if-let [limit-by-form (get opts :rate-limit-by)]\n                           `(if (expansion-limited!? ~expansion-id ~spec-form ~limit-by-form) false true)\n                           `(if (expansion-limited!? ~expansion-id ~spec-form               ) false true)))]\n\n                   `(enc/and* ~@(filter some? [sample-rate-form sf-form when-form rl-form]))))]\n\n           (assoc base-rv :allow? allow?-form))))))\n\n(comment\n  (filterable-expansion\n    {:sf-arity 2, :ct-sig-filter nil, :*rt-sig-filter* `*rt-sf*}\n    {:location*   nil\n     :location    {:ns (str *ns*)}\n     :line        42\n     :when        'false\n     ;; :elide?   true\n     ;; :allow?   false\n     :level       (do :info)\n     :sample-rate 0.3\n     :rate-limit  [[1 1000]]}))\n\n;;;; Signal handling\n\n(comment (enc/defonce ^:dynamic *sig-handlers* \"?[<wrapped-handler-fn>]\" nil))\n\n(defn get-handlers-map\n  \"Returns non-empty ?{<handler-id> {:keys [dispatch-opts handler-fn ...]}}.\"\n  ([handlers-vec     ] (get-handlers-map handlers-vec false))\n  ([handlers-vec raw?]\n   (when handlers-vec\n     (reduce\n       (fn [m wrapped-handler-fn]\n         (let [whm (meta wrapped-handler-fn)]\n           (assoc m (get whm :handler-id)\n             (if raw?\n               whm\n               (let [info (select-keys  whm [:dispatch-opts :handler-fn])]\n                 (if-let [stats-fn (get whm :stats-fn)]\n                   (assoc info :handler-stats_ (delay (stats-fn)))\n                   (do    info)))))))\n       nil handlers-vec))))\n\n(defn get-handlers-stats\n  \"Returns non-empty ?{<handler-id> ?{:keys [handling-nsecs counts]}}.\"\n  [handlers-vec]\n  (when-let [handlers-map (get-handlers-map handlers-vec :raw)]\n    (reduce-kv\n      (fn [m handler-id {:keys [stats-fn]}]\n        (if stats-fn\n          (assoc m handler-id (stats-fn))\n          (do    m)))\n      nil handlers-map)))\n\n(defn call-handlers!\n  \"Calls given handlers with the given signal.\n  Signal's type must implement `IFilterableSignal`.\"\n  [handlers-vec signal]\n  (run! (fn [wrapped-handler-fn] (wrapped-handler-fn signal)) handlers-vec))\n\n(defn stop-handlers!\n  \"Stops handlers in parallel and returns\n  {<handler-id> {:keys [okay error drained?]}}.\"\n  [handlers-vec]\n  (when-let [handlers-map (get-handlers-map handlers-vec :raw)]\n    (let [results ; {<handler-id> <result-or-promise>}\n          (reduce-kv\n            (fn [m handler-id {:keys [wrapped-handler-fn]}]\n              (assoc m handler-id\n                #?(:clj (enc/promised :daemon (wrapped-handler-fn))\n                   :cljs                      (wrapped-handler-fn))))\n            nil handlers-map)]\n\n      #?(:cljs results\n         :clj\n         (reduce-kv\n           (fn [    m handler-id  result_]\n             (assoc m handler-id @result_))\n           results results)))))\n\n(defn get-wrapped-handler-fn\n  \"Returns wrapped-handler-fn with given handler-id, or nil.\"\n  [handlers-vec handler-id]\n  (enc/rfirst #(= (get (meta %) :handler-id) handler-id) handlers-vec))\n\n(defn remove-handler\n  \"Returns updated, non-empty handlers vec.\"\n  [handlers-vec handler-id]\n  (not-empty\n    (filterv #(not= (get (meta %) :handler-id) handler-id)\n      handlers-vec)))\n\n(comment\n  (let [handlers\n        [(with-meta (fn []) {:handler-id :hid1})\n         (with-meta (fn []) {:handler-id :hid2})]]\n\n    [(get-handler    handlers :hid2)\n     (remove-handler handlers :hid2)]))\n\n(declare wrap-handler default-handler-priority)\n(defn add-handler\n  \"Returns updated, non-empty handlers vec.\"\n\n  ;; Given pre-wrapped handler-fn\n  ([handlers-vec handler-id pre-wrapped-handler-fn]\n   (if-not pre-wrapped-handler-fn\n     handlers-vec\n     (enc/sortv #(get-in (meta %) [:dispatch-opts :priority] default-handler-priority) enc/rcompare\n       (conj (or (remove-handler handlers-vec handler-id) []) pre-wrapped-handler-fn))))\n\n  ;; Given unwrapped handler-fn\n  ([handlers-vec handler-id unwrapped-handler-fn, lib-dispatch-opts dispatch-opts]\n   (if-not unwrapped-handler-fn\n     handlers-vec\n     (if (get dispatch-opts :no-wrap?) ; Undocumented\n       (add-handler handlers-vec handler-id unwrapped-handler-fn)\n       (add-handler handlers-vec handler-id\n         (wrap-handler handler-id unwrapped-handler-fn, lib-dispatch-opts dispatch-opts))))))\n\n;;; Telemere will set these when it's present\n(enc/defonce ^:dynamic *default-handler-error-fn* nil)\n(enc/defonce ^:dynamic *default-handler-backp-fn* nil)\n\n(defn as-middleware-fn\n  \"Returns (composed) unary middleware fn, or nil.\"\n  [fn-or-fns]\n  (when                    fn-or-fns\n    (if (vector?           fn-or-fns)\n      (enc/comp-middleware fn-or-fns)\n      (if (fn? fn-or-fns)\n        (do    fn-or-fns)\n        (throw\n          (ex-info \"[encore/signals] Unexpected middleware value\"\n            {:given    (enc/typed-val fn-or-fns)\n             :expected '#{nil fn [f1 f2 ...]}}))))))\n\n(def ^:private default-handler-priority 100)\n(def           default-handler-dispatch-opts\n  \"Default handler dispatch options, see\n  `help:handler-dispatch-options` for details.\"\n  #?(:cljs\n     {:priority default-handler-priority\n      :track-stats? false}\n\n     :clj\n     {:priority default-handler-priority,\n      :track-stats? true\n      :async\n      {:mode :blocking\n       :buffer-size      1024\n       :n-threads        1\n       :drain-msecs      6000\n       :convey-bindings? true}}))\n\n(defn wrap-handler\n  \"Wraps given handler-fn to add common handler-level functionality.\"\n  [handler-id handler-fn, lib-dispatch-opts user-dispatch-opts]\n  (let [dispatch-opts\n        (enc/nested-merge\n          default-handler-dispatch-opts ; Encore  defaults\n          lib-dispatch-opts             ; Library defaults\n          (when-let [m (meta handler-fn)]\n            (get m :dispatch-opts))     ; Unwrapped handler-fn defaults\n          user-dispatch-opts)\n\n        {:keys\n         [#?(:clj async) priority sample-rate rate-limit when-fn middleware,\n          kind-filter ns-filter id-filter min-level,\n          rl-error rl-backp error-fn backp-fn, track-stats?]}\n        dispatch-opts\n\n        [sample-rate sample-rate-fn]\n        (when      sample-rate\n          (if (fn? sample-rate)\n            [nil                sample-rate] ; Dynamic rate (use dynamic binding, deref atom, etc.)\n            [(enc/as-pnum! sample-rate) nil] ; Static  rate\n            ))\n\n        rl-handler    (when-let [spec rate-limit] (enc/rate-limiter {:allow-basic? true} spec))\n        sig-filter*   (sig-filter kind-filter ns-filter id-filter min-level)\n\n        middleware    (as-middleware-fn    middleware) ; Deprecated, kept temporarily for back compatibility\n        ;; middleware (have [:or nil? fn?] middleware) ; (fn [signal-value]) => ?modified-signal-value\n\n        rl-error (get dispatch-opts :rl-error (enc/rate-limiter-once-per (enc/ms :mins 1)))\n        rl-backp (get dispatch-opts :rl-backp (enc/rate-limiter-once-per (enc/ms :mins 1)))\n        backp-fn (get dispatch-opts :backp-fn ::default)\n        error-fn (get dispatch-opts :error-fn ::default)\n        error-fn*\n        (when error-fn\n          (fn [signal error]\n            (enc/catching\n              (if (and rl-error (rl-error)) ; error-fn rate-limited\n                nil ; noop\n                (when-let [error-fn\n                           (if (enc/identical-kw? error-fn ::default)\n                             *default-handler-error-fn*\n                             error-fn)]\n                  (if signal\n                    (error-fn {:handler-id handler-id, :signal signal, :error error})\n                    (error-fn {:handler-id handler-id,                 :error error})))))))\n\n        runner\n        #?(:cljs nil\n           :clj\n           (when async\n             (enc/runner\n               (assoc (have map? async)\n                 :auto-stop?  false\n                 :drain-msecs 0))))\n\n        stopped?_ (enc/latom false)\n        stop-fn ; Block => {:keys [okay error drained?]}\n        (fn []\n          ;; Called by `remove-handler!`, `with-handler/+`, `stop-handlers!`\n          (if-not (compare-and-set! stopped?_ false true) ; Stop accepting new signals\n            #?(:cljs                 {:okay :stopped}\n               :clj  (enc/assoc-some {:okay :stopped}\n                       :drained? (when runner (boolean (deref @runner 0 nil)))))\n\n            (let [drained? ; Block <= `:drain-msecs` to finish handling current signals\n                  #?(:cljs nil\n                     :clj\n                     (when runner\n                       (boolean\n                         (when-let [drained_ @runner]\n                           (if-let [drain-msecs (get-in dispatch-opts [:async :drain-msecs])]\n                             (deref drained_ drain-msecs nil)\n                             (deref drained_))))))\n\n                  handler-result\n                  (enc/try*\n                    (handler-fn) ; Give hander-fn opportunity to finalize, etc.\n                    {:okay :stopped}\n\n                    ;; Note that Cljs doesn't enforce runtime arity.\n                    ;; ((fn f1 [x])) will actually trigger (f1 nil), so it's best for\n                    ;; handlers to always include both (0, 1) arities.\n\n                    #?(:clj (catch clojure.lang.ArityException _ {:okay :stopped}))\n                    (catch :all t\n                      (when error-fn* (error-fn* nil t))\n                      {:error t})\n\n                    (finally (when runner (runner))))]\n\n              (enc/assoc-some handler-result :drained? drained?))))\n\n        ssb (when track-stats? (stats/summary-stats-buffered-fast 1e5 nil))\n\n        [cnt-allowed cnt-disallowed cnt-handled cnt-errors cnt-backp,\n         cnt-sampled cnt-filtered cnt-rate-limited cnt-suppressed cnt-dropped]\n        (when track-stats? (repeatedly 10 enc/counter))\n\n        handle-signal! ; Block => truthy\n        (fn [sig-raw]\n          (let [ns0 (when track-stats? (enc/now-nano))\n                result\n                (or\n                  (enc/try* ; Non-specific (global) trap\n                    (let [sample-rate (or sample-rate (when-let [f sample-rate-fn] (f)))\n                          allow?\n                          (if track-stats?\n                            (enc/and*\n                              (if sample-rate (if (< (Math/random) (double sample-rate)) true (do (cnt-sampled)  false)) true)\n                              (if sig-filter* (if (allow-signal? sig-raw sig-filter*)    true (do (cnt-filtered) false)) true)\n                              (if when-fn     (if (when-fn #_sig-raw)                    true (do (cnt-filtered) false)) true)\n                              (if rl-handler  (if (rl-handler) (do (cnt-rate-limited) false) true) true) ; Nb last (increments count)\n                              )\n\n                            (enc/and*\n                              (if sample-rate (< (Math/random) (double sample-rate))  true)\n                              (if sig-filter* (allow-signal? sig-raw sig-filter*)     true)\n                              (if when-fn     (when-fn #_sig-raw)                     true)\n                              (if rl-handler  (if (rl-handler) false true)            true) ; Nb last (increments count)\n                              ))]\n\n                      (when track-stats? (if allow? (cnt-allowed) (cnt-disallowed)))\n\n                      (when allow?\n                        (when-let [sig-val (signal-value sig-raw sample-rate)]\n                          (enc/try*\n                            (enc/if-not\n                                [sig-val*\n                                 (if middleware\n                                   (middleware sig-val) ; Apply handler middleware\n                                   (do         sig-val))]\n\n                              (do (when track-stats? (cnt-suppressed)) nil)\n                              (enc/try*\n                                (handler-fn sig-val*)\n                                (when track-stats? (cnt-handled))\n                                true\n                                (catch :all t (when track-stats? (cnt-errors)) (when error-fn* (error-fn* sig-val* t)))))\n                            (catch     :all t (when track-stats? (cnt-errors)) (when error-fn* (error-fn* sig-val  t)))))))\n                    (catch             :all t (when track-stats? (cnt-errors)) (when error-fn*\n                                                                                 (let [sig-dbg (or (enc/catching (signal-debug sig-raw)) sig-raw)]\n                                                                                   (error-fn* sig-dbg t)))))\n                  false)]\n\n            (when track-stats? (ssb (- (enc/now-nano) ^long ns0)))\n            result))\n\n        wrapped-handler-fn\n        (or\n          #?(:clj\n             (when runner\n               (fn async-wrapped-handler-fn\n                 ([       ] (stop-fn))\n                 ([sig-raw]\n                  (if (stopped?_)\n                    (do (when track-stats? (cnt-dropped)) nil)\n                    ;; Note that fn passed to runner isn't itself subject to (stopped?_)\n                    (when-let [back-pressure? (false? (runner (fn [] (handle-signal! sig-raw))))]\n                      (when track-stats? (cnt-backp))\n                      (when backp-fn\n                        (enc/catching\n                          (if (and rl-backp (rl-backp)) ; backp-fn rate-limited\n                            nil                         ; noop\n                            (let [backp-fn\n                                  (if (enc/identical-kw? backp-fn ::default)\n                                    *default-handler-backp-fn*\n                                    backp-fn)]\n                              (backp-fn {:handler-id handler-id})))))))))))\n\n          (fn sync-wrapped-handler-fn\n            ([       ] (stop-fn))\n            ([sig-raw]\n             (if (stopped?_)\n               (do (when track-stats? (cnt-dropped)) nil)\n               (handle-signal! sig-raw)))))\n\n        stats-fn\n        (when track-stats?\n          (fn\n            ([action] (throw (ex-info \"Not currently implemented\" {})))\n            ([]\n             {:handling-nsecs (when-let [sstats @ssb] @sstats)\n              :counts ; Chronologically\n              {:dropped       @cnt-dropped\n               :back-pressure @cnt-backp\n\n               :sampled       @cnt-sampled\n               :filtered      @cnt-filtered\n               :rate-limited  @cnt-rate-limited\n               :disallowed    @cnt-disallowed\n               :allowed       @cnt-allowed\n\n               :suppressed    @cnt-suppressed\n               :handled       @cnt-handled\n               :errors        @cnt-errors}})))]\n\n    (with-meta wrapped-handler-fn\n      {:handler-id         handler-id\n       :handler-fn         handler-fn\n       :dispatch-opts      dispatch-opts\n       :wrapped-handler-fn wrapped-handler-fn\n       :stats-fn           stats-fn})))\n\n;;;; Local API\n\n(comment\n  [level-aliases\n\n   help:filters\n   help:handlers\n   help:handler-dispatch-options\n\n   get-filters get-min-levels\n\n   get-handlers\n   get-handlers-stats\n\n   without-filters\n   set-kind-filter! with-kind-filter\n   set-ns-filter!   with-ns-filter\n   set-id-filter!   with-id-filter\n   set-min-level!   with-min-level\n\n   with-handler with-handler+\n   add-handler! remove-handler! stop-handlers!\n\n   *ctx*        set-ctx!        with-ctx        with-ctx+\n   *middleware* set-middleware! with-middleware with-middleware+])\n\n;;;\n\n#?(:clj\n   (defn- api:help:filters []\n     `(def  ~'help:filters\n        \"A signal will be provided to a handler iff ALL of the following are true:\n\n    1. Signal creation is allowed by \\\"signal filters\\\":\n      a. Compile-time: sample rate, kind, ns, id, level, when form, rate limit\n      b. Runtime:      sample rate, kind, ns, id, level, when form, rate limit\n\n    2. Signal handling is allowed by \\\"handler filters\\\":\n      a. Compile-time: not applicable\n      b. Runtime:      sample rate, kind, ns, id, level, when fn, rate limit\n\n    3. Signal  middleware (fn [signal]) => ?modified-signal does not return nil\n    4. Handler middleware (fn [signal]) => ?modified-signal does not return nil\n\n  Note that middleware provides a flexible way to filter signals by arbitrary\n  signal data/content conditions (return nil to filter signal).\n\n  Config:\n\n    To set signal filters (1a, 1b):\n\n      Use:\n        `set-kind-filter!`, `with-kind-filter`\n        `set-ns-filter!`,   `with-ns-filter`\n        `set-id-filter!`,   `with-id-filter`\n        `set-min-level!`,   `with-min-level`\n        or see `help:environmental-config`.\n\n    To set handler filters (2b) or handler middleware (4):\n\n      Provide relevant opts when calling `add-handler!` or `with-handler/+`.\n      See `help:handler-dispatch-options` for details.\n\n      Note: signal filters (1a, 1b) should generally be AT LEAST as permissive as\n      handler filters (2b), otherwise signals will be filtered before even\n      reaching handlers.\n\n    To set signal middleware (3): use `set-middleware!`, `with-middleware`\n\n  Compile-time vs runtime filters:\n\n    Compile-time filters are an advanced feature that can be tricky to set\n    and use correctly. Most folks will want ONLY runtime filters.\n\n    Compile-time filters works by eliding (completely removing the code for)\n    disallowed signals. This means zero performance cost for these signals,\n    but also means that compile-time filters are PERMANENT once applied.\n\n    So if you set `:info` as the compile-time minimum level, that'll REMOVE\n    CODE for every signal below `:info` level. To decrease that minimum level,\n    you'll need to rebuild.\n\n    Compile-time filters can be set ONLY with environmental config\n    (see `help:environmental-config` for details).\n\n  Signal and handler sampling is multiplicative:\n\n    Both signals and handlers can have independent sample rates, and these\n    MULTIPLY! If a signal is created with 20% sampling and a handler\n    handles 50% of received signals, then 10% of possible signals will be\n    handled (50% of 20%).\n\n    The final (multiplicative) rate is helpfully reflected in each signal's\n    `:sample-rate` value.\n\n  For more info:\n\n    - On signal  filters, see: `help:filters`\n    - On handler filters, see: `help:handler-dispatch-options`\n\n  If anything is unclear, please ping me (@ptaoussanis) so that I can\n  improve these docs!\"\n        \"See docstring\")))\n\n(comment (api:help:filters))\n\n#?(:clj\n   (defn- api:help:handlers []\n     `(def  ~'help:handlers\n        \"Signal handlers process created signals to do something with them (analyse them,\n        write them to console/file/queue/db, etc.).\n\n  Manage handlers with:\n\n    `get-handlers`       - Returns info  on  registered handlers (dispatch options, etc.)\n    `get-handlers-stats` - Returns stats for registered handlers (handling times,   etc.)\n\n    `add-handler!`       - Registers   given handler\n    `remove-handler!`    - Unregisters given handler\n\n    `with-handler`       - Executes form with ONLY the given handler        registered\n    `with-handler+`      - Executes form with      the given handler (also) registered\n\n    `stop-handlers!`     - Stops registered handlers\n      NB you should always call `stop-handlers!` somewhere appropriate - usually\n      near the end of your `-main` or shutdown procedure, AFTER all other code has\n      completed that could create signals.\n\n  See the relevant docstrings for details.\n  See `help:handler-dispatch-options` for handler filters, etc.\n\n  If anything is unclear, please ping me (@ptaoussanis) so that I can\n  improve these docs!\"\n        \"See docstring\")))\n\n#?(:clj\n   (defn- api:help:handler-dispatch-options []\n     `(def  ~'help:handler-dispatch-options\n        \"Dispatch options can be provided for each signal handler when calling\n  `add-handler!` or `with-handler/+`. These options will be merged over the\n  defaults specified by `default-handler-dispatch-opts`.\n\n  All handlers support the same dispatch options, including:\n\n    `:async` (Clj only) - may be `nil` (synchronous) or map with options:\n\n      `:buffer-size` (default 1024)\n        Size of request buffer, and the max number of pending requests before\n        configured back-pressure behaviour is triggered (see `:mode`).\n\n      `:mode` (default `:blocking`)\n        Back-pressure mode \u2208 #{:blocking :dropping :sliding}.\n        Controls what happens when a new request is made while request buffer is full:\n          `:blocking` => Blocks caller until buffer space is available\n          `:dropping` => Drops the newest request (noop)\n          `:sliding`  => Drops the oldest request\n\n      `:n-threads` (default 1)\n        Number of threads to use for executing fns (servicing request buffer).\n        NB execution order may be non-sequential when n > 1.\n\n      `:drain-msecs` (default 6000 msecs)\n        Maximum time (in milliseconds) to try allow pending execution requests to\n        complete when stopping handler. nil => no maximum.\n\n    `:priority` (default 100)\n      Optional handler priority \u2208\u2124.\n      Handlers will be called in descending priority order (larger ints first).\n\n    `:track-stats?` (default true)\n      Should handler track statistics (e.g. handling times) for\n      reporting by `get-handlers-stats`?\n\n    `:sample-rate` (default nil => no sampling)\n      Optional sample rate \u2208\u211d[0,1], or (fn dyamic-sample-rate []) => \u211d[0,1].\n      When present, handle only this (random) proportion of args:\n        1.0 => handle every arg (same as nil rate, default)\n        0.0 => noop   every arg\n        0.5 => handle random 50% of args\n\n    `:kind-filter` - Kind      filter as in `set-kind-filter!` (when relevant)\n    `:ns-filter`   - Namespace filter as in `set-ns-filter!`\n    `:id-filter`   - Id        filter as in `set-id-filter!`   (when relevant)\n    `:min-level`   - Minimum   level  as in `set-min-level!`\n\n    `:when-fn` (default nil => always allow)\n      Optional nullary (fn allow? []) that must return truthy for handler to be\n      called. When present, called *after* sampling and other filters, but before\n      rate limiting. Useful for filtering based on external state/context.\n\n      See `:middleware` for an alternative that takes a signal argument.\n\n    `:rate-limit` (default nil => no rate limit)\n      Optional rate limit spec as provided to `taoensso.encore/rate-limiter`,\n      {<limit-id> [<n-max-calls> <msecs-window>]}.\n\n      Examples:\n        {\\\"1/sec\\\"  [1   1000]} => Max 1  call  per 1000 msecs\n        {\\\"1/sec\\\"  [1   1000]\n         \\\"10/min\\\" [10 60000]} => Max 1  call  per 1000 msecs,\n                                 and 10 calls per 60   secs\n\n    `:middleware` (default nil => no middleware)\n      Optional (fn [signal]) => ?modified-signal to apply before\n      handling signal. When middleware returns nil, skips handler.\n\n      Compose multiple middleware fns together with `comp-middleware`.\n\n    `:error-fn` - (fn [{:keys [handler-id signal error]}]) to call on handler error.\n    `:backp-fn` - (fn [{:keys [handler-id             ]}]) to call on handler back-pressure.\n\n  If anything is unclear, please ping me (@ptaoussanis) so that I can\n  improve these docs!\"\n        \"See docstring\")))\n\n;;;\n\n#?(:clj\n   (defn- api:get-filters [*rt-sig-filter* ct-sig-filter]\n     `(defn ~'get-filters\n        \"Returns current ?{:keys [compile-time runtime]} filter config.\"\n        []\n        (enc/assoc-some nil\n          :compile-time (enc/force-ref  ~ct-sig-filter)\n          :runtime      (enc/force-ref ~*rt-sig-filter*)))))\n\n(comment (api:get-filters `my-ct-sig-filter `*my-rt-sig-filter*))\n\n#?(:clj\n   (defn- api:get-min-levels [sf-arity *rt-sig-filter* ct-sig-filter]\n     (case (int sf-arity)\n       (4)\n       `(defn ~'get-min-levels\n          \"Returns current ?{:keys [compile-time runtime]} minimum signal levels.\"\n          (~'[       ] (~'get-min-levels nil    (str *ns*)))\n          (~'[kind   ] (~'get-min-levels ~'kind (str *ns*)))\n          (~'[kind ns]\n           (enc/assoc-some nil\n             :runtime      (parse-min-level (get (enc/force-ref ~*rt-sig-filter*) :min-level) ~'kind ~'ns)\n             :compile-time (parse-min-level (get (enc/force-ref  ~ct-sig-filter)  :min-level) ~'kind ~'ns))))\n\n       (2 3)\n       `(defn ~'get-min-levels\n          \"Returns current ?{:keys [compile-time runtime]} minimum signal levels.\"\n          (~'[  ] (~'get-min-levels nil (str *ns*)))\n          (~'[ns]\n           (enc/assoc-some nil\n             :runtime      (parse-min-level (get (enc/force-ref ~*rt-sig-filter*) :min-level) nil ~'ns)\n             :compile-time (parse-min-level (get (enc/force-ref  ~ct-sig-filter)  :min-level) nil ~'ns)))))))\n\n(comment (api:get-min-levels 4 `*my-rt-sig-filter* `my-ct-sig-filter))\n\n;;;\n\n#?(:clj\n   (defn- api:get-handlers [*sig-handlers*]\n     `(defn ~'get-handlers\n        \"Returns ?{<handler-id> {:keys [dispatch-opts handler-fn handler-stats_]}}\n  for all registered signal handlers.\"\n        [] (get-handlers-map ~*sig-handlers*))))\n\n(comment (api:get-handlers `*my-sig-handlers*))\n\n#?(:clj\n   (defn- api:get-handlers-stats [*sig-handlers*]\n     `(defn ~'get-handlers-stats\n        \"Alpha, subject to change.\n  Returns ?{<handler-id> {:keys [handling-nsecs counts]}} for all registered\n  signal handlers that have the `:track-stats?` dispatch option enabled\n  (it is by default).\n\n  Stats include:\n\n    `:handling-nsecs` - Summary stats of nanosecond handling times, keys:\n      `:min`  - Minimum handling time\n      `:max`  - Maximum handling time\n      `:mean` - Arithmetic mean handling time\n      `:mad`  - Mean absolute deviation of handling time (measure of dispersion)\n      `:var`  - Variance                of handling time (measure of dispersion)\n      `:p50`  - 50th percentile of handling time (50% of times <= this)\n      `:p90`  - 90th percentile of handling time (90% of times <= this)\n      `:p99`  - 99th percentile of handling time\n      `:last` - Most recent        handling time\n      ...\n\n    `:counts` - Integer counts for handler outcomes, keys (chronologically):\n\n      `:dropped`       - Noop handler calls due to stopped handler\n      `:back-pressure` - Handler calls that experienced (async) back-pressure\n                         (possible noop, depending on back-pressure mode)\n\n      `:sampled`      - Noop  handler calls due to sample rate\n      `:filtered`     - Noop  handler calls due to kind/ns/id/level/when filtering\n      `:rate-limited` - Noop  handler calls due to rate limit\n      `:disallowed`   - Noop  handler calls due to sampling/filtering/rate-limiting\n      `:allowed`      - Other handler calls    (no sampling/filtering/rate-limiting)\n\n      `:suppressed`   - Noop handler calls due to nil middleware result\n      `:handled`      - Handler calls that completed successfully\n      `:errors`       - Handler calls that threw an error\n\n      Note that for performance reasons returned counts are not mutually atomic,\n      e.g. `:sampled` count may be incremented before `:disallowed` count is.\n\n  Useful for understanding/debugging how your handlers behave in practice,\n  especially when they're under stress (high-volumes, etc.).\n\n  Handler stats are tracked from the time each handler is last registered\n  (e.g. with an `add-handler!` call).\"\n        [] (get-handlers-stats ~*sig-handlers*))))\n\n(comment (api:get-handlers-stats `*my-sig-handlers*))\n\n;;;\n\n#?(:clj\n   (defn-     api:without-filters [*rt-sig-filter*]\n     `(defmacro ~'without-filters\n        \"Executes form without any runtime signal filters.\"\n        ~'[form] `(binding [~'~*rt-sig-filter* nil] ~~'form))))\n\n(comment (api:without-filters `*my-rt-sig-filter*))\n\n#?(:clj\n   (defn-     api:with-kind-filter [*rt-sig-filter*]\n     `(defmacro ~'with-kind-filter\n        \"Executes form with given signal kind filter in effect.\n  See `set-kind-filter!` for details.\"\n        ~'[kind-filter form]\n        `(binding [~'~*rt-sig-filter* (update-sig-filter ~'~*rt-sig-filter* {:kind-filter ~~'kind-filter})]\n           ~~'form))))\n\n(comment (api:with-kind-filter `*my-rt-sig-filter*))\n\n#?(:clj\n   (defn- api:set-kind-filter! [*rt-sig-filter*]\n     `(defn ~'set-kind-filter!\n        \"Sets signal kind filter based on given `kind-filter` spec.\n  `kind-filter` may be:\n\n    - A regex pattern of kind/s to allow\n    - A str/kw/sym to allow, with \\\"*\\\" and \\\"(.*)\\\" as wildcards:\n      \\\"foo.*\\\"   will allow \\\"foo.bar\\\"\n      \\\"foo(.*)\\\" will allow \\\"foo.bar\\\" and \\\"foo\\\"\n\n    - A set/vector of above (allow on any match)\n    - A map, {:allow <spec> :disallow <spec>} with specs as above:\n      If present, `:allow`    spec MUST     match, AND\n      If present, `:disallow` spec MUST NOT match.\"\n        ~'[kind-filter]\n        (enc/force-ref\n          (enc/update-var-root! ~*rt-sig-filter*\n            (fn [old#] (update-sig-filter old# {:kind-filter ~'kind-filter})))))))\n\n(comment (api:set-ns-filter! `*my-rt-sig-filter*))\n\n#?(:clj\n   (defn-     api:with-ns-filter [*rt-sig-filter*]\n     `(defmacro ~'with-ns-filter\n        \"Executes form with given signal namespace filter in effect.\n  See `set-ns-filter!` for details.\"\n        ~'[ns-filter form]\n        `(binding [~'~*rt-sig-filter* (update-sig-filter ~'~*rt-sig-filter* {:ns-filter ~~'ns-filter})]\n           ~~'form))))\n\n(comment (api:with-ns-filter `*my-rt-sig-filter*))\n\n#?(:clj\n   (defn- api:set-ns-filter! [*rt-sig-filter*]\n     `(defn ~'set-ns-filter!\n        \"Sets signal namespace filter based on given `ns-filter` spec.\n  `ns-filter` may be:\n\n    - A namespace.\n    - A regex pattern of namespaces/s to allow\n    - A str/kw/sym to allow, with \\\"*\\\" and \\\"(.*)\\\" as wildcards:\n      \\\"foo.*\\\"   will allow \\\"foo.bar\\\"\n      \\\"foo(.*)\\\" will allow \\\"foo.bar\\\" and \\\"foo\\\"\n\n    - A set/vector of above (allow on any match)\n    - A map, {:allow <spec> :disallow <spec>} with specs as above:\n      If present, `:allow`    spec MUST     match, AND\n      If present, `:disallow` spec MUST NOT match.\"\n        ~'[ns-filter]\n        (enc/force-ref\n          (enc/update-var-root! ~*rt-sig-filter*\n            (fn [old#] (update-sig-filter old# {:ns-filter ~'ns-filter})))))))\n\n(comment (api:set-ns-filter! `*my-rt-sig-filter*))\n\n#?(:clj\n   (defn-     api:with-id-filter [*rt-sig-filter*]\n     `(defmacro ~'with-id-filter\n        \"Executes form with given signal id filter in effect.\n  See `set-id-filter!` for details.\"\n        ~'[id-filter form]\n        `(binding [~'~*rt-sig-filter* (update-sig-filter ~'~*rt-sig-filter* {:id-filter ~~'id-filter})]\n           ~~'form))))\n\n(comment (api:with-id-filter `*my-rt-sig-filter*))\n\n#?(:clj\n   (defn- api:set-id-filter! [*rt-sig-filter*]\n     `(defn ~'set-id-filter!\n        \"Sets signal id filter based on given `id-filter` spec.\n  `id-filter` may be:\n\n    - A regex pattern of id/s to allow\n    - A str/kw/sym to allow, with \\\"*\\\" and \\\"(.*)\\\" as wildcards:\n      \\\"foo.*\\\"   will allow \\\"foo.bar\\\"\n      \\\"foo(.*)\\\" will allow \\\"foo.bar\\\" and \\\"foo\\\"\n\n    - A set/vector of above (allow on any match)\n    - A map, {:allow <spec> :disallow <spec>} with specs as above:\n      If present, `:allow`    spec MUST     match, AND\n      If present, `:disallow` spec MUST NOT match.\"\n        ~'[id-filter]\n        (enc/force-ref\n          (enc/update-var-root! ~*rt-sig-filter*\n            (fn [old#] (update-sig-filter old# {:id-filter ~'id-filter})))))))\n\n(comment (api:set-id-filter! `*my-rt-sig-filter*))\n\n#?(:clj\n   (defn- api:with-min-level [sf-arity *rt-sig-filter*]\n     (let [self (symbol (str *ns*) \"with-min-level\")]\n       (case (int sf-arity)\n         (4)\n         `(defmacro ~'with-min-level\n            \"Executes form with given minimum signal level in effect.\n  See `set-min-level!` for details.\"\n            (~'[               min-level form] (list '~self nil    nil ~'min-level ~'form))\n            (~'[kind           min-level form] (list '~self ~'kind nil ~'min-level ~'form))\n            (~'[kind ns-filter min-level form]\n             `(binding [~'~*rt-sig-filter*\n                        (update-sig-filter ~'~*rt-sig-filter*\n                          {:min-level-fn\n                           (fn [~'old-ml#]\n                             (update-min-level ~'old-ml# ~~'kind ~~'ns-filter ~~'min-level))})]\n                ~~'form)))\n\n         (2 3)\n         `(defmacro ~'with-min-level\n            \"Executes form with given minimum signal level in effect.\n  See `set-min-level!` for details.\"\n            (~'[          min-level form] (list '~self nil ~'min-level ~'form))\n            (~'[ns-filter min-level form]\n             `(binding [~'~*rt-sig-filter*\n                        (update-sig-filter ~'~*rt-sig-filter*\n                          {:min-level-fn\n                           (fn [~'old-ml#]\n                             (update-min-level ~'old-ml# nil ~~'ns-filter ~~'min-level))})]\n                ~~'form)))))))\n\n(comment (api:with-min-level 4 `*my-rt-sig-filter*))\n\n#?(:clj\n   (defn- api:set-min-level! [sf-arity *rt-sig-filter*]\n     (case (int sf-arity)\n       (4)\n       `(defn ~'set-min-level!\n          \"Sets minimum signal level based on given `min-level` spec.\n  `min-level` may be:\n\n    - nil (=> no minimum level).\n    - A level keyword (see `level-aliases` var for details).\n    - An integer.\n\n  If `ns-filter` is provided, then the given minimum level\n  will apply only for the namespace/s that match `ns-filter`.\n  See `set-ns-filter!` for details.\n\n  If non-nil `kind` is provided, then the given minimum level\n  will apply only for that signal kind.\n\n  Examples:\n    (set-min-level! nil)   ; Disable        minimum level\n    (set-min-level! :info) ; Set `:info` as minimum level\n    (set-min-level! 100)   ; Set 100     as minimum level\n\n    ;; Set `:debug` as minimum level for current namespace\n    ;; (nil `kind` => all kinds)\n    (set-min-level! nil *ns* :debug)\"\n          (~'[               min-level] (~'set-min-level! nil    nil ~'min-level))\n          (~'[kind           min-level] (~'set-min-level! ~'kind nil ~'min-level))\n          (~'[kind ns-filter min-level]\n           (enc/force-ref\n             (enc/update-var-root! ~*rt-sig-filter*\n               (fn [old-sf#]\n                 (update-sig-filter old-sf#\n                   {:min-level-fn\n                    (fn [old-ml#]\n                      (update-min-level old-ml# ~'kind ~'ns-filter ~'min-level))}))))))\n\n       (2 3)\n       `(defn ~'set-min-level!\n          \"Sets minimum signal level based on given `min-level` spec.\n`min-level` may be:\n\n    - nil (=> no minimum level).\n    - A level keyword (see `level-aliases` var for details).\n    - An integer.\n\n  If `ns-filter` is provided, then the given minimum level\n  will apply only for the namespace/s that match `ns-filter`.\n  See `set-ns-filter!` for details.\n\n  Examples:\n    (set-min-level! nil)   ; Disable        minimum level\n    (set-min-level! :info) ; Set `:info` as minimum level\n    (set-min-level! 100)   ; Set 100     as minimum level\n\n    ;; Set `:debug` as minimum level for current namespace\n    (set-min-level! *ns* :debug)\"\n          (~'[          min-level] (~'set-min-level! nil ~'min-level))\n          (~'[ns-filter min-level]\n           (enc/force-ref\n             (enc/update-var-root! ~*rt-sig-filter*\n               (fn [old-sf#]\n                 (update-sig-filter old-sf#\n                   {:min-level-fn\n                    (fn [old-ml#]\n                      (update-min-level old-ml# nil ~'ns-filter ~'min-level))})))))))))\n\n(comment (api:set-min-level! 4 `*my-rt-sig-filter*))\n\n;;;\n\n#?(:clj\n   (defn- api:with-handler [*sig-handlers* lib-dispatch-opts]\n     (let [self (symbol (str *ns*) \"with-handler\")]\n       `(defmacro ~'with-handler\n          \"Executes form with ONLY the given signal handler registered.\n  Stops handler after use. Useful for tests/debugging.\n\n  See `help:handler-dispatch-options` for handler filters, etc.\n  See also `with-handler+`.\"\n          (~'[handler-id handler-fn               form] (list '~self ~'handler-id ~'handler-fn nil ~'form))\n          (~'[handler-id handler-fn dispatch-opts form]\n           `(let [~'wrapped-handler-fn# (wrap-handler ~~'handler-id ~~'handler-fn ~~lib-dispatch-opts ~~'dispatch-opts)]\n              (enc/try*\n                (binding [~'~*sig-handlers* (add-handler {} ~~'handler-id ~'wrapped-handler-fn#)] ~~'form)\n                (finally (~'wrapped-handler-fn#)))))))))\n\n(comment (api:with-handler `*my-sig-handlers* {:my-opt :foo}))\n\n#?(:clj\n   (defn- api:with-handler+ [*sig-handlers* lib-dispatch-opts]\n     (let [self (symbol (str *ns*) \"with-handler+\")]\n       `(defmacro ~'with-handler+\n          \"Executes form with the given signal handler (also) registered.\n  Stops handler after use. Useful for tests/debugging.\n\n  See `help:handler-dispatch-options` for handler filters, etc.\n  See also `with-handler`.\"\n          (~'[handler-id handler-fn               form] (list '~self ~'handler-id ~'handler-fn nil ~'form))\n          (~'[handler-id handler-fn dispatch-opts form]\n           `(let [~'wrapped-handler-fn# (wrap-handler ~~'handler-id ~~'handler-fn ~~lib-dispatch-opts ~~'dispatch-opts)]\n              (enc/try*\n                (binding [~'~*sig-handlers* (add-handler ~'~*sig-handlers* ~~'handler-id ~'wrapped-handler-fn#)] ~~'form)\n                (finally (~'wrapped-handler-fn#)))))))))\n\n(comment (api:with-handler+ `*my-sig-handlers* {:my-opt :foo}))\n\n#?(:clj\n   (defn- api:add-handler! [*sig-handlers* lib-dispatch-opts]\n     `(defn ~'add-handler!\n        \"Registers given signal handler and returns\n  {<handler-id> {:keys [dispatch-opts handler-fn]}} for all handlers\n  now registered. If an old handler already existed under the same id, stop it.\n\n  `handler-fn` should be a fn of exactly 2 arities:\n\n    [signal] ; Single argument\n      Called asynchronously or synchronously (depending on dispatch options)\n      to do something useful with the given signal.\n\n      Example actions:\n        Save data to disk or db, `tap>`, log, `put!` to an appropriate\n        `core.async` channel, filter, aggregate, use for a realtime analytics\n        dashboard, examine for outliers or unexpected data, etc.\n\n    [] ; No arguments\n      Called exactly once when stopping handler to provide an opportunity\n      for handler to flush buffers, close files, etc. May just noop.\n\n  NB you should always call `stop-handlers!` somewhere appropriate - usually\n  near the end of your `-main` or shutdown procedure, AFTER all other code has\n  completed that could create signals.\n\n  See `help:handler-dispatch-options` for handler filters, etc.\"\n        (~'[handler-id handler-fn              ] (~'add-handler! ~'handler-id ~'handler-fn nil))\n        (~'[handler-id handler-fn dispatch-opts]\n         {:arglists\n          '([handler-id handler-fn]\n            [handler-id handler-fn\n             {:as   dispatch-opts\n              :keys [async priority sample-rate rate-limit when-fn middleware,\n                     kind-filter ns-filter id-filter min-level,\n                     error-fn backp-fn]}])}\n\n         (let [removed-handler# (get-wrapped-handler-fn ~*sig-handlers* ~'handler-id)\n               new-handlers-vec#\n               (enc/update-var-root! ~*sig-handlers*\n                 (fn [m#]\n                   (add-handler m# ~'handler-id ~'handler-fn,\n                     ~lib-dispatch-opts ~'dispatch-opts)))]\n\n           (when removed-handler# (removed-handler#))\n           (get-handlers-map new-handlers-vec#))))))\n\n(comment (api:add-handler! `*my-sig-handlers* 'lib-dispatch-opts))\n\n#?(:clj\n   (defn- api:remove-handler! [*sig-handlers*]\n     `(defn ~'remove-handler!\n        \"Stops and deregisters signal handler with given id, and returns\n  ?{<handler-id> {:keys [dispatch-opts handler-fn]}} for all handlers\n  still registered.\"\n        ~'[handler-id]\n        (let [removed-handler#  (get-wrapped-handler-fn ~*sig-handlers* ~'handler-id)\n              new-handlers-vec# (enc/update-var-root!   ~*sig-handlers*\n                                  (fn [m#] (remove-handler m# ~'handler-id)))]\n\n          (when removed-handler# (removed-handler#))\n          (get-handlers-map new-handlers-vec#)))))\n\n(comment (api:remove-handler! `*my-sig-handlers*))\n\n#?(:clj\n   (defn- api:stop-handlers! [*sig-handlers*]\n     `(defn ~'stop-handlers!\n        \"Stops registered signal handlers in parallel by calling each\n  handler-fn with no arguments. This gives each handler the opportunity\n  to flush buffers, close files, etc.\n\n  Each handler will immediately stop accepting new signals, nooping if called.\n\n  Blocks to return ?{<handler-id> {:keys [okay error]}}, honouring each\n  handler's `:drain-msecs` value (see `help:handler-dispatch-options`).\n\n  NB you should always call `stop-handlers!` somewhere appropriate - usually\n  near the end of your `-main` or shutdown procedure, AFTER all other code has\n  completed that could create signals.\"\n        [] (stop-handlers! ~*sig-handlers*))))\n\n(comment (api:stop-handlers! `*my-sig-handlers*))\n\n;;;;\n\n#?(:clj\n   (defn- api:*ctx* []\n     `(enc/def* ~'*ctx* {:dynamic true}\n        \"Optional context (state) attached to all signals.\n  Value may be any type, but is usually nil or a map. Default (root) value is nil.\n\n  Useful for dynamically attaching arbitrary app-level state to signals.\n\n  Re/bind dynamic        value using `with-ctx`, `with-ctx+`, or `binding`.\n  Modify  root (default) value using `set-ctx!`.\n\n  As with all dynamic Clojure vars, \\\"binding conveyance\\\" applies when using\n  futures, agents, etc.\n\n  Tips:\n    - Value may be (or may contain) an atom if you want mutable semantics.\n    - Value may be of form {<scope-id> <data>} for custom scoping, etc.\n    - Use `get-env` to set default (root) value based on environmental config.\"\n        nil)))\n\n#?(:clj\n   (defn- api:*middleware* []\n     `(enc/def* ~'*middleware* {:dynamic true}\n        \"Optional (fn [signal]) => ?modified-signal to apply to all signals.\n  When middleware returns nil, skips all handlers. Default (root) value is nil.\n\n  Useful for dynamically transforming signals and/or filtering signals\n  by signal data/content/etc.\n\n  Re/bind dynamic        value using `with-middleware`, `with-middleware+`, `binding`.\n  Modify  root (default) value using `set-middleware!`.\n\n  As with all dynamic Clojure vars, \\\"binding conveyance\\\" applies when using\n  futures, agents, etc.\n\n  Examples:\n\n    ;; Filter all signals by returning nil:\n    (t/set-middleware! (fn [signal] (when-not (:skip-me? signal) signal)))\n\n    ;; Remove key/s from all signals:\n    (t/set-middleware! (fn [signal] (dissoc signal :unwanted-key1 ...)))\n\n    ;; Remove key/s from signals to specific handler:\n    (t/add-handler! ::my-handler my-handler\n      {:middleware (fn [signal] (dissoc signal :unwanted-key1 ...))})\n\n    ;; Set middleware for specific signal/s:\n    (binding [*middleware* (fn [signal] ...)]\n      (...))\n\n  Tips:\n    - Compose multiple middleware fns together with `comp-middleware`.\n    - Use `get-env` to set default (root) value based on environmental config.\"\n        nil)))\n\n(defn update-ctx\n  \"Returns `new-ctx` given `old-ctx` and an update map or fn.\"\n  [old-ctx update-map-or-fn]\n  (enc/cond\n    (nil? update-map-or-fn)              old-ctx\n    (map? update-map-or-fn) (enc/merge   old-ctx update-map-or-fn) ; Before ifn\n    (ifn? update-map-or-fn) (update-map-or-fn old-ctx)\n    :else\n    (enc/unexpected-arg! update-map-or-fn\n      {:context  `update-ctx\n       :param    'update-map-or-fn\n       :expected '#{nil map fn}})))\n\n#?(:clj\n   (defn- api:set-ctx! []\n     `(defn ~'set-ctx!\n        \"Set `*ctx*` var's default (root) value. See `*ctx*` for details.\"\n        ~'[root-ctx-val] (enc/set-var-root! ~'*ctx* ~'root-ctx-val))))\n\n#?(:clj\n   (defn- api:set-middleware! []\n     `(defn ~'set-middleware!\n        \"Set `*middleware*` var's default (root) value. See `*middleware*` for details.\"\n        ~'[?root-middleware-fn]\n        (enc/set-var-root! ~'*middleware* ~'?root-middleware-fn))))\n\n#?(:clj\n   (defn- api:with-ctx []\n     (let [*ctx* (symbol (str *ns*) \"*ctx*\")]\n       `(defmacro ~'with-ctx\n          \"Evaluates given form with given `*ctx*` value. See `*ctx*` for details.\"\n          ~'[ctx-val form] `(binding [~'~*ctx* ~~'ctx-val] ~~'form)))))\n\n#?(:clj\n   (defn- api:with-ctx+ []\n     (let [*ctx* (symbol (str *ns*) \"*ctx*\")]\n       `(defmacro ~'with-ctx+\n          \"Evaluates given form with updated `*ctx*` value.\n\n  `update-map-or-fn` may be:\n    - A map to merge with    current `*ctx*` value, or\n    - A unary fn to apply to current `*ctx*` value\n\n  See `*ctx*` for details.\"\n          ~'[update-map-or-fn form]\n          `(binding [~'~*ctx* (update-ctx ~'~*ctx* ~~'update-map-or-fn)] ~~'form)))))\n\n#?(:clj\n   (defn- api:with-middleware []\n     (let [*middleware* (symbol (str *ns*) \"*middleware*\")]\n       `(defmacro ~'with-middleware\n          \"Evaluates given form with given `*middleware*` value.\n  See `*middleware*` for details.\"\n          ~'[?middleware-fn form]\n          `(binding [~'~*middleware* ~~'?middleware-fn] ~~'form)))))\n\n#?(:clj\n   (defn- api:with-middleware+ []\n     (let [*middleware* (symbol (str *ns*) \"*middleware*\")]\n       `(defmacro ~'with-middleware+\n          \"Evaluates given form with composed `*middleware*` value.\n  Same as (with-middleware (comp-middleware *middleware* ?middleware-fn) ...).\n  See `*middleware*` for details.\"\n          ~'[?middleware-fn form]\n          `(binding [~'~*middleware* (enc/comp-middleware ~'~*middleware* ~~'?middleware-fn)]\n             ~~'form)))))\n\n;;;;\n\n#?(:clj\n   (defmacro def-api\n     \"Defines signal API vars in current ns.\n  NB Cljs ns will need appropriate `:require-macros`.\"\n     [{:as opts\n       :keys\n       [sf-arity lib-dispatch-opts\n        ct-sig-filter *rt-sig-filter* *sig-handlers*\n        exclude]}]\n\n     (enc/have? [:ks>= #{:sf-arity :ct-sig-filter :*rt-sig-filter* :*sig-handlers*}] opts)\n     (enc/have? [:or nil? symbol?]  ct-sig-filter  *rt-sig-filter*  *sig-handlers*)\n\n     (when-not (contains? #{2 3 4} sf-arity)\n       (unexpected-sf-artity! sf-arity `def-api))\n\n     (let [clj?            (not (:ns &env))\n           sf-arity        (int sf-arity)\n           ct-sig-filter   (enc/resolve-sym &env  ct-sig-filter)\n           *rt-sig-filter* (enc/resolve-sym &env *rt-sig-filter*)\n           *sig-handlers*  (enc/resolve-sym &env *sig-handlers*)\n           incl?           (complement (set exclude))]\n\n       `(do\n          (enc/defalias level-aliases)\n\n          ~(api:help:filters)\n          ~(api:help:handlers)\n          ~(api:help:handler-dispatch-options)\n\n          ~(api:get-filters             *rt-sig-filter* ct-sig-filter)\n          ~(api:get-min-levels sf-arity *rt-sig-filter* ct-sig-filter)\n\n          ~(api:get-handlers       *sig-handlers*)\n          ~(api:get-handlers-stats *sig-handlers*)\n\n          ~(when clj? (api:without-filters *rt-sig-filter*))\n\n          ~(when (and (>= sf-arity 4) clj?) (api:with-kind-filter *rt-sig-filter*))\n          ~(when      (>= sf-arity 4)       (api:set-kind-filter! *rt-sig-filter*))\n\n          ~(when clj? (api:with-ns-filter *rt-sig-filter*))\n          ~(do        (api:set-ns-filter! *rt-sig-filter*))\n\n          ~(when (and (>= sf-arity 3) clj?) (api:with-id-filter *rt-sig-filter*))\n          ~(when      (>= sf-arity 3)       (api:set-id-filter! *rt-sig-filter*))\n\n          ~(when clj? (api:with-min-level sf-arity *rt-sig-filter*))\n          ~(do        (api:set-min-level! sf-arity *rt-sig-filter*))\n\n          ~(when clj? (api:with-handler  *sig-handlers* lib-dispatch-opts))\n          ~(when clj? (api:with-handler+ *sig-handlers* lib-dispatch-opts))\n\n          ~(api:add-handler!    *sig-handlers* lib-dispatch-opts)\n          ~(api:remove-handler! *sig-handlers*)\n          ~(api:stop-handlers!  *sig-handlers*)\n\n          ~@(when (incl? :ctx)\n              [(api:*ctx*)\n               (api:set-ctx!)\n               (api:with-ctx)\n               (api:with-ctx+)])\n\n          ~@(when (incl? :middleware)\n              [(api:*middleware*)\n               (api:set-middleware!)\n               (api:with-middleware)\n               (api:with-middleware+)])))))\n\n(comment\n  ;; See `taoensso.encore-tests.required-ns` ns\n  (macroexpand\n    '(def-api\n       {:sf-arity 4\n        :ct-sig-filter    my-ct-sig-filter\n        :*rt-sig-filter* *my-rt-sig-filter*\n        :*sig-handlers*  *my-sig-handlers*})))\n\n;;;; Utils\n\n(enc/def* upper-qn\n  \"`:foo/bar` -> \\\"FOO/BAR\\\", etc.\"\n  {:arglists '([x]), :tag #?(:clj 'String :cljs 'string)}\n  (enc/fmemoize (fn [x] (str/upper-case (enc/as-qname x)))))\n\n(comment (upper-qn :foo/bar))\n\n(enc/def* format-level\n  \"`:info` -> \\\"INFO\\\",\n       `5` -> \\\"LEVEL:5\\\", etc.\"\n  {:arglists '([x]), :tag #?(:clj 'String :cljs 'string)}\n  (enc/fmemoize\n    (fn [x]\n      (if (keyword?   x)\n        (upper-qn     x)\n        (str \"LEVEL:\" x)))))\n\n(comment (format-level :info))\n\n(enc/def* format-id\n  \"`:foo.bar/baz` -> \\\"::baz\\\", etc.\"\n  {:arglists '([ns x]), :tag #?(:clj 'String :cljs 'string)}\n  (enc/fmemoize\n    (fn [ns x]\n      (if (keyword? x)\n        (if (= (namespace x) ns)\n          (str \"::\" (name x))\n          (str            x))\n        (str x)))))\n\n(comment\n  (format-id (str *ns*) ::id1)\n  (format-id nil ::id1))\n\n(let [cached\n      (enc/fmemoize\n        (fn [base line column]\n          (if line\n            (if column\n              (str base \"(\" line \",\" column \")\")\n              (str base \"(\" line            \")\"))\n            base)))]\n\n  (enc/def* format-location\n    \"Returns \\\"<ns/file>(<line>,<column>)\\\", etc.\"\n    {:tag #?(:clj 'String :cljs 'string)\n     :arglists '([ns line column file] [signal])}\n    (fn\n      ([ns line column file] (when-let [base (or ns file)] (cached base line column)))\n      ([location]\n       (when-let [base (or (get location :ns) (get location :file))]\n         (let [{:keys [line column]} location]\n           (cached base line column)))))))\n\n(comment\n  (format-location \"my-ns\" 120 8 nil)\n  (format-location nil     120 8 *file*))\n\n(defn signal-with-combined-sample-rate [handler-sample-rate sig-val]\n  (or\n    (when handler-sample-rate\n      (when (map? sig-val)\n        (assoc sig-val :sample-rate\n          (*\n            (double handler-sample-rate)\n            (double (or (get sig-val :sample-rate) 1.0))))))\n    sig-val))\n\n(comment (signal-with-combined-sample-rate 0.2 {:sample-rate 0.3}))\n"],"x_google_ignoreList":[0]}