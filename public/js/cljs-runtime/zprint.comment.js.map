{"version":3,"sources":["zprint/comment.cljc"],"mappings":"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","names":["zprint.comment/blanks","n","cljs.core.apply","cljs.core/str","cljs.core.repeat","zprint.comment/split-lf","s","input","out","cljs.core/not","next-lf","clojure.string.index_of","chunk","cljs.core.subs","cljs.core.conj","zprint.comment/capital?","cljs.core/re-find","zprint.comment/capitalize-first","clojure.string/capitalize","zprint.comment/adjust-border","start-col","border","width","actual-space","x__5090__auto__","y__5091__auto__","new-width","zprint.comment/tag-l-size","t","G__71515","cljs.core/Keyword","zprint.comment/left-or-up","zloc","ploc","total-up","next-left","rewrite-clj.zip/left*","moving-up","rewrite-clj.zip/up*","up-tag","rewrite-clj.zip/tag","up-size","zprint.comment/length-after-newline","nl-split","clojure.string.split","nl-num","cljs.core/count","cljs.core/last","zprint.comment/length-before","vec__71531","cljs.core.nth","next-zloc","indent-before","vec__71542","zstr","zprint.zfns/zstring","length-right-of-newline","zprint.comment/inlinecomment?","nloc","spaces","passed-nl?","vec__71563","tnloc","zprint.zfns/ztag","cljs.core._EQ_","nstr","trim-nstr","clojure.string/trimr","nloc-length-before","zloc-length-before","cljs.core.not_EQ_","rewrite-clj.zip/length","zprint.comment/last-space","from-index","rev-seq","cljs.core/reverse","cljs.core.take","seq-after-space","p1__71570#","cljs.core.take_while","space-index","zprint.comment/next-space","p1__71573#","cljs.core.drop","cljs.core/seq","p__71580","vec__71581","zprint.comment/wrap-comment","color","stype","element","start","width-configured","comment-width","semi-str","rest-str","space-str","newline?","comment-str","cljs.core/transient","cljs.core/empty?","cljs.core/persistent!","cljs.core.conj_BANG_","last-space-index","or__5002__auto__","next-comment","p__71612","vec__71613","zprint.comment/loc-vec","split","zprint.comment/style-loc-vec","indent","style-vec","cljs.core/butlast","cljs.core.reductions","zprint.comment/lift-vec","out-vec","cljs.core/first","element-vec","cljs.core/next","zprint.comment/lift-style-vec","cljs.core.reduce","p__71653","map__71655","cljs.core/--destructure-map","map__71656","cljs.core.get","zprint.comment/fzprint-wrap-comments","smart-wrap?","options","top-level-border","_","cljs.core/some","cljs.core.println","G__71673","G__71674","fexpr__71672","wrap-style-vec","cljs.core.mapv","cljs.core.partial","G__71682","G__71683","fexpr__71681","out-style-vec","zprint.comment/find-element-from-end","element-pred?","index","vec__71687","e","zprint.comment/line-size","cljs.core/+","cljs.core.map","zprint.comment/space-before-comment","indent-index","p1__71707#","this-line-vec","cljs.core/nthnext","zprint.comment/get-semis-and-spaces","zprint.comment/match-regex-seq","regex-seq","regex-source","groups?","match","e71733","js/Error","cljs.core.pr_str","cljs.core/vector?","G__71740","G__71741","G__71742","G__71743","zprint.comment/match-and-modify-comment","end+start-cg","end+skip-cg","skip?","vec__71754","whole-match","semi-match","after-semi-match","zprint.comment/fit-in-comment-group?","this-start-col","end-cg","number-semis","current-spacing","vec__71770","semi-count","space-count","len","p__71788","map__71790","map__71791","map__71792","zprint.comment/get-next-comment-group","top-level?","depth","start-col-vec","idx","nl-indent-count","vec__71832","what","cljs.core.assoc","vec__71845","vec__71848","fit-return","zprint.comment/style-lines-in-comment-group","comment-group","lengths","p1__71868#","max-length","cljs.core/max","zprint.comment/first-space-left","clojure.string.last_index_of","zprint.comment/first-space-right","zprint.comment/split-str-at-space-left","space-left","zprint.comment/split-str-at-space","vec__72022","start-str","end-str","return-vec","space-right","zprint.comment/insert-str-into-style-vec","style-idx","vec__72036","old-s","zprint.comment/delete-style-vec-element","vec__72050","vec__72053","rs","right-what","right-element","ls","left-what","left-element","zprint.comment/ends-w-punctuation?","clojure.string/ends-with?","zprint.comment/figure-separator","left","right","clojure.string/includes?","terminated?","capitalized?","right-more-than-one?","left-empty?","and__5000__auto__","zprint.comment/move-ls-to-us","us-text","ls-text","available-space","vec__72125","vec__72128","separator","new-ls-text","new-end-us","new-ls","var_args","G__72154","zprint.comment/text-to-comment","us","space-count-from-us","zprint.comment.text_to_comment","zprint.comment/balance-two-comments","usable-space","upper-idx","lower-idx","vec__72220","vec__72223","ucolor","uwhat","upper-element","lcolor","lwhat","lower-element","front-matter","upper-space","lower-space","vec__72242","new-us","new-start-ls","full-us","vec__72262","full-ls","vec__72300","p__72328","map__72330","map__72331","map__72332","zprint.comment/flow-comments-in-group","max-variance","last-max","space-factor","comment-lines","max-width","cljs.core/second","length-vec","length-len","butlast-length-vec","last-len","cljs.core/peek","max-not-last","include-last?","cg-variance","zprint.util/variance","last-force?","max-space","line-count","cg","already-changed?","vec__72398","new-style-vec","changed?","cljs.core.concat","cljs.core/List","cljs.core/nnext","p__72434","map__72435","map__72436","map__72437","zprint.comment/fzprint-smart-wrap","cljs.core.into","G__72444","G__72445","fexpr__72443","p1__72404#","p2__72405#","p3__72406#","cljs.core/PersistentVector","cljs.core.range","vec__72473","new-depth","next-idx","cljs.core.subvec","p__72483","map__72484","zprint.comment/fzprint-inline-comments","cvec","last-out","vec__72506","vec__72509","vec__72512","c","ne","nn","next-element","le","new-element","zprint.comment/max-aligned-inline-comment-distance","zprint.comment/find-aligned-inline-comments","last-indent","current-seq","current-column","distance","vec__72547","start-column","zprint.comment/find-consecutive-inline-comments","vec__72598","p__72629","vec__72631","zprint.comment/comment-column","comment-index","column","p__72650","vec__72651","zprint.comment/comment-vec-column","inline-comment-index","comment-vec","spaces-before","zprint.comment/comment-vec-seq-column","comment-vec-seq","zprint.comment/comment-vec-all-column","comment-vec-all","zprint.comment/minimum-column","minimum-vec","p1__72671#","minimum-col","p__72690","vec__72692","zprint.comment/change-start-column","new-start-column","vec__72712","delta-spaces","new-spaces","previous-element-index","previous-element","new-previous-element","zprint.comment/align-comment-vec","zprint.comment/fzprint-align-inline-comments","G__72737","G__72738","fexpr__72736","cljs.core.map_indexed","a","b","style","comment-vec-column"],"sourcesContent":["(ns ^:no-doc zprint.comment\n  #?@(:cljs [[:require-macros\n              [zprint.macros :refer\n               [dbg dbg-pr dbg-form dbg-print dbg-s dbg-s-pr zfuture]]]])\n  (:require #?@(:clj [[zprint.macros :refer\n                       [dbg-pr dbg dbg-form dbg-print dbg-s dbg-s-pr zfuture]]])\n            [clojure.string :as s]\n            [zprint.zfns :refer [zstring ztag]]\n            [zprint.util :refer [variance]]\n            [rewrite-clj.zip :as z :refer [left* up* tag length]]\n            #_[taoensso.tufte :as tufte :refer (p defnp profiled profile)]))\n\n#_(tufte/add-basic-println-handler! {})\n\n;;\n;; # Utility Functions\n;;\n\n;\n; Interestingly, this is faster than (apply str (repeat n \\space)) by\n; about 30%.\n\n(defn blanks\n  \"Produce a blank string of desired size.\"\n  [n]\n  (apply str (repeat n \" \")))\n\n(defn split-lf\n  \"Do split for newlines, instead of using regular expressions.\"\n  [s]\n  (loop [input s\n         out []]\n    (if-not input\n      out\n      (let [next-lf (clojure.string/index-of input \"\\n\")\n            chunk (if next-lf (subs input 0 next-lf) input)]\n        (recur (if next-lf (subs input (inc next-lf)) nil) (conj out chunk))))))\n\n(defn capital?\n  \"True if the first letter of the string is a capital letter.\"\n  [s]\n  (re-find #\"^[A-Z]\" s))\n\n(defn capitalize-first\n  \"Capitalize the first character.  Don't mess with the others.\"\n  [s]\n  (str (clojure.string/capitalize (subs s 0 1)) (subs s 1)))\n\n(defn adjust-border\n  \"Possibly reduce the border because we don't have a lot of space left.\n  Returns a new width.\"\n  [start-col border width]\n  (let [actual-space (- width start-col)\n        ; Adjust border for how much space we really have\n        ; but don't use too much!\n        border (int (min border (/ actual-space 6)))\n        new-width (- width border)]\n    #_(println \"adjust-border: start-col:\" start-col\n               \"border:\" border\n               \"width:\" width\n               \"output width:\" new-width)\n    new-width))\n\n(defn tag-l-size\n  \"Given a tag into which you can go down from rewrite-clj, which must be\n  a collection of some kind, return the size the l-str.  All of the tag\n  values into which you can go down must be in this list for indent-before\n  to work correctly.  It uses these values when it steps up out of one of\n  these things to see how big the thing would have been if it showed up\n  as characters.\"\n  [t]\n  (case t\n    :list 1\n    :vector 1\n    :set 2\n    :map 1\n    :uneval 2\n    :reader-macro 1\n    :meta 1\n    :quote 1\n    :syntax-quote 1\n    :fn 2\n    :unquote 1\n    :deref 1\n    :namespaced-map 1\n    0))\n\n(defn left-or-up\n  \"Take a zloc and move left if possible, or move up if necessary.\n  Return a vector with [up-size new-zloc]\"\n  [zloc]\n  (loop [ploc zloc\n         total-up 0]\n    #_(prn \"left-or-up: ploc:\" (zstring ploc) \"total-up:\" total-up)\n    (let [next-left (left* ploc)]\n      (if next-left\n        [total-up next-left]\n        ; can't go left, what about up?\n        (let [moving-up (up* ploc)\n              up-tag (when moving-up (tag moving-up))\n              up-size (tag-l-size up-tag)]\n          #_(prn \"left-or-up: up-tag:\" up-tag)\n          (if-not moving-up\n            ; can't go up, ran out of expression\n            [total-up nil]\n            (recur moving-up (+ total-up up-size))))))))\n\n(defn length-after-newline\n  \"Given a string, return the number of characters to the right\n  of any newlines in the string.  Will return nil if no newlines\n  in the string.\"\n  [s]\n  (let [nl-split (clojure.string/split (str s \" \") #\"\\n\")\n        nl-num (dec (count nl-split))]\n    (when-not (zero? nl-num) (dec (count (last nl-split))))))\n\n(defn length-before\n  \"Given a zloc, find the amount of printing space before it on its\n  current line.\"\n  [zloc]\n  (let [[up-size next-zloc] (left-or-up zloc)]\n    (loop [ploc next-zloc\n           indent-before up-size]\n      (if-not ploc\n        (do #_(prn \"length-before: if-not ploc:\" indent-before) indent-before)\n        ; we assume we have a ploc\n        (let [zstr (if ploc (zstring ploc) \"\")\n              length-right-of-newline (length-after-newline zstr)\n              [up-size next-zloc] (left-or-up ploc)]\n          #_(prn \"length-before: (nil? ploc):\" (nil? ploc)\n                 \"zstr:\" zstr\n                 \"up-size:\" up-size\n                 \"length-right-of-newline:\" length-right-of-newline\n                 \"(tag ploc):\" (tag ploc)\n                 \"ploc:\" (zstring ploc)\n                 \"next-zloc:\" (zstring next-zloc))\n          (if length-right-of-newline\n            ; hit a newline\n            (do #_(prn \"length-before: length-right-of-newline:\"\n                         length-right-of-newline\n                       \"indent-before:\" indent-before)\n                (+ length-right-of-newline indent-before))\n            (recur next-zloc (+ indent-before (count zstr) up-size))))))))\n\n\n(defn inlinecomment?\n  \"If this is an inline comment, returns a vector with the amount\n  of space that was between this and the previous element and the\n  starting column of this inline comment.  That means that if we\n  go left, we get something other than whitespace before a newline.\n  If we get only whitespace before a newline, then this is considered\n  an inline comment if the comment at the end of the previous line\n  was an inline comment and we were aligned with that comment.\n  Assumes zloc is a comment.\"\n  [zloc]\n  #_(prn \"inlinecomment? zloc:\" (zstring zloc))\n  (loop [nloc (left* zloc)\n         spaces 0\n         passed-nl? false]\n    (let #?(:clj [tnloc (ztag nloc)]\n            :cljs [[tnloc spaces]\n                   (let [tnloc (ztag nloc)]\n                     (if (= tnloc :whitespace)\n                       ; might be whitespace with an embedded comma in cljs\n                       (let [nstr (zstring nloc)\n                             trim-nstr (clojure.string/trimr nstr)]\n                         (if (pos? (count trim-nstr))\n                           ; it had something besides spaces in it\n                           ; we will assume a comma\n                           ;  correct things\n                           [:comma\n                            (+ spaces (- (count nstr) (count trim-nstr)))]\n                           ; it was all whitespace -- don't correct\n                           [:whitespace spaces]))\n                       [tnloc spaces]))])\n         #_(prn \"inlinecomment? tnloc:\" tnloc\n                \"spaces:\" spaces\n                \"nloc:\" (zstring nloc))\n         (cond (nil? tnloc) nil ; the start of the zloc\n               (= tnloc :newline) (recur (left* nloc) spaces true)\n               (or (= tnloc :comment) (= tnloc :comment-inline))\n                 ; Two comments in a row don't have a newline showing\n                 ; between them, it is captured by the first comment. Sigh.\n                 ; Except now it isn't, as we split the newlines out.\n                 (do #_(prn \"inlinecomment? found previous comment!\")\n                     ; is it an inline comment?\n                     (when (inlinecomment? nloc)\n                       ; figure the total alignment from the newline\n                       (let [nloc-length-before (length-before nloc)\n                             zloc-length-before (length-before zloc)]\n                         #_(prn \"inlinecomment?:\"\n                                \"nloc-length-before:\" nloc-length-before\n                                \"zloc-length-before:\" zloc-length-before\n                                \"spaces:\" spaces)\n                         (if (= nloc-length-before zloc-length-before)\n                           ; we have a lineup\n                           [spaces zloc-length-before]\n                           nil))))\n               (not= tnloc :whitespace)\n                 (if passed-nl? nil [spaces (length-before zloc)])\n               :else (recur (left* nloc)\n                            ^long (+ ^long (length nloc) spaces)\n                            passed-nl?)))))\n\n;;\n;; # Comment Wrap Support\n;;\n\n(defn last-space\n  \"Take a string and an index, and look for the last space prior to the\n  index. If we wanted to tie ourselves to 1.8, we could use \n  clojure.string/last-index-of, but we don't.  However, we use similar\n  conventions, i.e., if no space is found, return nil, and if the index\n  is a space return that value, and accept any from-index, including one\n  larger than the length of the string.\"\n  [s from-index]\n  (let [from-index (min (dec (count s)) from-index)\n        rev-seq (reverse (take (inc from-index) s))\n        seq-after-space (take-while #(not= % \\space) rev-seq)\n        space-index (- from-index (count seq-after-space))]\n    (if (neg? space-index) nil space-index)))\n\n(defn next-space\n  \"Take a string and an index, and look for the next space *after* the\n  index. If no space is found, return nil. Accept any from-index, \n  including one larger than the length of the string.\"\n  [s from-index]\n  (let [from-index (inc from-index)]\n    (when (< from-index (count s))\n      (let [seq-after-space (take-while #(not= % \\space)\n                                        (drop from-index (seq s)))\n            space-index (+ from-index (count seq-after-space))]\n        (if (>= space-index (count s)) nil space-index)))))\n\n; transient may have made this worse\n(defn wrap-comment\n  \"If this is a comment, and it is too long, word wrap it to the right width.\n  Note that top level comments may well end with a newline, so remove it\n  and reapply it at the end if that is the case.\"\n  [width border [s color stype :as element] start]\n  (if-not (or (= stype :comment) (= stype :comment-inline))\n    element\n    (let [width-configured width\n          width (adjust-border start border width)\n          #_(println \"\\nborder (configured):\" border\n                     \"border (adjusted):\" (- width-configured width)\n                     \"width (adjusted):\" width)\n          ; This is really available-width, not the actual width of the\n          ; comment.\n          comment-width (- width start)\n          semi-str (re-find #\";*\" s)\n          rest-str (subs s (count semi-str))\n          space-str (re-find #\" *\" rest-str)\n          rest-str (subs rest-str (count space-str))\n          newline? (re-find #\"\\n$\" s)\n          comment-width (- comment-width (count semi-str) (count space-str))\n          #_(println \"\\ncomment-width:\" comment-width\n                     \"semi-str:\" semi-str\n                     \"space-str:\" space-str\n                     \"rest-str:\" rest-str)]\n      (loop [comment-str rest-str\n             out (transient [])]\n        #_(prn \"comment-str:\" comment-str)\n        (if (empty? comment-str)\n          (if (zero? (count out))\n            (if newline?\n              [[semi-str color stype] [\"\\n\" :none :indent 38]]\n              [[semi-str color stype]])\n            (persistent! (if newline? (conj! out [\"\\n\" :none :indent 39]) out)))\n          (let [last-space-index (if (<= (count comment-str) comment-width)\n                                   (dec (count comment-str))\n                                   (if (<= comment-width 0)\n                                     (or (next-space comment-str 0)\n                                         (dec (count comment-str)))\n                                     (or (last-space comment-str comment-width)\n                                         (next-space comment-str comment-width)\n                                         (dec (count comment-str)))))\n                next-comment (clojure.string/trimr\n                               (subs comment-str 0 (inc last-space-index)))]\n            #_(prn \"last-space-index:\" last-space-index\n                   \"next-comment:\" next-comment)\n            (recur\n              (subs comment-str (inc last-space-index))\n              (if (zero? (count out))\n                ;(empty? out)\n                (conj! out [(str semi-str space-str next-comment) color stype])\n                (conj! (conj! out [(str \"\\n\" (blanks start)) :none :indent 40])\n                       [(str semi-str space-str next-comment) color\n                        :comment-wrap])))))))))\n\n(defn loc-vec\n  \"Takes the start of this vector and the vector itself.\"\n  [start [s]]\n  (let [split (split-lf s)]\n    (if (= (count split) 1) (+ start (count s)) (count (last split)))))\n\n(defn style-loc-vec\n  \"Take a style-vec and produce a style-loc-vec with the starting column\n  of each element in the style-vec. Accepts a beginning indent.\"\n  [indent style-vec]\n  (butlast (reductions loc-vec indent style-vec)))\n\n; Transient didn't help here, rather it hurt a bit.\n\n(defn lift-vec\n  \"Take a transient output vector and a vector and lift any style-vec elements\n  out of the input vector.\"\n  [out-vec element]\n  (if (string? (first element))\n    (conj out-vec element)\n    (loop [element-vec element\n           out out-vec]\n      (if-not element-vec\n        out\n        (recur (next element-vec) (conj out (first element-vec)))))))\n\n(defn lift-style-vec\n  \"Take a style-vec [[s color type] [s color type] [[s color type]\n  [s color type]] [s color type] ...] and lift out the inner vectors.\"\n  [style-vec]\n  (reduce lift-vec [] style-vec))\n\n(defn fzprint-wrap-comments\n  \"Take the final output style-vec, and wrap any comments which run over\n  the width. Looking for \"\n  [{:keys [width], {:keys [border smart-wrap?]} :comment, :as options}\n   style-vec]\n  #_(def wcsv style-vec)\n  (let [start-col (style-loc-vec (or (:indent options) 0) style-vec)\n        ; We need this for top level comments.\n        top-level-border border\n        ; If we are doing smart-wrap?, then use the border for smart-wrap.\n        ; The smart-wrap border is used for the interior lines, and some\n        ; very strange things can happen if a different border is used for\n        ; the final line.  So we force all of the lines to use the same\n        ; border.\n        border\n          (if smart-wrap? (:border (:smart-wrap (:comment options))) border)\n        _ (dbg-s options\n                 #{:comment-wrap}\n                 \"fzprint-wrap-comments: indent:\" (:indent options)\n                 \"border (configured):\" border\n                 \"count style-vec:\" (count style-vec)\n                 \"count start-col:\" (count start-col)\n                 \"start-col:\" start-col)\n        #_(def stc start-col)\n        _ (dbg-s\n            options\n            #{:comment-wrap}\n            \"fzprint-wrap-comments: style-vec:\"\n            ((:dzprint options) {:list {:wrap? true, :indent 1}} style-vec))\n        _ (dbg-s options #{:wrap} \"fzprint-wrap-comments: start-col:\" start-col)\n        ; We need to special case top level comments here, and they aren't\n        ; trivial to detect.  Basically, if we have one element in the\n        ; style-vec and it is a comment, we will consider it a top level\n        ; comment.  Then we will use top-level-border.\n        wrap-style-vec\n          (if (and (= (count style-vec) 1)\n                   (= (nth (first style-vec) 2) :comment))\n            (mapv (partial wrap-comment width top-level-border)\n              style-vec\n              start-col)\n            (mapv (partial wrap-comment width border) style-vec start-col))\n        #_(def wsv wrap-style-vec)\n        _ (dbg-s options\n                 #{:comment-wrap}\n                 \"fzprint-wrap-comments: wrapped:\"\n                 ((:dzprint options)\n                   {:list {:wrap? true, :indent 1}}\n                   wrap-style-vec))\n        out-style-vec (lift-style-vec wrap-style-vec)]\n    out-style-vec))\n\n(defn find-element-from-end\n  \"Find a the first element of this type working from the end of a \n  style-vec.  Return the index of the element.\"\n  [element-pred? style-vec]\n  (loop [index (dec (count style-vec))]\n    (if (neg? index)\n      nil\n      (let [[_ _ e] (nth style-vec index)]\n        (if (element-pred? e) index (recur (dec index)))))))\n\n(defn line-size\n  \"Given a style-vec, how big is it in actual characters.  This doesn't\n  handle newlines.\"\n  [style-vec]\n  (apply + (map (partial loc-vec 0) style-vec)))\n\n(defn space-before-comment\n  \"Given a style-vec, whose last element in a comment, find the amount\n  of space before that comment on the line.\"\n  [style-vec]\n  (let [indent-index (find-element-from-end #(or (= % :indent) (= % :newline))\n                                            style-vec)\n        this-line-vec\n          (if indent-index (nthnext style-vec indent-index) style-vec)]\n    (line-size (butlast this-line-vec))))\n\n;;\n;; # Smart Wrap\n;;\n\n(defn get-semis-and-spaces\n  \"Given a string that starts with a semicolon, count the semicolons\n  and the spaces after it, and return both: [semi-count space-count blank?].\"\n  [s]\n  (let [semi-str (re-find #\"^;*\" s)\n        rest-str (subs s (count semi-str))\n        space-str (re-find #\"^ *\" rest-str)]\n    [(count semi-str) (count space-str)]))\n\n(defn match-regex-seq\n  \"Given a vector of regex expressions, attempt to match each \n  against a string.  If any match, return the matched value which\n  must be a vector, else nil.\"\n  [regex-seq regex-source groups? s]\n  (when (first regex-seq)\n    (let [match (try (re-find (first regex-seq) s)\n                     (catch #?(:clj Exception\n                               :cljs :default)\n                       e\n                       (throw (#?(:clj Exception.\n                                  :cljs js/Error.)\n                               (str \"Invalid regular expression: '\"\n                                      (pr-str (first regex-seq))\n                                    \"' in \" regex-source\n                                    \" produced \" (str e))))))]\n      #_(println \"match-regex-seq:\" match \"s:\" (pr-str s))\n      (if match\n        (if (or (vector? match) (not groups?))\n          match\n          (throw (#?(:clj Exception.\n                     :cljs js/Error.)\n                  (str \"match-and-modify: regex from \"\n                       regex-source\n                       \" doesn't return groups. Regex: '\"\n                       (pr-str (first regex-seq))\n                       \"'.\"))))\n        (match-regex-seq (next regex-seq) regex-source groups? s)))))\n\n(defn match-and-modify-comment\n  \"Given a series of regular expressions, which *must* match\n  two groups where the first group is a variable number of semicolons\n  at the beginning, and the second group is some exdented item like\n  a 'o', '-', '1', or '1.', if any of them match, replace the second group \n  with spaces and return the resulting string, otherwise return the\n  string unchanged. Returns [s skip?] in case the comment string\n  matched the end+skip-cg vector of regexs.\"\n  [end+start-cg end+skip-cg s]\n  #_(println \"match-and-modify-comment s:\" s)\n  (let [skip? (match-regex-seq end+skip-cg :end+skip-cg nil s)]\n    (if skip?\n      [s true]\n      (let [match (match-regex-seq end+start-cg :end+start-cg true s)]\n        (if match\n          (let [[whole-match semi-match after-semi-match] match]\n            #_(println \"match-and-modify-comment match:\" match)\n            [(str semi-match\n                  (blanks (count after-semi-match))\n                  (subs s (count whole-match))) false])\n          [s false])))))\n\n(defn fit-in-comment-group?\n  \"Figure out if this comments fits in the current comment group.\n  Start simple, enhance later. Returns :fit, :skip, :next to represent\n  what to do when dealing with this line.  :fit means it goes in the\n  current comment group, :end means that it fits in this comment group\n  but ends this groupi, :skip means that it doesn't go into any\n  comment group, and :next means that it goes in the next comment group.\"\n  [s this-start-col end+start-cg end+skip-cg end-cg start-col number-semis\n   current-spacing]\n  #_(println \"fit-in-comment-group? s:\" s)\n  (let [[semi-count space-count] (get-semis-and-spaces s)\n        len (count s)]\n    (cond\n      ; If it matches either regex group, then it terminates a group\n      (match-regex-seq end+skip-cg :end+skip-cg nil s) :skip\n      (match-regex-seq end+start-cg :end+start-cg true s) :next\n      (and (= this-start-col start-col)\n           (= semi-count number-semis)\n           (= space-count current-spacing))\n        (if (match-regex-seq end-cg :end-cg nil s) :end :fit)\n      :else :next)))\n\n(defn get-next-comment-group\n  \"Get the next comment group.  A comment group is a set of comments\n  which are:\n    o On contiguous lines\n    o Contain no blank comment lines\n    o Have the starting column of their first ; the same\n    o Have the same number of beginning ; characters\n    o Have the same number of spaces after their rightmost ;\n       or\n    o Have an outdented single character or number, and have the\n      same number of spaces between the rightmost semi and the beginning\n      of the text if you ignore the outdented character or number\n\n  The final critiera is managed by a set of regular expressions\n  which each match two groups -- the contiguous ; characters, and\n  any outdented information after the rightmost ; and before the\n  remaining text.\n\n  Takes a starting index, and two vectors.  The start-col-vec is a\n  vector of the starting columns of each element in the style-vec.\n  They must be the same length!  Returns a vector with the starting\n  element in the style vec of each comment of this comment group.\n  Returns [depth [next-element-index semi-count space-count\n  comment-group-members]] If next-element-index is nil, this was\n  the last comment group in the style-vec and it may or may not\n  have any additional indexes in the vector.\n  \n  Also tracks the depth.\"\n  [{{:keys [smart-wrap?],\n     {:keys [end+start-cg end+skip-cg end-cg top-level?]} :smart-wrap}\n      :comment,\n    :as options} depth index start-col-vec style-vec]\n  (dbg-s options\n         #{:smart-wrap}\n         \"get-next-comment-group: depth:\" depth\n         \"end+start-cg\" end+start-cg\n         \"end+skip-cg\" end+skip-cg)\n  (loop [idx index\n         depth depth\n         start-col 0\n         number-semis 0 ; non-zero says we currently in a group\n         current-spacing 0\n         nl-indent-count 0\n         out [nil 0 0]]\n    ; Find the start of the comment group\n    (let [[s color what :as element] (nth style-vec idx [\"\" :none :end])]\n      (dbg-s-pr options\n                #{:smart-wrap}\n                \"get-next-comment-group: depth:\" depth\n                \"s:\" s\n                \"what:\" what\n                \"number-semis:\" number-semis\n                \"current-spacing:\" current-spacing\n                \"out:\" out)\n      (if (= what :end)\n        ; We are out of elements to search.  We might have been\n        ; in a comment group, and we might not have.  In either\n        ; case, the first element is nil, which is correct as it\n        ; signals that there isn't another comment group to look for.\n        ; Use number-semis as a sentinal for whether we are currently\n        ; in a comment-group.\n        (if (zero? number-semis)\n          [depth out]\n          [depth\n           (assoc out\n             1 number-semis\n             2 current-spacing)])\n        (cond\n          (= what :left) (recur (inc idx)\n                                (inc depth)\n                                start-col\n                                number-semis\n                                current-spacing\n                                nl-indent-count\n                                out)\n          (= what :right) (recur (inc idx)\n                                 (dec depth)\n                                 start-col\n                                 number-semis\n                                 current-spacing\n                                 nl-indent-count\n                                 out)\n          ; Don't bother looking for comments at the top level, since\n          ; every top level line is in a style-vec by itself.\n          (zero? depth) (recur (inc idx)\n                               depth\n                               start-col\n                               number-semis\n                               current-spacing\n                               nl-indent-count\n                               out)\n          :else\n            (if (zero? number-semis)\n              ; we are not yet in a group -- just looking for a comment\n              (if (or (= what :comment) (= what :comment-inline))\n                ; any comment starts a group\n                (let [[s skip?]\n                        (match-and-modify-comment end+start-cg end+skip-cg s)\n                      ; having possibly modified the beginning of the\n                      ; comment\n                      [semi-count space-count] (when-not skip?\n                                                 (get-semis-and-spaces s))]\n                  #_(println \"semi-count:\" semi-count\n                             \"space-count:\" space-count\n                             \"blank?\" blank?\n                             \"s:\" s)\n                  (if skip?\n                    ; blank comment line or one to skip, ignore it\n                    (recur (inc idx) depth 0 0 0 0 out)\n                    (recur (inc idx)\n                           depth\n                           (nth start-col-vec idx)\n                           semi-count\n                           space-count\n                           nl-indent-count\n                           (conj out idx))))\n                ; not a comment, or not an interesting one, anyway\n                ; and not yet in a group -- move on\n                (recur (inc idx) depth 0 0 0 0 out))\n              ; we are already in a group, see if we should remain in it\n              (cond (or (= what :newline) (= what :indent))\n                      (if (zero? nl-indent-count)\n                        ; This is our first newline or indent, we are still\n                        ; in the group.\n                        (recur (inc idx)\n                               depth\n                               start-col\n                               number-semis\n                               current-spacing\n                               1\n                               out)\n                        ; Too many newlines, we're done. Start next comment\n                        ; group search with next index.\n                        [depth\n                         (assoc out\n                           0 (inc idx)\n                           1 number-semis\n                           2 current-spacing)])\n                    (or (= what :comment) (= what :comment-inline))\n                      ; Need to see if we should remain in the group\n                      (let [fit-return (fit-in-comment-group? s\n                                                              (nth start-col-vec\n                                                                   idx)\n                                                              end+start-cg\n                                                              end+skip-cg\n                                                              end-cg\n                                                              start-col\n                                                              number-semis\n                                                              current-spacing)]\n                        (dbg-s options\n                               #{:fit-in-comment-group}\n                               \"get-next-comment-group: fit-in-comment-group:\"\n                               (pr-str s)\n                               fit-return)\n                        (cond\n                          (= fit-return :fit)\n                            ; yes, this fits in the current group,\n                            ; continue\n                            (recur (inc idx)\n                                   depth\n                                   start-col    ; don't need a new one\n                                   number-semis ; of any of these\n                                   current-spacing\n                                   0\n                                   (conj out idx))\n                          (= fit-return :skip) [depth\n                                                (assoc out\n                                                  0 (inc idx)\n                                                  1 number-semis\n                                                  2 current-spacing)]\n                          (= fit-return :next) [depth\n                                                (assoc out\n                                                  0 idx\n                                                  1 number-semis\n                                                  2 current-spacing)]\n                          (= fit-return :end) [depth\n                                               ; This one is in the cg\n                                               (assoc (conj out idx)\n                                                 ; The next one starts the\n                                                 ; next group\n                                                 0 (inc idx)\n                                                 1 number-semis\n                                                 2 current-spacing)]\n                          :else\n                            (throw\n                              (#?(:clj Exception.\n                                  :cljs js/Error.)\n                               (str\n                                 \"Internal error in get-next-comment-group: '\"\n                                 fit-return\n                                 \"'.\")))))\n                    ; Not a newline or a comment, ends comment group\n                    ; This will also cause any inline comment without\n                    ; just whitespace on the left to terminate a comment\n                    ; group.\n                    :else [depth\n                           (assoc out\n                             0 (inc idx)\n                             1 number-semis\n                             2 current-spacing)])))))))\n\n(defn style-lines-in-comment-group\n  \"Do style-lines (rather differently) for a set of comments in a \n  comment-group.  Return [<line-count> <max-width> [line-lengths]].\"\n  [start-col-vec style-vec comment-group]\n  ; We can do this much more easily, since we know that a comment\n  ; group has only comments, and only one per line.  we also know\n  ; the starting column of all of them.\n  (let [lengths (mapv #(count (first (nth style-vec %))) comment-group)\n        ; Add the starting column to the actual length.  Assumes\n        ; they all have the same starting column!\n        lengths (mapv (partial + (nth start-col-vec (first comment-group)))\n                  lengths)\n        max-length (apply max lengths)]\n    [(count comment-group) max-length lengths]))\n\n(defn first-space-left\n  \"Find the first space to the left of idx in the string s. Returns a number\n  or nil if no space.\"\n  [s idx]\n  (clojure.string/last-index-of s \" \" idx))\n\n(defn first-space-right\n  \"Find the first space to the left of idx in the string s. Returns a number\n  or nil if no space.\"\n  [s idx]\n  (clojure.string/index-of s \" \" idx))\n\n(defn split-str-at-space-left\n  \"Split the string at the first space to the left of idx, if any\n  is found.  Returns [start-str end-str].  If no space is found,\n  end-str is nil.  If idx is beyond the end of s, then puts all of\n  s into start-str, and makes end-str be an empty string, not nil.\n  Note -- leaves the first left space out of the resulting strings.\"\n  [s idx]\n  (if (> idx (count s))\n    [s \"\"]\n    (let [space-left (first-space-left s idx)]\n      (if space-left\n        [(subs s 0 space-left) (subs s (inc space-left))]\n        [s nil]))))\n\n(defn split-str-at-space\n  \"Split the string at the first space to the left of idx, if any\n  is found.  Returns [start-str end-str].  If no space is found,\n  instead of using the first space to the left of idx, the first\n  space to the right of idx is used.  If no space at all can be\n  found, end-str is nil.  If idx is beyond the end of s, then puts\n  all of s into start-str, and makes end-str be an empty string,\n  not nil.  Note -- leaves the space where the string is split out\n  of the resulting strings.\"\n  [s idx]\n  (let [[start-str end-str :as return-vec] (split-str-at-space-left s idx)]\n    (if (nil? end-str)\n      ; didn't find a space to the left, what about the right?\n      (let [space-right (first-space-right s idx)]\n        (if space-right\n          [(subs s 0 space-right) (subs s (inc space-right))]\n          [s nil]))\n      return-vec)))\n\n(defn insert-str-into-style-vec\n  \"Insert string s into the style-vec at index style-idx.\"\n  [style-vec s style-idx]\n  (let [[old-s color what :as element] (nth style-vec style-idx)]\n    (assoc style-vec style-idx [s color what])))\n\n(defn delete-style-vec-element\n  \"Make a style-vec element an empty string and remove :newline or :indent\n   immediately before it.\"\n  [style-vec style-idx]\n  (if (zero? style-idx)\n    ; can't mess with something before the zeroth element\n    style-vec\n    (let [[rs color right-what :as right-element] (nth style-vec style-idx)\n          [ls color left-what :as left-element] (nth style-vec (dec style-idx))]\n      #_(prn \"delete-style-vec-element: \" left-element right-element)\n      (if (and (or (= right-what :comment) (= right-what :comment-inline))\n               (or (= left-what :indent) (= left-what :newline)))\n        (assoc style-vec\n          style-idx [\"\" :none :deleted]\n          (dec style-idx) [\"\" :none :deleted])\n        (throw (#?(:clj Exception.\n                   :cljs js/Error.)\n                (str \"can't delete style vec element idx: \" style-idx\n                     \" element: \" right-element)))))))\n\n(defn ends-w-punctuation?\n  \"Take a string, an return true if it ends with some kind of\n  punctuation.  Returns nil if it does not, which signals that\n  some kind of terminating punctuation must be added.\"\n  [s]\n  (if (empty? s)\n    true\n    (or (clojure.string/ends-with? s \".\")\n        (clojure.string/ends-with? s \"!\")\n        (clojure.string/ends-with? s \"?\")\n        (clojure.string/ends-with? s \":\"))))\n\n(defn figure-separator\n  \"Takes two string fragments to glue together.  We assume a space\n  between them (unless the left is empty), but figure out if we\n  need to have a period and possibly capitalize the beginning of\n  the second one. Just use a space if either left or right contains\n  parentheses, so we don't add periods and caps inside of commented\n  out code. Returns [separator new-right]\"\n  [left right]\n  (if (or (clojure.string/includes? left \"(\")\n          (clojure.string/includes? left \")\")\n          (clojure.string/includes? right \"(\")\n          (clojure.string/includes? right \")\"))\n    [\" \" right]\n    (let [terminated? (ends-w-punctuation? left)\n          capitalized? (capital? right)\n          right-more-than-one? (> (count (re-find #\"^\\w*\" right)) 1)\n          ; If there is nothing on the left, we don't need a space.  We\n          ; also don't know if it was the end of a sentence, and have\n          ; no particularly convenient way to find out.\n          left-empty? (empty? left)]\n      #_(prn \"figure-separator: left:\" left \"right:\" right)\n      (cond left-empty? [\"\" right]\n            (and terminated? capitalized?) [\" \" right]\n            terminated? [\" \" (capitalize-first right)]\n            (and capitalized? right-more-than-one?) [\". \" right]\n            :else [\" \" right]))))\n\n(defn move-ls-to-us\n  \"Look at just the text (not semis or initial spaces) of the us and ls\n  and the available space, and determine if there is any reason to move\n  some or all of the ls onto the us.  If there is, do it, and return new\n  strings.  Returns [new-us new-ls].  If new-ls is nil, then no changes\n  were warrented.  If new-ls is empty (but not nil), then it means that\n  all of the text from the ls moved to the us.  Figures out the necessary\n  separator(s), based in part of the existing punctuation.\"\n  [us-text ls-text available-space]\n  (let [; First, figure the separator(s), since we can't tell what will\n        ; fit without knowing what separators to use, if any.\n        [separator new-ls-text] (figure-separator us-text ls-text)\n        available-space (- available-space (count separator))\n        ; If new-ls is nil, no changes were made.  If new-ls is empty\n        ; but non-nil, then it is all in new-end-us, to be moved up\n        ; to the us in its entirety.\n        [new-end-us new-ls] (split-str-at-space-left new-ls-text\n                                                     available-space)]\n    (if new-ls\n      ; We have two pieces, so new-end-us goes up, and new-ls stays here.\n      [(str us-text separator new-end-us) new-ls]\n      ; We didn't make any changes, leave things as they are.\n      [us-text nil])))\n\n(defn text-to-comment\n  \"Prepend the correct number of semicolons and spaces to a comment\n  string.\"\n  ([semi-count space-count s us]\n   (if us\n     ; If we have an us, then don't load the returned string with\n     ; space-count spaces, but rather get those characters out of the us\n     ; instead. This handles exdented things linke o and *.\n     (let [space-count-from-us (subs us semi-count (+ semi-count space-count))]\n       (str (apply str (repeat semi-count \";\")) space-count-from-us s))\n     (str (apply str (repeat semi-count \";\")) (blanks space-count) s)))\n  ([semi-count space-count s] (text-to-comment semi-count space-count s nil)))\n\n(defn balance-two-comments\n  \"Take the index into the style-vec for two comments, and balance\n  the words in them. Note that usable-space is start-col based.\n  Returns a new style-vec in [new-style-vec changed?].\"\n  [options start-col-vec style-vec semi-count space-count usable-space upper-idx\n   lower-idx comment-group]\n  (let [[us ucolor uwhat :as upper-element] (nth style-vec upper-idx)\n        [ls lcolor lwhat :as lower-element] (nth style-vec lower-idx)\n        ; All of the space measurement up to this point includes the\n        ; semis and spaces on the front of every line.  Including\n        ; usable-space\n        front-matter (+ semi-count space-count)\n        ; Get upper and lower strings w/out semis or spaces\n        us-text (subs us front-matter)\n        ls-text (subs ls front-matter)\n        upper-space (count us-text)\n        lower-space (count ls-text)\n        ; Since we are doing -text operations, adjust usable space\n        ; to reflect that.\n        usable-space (- usable-space front-matter)]\n    (dbg-s options\n           #{:smart-wrap :balance-comments}\n           \"balance-two-comments: usable-space:\" usable-space\n           \"upper-idx:\" upper-idx\n           \"lower-idx:\" lower-idx\n           \"\\nus:\" (pr-str us)\n           \"\\nls:\" (pr-str ls))\n    (cond\n      (> upper-space usable-space)\n        ; Move from upper to lower if we can. It might be that there is one\n        ; thing on the upper that simply doesn't fit.\n        (let [[new-us new-start-ls] (split-str-at-space us-text usable-space)]\n          (dbg-s options\n                 #{:balance-comments}\n                 \"...upper->lower\"\n                 \"\\n   us:\" (pr-str us-text)\n                 \"\\n   \" (count us-text)\n                 \"\\n   ls:\" (pr-str ls-text)\n                 \"\\n   \" (count ls-text)\n                 \"\\n   new-us:\" (pr-str new-us)\n                 \"\\n   \" (count new-us)\n                 \"\\n   new-start-ls:\" (pr-str new-start-ls)\n                 \"\\n   \" (count new-start-ls))\n          (if (not (empty? new-start-ls))\n            (let [full-us (text-to-comment semi-count space-count new-us us)]\n              (let [[separator new-ls-text] (figure-separator new-start-ls\n                                                              ls-text)\n                    full-ls (text-to-comment\n                              semi-count\n                              space-count\n                              (str new-start-ls separator new-ls-text))]\n                (dbg-s options\n                       #{:balance-comments}\n                       \".2.new-ls:\"\n                       (pr-str full-ls))\n                [(-> style-vec\n                     (insert-str-into-style-vec full-us upper-idx)\n                     (insert-str-into-style-vec full-ls lower-idx)) true]))\n            [style-vec nil]))\n      (and\n        (do (dbg-s options\n                   #{:balance-comments}\n                   \"...(< upper-space usable-space)\" (< upper-space\n                                                        usable-space)\n                   \"\\n   upper-space:\" upper-space\n                   \"\\n   lower-space:\" lower-space\n                   \"\\n   ls:\" (pr-str ls))\n            (< upper-space usable-space))\n        ; If the lower is shorter than the upper, and the lower is the last\n        ; line in the comment-group, and the lower won't entirely fit onto\n        ; the upper (and thus allow us to remove a comment line), then\n        ; don't bother changing these lines\n        (do (dbg-s options\n                   #{:balance-comments}\n                   \"...(< lower-space upper-space)\" (< lower-space upper-space)\n                   \"(- usable-space upper-space)\" (- usable-space upper-space)\n                   \"(+ semi-count space-count)\" (+ semi-count space-count)\n                   \"(- lower-space (+ semi-count space-count))\"\n                     (- lower-space (+ semi-count space-count)))\n            true)\n        (not (and (< lower-space upper-space)\n                  (= (count comment-group) 2)\n                  (neg? (- (- usable-space upper-space)\n                           ; Include space between them\n                           (inc (- lower-space (+ semi-count space-count))))))))\n        ; Move from lower to upper if possible. We need something from the\n        ; lower string that is less than the available space between the\n        ; end of the upper string and the end of the usable space. Note\n        ; that move-ls-to-us handles variable sized separators.\n        (let [available-space (- usable-space upper-space)\n              ; If new-ls is non-nil, that means that things changed.\n              ; However, new-ls might still be empty, indicating that\n              ; everything moved to the new-us!\n              [new-us new-ls] (move-ls-to-us us-text ls-text available-space)]\n          (dbg-s options\n                 #{:balance-comments}\n                 \"...move from lower to upper\"\n                 \"\\n available-space (- usable-space upper-space):\"\n                   available-space\n                 \"\\n   new-us:\" (pr-str new-us)\n                 \"\\n   \" (count new-us)\n                 \"\\n   new-ls:\" (pr-str new-ls)\n                 \"\\n   \" (count new-ls))\n          ; If new-ls is non-nil, it might still be empty!\n          (if new-ls\n            (let [full-us (text-to-comment semi-count space-count new-us us)]\n              (if (empty? new-ls)\n                [(-> style-vec\n                     (insert-str-into-style-vec full-us upper-idx)\n                     (delete-style-vec-element lower-idx)) true]\n                (let [full-ls (text-to-comment semi-count space-count new-ls)]\n                  [(-> style-vec\n                       (insert-str-into-style-vec full-us upper-idx)\n                       (insert-str-into-style-vec full-ls lower-idx)) true])))\n            ; We didn't make any changes, leave things as they are.\n            (do (dbg-s options #{:balance-comments} \"...no changes:\")\n                [style-vec nil])))\n      :else [style-vec nil])))\n\n(defn flow-comments-in-group\n  \"For multple line comment groups, do some 'smart' word wrapping,\n  where we will move words back up to a line with less than the\n  others, and also move words down when a line is too long.  Returns\n  style-vec.\"\n  [{:keys [width],\n    {{:keys [border max-variance last-max space-factor]} :smart-wrap} :comment,\n    :as options} start-col-vec style-vec semi-count space-count comment-group]\n  (let [comment-lines\n          (style-lines-in-comment-group start-col-vec style-vec comment-group)\n        ; They all have the same start-col, by definition\n        start-col (nth start-col-vec (first comment-group))\n        max-width (second comment-lines)\n        length-vec (nth comment-lines 2)\n        length-len (count length-vec)\n        butlast-length-vec (butlast length-vec)\n        last-len (peek length-vec)\n        max-not-last (if (> length-len 1)\n                       (apply max butlast-length-vec)\n                       (first length-vec))\n        ; Include last line in the group in variance for the whole group\n        ; if the last line is at least as long as the longest prior to\n        ; the last, and we have more than one line, or if we have only\n        ; two lines/.\n        include-last? (or (and (> length-len 1) (>= last-len max-not-last))\n                          (= length-len 2))\n        cg-variance\n          (or (variance (if include-last? length-vec (butlast length-vec))) 0)\n        ; This calculation is all width based, not start-col based.\n        ;\n        ; Ignore max-variance test if we have more than one line,\n        ; and the last line is longer than any previous line by at\n        ; least last-max.\n        last-force? (and (> length-len 1)\n                         (> last-len max-not-last)\n                         (> (- last-len max-not-last) last-max))\n        ; Adjust border for how much space we really have\n        ; but don't use too much!\n        width (adjust-border start-col border width)\n        usable-space (- width start-col)\n        max-space (- max-width start-col)\n        line-count (count comment-group)\n        space-factor (if (< space-factor 1) 1 space-factor)]\n    (dbg-s options\n           #{:smart-wrap :flow-comments}\n           \"flow-comments-in-group: max-variance:\" max-variance\n           \"cg-variance:\" cg-variance\n           \"include-last?\" include-last?\n           \"last-len:\" last-len\n           \"max-not-last:\" max-not-last\n           \"(- last-len max-not-last):\" (- last-len max-not-last)\n           \"max-width:\" max-width\n           \"max-space:\" max-space\n           \"usable-space:\" usable-space)\n    (if (and (< cg-variance max-variance)\n             (>= max-space (int (/ usable-space space-factor)))\n             (<= max-space usable-space)\n             (>= line-count 2)\n             (not last-force?))\n      ; Don't do anything to this comment-group\n      style-vec\n      ; Loop through lines in comment group, taking them two at a time\n      (loop [cg comment-group\n             style-vec style-vec\n             already-changed? nil]\n        (if (<= (count cg) 1)\n          style-vec\n          (let [[new-style-vec changed?] (balance-two-comments\n                                           options\n                                           start-col-vec\n                                           style-vec\n                                           semi-count\n                                           space-count\n                                           usable-space\n                                           (first cg)\n                                           (second cg)\n                                           cg)]\n            ; Did we delete the second one?\n            (if (= (nth (nth new-style-vec (second cg)) 2) :deleted)\n              ; rewrite the comment group to drop it out\n              (recur (concat (list (first cg)) (nnext cg))\n                     new-style-vec\n                     (or already-changed? changed?))\n              (recur (next cg)\n                     new-style-vec\n                     (or already-changed? changed?)))))))))\n\n(defn fzprint-smart-wrap\n  \"Do smart wrap over the entire style-vec.  Returns a possibly new\n  style-vec.  \n  \n  Note that top-level isn't really a thing, since every actual\n  top-level element comes in one at a time, so they will all have\n  their own comment group, and never get smart wrapped because of\n  that.  We have been keeping track of the depth, and we continue\n  to do so since there might be some reason we cared in the future,\n  but it really makes no actual difference to the output at this\n  point.  That is to say, from this routine, you can't do top-level\n  smart wrapping, period.  Because you never see two top-level\n  comments at the same time.\n  \n  Note also that this routine doesn't complete the wrapping, as it\n  never creates new lines, just wraps within the lines that we have.\n  It may leave the last line with a lot of stuff on it, and let\n  fzprint-wrap-comments turn that last line into multiple lines.\"\n  [{:keys [width],\n    {:keys [smart-wrap?], {:keys [border]} :smart-wrap} :comment,\n    :as options} style-vec]\n  #_(def fsw-in style-vec)\n  (let [start-col (style-loc-vec (or (:indent options) 0) style-vec)\n        style-vec (into [] style-vec)]\n    ; This can cause bad interactions with :dbg stuff, since it calls\n    ; zprint!\n    (dbg-s options\n           #{:smart-wrap :comment-group}\n           \"fzprint-smart-wrap smart-wrap?\"\n           smart-wrap?\n           \"border:\"\n           border\n           ((:dzprint options)\n             {}\n             (map #(vector %1 %2 %3) (range) start-col style-vec)))\n    (loop [idx 0\n           depth 0\n           style-vec style-vec]\n      (let [[new-depth comment-group]\n              (get-next-comment-group options depth idx start-col style-vec)\n            next-idx (first comment-group)\n            semi-count (second comment-group)\n            space-count (nth comment-group 2)\n            cg (subvec comment-group 3)]\n        (dbg-s options\n               #{:smart-wrap :comment-group}\n               \"fzprint-smart-wrap comment-group:\" cg\n               \"depth:\" new-depth\n               \"next-idx:\" next-idx\n               \"semi-count:\" semi-count\n               \"space-count:\" space-count)\n        (if (empty? cg)\n          style-vec\n          (let [new-style-vec (flow-comments-in-group options\n                                                      start-col\n                                                      style-vec\n                                                      semi-count\n                                                      space-count\n                                                      cg)]\n            (if (not (nil? next-idx))\n              (recur next-idx new-depth new-style-vec)\n              new-style-vec)))))))\n\n;;\n;; Inline Comments\n;;\n\n(defn fzprint-inline-comments\n  \"Try to bring inline comments back onto the line on which they belong.\"\n  [{:keys [width], :as options} style-vec]\n  #_(def fic style-vec)\n  (dbg-pr options \"fzprint-inline-comments:\" style-vec)\n  (loop [cvec style-vec\n         last-out [\"\" nil nil]\n         out []]\n    (if-not cvec\n      (do #_(def fico out) out)\n      (let [[s c e :as element] (first cvec)\n            [_ _ ne nn :as next-element] (second cvec)\n            [_ _ le] last-out\n            new-element\n              (cond (and (or (= e :indent) (= e :newline))\n                         (= ne :comment-inline))\n                      (if-not (or (= le :comment) (= le :comment-inline))\n                        ; Regular line to get the inline comment\n                        [(blanks nn) c :whitespace 25]\n                        ; Last element was a comment... Can't put a comment\n                        ; on a comment, but we want to indent it like the\n                        ; last comment. How much space before the last\n                        ; comment?\n                        (do #_(prn \"inline:\" (space-before-comment out))\n                            [(str \"\\n\" (blanks (space-before-comment out))) c\n                             :indent 41]))\n                    :else element)]\n        (recur (next cvec) new-element (conj out new-element))))))\n\n;;\n;; ## Align inline comments\n;;\n\n(def max-aligned-inline-comment-distance 5)\n\n(defn find-aligned-inline-comments\n  \"Given a style-vec, find previously aligned inline comments and\n  output the as a sequence of vectors of comments. The previously\n  aligned comments do not have to be consecutive, but they can't\n  be separated by more than max-aligned-inline-comment-distance.\n  Each comment itself is a vector: [indent-index inline-comment-index],\n  yielding a [[[indent-index inline-comment-index] [indent-index\n  inline-comment-index] ...] ...].  The indexes are into the\n  style-vec.\"\n  [style-vec]\n  #_(def fcic style-vec)\n  (loop [cvec style-vec\n         index 0\n         last-indent 0\n         current-seq []\n         current-column 0\n         distance 0\n         out []]\n    (if-not cvec\n      (let [out (if (> (count current-seq) 0) (conj out current-seq) out)]\n        #_(def fcico out)\n        out)\n      (let [[s c e spaces start-column :as element] (first cvec)]\n        (cond\n          (= e :comment-inline)\n            (if (= start-column current-column)\n              ; include this inline comment in the current-seq, since\n              ; it has the same starting column\n              (recur (next cvec)\n                     (inc index)\n                     nil\n                     (if last-indent\n                       (conj current-seq [last-indent index])\n                       (throw (#?(:clj Exception.\n                                  :cljs js/Error.)\n                               (str \"find-aligned-inline-comments a:\" index))))\n                     current-column\n                     ; distance from last inline comment is zero\n                     0\n                     out)\n              ; start a new current-seq, since this comment's starting\n              ; column doesn't match the current-column of the current-seq\n              (recur (next cvec)\n                     (inc index)\n                     nil\n                     (if last-indent\n                       [[last-indent index]]\n                       (throw (#?(:clj Exception.\n                                  :cljs js/Error.)\n                               (str \"find-aligned-inline-comments b:\" index))))\n                     ; new starting column\n                     start-column\n                     ; distance from the last inline comment is zero\n                     0\n                     ; if we have more than one current inline comments,\n                     ; add them to the out vector\n                     (if (> (count current-seq) 0) (conj out current-seq) out)))\n          (or (= e :indent) (= e :newline))\n            (if (>= distance max-aligned-inline-comment-distance)\n              ; We have gone too far\n              (recur (next cvec)\n                     (inc index)\n                     ; last-indent is this index\n                     index\n                     []\n                     ; current-column\n                     0\n                     ; distance\n                     0\n                     (if (> (count current-seq) 0) (conj out current-seq) out))\n              ; We have not gone too far\n              (recur (next cvec)\n                     (inc index)\n                     ; last-indent is this index\n                     index\n                     current-seq\n                     current-column\n                     ; we've passed another line\n                     (inc distance)\n                     out))\n          :else (recur (next cvec)\n                       (inc index)\n                       last-indent\n                       current-seq\n                       current-column\n                       distance\n                       out))))))\n\n(defn find-consecutive-inline-comments\n  \"Given a style-vec, find consecutive inline comments and output\n  them as a sequence of vectors of comments.  Each comment itself\n  is a vector: [indent-index inline-comment-index], yielding a\n  [[[indent-index inline-comment-index] [indent-index inline-comment-index]\n  ...] ...]\"\n  [options style-vec]\n  #_(def fcic style-vec)\n  (loop [cvec style-vec\n         index 0\n         last-indent 0\n         current-seq []\n         out []]\n    (if-not cvec\n      (do #_(def fcico out)\n          (if last-indent\n            ; if we have a last-indent, then we didn't\n            ; just have a comment.  But if we have more\n            ; than one comment vector in current-seq,\n            ; make sure we keep track of that\n            (if (> (count current-seq) 0) (conj out current-seq) out)\n            ; if we didn't have last-indent, then we\n            ; just had a comment, so keep collecting\n            ; them\n            out)\n          #_out)\n      (let [[s c e :as element] (first cvec)]\n        (dbg-s options\n               #{:consecutive}\n               \"find-consecutive-inline-comments element:\" (pr-str element)\n               \"\\n index:\" index\n               \"\\n last-indent:\" last-indent\n               \"\\n current-seq:\" current-seq\n               \"\\n out:\" out)\n        (cond\n          (= e :comment-inline)\n            (recur (next cvec)\n                   (inc index) ; index\n                   nil         ; next last-indent\n                   (if last-indent\n                     (conj current-seq [last-indent index])\n                     (throw (#?(:clj Exception.\n                                :cljs js/Error.)\n                             (str \"find-consecutive-inline-comments:\" index))))\n                   out)\n          (or (= e :indent) (= e :newline))\n            (recur (next cvec)\n                   (inc index) ; index\n                   index       ; next last-indent\n                   (if last-indent\n                     ; if we have a last-indent, then we didn't\n                     ; just have a comment\n                     []\n                     ; if we don't have a last-indent, then we\n                     ; did just have a comment previously, so keep\n                     ; collecting comments\n                     current-seq)\n                   (if last-indent\n                     ; if we have a last-indent, then we didn't\n                     ; just have a comment.  But if we have more\n                     ; than one comment vector in current-seq,\n                     ; make sure we keep track of that\n                     (if (> (count current-seq) 0) (conj out current-seq) out)\n                     ; if we didn't have last-indent, then we\n                     ; just had a comment, so keep collecting\n                     ; them\n                     out))\n          :else (recur (next cvec) (inc index) last-indent current-seq out))))))\n\n(defn comment-column\n  \"Takes a single vector of [indent-index comment-index] and will show the\n  column on the line in which the comment starts.\"\n  [[indent-index comment-index] style-vec]\n  (when-not (vector? style-vec)\n    (throw (#?(:clj Exception.\n               :cljs js/Error.)\n            (str \"comment-column: style-vec not a vector!! \" style-vec))))\n  (loop [index indent-index\n         column 0]\n    (if (= index comment-index)\n      column\n      (recur (inc index) (loc-vec column (nth style-vec index))))))\n\n(defn comment-vec-column\n  \"Take a single inline comment vector:\n  [indent-index inline-comment-index] \n  and replace it with [inline-comment-index start-column spaces-before].\"\n  [style-vec [indent-index inline-comment-index :as comment-vec]]\n  #_(prn \"comment-vec-column:\" style-vec comment-vec)\n  (let [start-column (comment-column comment-vec style-vec)\n        spaces-before (if (= (count style-vec) 1)\n                        (nth (first style-vec) 3)\n                        (loc-vec 0 (nth style-vec (dec inline-comment-index))))]\n    [inline-comment-index start-column spaces-before]))\n\n(defn comment-vec-seq-column\n  \"Take a single vector of inline comments\n  [[indent-index inline-comment-index] [indent-index inline-comment-index]\n   ...] and replace it with [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...]\"\n  [style-vec comment-vec-seq]\n  (map (partial comment-vec-column style-vec) comment-vec-seq))\n\n(defn comment-vec-all-column\n  \"Take a seq of all of the comments as produced by \n  find-consecutive-inline-comments, and turn it into:\n  [[[inline-comment-index start-column spaces-before] [inline-comment-index\n  start-column spaces-before]\n  ...] ...]\"\n  [style-vec comment-vec-all]\n  (map (partial comment-vec-seq-column style-vec) comment-vec-all))\n\n(defn minimum-column\n  \"Given a set of inline comments:\n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], determine\n   the minimum column at which they could be aligned.\"\n  [comment-vec]\n  (let [minimum-vec (map #(inc (- (second %) (nth % 2))) comment-vec)\n        minimum-col (apply max minimum-vec)]\n    minimum-col))\n\n(defn change-start-column\n  \"Given a new start-column, and a vector \n  [[inline-comment-index start-column spaces-before]\n  and a style-vec, return a new style-vec with the inline-comment starting\n  at a new column.\"\n  [new-start-column style-vec\n   [inline-comment-index start-column spaces-before :as comment-vec]]\n  (if (zero? inline-comment-index)\n    style-vec\n    (let [delta-spaces (- new-start-column start-column)\n          new-spaces (+ spaces-before delta-spaces)\n          previous-element-index (dec inline-comment-index)\n          #_(prn \"change-start-column:\"\n                 \"spaces-before:\" spaces-before\n                 \"delta-spaces:\" delta-spaces\n                 \"new-spaces:\" new-spaces)\n          [s c e :as previous-element] (nth style-vec previous-element-index)\n          new-previous-element\n            (cond (= e :indent) [(str \"\\n\" (blanks new-spaces)) c e]\n                  (= e :whitespace) [(str (blanks new-spaces)) c e 26]\n                  :else (throw\n                          (#?(:clj Exception.\n                              :cljs js/Error.)\n                           (str\n                             \"change-start-column: comment preceded by neither\"\n                             \" an :indent nor :whitespace!\"\n                             e))))]\n      (assoc style-vec previous-element-index new-previous-element))))\n\n(defn align-comment-vec\n  \"Given one set of inline comments: \n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], align them \n   as best as possible, and return the modified style-vec.\"\n  [style-vec comment-vec]\n  (let [minimum-col (minimum-column comment-vec)]\n    (reduce (partial change-start-column minimum-col) style-vec comment-vec)))\n\n(defn fzprint-align-inline-comments\n  \"Given the current style-vec, align all inline comments.\"\n  [options style-vec]\n  (dbg-s options\n         #{:align-inline}\n         \"fzprint-align-inline-comments: style-vec:\"\n         ((:dzprint options)\n           {:vector {:wrap? false, :indent 1}}\n           (map-indexed (fn [a b] (vector a b)) style-vec)\n           #_style-vec))\n  (let [style (:inline-align-style (:comment options))]\n    (if (= style :none)\n      style-vec\n      (let [comment-vec\n              (cond (= style :aligned) (find-aligned-inline-comments style-vec)\n                    (= style :consecutive)\n                      (find-consecutive-inline-comments options style-vec))\n            _ (dbg-s options\n                     #{:align-inline}\n                     \"fzprint-align-inline-comments: comment-vec:\"\n                     comment-vec)\n            comment-vec-column (comment-vec-all-column style-vec comment-vec)]\n        (reduce align-comment-vec style-vec comment-vec-column)))))\n\n"],"x_google_ignoreList":[0]}