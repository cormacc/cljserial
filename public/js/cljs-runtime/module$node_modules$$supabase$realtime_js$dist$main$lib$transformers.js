shadow$provide.module$node_modules$$supabase$realtime_js$dist$main$lib$transformers = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.httpEndpointURL = exports.toTimestampString = exports.toArray = exports.toJson = exports.toNumber = exports.toBoolean = exports.convertCell = exports.convertColumn = exports.convertChangeData = exports.PostgresTypes = void 0;
  var PostgresTypes;
  (function(PostgresTypes) {
    PostgresTypes.abstime = "abstime";
    PostgresTypes.bool = "bool";
    PostgresTypes.date = "date";
    PostgresTypes.daterange = "daterange";
    PostgresTypes.float4 = "float4";
    PostgresTypes.float8 = "float8";
    PostgresTypes.int2 = "int2";
    PostgresTypes.int4 = "int4";
    PostgresTypes.int4range = "int4range";
    PostgresTypes.int8 = "int8";
    PostgresTypes.int8range = "int8range";
    PostgresTypes.json = "json";
    PostgresTypes.jsonb = "jsonb";
    PostgresTypes.money = "money";
    PostgresTypes.numeric = "numeric";
    PostgresTypes.oid = "oid";
    PostgresTypes.reltime = "reltime";
    PostgresTypes.text = "text";
    PostgresTypes.time = "time";
    PostgresTypes.timestamp = "timestamp";
    PostgresTypes.timestamptz = "timestamptz";
    PostgresTypes.timetz = "timetz";
    PostgresTypes.tsrange = "tsrange";
    PostgresTypes.tstzrange = "tstzrange";
  })(PostgresTypes = exports.PostgresTypes || (exports.PostgresTypes = {}));
  exports.convertChangeData = (columns, record, options = {}) => {
    var _a;
    const skipTypes = null !== (_a = options.skipTypes) && void 0 !== _a ? _a : [];
    return Object.keys(record).reduce((acc, rec_key) => {
      acc[rec_key] = (0,exports.convertColumn)(rec_key, columns, record, skipTypes);
      return acc;
    }, {});
  };
  exports.convertColumn = (columnName, columns, record, skipTypes) => {
    columns = columns.find(x => x.name === columnName);
    columns = null === columns || void 0 === columns ? void 0 : columns.type;
    record = record[columnName];
    return columns && !skipTypes.includes(columns) ? (0,exports.convertCell)(columns, record) : record;
  };
  exports.convertCell = (type, value) => {
    if ("_" === type.charAt(0)) {
      return type = type.slice(1, type.length), (0,exports.toArray)(value, type);
    }
    switch(type) {
      case PostgresTypes.bool:
        return (0,exports.toBoolean)(value);
      case PostgresTypes.float4:
      case PostgresTypes.float8:
      case PostgresTypes.int2:
      case PostgresTypes.int4:
      case PostgresTypes.int8:
      case PostgresTypes.numeric:
      case PostgresTypes.oid:
        return (0,exports.toNumber)(value);
      case PostgresTypes.json:
      case PostgresTypes.jsonb:
        return (0,exports.toJson)(value);
      case PostgresTypes.timestamp:
        return (0,exports.toTimestampString)(value);
      case PostgresTypes.abstime:
      case PostgresTypes.date:
      case PostgresTypes.daterange:
      case PostgresTypes.int4range:
      case PostgresTypes.int8range:
      case PostgresTypes.money:
      case PostgresTypes.reltime:
      case PostgresTypes.text:
      case PostgresTypes.time:
      case PostgresTypes.timestamptz:
      case PostgresTypes.timetz:
      case PostgresTypes.tsrange:
      case PostgresTypes.tstzrange:
        return value;
      default:
        return value;
    }
  };
  exports.toBoolean = value => {
    switch(value) {
      case "t":
        return !0;
      case "f":
        return !1;
      default:
        return value;
    }
  };
  exports.toNumber = value => {
    if ("string" === typeof value) {
      const parsedValue = parseFloat(value);
      if (!Number.isNaN(parsedValue)) {
        return parsedValue;
      }
    }
    return value;
  };
  exports.toJson = value => {
    if ("string" === typeof value) {
      try {
        return JSON.parse(value);
      } catch (error) {
        console.log(`JSON parse error: ${error}`);
      }
    }
    return value;
  };
  exports.toArray = (value, type) => {
    if ("string" !== typeof value) {
      return value;
    }
    const lastIdx = value.length - 1, closeBrace = value[lastIdx];
    if ("{" === value[0] && "}" === closeBrace) {
      let arr;
      value = value.slice(1, lastIdx);
      try {
        arr = JSON.parse("[" + value + "]");
      } catch (_) {
        arr = value ? value.split(",") : [];
      }
      return arr.map(val => (0,exports.convertCell)(type, val));
    }
    return value;
  };
  exports.toTimestampString = value => "string" === typeof value ? value.replace(" ", "T") : value;
  exports.httpEndpointURL = socketUrl => {
    socketUrl = socketUrl.replace(/^ws/i, "http");
    socketUrl = socketUrl.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, "");
    return socketUrl.replace(/\/+$/, "");
  };
};

//# sourceMappingURL=module$node_modules$$supabase$realtime_js$dist$main$lib$transformers.js.map
