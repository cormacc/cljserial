shadow$provide.module$node_modules$$supabase$postgrest_js$dist$cjs$PostgrestQueryBuilder = function(global, require, module, exports) {
  global = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {"default":mod};
  };
  Object.defineProperty(exports, "__esModule", {value:!0});
  const PostgrestFilterBuilder_1 = global(require("module$node_modules$$supabase$postgrest_js$dist$cjs$PostgrestFilterBuilder"));
  class PostgrestQueryBuilder {
    constructor(url, {headers = {}, schema, fetch}) {
      this.url = url;
      this.headers = headers;
      this.schema = schema;
      this.fetch = fetch;
    }
    select(columns, {head = !1, count} = {}) {
      head = head ? "HEAD" : "GET";
      let quoted = !1;
      columns = (null !== columns && void 0 !== columns ? columns : "*").split("").map(c => {
        if (/\s/.test(c) && !quoted) {
          return "";
        }
        '"' === c && (quoted = !quoted);
        return c;
      }).join("");
      this.url.searchParams.set("select", columns);
      count && (this.headers.Prefer = `count=${count}`);
      return new PostgrestFilterBuilder_1.default({method:head, url:this.url, headers:this.headers, schema:this.schema, fetch:this.fetch, allowEmpty:!1});
    }
    insert(values, {count, defaultToNull = !0} = {}) {
      const prefersHeaders = [];
      this.headers.Prefer && prefersHeaders.push(this.headers.Prefer);
      count && prefersHeaders.push(`count=${count}`);
      defaultToNull || prefersHeaders.push("missing\x3ddefault");
      this.headers.Prefer = prefersHeaders.join(",");
      Array.isArray(values) && (count = values.reduce((acc, x) => acc.concat(Object.keys(x)), []), 0 < count.length && (count = [...(new Set(count))].map(column => `"${column}"`), this.url.searchParams.set("columns", count.join(","))));
      return new PostgrestFilterBuilder_1.default({method:"POST", url:this.url, headers:this.headers, schema:this.schema, body:values, fetch:this.fetch, allowEmpty:!1});
    }
    upsert(values, {onConflict, ignoreDuplicates = !1, count, defaultToNull = !0} = {}) {
      ignoreDuplicates = [`resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`];
      void 0 !== onConflict && this.url.searchParams.set("on_conflict", onConflict);
      this.headers.Prefer && ignoreDuplicates.push(this.headers.Prefer);
      count && ignoreDuplicates.push(`count=${count}`);
      defaultToNull || ignoreDuplicates.push("missing\x3ddefault");
      this.headers.Prefer = ignoreDuplicates.join(",");
      Array.isArray(values) && (onConflict = values.reduce((acc, x) => acc.concat(Object.keys(x)), []), 0 < onConflict.length && (onConflict = [...(new Set(onConflict))].map(column => `"${column}"`), this.url.searchParams.set("columns", onConflict.join(","))));
      return new PostgrestFilterBuilder_1.default({method:"POST", url:this.url, headers:this.headers, schema:this.schema, body:values, fetch:this.fetch, allowEmpty:!1});
    }
    update(values, {count} = {}) {
      const prefersHeaders = [];
      this.headers.Prefer && prefersHeaders.push(this.headers.Prefer);
      count && prefersHeaders.push(`count=${count}`);
      this.headers.Prefer = prefersHeaders.join(",");
      return new PostgrestFilterBuilder_1.default({method:"PATCH", url:this.url, headers:this.headers, schema:this.schema, body:values, fetch:this.fetch, allowEmpty:!1});
    }
    delete({count} = {}) {
      const prefersHeaders = [];
      count && prefersHeaders.push(`count=${count}`);
      this.headers.Prefer && prefersHeaders.unshift(this.headers.Prefer);
      this.headers.Prefer = prefersHeaders.join(",");
      return new PostgrestFilterBuilder_1.default({method:"DELETE", url:this.url, headers:this.headers, schema:this.schema, fetch:this.fetch, allowEmpty:!1});
    }
  }
  exports.default = PostgrestQueryBuilder;
};

//# sourceMappingURL=module$node_modules$$supabase$postgrest_js$dist$cjs$PostgrestQueryBuilder.js.map
