shadow$provide.module$node_modules$$supabase$realtime_js$dist$main$RealtimePresence = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.REALTIME_PRESENCE_LISTEN_EVENTS = void 0;
  (function(REALTIME_PRESENCE_LISTEN_EVENTS) {
    REALTIME_PRESENCE_LISTEN_EVENTS.SYNC = "sync";
    REALTIME_PRESENCE_LISTEN_EVENTS.JOIN = "join";
    REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE = "leave";
  })(exports.REALTIME_PRESENCE_LISTEN_EVENTS || (exports.REALTIME_PRESENCE_LISTEN_EVENTS = {}));
  class RealtimePresence {
    constructor(channel, opts) {
      this.channel = channel;
      this.state = {};
      this.pendingDiffs = [];
      this.joinRef = null;
      this.caller = {onJoin:() => {
      }, onLeave:() => {
      }, onSync:() => {
      }};
      channel = (null === opts || void 0 === opts ? void 0 : opts.events) || {state:"presence_state", diff:"presence_diff"};
      this.channel._on(channel.state, {}, newState => {
        const {onJoin, onLeave, onSync} = this.caller;
        this.joinRef = this.channel._joinRef();
        this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
        this.pendingDiffs.forEach(diff => {
          this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
        });
        this.pendingDiffs = [];
        onSync();
      });
      this.channel._on(channel.diff, {}, diff => {
        const {onJoin, onLeave, onSync} = this.caller;
        this.inPendingSyncState() ? this.pendingDiffs.push(diff) : (this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave), onSync());
      });
      this.onJoin((key, currentPresences, newPresences) => {
        this.channel._trigger("presence", {event:"join", key, currentPresences, newPresences});
      });
      this.onLeave((key, currentPresences, leftPresences) => {
        this.channel._trigger("presence", {event:"leave", key, currentPresences, leftPresences});
      });
      this.onSync(() => {
        this.channel._trigger("presence", {event:"sync"});
      });
    }
    static syncState(currentState, newState, onJoin, onLeave) {
      const state = this.cloneDeep(currentState), transformedState = this.transformState(newState), joins = {}, leaves = {};
      this.map(state, (key, presences) => {
        transformedState[key] || (leaves[key] = presences);
      });
      this.map(transformedState, (key, newPresences) => {
        var currentPresences = state[key];
        if (currentPresences) {
          const newPresenceRefs = newPresences.map(m => m.presence_ref), curPresenceRefs = currentPresences.map(m => m.presence_ref);
          newPresences = newPresences.filter(m => 0 > curPresenceRefs.indexOf(m.presence_ref));
          currentPresences = currentPresences.filter(m => 0 > newPresenceRefs.indexOf(m.presence_ref));
          0 < newPresences.length && (joins[key] = newPresences);
          0 < currentPresences.length && (leaves[key] = currentPresences);
        } else {
          joins[key] = newPresences;
        }
      });
      return this.syncDiff(state, {joins, leaves}, onJoin, onLeave);
    }
    static syncDiff(state, diff, onJoin, onLeave) {
      const {joins, leaves} = {joins:this.transformState(diff.joins), leaves:this.transformState(diff.leaves)};
      onJoin || (onJoin = () => {
      });
      onLeave || (onLeave = () => {
      });
      this.map(joins, (key, newPresences) => {
        var _a;
        const currentPresences = null !== (_a = state[key]) && void 0 !== _a ? _a : [];
        state[key] = this.cloneDeep(newPresences);
        if (0 < currentPresences.length) {
          const joinedPresenceRefs = state[key].map(m => m.presence_ref);
          _a = currentPresences.filter(m => 0 > joinedPresenceRefs.indexOf(m.presence_ref));
          state[key].unshift(..._a);
        }
        onJoin(key, currentPresences, newPresences);
      });
      this.map(leaves, (key, leftPresences) => {
        let currentPresences = state[key];
        if (currentPresences) {
          var presenceRefsToRemove = leftPresences.map(m => m.presence_ref);
          currentPresences = currentPresences.filter(m => 0 > presenceRefsToRemove.indexOf(m.presence_ref));
          state[key] = currentPresences;
          onLeave(key, currentPresences, leftPresences);
          0 === currentPresences.length && delete state[key];
        }
      });
      return state;
    }
    static map(obj, func) {
      return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]));
    }
    static transformState(state) {
      state = this.cloneDeep(state);
      return Object.getOwnPropertyNames(state).reduce((newState, key) => {
        const presences = state[key];
        newState[key] = "metas" in presences ? presences.metas.map(presence => {
          presence.presence_ref = presence.phx_ref;
          delete presence.phx_ref;
          delete presence.phx_ref_prev;
          return presence;
        }) : presences;
        return newState;
      }, {});
    }
    static cloneDeep(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    onJoin(callback) {
      this.caller.onJoin = callback;
    }
    onLeave(callback) {
      this.caller.onLeave = callback;
    }
    onSync(callback) {
      this.caller.onSync = callback;
    }
    inPendingSyncState() {
      return !this.joinRef || this.joinRef !== this.channel._joinRef();
    }
  }
  exports.default = RealtimePresence;
};

//# sourceMappingURL=module$node_modules$$supabase$realtime_js$dist$main$RealtimePresence.js.map
