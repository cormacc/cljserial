shadow$provide.module$node_modules$$supabase$postgrest_js$dist$cjs$PostgrestBuilder = function(global, require, module, exports) {
  global = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {"default":mod};
  };
  Object.defineProperty(exports, "__esModule", {value:!0});
  const node_fetch_1 = global(require("module$node_modules$$supabase$node_fetch$browser")), PostgrestError_1 = global(require("module$node_modules$$supabase$postgrest_js$dist$cjs$PostgrestError"));
  class PostgrestBuilder {
    constructor(builder) {
      this.shouldThrowOnError = !1;
      this.method = builder.method;
      this.url = builder.url;
      this.headers = builder.headers;
      this.schema = builder.schema;
      this.body = builder.body;
      this.shouldThrowOnError = builder.shouldThrowOnError;
      this.signal = builder.signal;
      this.isMaybeSingle = builder.isMaybeSingle;
      this.fetch = builder.fetch ? builder.fetch : "undefined" === typeof fetch ? node_fetch_1.default : fetch;
    }
    throwOnError() {
      this.shouldThrowOnError = !0;
      return this;
    }
    setHeader(name, value) {
      this.headers = Object.assign({}, this.headers);
      this.headers[name] = value;
      return this;
    }
    then(onfulfilled, onrejected) {
      void 0 !== this.schema && (["GET", "HEAD"].includes(this.method) ? this.headers["Accept-Profile"] = this.schema : this.headers["Content-Profile"] = this.schema);
      "GET" !== this.method && "HEAD" !== this.method && (this.headers["Content-Type"] = "application/json");
      var _fetch = this.fetch;
      _fetch = _fetch(this.url.toString(), {method:this.method, headers:this.headers, body:JSON.stringify(this.body), signal:this.signal}).then(async res => {
        var _a, _b;
        let error = null, data = null, count = null, status = res.status, statusText = res.statusText;
        if (res.ok) {
          if ("HEAD" !== this.method) {
            var _c = await res.text();
            "" !== _c && (data = "text/csv" === this.headers.Accept ? _c : this.headers.Accept && this.headers.Accept.includes("application/vnd.pgrst.plan+text") ? _c : JSON.parse(_c));
          }
          _c = null === (_a = this.headers.Prefer) || void 0 === _a ? void 0 : _a.match(/count=(exact|planned|estimated)/);
          res = null === (_b = res.headers.get("content-range")) || void 0 === _b ? void 0 : _b.split("/");
          _c && res && 1 < res.length && (count = parseInt(res[1]));
          this.isMaybeSingle && "GET" === this.method && Array.isArray(data) && (1 < data.length ? (error = {code:"PGRST116", details:`Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`, hint:null, message:"JSON object requested, multiple (or no) rows returned"}, count = data = null, status = 406, statusText = "Not Acceptable") : data = 1 === data.length ? data[0] : null);
        } else {
          _b = await res.text();
          try {
            error = JSON.parse(_b), Array.isArray(error) && 404 === res.status && (data = [], error = null, status = 200, statusText = "OK");
          } catch (_d) {
            404 === res.status && "" === _b ? (status = 204, statusText = "No Content") : error = {message:_b};
          }
          error && this.isMaybeSingle && (null === (_c = null === error || void 0 === error ? void 0 : error.details) || void 0 === _c ? 0 : _c.includes("0 rows")) && (error = null, status = 200, statusText = "OK");
          if (error && this.shouldThrowOnError) {
            throw new PostgrestError_1.default(error);
          }
        }
        return {error, data, count, status, statusText};
      });
      this.shouldThrowOnError || (_fetch = _fetch.catch(fetchError => {
        var _a, _b, _c;
        return {error:{message:`${null !== (_a = null === fetchError || void 0 === fetchError ? void 0 : fetchError.name) && void 0 !== _a ? _a : "FetchError"}: ${null === fetchError || void 0 === fetchError ? void 0 : fetchError.message}`, details:`${null !== (_b = null === fetchError || void 0 === fetchError ? void 0 : fetchError.stack) && void 0 !== _b ? _b : ""}`, hint:"", code:`${null !== (_c = null === fetchError || void 0 === fetchError ? void 0 : fetchError.code) && void 0 !== _c ? _c : ""}`}, 
        data:null, count:null, status:0, statusText:""};
      }));
      return _fetch.then(onfulfilled, onrejected);
    }
  }
  exports.default = PostgrestBuilder;
};

//# sourceMappingURL=module$node_modules$$supabase$postgrest_js$dist$cjs$PostgrestBuilder.js.map
