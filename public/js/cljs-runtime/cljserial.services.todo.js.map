{"version":3,"sources":["cljserial/services/todo.cljs"],"mappings":";AAQA,mCAAA,nCAAKA;AAOL,iCAAA,jCAAKC;AAEL,+BAAA,mFAAA,mDAAA,mFAAA,yFAAA,mFAAA,oEAAA,mFAAA,0DAAA,2CAAA,kDAAA,4BAAA,mFAAA,qDAAA,t3BAAKC,0SAEGD;AAIR,kCAAA,mFAAA,rHAAKE,8KACMF,+BAAOC;AAElB,qCAAA,mFAAA,qDAAA,kDAAA,2DAAA,1RAAKE;AAEL,oCAAA,mFAAA,mDAAA,mFAAA,6DAAA,kEAAA,mFAAA,gGAAA,mFAAA,loBAAKC,ugBAGMF,8LACMC;AAEjB;;;yCAAA,zCAAMI,0FAEHC;AAFH,AAAA,oBAGSC;AAHT;AAAA,AAAA,MAAA,KAAAJ,MAAA;;;AAAA,GAGoBK;AAHpB;AAAA,AAAA,MAAA,KAAAL,MAAA;;;AAAA,oBAG4BG;AAH5B;AAAA,AAAA,MAAA,KAAAH,MAAA;;;AAAA,IAAAC,YAAA,2CAAA,sEAAA,+EAAA,mEAAA,3JAKaE,iEACH,AAACG;AANX,AAAA,oBAIUF;AAJV;AAAA,AAAA,MAAA,KAAAJ,MAAA;;;AAAA,oBAIqBD;AAJrB;AAAA,AAAA,MAAA,KAAAC,MAAA;;;AAAA,oBAI+BC;AAJ/B;AAAA,AAAA,MAAA,KAAAD,MAAA;;;AAAAC;;AAoDA,AAAKM,mDAAyB,AAACC,8CAA8BX;AAa7D,AAAKY,yDAA+B,AAACC,+CAA+BhB;AAapE,iDAAA,jDAAKiB,oIACF,iBAAAC,WAAA,mFAAA,8DAAA;AAAA,AAAA,0HAAAA,iDAAAA,nKAACC,0DAAAA,oEAAAA;KACDN,iDACAE;AASH;;;;;2CAAA,3CAAMK,8FAIHC;AAJH,AAKE,OAAC,2DAAA,3DAACC,6CAAKC,mBAAO,AAACC,eAAK,AAACC,eAAKJ;;AAK5B,IAAAK,iBAAA;IAAAC,iBAOC,cAAAE,HAAKG;AAAL,AAAA,IAAAF,aAAAD;QAAA,AAAAE,4CAAAD,WAAA,IAAA,/DAASG;oBAAT,AAAAF,4CAAAD,WAAA,IAAA,3EAAWI;AAAX,AACE,6BAAA,mFAAA,8DAAA,vKAACC,mBAASH,+NAA6BE;;AAR1C,AAAA,mIAAAR,eAAAC,+DAAAD,eAAAC,/NAACC,kEAAAA,iGAAAA;AA0CD,IAAAQ,iBAAA;IAAAC,iBAMCpB;IANDqB,iBAcC,iBAAAC,NAAKlB;AAAL,AAAA,IAAAmB,aAAAD;QAAA,AAAAR,4CAAAS,WAAA,IAAA,/DAAYP;WAAZ,AAAAF,4CAAAS,WAAA,IAAA,lEAAcC;AAAd,AACE,GAAAC;AAAA,AAAA,AAAAC,qDAAA,0BAAA,wDAAA,AAAAC,mBAAA,2CAAA,8DAAA,oDAAA,aAAA,tEAAqBH;;AAArB;;AACA,IAAMI,KAAG,AAACzB,yCAAiBC;AAA3B,AACE,8DAAA,2CAAA,qDAAA,yEAAA,qDAAA,rRAACyB,8CAAMzB,MAAMwB,gGAAQA,uEAAgBJ;;AAjB1C,AAAA,mIAAAL,eAAAC,eAAAC,+DAAAF,eAAAC,eAAAC,7PAACV,kEAAAA,gHAAAA;AAoBD,IAAAmB,iBAAA;IAAAC,iBAEC/B;IAFDgC,iBAGC,iBAAAC,NAAK7B;AAAL,AAAA,IAAA8B,aAAAD;QAAA,AAAAnB,4CAAAoB,WAAA,IAAA,/DAAYlB;SAAZ,AAAAF,4CAAAoB,WAAA,IAAA,hEAAcN;AAAd,AACE,+DAAA,sFAAA,9IAACO,kDAAU/B,yFAAOwB,gEAAUQ;;AAJ/B,AAAA,mIAAAN,eAAAC,eAAAC,+DAAAF,eAAAC,eAAAC,7PAACrB,kEAAAA,gHAAAA;AAOD,IAAA0B,iBAAA;IAAAC,iBAECtC;IAFDuC,iBAGC,iBAAAC,NAAKpC;AAAL,AAAA,IAAAqC,aAAAD;QAAA,AAAA1B,4CAAA2B,WAAA,IAAA,/DAAYzB;SAAZ,AAAAF,4CAAA2B,WAAA,IAAA,hEAAcb;YAAd,AAAAd,4CAAA2B,WAAA,IAAA,nEAAiBC;AAAjB,AACE,gCAAA,sFAAA,/GAACxB,mBAASd,yFAAOwB,+EAAiBc;;AAJrC,AAAA,mIAAAL,eAAAC,eAAAC,+DAAAF,eAAAC,eAAAC,7PAAC5B,kEAAAA,gHAAAA;AAOD,IAAAgC,iBAAA;IAAAC,iBAEC5C;IAFD6C,iBAGC,iBAAAC,NAAK1C;AAAL,AAAA,IAAA2C,aAAAD;QAAA,AAAAhC,4CAAAiC,WAAA,IAAA,/DAAY/B;SAAZ,AAAAF,4CAAAiC,WAAA,IAAA,hEAAcnB;AAAd,AACE,OAACoB,+CAAO5C,MAAMwB;;AAJjB,AAAA,mIAAAe,eAAAC,eAAAC,+DAAAF,eAAAC,eAAAC,7PAAClC,kEAAAA,gHAAAA;AAuBD,IAAAsC,iBAAA;IAAAC,iBAEC,WAAKnC,GAAGC;AAAR,AACE,OAAA,4FAAYD;;AAHf,AAAA,yHAAAkC,eAAAC,0DAAAD,eAAAC,hNAACC,6DAAAA,4FAAAA;AAqCD,IAAAC,iBAAA;IAAAC,iBAAA;IAAAC,iBAAA,mFAAA;IAAAC,iBAGC,WAAKC,UAAUxC;AAAf,AACE,OAAA,iGAAcwC;;AAJjB,AAAA,yHAAAJ,eAAAC,eAAAC,eAAAC,0DAAAH,eAAAC,eAAAC,eAAAC,5QAACJ,6DAAAA,0HAAAA","names":["cljserial.services.todo/store-id","cljserial.services.todo/TaskId","cljserial.services.todo/Task","cljserial.services.todo/TaskMap","cljserial.services.todo/TaskFilter","cljserial.services.todo/TaskStore","js/Error","%","cljserial.services.todo/new-task-store","store-id","malli.core/validate","cljs.core/string?","cljs.core/sorted-map","cljserial.services.todo/schema-check-interceptor","cljserial.utils.dbfx/schema-check-interceptor","cljserial.services.todo/todo-browser-cache-interceptor","cljserial.utils.dbfx/browser-cache-interceptor","cljserial.services.todo/todo-task-interceptors","G__56000","cljserial.utils.dbfx/path","cljserial.services.todo/allocate-next-id","todos","cljs.core.fnil","cljs.core/inc","cljs.core/last","cljs.core/keys","G__56005","G__56006","cljserial.utils.dbfx/reg-event-db","p__56009","vec__56010","cljs.core.nth","db","_","new-filter-kw","cljs.core/assoc-in","G__56014","G__56015","G__56016","p__56018","vec__56019","text","js/goog.debug.LOGGING_ENABLED","lambdaisland.glogi.log","cljs.core/identity","id","cljs.core.assoc","G__56023","G__56024","G__56025","p__56026","vec__56027","cljs.core.update_in","cljs.core/not","G__56030","G__56031","G__56032","p__56033","vec__56035","title","G__56039","G__56040","G__56041","p__56042","vec__56043","cljs.core.dissoc","G__56046","G__56047","cljserial.utils.dbfx/reg-sub","G__56048","G__56049","G__56050","G__56051","todo-data"],"sourcesContent":["(ns cljserial.services.todo\n  (:require\n   [lambdaisland.glogi :as log]\n   [malli.core :as m]\n   [cljserial.utils.dbfx :as dbfx :refer [reg-event-db reg-sub path]]))\n\n\n\n(def store-id \"todos-refx\")                         ;; localstore key\n\n\n;; -------------------------------------------------------------------------------------\n;; -------------------------------------------------------------------------------------\n;; SCHEMA (malli)\n\n(def TaskId :int)\n\n(def Task\n  [:map\n   [:id TaskId]\n   [:description [:string {:min 1}]]\n   [:done :boolean]])\n\n(def TaskMap\n  [:map-of TaskId Task])\n\n(def TaskFilter [:enum :all :pending :done])\n\n(def TaskStore\n  [:map\n   [:store-id :string]\n   [:tasks TaskMap]\n   [:task-filter TaskFilter]])\n\n(defn new-task-store\n  \"Generate a new empty TaskStore with the provided `store-id`\"\n  [store-id]\n  {:pre [m/validate string? store-id]\n   :post [m/validate TaskStore %]}\n  {:store-id store-id\n   :tasks (sorted-map)\n   :task-filter :all})\n\n;; -------------------------------------------------------------------------------------\n;; -------------------------------------------------------------------------------------\n;; INTERCEPTORS\n;;\n;; Interceptors are a more advanced topic. So, we're plunging into the deep\n;; end here.\n;;\n;; There is a tutorial on Interceptors in re-frame's `/docs`, but to get\n;; you going fast, here's a very high level description ...\n;;\n;; Every event handler can be \"wrapped\" in a chain of interceptors. A\n;; \"chain of interceptors\" is actually just a \"vector of interceptors\". Each\n;; of these interceptors can have a `:before` function and an `:after` function.\n;; Each interceptor wraps around the \"handler\", so that its `:before`\n;; is called before the event handler runs, and its `:after` runs after\n;; the event handler has run.\n;;\n;; Interceptors with a `:before` action, can be used to \"inject\" values\n;; into what will become the `coeffects` parameter of an event handler.\n;; That's a way of giving an event handler access to certain resources,\n;; like values in LocalStore.\n;;\n;; Interceptors with an `:after` action, can, among other things,\n;; process the effects produced by the event handler. One could\n;; check if the new value for `app-db` correctly matches a Spec.\n;;\n\n;; -- First Interceptor ------------------------------------------------------\n;;\n;; Event handlers change state, that's their job. But what happens if there's\n;; a bug in the event handler and it corrupts application state in some subtle way?\n;; Next, we create an interceptor called `schema-check-interceptor`.\n;; Later, we use this interceptor in the interceptor chain of all event handlers.\n;; When included in the interceptor chain of an event handler, this interceptor\n;; runs `check-and-throw` `after` the event handler has finished, checking\n;; the value for `app-db` against a spec.\n;; If the event handler corrupted the value for `app-db` an exception will be\n;; thrown. This helps us detect event handler bugs early.\n;; Because all state is held in `app-db`, we are effectively validating the\n;; ENTIRE state of the application after each event handler runs.  All of it.\n\n\n;; now we create an interceptor using `after`\n(def schema-check-interceptor (dbfx/schema-check-interceptor TaskMap))\n\n\n\n;; -- Second Interceptor -----------------------------------------------------\n;;\n;; Part of the TodoMVC challenge is to store todos in local storage.\n;; Next, we define an interceptor to help with this challenge.\n;; This interceptor runs `after` an event handler, and it stores the\n;; current todos into local storage.\n;; Later, we include this interceptor into the interceptor chain\n;; of all event handlers which modify todos.  In this way, we ensure that\n;; every change to todos is written to local storage.\n(def todo-browser-cache-interceptor (dbfx/browser-cache-interceptor store-id))\n\n\n\n;; -- Interceptor Chain ------------------------------------------------------\n;;\n;; Each event handler can have its own chain of interceptors.\n;; We now create the interceptor chain shared by all event handlers\n;; which manipulate todos.\n;; A chain of interceptors is a vector of interceptors.\n;; The initial `path` interceptor ensures that the value passed to subsequent interceptors\n;; including the event handler will be the value from that path within the db rather than entire\n;; db, and the returned value will be interpreted in the same way (i.e. treated as an `assoc-in` operation)\n(def todo-task-interceptors\n  [(path [:todo-data :tasks])      ;; Extract the data of interest\n   schema-check-interceptor        ;; ensure the spec is still valid  (after)\n   todo-browser-cache-interceptor]);; write todos to localstore  (after)\n\n\n;; -------------------------------------------------------------------------------------\n;; -------------------------------------------------------------------------------------\n;; EVENTS\n\n;; -- Helpers -----------------------------------------------------------------\n\n(defn allocate-next-id\n  \"Returns the next todo id.\n  Assumes todos are sorted.\n  Returns one more than the current largest id.\"\n  [todos]\n  ((fnil inc 0) (last (keys todos))))\n\n;; -- Event Handlers -----------------------------------------------------------------\n\n;; usage:  (dispatch [:apply-todo-filter  :pending])\n(reg-event-db      ;; part of the re-frame API\n :apply-todo-filter     ;; event-id\n\n  ;; only one interceptor\n ;; [schema-check-interceptor]       ;; after event handler runs, check app-db for correctness. Does it still match Spec?\n\n  ;; handler\n (fn [db [_ new-filter-kw]]     ;; new-filter-kw is one of :all, :active or :done\n   (assoc-in db [:todo-data :task-filter] new-filter-kw)))\n\n;; NOTE: below is a rewrite of the event handler (above) using a `path` Interceptor\n;; You'll find it illuminating to compare this rewrite with the original.\n;;\n;; A `path` interceptor has BOTH a before and after action.\n;; When you create one, you supply \"a path\" into `app-db`, like:\n;; [:a :b 1]\n;; The job of \"before\" is to replace the app-db with the value\n;; of `app-db` at the nominated path. And, then, \"after\" to\n;; take the event handler returned value and place it back into\n;; app-db at the nominated path.  So the event handler works\n;; with a particular, narrower path within app-db, not all of it.\n;;\n;; So, `path` operates a little like `update-in`\n;;\n#_(reg-event-db\n   :apply-todo-filter\n\n  ;; this now a chain of 2 interceptors. Note use of `path`\n   [schema-check-interceptor\n    (path :todo-data :task-filter)]\n\n  ;; The event handler\n  ;; Because of the `path` interceptor above, the 1st parameter to\n  ;; the handler below won't be the entire 'db', and instead will\n  ;; be the value at the path `[:task-filter]` within db.\n  ;; Equally the value returned will be the new value for that path\n  ;; within app-db.\n   (fn [old-task-filter-value [_ new-task-filter-value]]\n     new-task-filter-value))                  ;; return new state for the path\n\n\n;; usage:  (dispatch [:add-todo  \"a description string\"])\n(reg-event-db                     ;; given the text, create a new todo\n :add-todo\n\n  ;; Use the standard interceptors, defined above, which we\n  ;; use for all todos-modifying event handlers. Looks after\n  ;; writing todos to LocalStore, etc.\n todo-task-interceptors\n\n  ;; The event handler function.\n  ;; The \"path\" interceptor in `todo-task-interceptors` means 1st parameter is the\n  ;; value at `:tasks` path within `db`, rather than the full `db`.\n  ;; And, further, it means the event handler returns just the value to be\n  ;; put into the `[:tasks]` path, and not the entire `db`.\n  ;; So, again, a path interceptor acts like clojure's `update-in`\n (fn [todos [_ text]]\n   (log/debug :todo/add text)\n   (let [id (allocate-next-id todos)]\n     (assoc todos id {:id id :description text :done false}))))\n\n\n(reg-event-db\n :toggle-todo\n todo-task-interceptors\n (fn [todos [_ id]]\n   (update-in todos [id :done] not)))\n\n\n(reg-event-db\n :save-todo\n todo-task-interceptors\n (fn [todos [_ id title]]\n   (assoc-in todos [id :description] title)))\n\n\n(reg-event-db\n :delete-todo\n todo-task-interceptors\n (fn [todos [_ id]]\n   (dissoc todos id)))\n\n\n;; -------------------------------------------------------------------------------------\n;; -------------------------------------------------------------------------------------\n;; SUBSCRIPTIONS\n\n;; -------------------------------------------------------------------------------------\n;; Layer 2\n;;\n;; See https://day8.github.io/re-frame/subscriptions/\n;;\n;; Layer 2 query functions are \"extractors\". They take from `app-db`\n;; and don't do any further computation on the extracted values. Any further\n;; computation should happen in Layer 3.\n;; Why?  It is an efficiency thing. Every Layer 2 subscription will rerun any time\n;; that `app-db` changes (in any way). As a result, we want Layer 2 to be trivial.\n;;\n\n(reg-sub\n :todo-data          ;; usage:   (use-sub [:task-filter])\n (fn [db _]        ;; db is the (map) value stored in the app-db atom\n   (:todo-data db))) ;; extract a value from the application state\n\n;; -------------------------------------------------------------------------------------\n;; Layer 3\n;;\n;; See https://day8.github.io/re-frame/subscriptions/\n;;\n;; A subscription handler is a function which is re-run when its input signals\n;; change. Each time it is rerun, it produces a new output (return value).\n;;\n;; In the simple case, app-db is the only input signal, as was the case in the two\n;; simple subscriptions above. But many subscriptions are not directly dependent on\n;; app-db, and instead, depend on a value derived from app-db.\n;;\n;; Such handlers represent \"intermediate nodes\" in a signal graph.  New values emanate\n;; from app-db, and flow out through a signal graph, into and out of these intermediate\n;; nodes, before a leaf subscription delivers data into views which render data as hiccup.\n;;\n;; When writing and registering the handler for an intermediate node, you must nominate\n;; one or more input signals (typically one or two).\n;;\n;; reg-sub allows you to supply:\n;;\n;;   1. a function which returns the input signals. It can return either a single signal or\n;;      a vector of signals, or a map where the values are the signals.\n;;\n;;   2. a function which does the computation. It takes input values and produces a new\n;;      derived value.\n;;\n;; In the two simple examples at the top, we only supplied the 2nd of these functions.\n;; But now we are dealing with intermediate (layer 3) nodes, we'll need to provide both fns.\n;;\n\n\n(reg-sub\n :task-filter          ;; usage:   (use-sub [:task-filter])\n :<- [:todo-data]\n (fn [todo-data _]        ;; db is the (map) value stored in the app-db atom\n   (:task-filter todo-data))) ;; extract a value from the application state\n"]}