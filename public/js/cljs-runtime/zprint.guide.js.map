{"version":3,"sources":["zprint/guide.cljc"],"mappings":"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","names":["var_args","G__66579","zprint.guide/rodguide","js/Error","rod-options","options","len","sexpr","zprint.guide.rodguide","cljs.core._EQ_","cljs.core/first","multi-arity-nl?","cljs.core.get","docstring?","cljs.core.nth","rest","cljs.core/nthnext","multi-arity?","cljs.core/vector?","cljs.core/next","rest-guide","cljs.core.repeat","cljs.core/count","cljs.core.into","and__5000__auto__","cljs.core.interleave","cljs.core.conj","guide","G__66599","option-map","cljs.core.assoc","zprint.guide/constant-or-vector?","element","cljs.core/Keyword","p__66617","vec__66618","zprint.guide/count-constants","constant-count","possible-constant?","cljs.core/not","cljs.core/reduced","G__66628","zprint.guide/moustacheguide","vec__66630","rev-sexpr","cljs.core/reverse","_","cljs.core.reduce","pair-count","pair-guide","non-pair-count","non-pair-guide","cljs.core.interpose","cljs.core.concat","cljs.core/some","cljs.core.println","zprint.guide/add-double-quotes","s","G__66643","zprint.guide/areguide","are-options","zprint.guide.areguide","justify?","max-variance","or__5002__auto__","caller-options","fexpr__66648","current-indent","are-indent","table-indent","arg-vec-len","cljs.core/second","test-len","rows","excess-tests","alignment-vec","zfn-map","zloc-seq-nc","G__66653","G__66654","fexpr__66652","cljs.core/identity","args","cljs.core.drop","arg-strs","cljs.core.mapv","seq-of-seqs","cljs.core.partition","max-width-vec","zprint.util.column_alignment","zprint.util/cumulative-alignment","mark-guide","cljs.core/vec","cljs.core/flatten","cljs.core/vector","cljs.core.range","new-row-guide","G__66657","cljs.core/empty?","multi-row-guide","cljs.core.apply","cljs.core/concat","G__66658","G__66662","zprint.guide/areguide-basic","beginning","cljs.core.take","single-row","row-guide","G__66665","G__66680","zprint.guide/jrequireguide","keyword","vectors+lists","p1__66668#","cljs.core.filter","cljs.core/list?","max-first","element-guide","vector-guide","G__66699","zprint.guide/rumguide","vec__66701","up-to-arguments","args-and-after","p1__66693#","cljs.core/split-with","lt","lt?","mixin-indent","beginning-guide","middle-element-count","middle-guide","end-element-count","end-guide","G__66718","zprint.guide/rumguide-1","vec__66721","p1__66713#","G__66730","zprint.guide/rumguide-2","vec__66735","p1__66727#","G__66755","zprint.guide/odrguide","vec__66758","vec__66761","vec__66764","vectors","beyond","alignment-guide","keyword-1","keyword-1-lists","keyword-2","keyword-2-lists","G__66768","zprint.guide/guide-arg-count","zprint.guide/guide-insert","p__66784","vec__66786","zprint.guide/handle-args","running-arg-count","command","command-arg-count","before","after","G__66791","G__66795","zprint.guide/guideguide","G__66798","G__66806","zprint.guide/defprotocolguide","vec__66809","third","fourth","fifth","docstring","option","option-value","G__66813","G__66817","zprint.guide/signatureguide1","cljs.core/conj","G__66824","zprint.guide/defprotocolguide-s","vec__66827","remaining","cljs.core/nnext","cljs.core.map_indexed","idx","item","G__66834","zprint.guide/semantic3"],"sourcesContent":["(ns ^:no-doc zprint.guide\n  #?@(:cljs [[:require-macros\n              [zprint.macros :refer\n               [dbg dbg-s dbg-pr dbg-s-pr dbg-form dbg-print zfuture]]]])\n  (:require #?@(:clj [[zprint.macros :refer\n                       [dbg-pr dbg-s-pr dbg dbg-s dbg-form dbg-print zfuture]]])\n            [zprint.util :refer [column-alignment cumulative-alignment]]))\n\n;;\n;; Contains functions which can be called with {:option-fn <fn>} to\n;; produce\n;; a \"guide\", which is, roughtly, a sequence comprised of keywords\n;; which describe how to format an expression.  A guide must be created\n;; explicitly for the expression to be formatted.\n;;\n;; For instance, this expression: (a b c d e f g) could be formatted\n;; for this output:\n;;\n;; (a b c\n;;  d e f\n;;  g)\n;;\n;; by this guide:\n;;\n;; [:element :element :element :newline :element :element :element\n;; :newline\n;;  :element]\n;;          \n;; There are a lot more keywords and other things which can be in a guide\n;; than demonstrated above.\n\n;;\n;; # Guide for \"rules of defn\", an alternative way to format defn\n;; expressions.\n;;\n\n(defn rodguide\n  \"Given a structure which starts with defn, create a guide for the\n  'rules of defn', an alternative approach to formatting a defn.\"\n  ([] \"rodguide\")\n  ; If you call a guide with partial because it has its own options map,\n  ; the \"no-argument\" arity must include the options map!\n  ([rod-options] \"rodguide\")\n  ; Since we have released this before, we will also allow it to be called\n  ; without rod-options\n  ([options len sexpr] (rodguide {} options len sexpr))\n  ([rod-options options len sexpr]\n   (when (or (= (str (first sexpr)) \"defn\") (= (str (first sexpr)) \"defn-\"))\n     (let [multi-arity-nl? (get rod-options :multi-arity-nl? true)\n           docstring? (string? (nth sexpr 2))\n           rest (nthnext sexpr (if docstring? 3 2))\n           multi-arity? (not (vector? (first rest)))\n           rest (if multi-arity? rest (next rest))\n           #_#_zfn-map (:zfn-map options)\n           #_#_rest-count ((:zcount zfn-map) (:zloc options))\n           ; It is not just that the count is off.\n           rest-guide (repeat (dec #_rest-count (count rest)) :element)\n           rest-guide\n             (into []\n                   (if (and multi-arity? multi-arity-nl?)\n                     (interleave rest-guide (repeat :newline) (repeat :newline))\n                     (interleave rest-guide (repeat :newline))))\n           ; Make interleave into interpose\n           rest-guide (conj rest-guide :element)\n           guide (cond-> [:element :element]\n                   docstring? (conj :newline :element :newline)\n                   (not multi-arity?) (conj :element :newline)\n                   (and multi-arity? (not docstring?)) (conj :newline)\n                   :rest (into rest-guide))\n           option-map {:guide guide, :next-inner {:list {:option-fn nil}}}]\n       (if multi-arity?\n         (assoc option-map\n           :next-inner {:list {:option-fn nil},\n                        :fn-map {:vector :force-nl},\n                        :next-inner-restore [[:fn-map :vector]]})\n         option-map)))))\n\n; Use this to use the above:\n;\n; (czprint rod4\n;    {:parse-string? true\n;     :fn-map {\"defn\" [:guided {:list {:option-fn rodguide}}]}})\n\n;;\n;; # Guide to replicate the existing output for {:style :moustache}\n;;\n\n(defn constant-or-vector?\n  \"Return true if a constant or vector.\"\n  [element]\n  #_(println \"c-or-v?\" element)\n  (or (number? element)\n      (string? element)\n      (vector? element)\n      (keyword? element)\n      (= element true)\n      (= element false)))\n\n(defn count-constants\n  [[constant-count possible-constant?] element]\n  (if possible-constant?\n    (if (constant-or-vector? element)\n      [(inc constant-count) (not possible-constant?)]\n      (reduced [constant-count possible-constant?]))\n    [constant-count (not possible-constant?)]))\n\n(defn moustacheguide\n  \"Reimplement :style :moustache with guides.\"\n  ([] \"moustacheguide\")\n  ([options len sexpr]\n   ; First, find the pairs.\n   (let [rev-sexpr (reverse sexpr)\n         [constant-count _] (reduce count-constants [0 false] rev-sexpr)\n         pair-count (* constant-count 2)\n         pair-guide (into [] (repeat pair-count :element))\n         pair-guide (conj pair-guide :group-end)\n         pair-guide (conj pair-guide :element-pair-group)\n         non-pair-count (- (count sexpr) pair-count)\n         non-pair-guide (repeat non-pair-count :element)\n         non-pair-guide (into [] (interpose :newline non-pair-guide))\n         guide (conj non-pair-guide :newline :group-begin)\n         guide (concat guide pair-guide)]\n     (dbg-s options\n            :guide\n            \"moustacheguide: sexpr\" sexpr\n            \"pair-count:\" pair-count\n            \"output:\" guide)\n     {:guide guide,\n      :pair {:justify? true},\n      :next-inner {:pair {:justify? false}, :list {:option-fn nil}}})))\n\n; Use this to use the above:\n;\n;(czprint mapp6g\n;   {:parse-string? true\n;    :fn-map {\"m/app\" [:guided {:list {:option-fn moustacheguide}}]}})\n\n\n;;\n;; # Guide for the \"are\" function\n;;\n\n(defn add-double-quotes\n  \"Given two arguments, an s-expression and a string, if the s-expression\n  is actually a string, add a double quote on to the beginning and end of\n  the string.\"\n  [sexpr s]\n  (if (string? sexpr) (str \"\\\"\" s \"\\\"\") s))\n\n(defn areguide\n  \"Format are test functions.  Call it with (partial {} areguide), where\n  the map can be {:justify? true} to justify the various rows. It will\n  use {:pair {:justify {:max-variance n}}} for the variance, but you can\n  give it a variance to use with {:max-variance n} in the map which is\n  its first argument.\"\n  ([] \"areguide\")\n  ; If you call a guide with partial because it has its own options map,\n  ; the \"no-argument\" arity must include the options map!\n  ([are-options] \"areguide\")\n  ; Since we have released this before, we will also allow it to be called\n  ; without are-options\n  ([options len sexpr] (areguide {} options len sexpr))\n  ([are-options options len sexpr]\n   (let [justify? (:justify? are-options)\n         max-variance (when justify?\n                        (or (:max-variance are-options)\n                            (:max-variance (:justify (:pair options)))))\n         caller-options ((:caller options) options)\n         current-indent (or (:indent-arg caller-options)\n                            (:indent caller-options))\n         are-indent (:indent are-options)\n         table-indent (+ current-indent (or are-indent current-indent))\n         arg-vec-len (count (second sexpr))\n         test-len (- (count sexpr) 3)\n         rows (/ test-len arg-vec-len)\n         excess-tests (- test-len (* rows arg-vec-len))\n         alignment-vec\n           (when justify?\n             (let [; zloc-seq no comments\n                   zfn-map (:zfn-map options)\n                   zloc-seq-nc\n                     ((:zmap-no-comment zfn-map) identity (:zloc options))\n                   args (drop 3 zloc-seq-nc)\n                   ; Get the lengths of the actual zloc values, not the\n                   ; sexpr\n                   arg-strs (mapv (:zstring zfn-map) args)\n                   #_(prn \"early arg-strs:\" arg-strs)\n                   ; This makes strings too long, but it was presumably\n                   ; added for some reason?  Issue #212 arg-strs (mapv\n                   ; add-double-quotes (drop 3 sexpr) arg-strs)\n                   #_(prn \"later arg-strs:\" arg-strs)\n                   seq-of-seqs (partition arg-vec-len arg-vec-len [] arg-strs)\n                   max-width-vec (column-alignment max-variance\n                                                   seq-of-seqs\n                                                   nil\n                                                   :no-string-adj?)\n                   alignment-vec (cumulative-alignment max-width-vec)]\n               #_(prn \"max-width-vec:\" max-width-vec\n                      \"alignment-vec:\" alignment-vec)\n               alignment-vec))\n         mark-guide\n           (vec (flatten\n                  (mapv vector (repeat :mark-at-indent) (range) alignment-vec)))\n         new-row-guide (cond-> [:element :indent table-indent]\n                         (not (empty? alignment-vec))\n                           (into (interleave (repeat :align)\n                                             (range (count alignment-vec))\n                                             (repeat :element)))\n                         (empty? alignment-vec) (into (repeat (dec arg-vec-len)\n                                                              :element))\n                         true (conj :indent-reset :newline))\n         multi-row-guide (apply concat (repeat rows new-row-guide))\n         guide (cond-> (-> [:element :element :element-best :newline]\n                           (into mark-guide)\n                           (into multi-row-guide))\n                 (pos? excess-tests) (conj :element-*))]\n     #_(prn \"guide:\" guide)\n     {:guide guide, :next-inner {:list {:option-fn nil}}})))\n\n(defn areguide-basic\n  \"Format are test functions, no justification.\"\n  ([] \"areguide\")\n  ([options len sexpr]\n   (let [arg-vec-len (count (second sexpr))\n         beginning (take 3 sexpr)\n         test-len (- (count sexpr) 3)\n         rows (/ test-len arg-vec-len)\n         excess-tests (- test-len (* rows arg-vec-len))\n         single-row (into [:newline] (repeat arg-vec-len :element))\n         row-guide (apply concat (repeat rows single-row))\n         guide (cond-> (-> [:element :element :element-best]\n                           (into row-guide))\n                 (pos? excess-tests) (conj :newline :element-*))]\n     {:guide guide, :next-inner {:list {:option-fn nil}}})))\n\n\n; Do this to use the above:\n;\n; (czprint are3\n;   {:parse-string? true\n;    :fn-map {\"are\" [:guided {:list {:option-fn areguide}}]}})\n;\n\n;;\n;; # Guide to justify the content of the vectors in a (:require ...)\n;;\n\n;\n; A much simpler version of the require guide.  This version doesn't\n; require\n; use of the call-stack, and has only one option-fn instead of two.  It\n; also\n; uses the new variance-based justification capabilities.\n;\n\n(defn jrequireguide\n  \"Justify the first things in a variety of settings.  The first argument\n  is the things to recognize, and can be :require, :require-macros, or \n  :import. :require and :require-macros are handled the same, and :import\n  is handled differently since it has the values all in the same expression.\n  Handles sequences with lists or vectors. Note that it justifies the :as\n  and :refer as pairs, so a simple :as doesn't justify with anything, and\n  so looks out of place with the other vector's :refers.\"\n  ([] \"jrequireguide\")\n  ; If you call a guide with partial because it has its a required first\n  ; argument, ; the \"no-argument\" arity must include the first argument!\n  ([keyword] \"jrequireguide\")\n  ([keyword options len sexpr]\n   (when (= (first sexpr) keyword)\n     (let [vectors+lists (filter #(or (vector? %) (list? %)) sexpr)]\n       (when (not (empty? vectors+lists))\n         (let [max-width-vec (column-alignment (:max-variance\n                                                 (:justify (:pair options)))\n                                               vectors+lists\n                                               ; only do the first column\n                                               1)\n               _ (dbg-s options\n                        :guide\n                        \"jrequireguide max-width-vec:\"\n                        max-width-vec)\n               max-first (first max-width-vec)\n               element-guide :element-pair-*\n               vector-guide (if max-first\n                              (if (= (first sexpr) :import)\n                                [:mark-at 0 (inc max-first) :element :align 0\n                                 :indent-here #_(+ max-first 2) :element-*]\n                                [:mark-at 0 (inc max-first) :element :align 0\n                                 element-guide])\n                              ; We can't justify things, fall back to this.\n                              [:element element-guide])]\n           ; Do this for all of the first level vectors and lists  below\n           ; the :require, but no other vectors or lists more deeply\n           ; nested.\n           {:next-inner {:vector {:option-fn (fn [_ _ _] {:guide vector-guide}),\n                                  :wrap-multi? true,\n                                  :hang? true},\n                         :list {:option-fn (fn [_ _ _] {:guide vector-guide}),\n                                :wrap-multi? true,\n                                :hang? true},\n                         :pair {:justify? true},\n                         :next-inner-restore\n                           [[:vector :option-fn] [:vector :wrap-multi?]\n                            [:vector :hang?] [:list :option-fn]\n                            [:list :wrap-multi?] [:list :hang?]\n                            [:pair :justify?]]}}))))))\n\n; Do this to use the above:\n;\n; (czprint jr1\n;    {:parse-string? true\n;    :fn-map {\":require\" [:none {:list {:option-fn jrequireguide}}]}})\n\n;;\n;; # Guide to replicate the output of :arg1-mixin\n;; \n\n(defn rumguide\n  \"Assumes that this is rum/defcs or something similar. Implement :arg1-mixin\n  with guides using :spaces.  For guide testing, do not use this as a model\n  for how to write a guide.\"\n  ([] \"rumguide\")\n  ([options len sexpr]\n   (let [docstring? (string? (nth sexpr 2))\n         [up-to-arguments args-and-after]\n           (split-with #(not (or (vector? %)\n                                 (and (list? %) (vector? (first %)))))\n                       sexpr)\n         #_(println \"rumguide: up-to-arguments:\" up-to-arguments\n                    \"\\nargs-and-after:\" args-and-after)]\n     (if (empty? args-and-after)\n       {:list {:option-fn nil}}\n       (let [lt (nth sexpr (if docstring? 3 2))\n             lt? (= (str lt) \"<\")\n             mixin-indent (if lt? 2 1)\n             beginning-guide [:element :element :newline]\n             beginning-guide (if docstring?\n                               (concat beginning-guide [:element :newline])\n                               beginning-guide)\n             middle-element-count\n               (- (count up-to-arguments) 2 (if docstring? 1 0) (if lt? 1 0))\n             middle-guide\n               (if (pos? middle-element-count)\n                 (if lt? [:element :element :newline] [:element :newline])\n                 [])\n             #_(println \"middle-element-count:\" middle-element-count)\n             middle-guide (concat middle-guide\n                                  (repeat (dec middle-element-count)\n                                          [:spaces mixin-indent :element\n                                           :newline]))\n             end-element-count (count args-and-after)\n             end-guide [:element\n                        (repeat (dec end-element-count) [:newline :element])]\n             guide (concat beginning-guide middle-guide end-guide)\n             ; This could have been done so flatten wasn't necessary\n             ; but it for testing it wasn't worth the re-work.\n             guide (flatten guide)\n             #_(println \"rumguide: guide:\" guide)]\n         {:guide guide, :next-inner {:list {:option-fn nil}}})))))\n\n(defn rumguide-1\n  \"Assumes that this is rum/defcs or something similar. Implement :arg1-mixin\n  with guides using :align.  For guide testing, do not use this as a model\n  for how to write a guide.\"\n  ([] \"rumguide\")\n  ([options len sexpr]\n   (let [docstring? (string? (nth sexpr 2))\n         [up-to-arguments args-and-after]\n           (split-with #(not (or (vector? %)\n                                 (and (list? %) (vector? (first %)))))\n                       sexpr)\n         #_(println \"rumguide: up-to-arguments:\" up-to-arguments\n                    \"\\nargs-and-after:\" args-and-after)]\n     (if (empty? args-and-after)\n       {:list {:option-fn nil}}\n       (let [lt (nth sexpr (if docstring? 3 2))\n             lt? (= (str lt) \"<\")\n             beginning-guide [:element :element :newline]\n             beginning-guide (if docstring?\n                               (concat beginning-guide [:element :newline])\n                               beginning-guide)\n             middle-element-count\n               (- (count up-to-arguments) 2 (if docstring? 1 0) (if lt? 1 0))\n             middle-guide (if (pos? middle-element-count)\n                            (if lt?\n                              [:element :mark 1 :align 1 :element :newline]\n                              [:mark 1 :align 1 :element :newline])\n                            [])\n             #_(println \"middle-element-count:\" middle-element-count)\n             middle-guide (concat middle-guide\n                                  (repeat (dec middle-element-count)\n                                          [:align 1 :element :newline]))\n             end-element-count (count args-and-after)\n             end-guide [:element\n                        (repeat (dec end-element-count) [:newline :element])]\n             guide (concat beginning-guide middle-guide end-guide)\n             ; This could have been done so flatten wasn't necessary\n             ; but it for testing it wasn't worth the re-work.\n             guide (flatten guide)\n             #_(println \"rumguide: guide:\" guide)]\n         {:guide guide, :next-inner {:list {:option-fn nil}}})))))\n\n(defn rumguide-2\n  \"Assumes that this is rum/defcs or something similar. Implement :arg1-mixin\n  with guides using :indent.  This is probably the simplest and therefore the\n  best of them all.  For guide testing, do not use this as a model for how\n  to write a guide.\"\n  ([] \"rumguide\")\n  ([options len sexpr]\n   (let [docstring? (string? (nth sexpr 2))\n         [up-to-arguments args-and-after]\n           (split-with #(not (or (vector? %)\n                                 (and (list? %) (vector? (first %)))))\n                       sexpr)\n         #_(println \"rumguide: up-to-arguments:\" up-to-arguments\n                    \"\\nargs-and-after:\" args-and-after)]\n     (if (empty? args-and-after)\n       {:list {:option-fn nil}}\n       (let [lt (nth sexpr (if docstring? 3 2))\n             lt? (= (str lt) \"<\")\n             beginning-guide [:element :element :newline]\n             beginning-guide (if docstring?\n                               (concat beginning-guide [:element :newline])\n                               beginning-guide)\n             middle-element-count\n               (- (count up-to-arguments) 2 (if docstring? 1 0) (if lt? 1 0))\n             middle-guide (if (pos? middle-element-count)\n                            (if lt?\n                              [:element :indent 4 :element :newline]\n                              [:indent 4 :element :newline])\n                            [])\n             #_(println \"middle-element-count:\" middle-element-count)\n             middle-guide (concat middle-guide\n                                  (repeat (dec middle-element-count)\n                                          [:element :newline]))\n             end-element-count (count args-and-after)\n             end-guide [:indent-reset :element\n                        (repeat (dec end-element-count) [:newline :element])]\n             guide (concat beginning-guide middle-guide end-guide)\n             ; This could have been done so flatten wasn't necessary\n             ; but it for testing it wasn't worth the re-work.\n             guide (flatten guide)\n             #_(println \"rumguide: guide:\" guide)]\n         {:guide guide, :next-inner {:list {:option-fn nil}}})))))\n\n\n; Do this to use the above:\n;\n; (czprint cz8x1\n;     {:parse-string? true\n;     :fn-map {\"rum/defcs\" [:guided {:list {:option-fn rumguide}}]}})\n\n(defn odrguide\n  \"Justify O'Doyles Rules\"\n  ([] \"odrguide\")\n  ([options len sexpr]\n   (when (= (first sexpr) :what)\n     (let [[vectors beyond] (split-with vector? (next sexpr))\n           max-width-vec (column-alignment (:max-variance (:justify (:pair\n                                                                      options)))\n                                           vectors)\n           alignment-vec (cumulative-alignment max-width-vec)\n           mark-guide\n             (vec (flatten\n                    (mapv vector (repeat :mark-at) (range) alignment-vec)))\n           alignment-guide\n             (mapv vector (repeat :align) (range (count alignment-vec)))\n           vector-guide (into mark-guide\n                              (flatten [(interleave (repeat :element)\n                                                    alignment-guide)\n                                        :element-*]))\n           keyword-1 (first beyond)\n           [keyword-1-lists beyond] (split-with list? (next beyond))\n           keyword-2 (first beyond)\n           [keyword-2-lists beyond] (split-with list? (next beyond))\n           _ (dbg-s options\n                    :guide\n                    \"odrguide alignment-vec:\" alignment-vec\n                    \"mark-guide:\" mark-guide\n                    \"alignment-guide:\" alignment-guide\n                    \"vector-guide:\" vector-guide\n                    \"keyword-1:\" keyword-1\n                    \"keyword-1-lists:\" keyword-1-lists\n                    \"keyword-2:\" keyword-2\n                    \"keyword-2-lists:\" keyword-2-lists)\n           guide\n             (cond-> (->\n                       [:element :indent 2 :options\n                        {:guide vector-guide,\n                         :vector {:wrap-multi? true, :hang? true}} :group-begin]\n                       (into (repeat (count vectors) :element))\n                       (conj :group-end\n                             :element-newline-best-group :options-reset\n                             :options {:vector {:wrap-multi? true, :hang? true}}\n                             :indent 1))\n               keyword-1 (conj :newline :element)\n               (not (empty? keyword-1-lists))\n                 (-> (conj :indent 2 :group-begin)\n                     (into (repeat (count keyword-1-lists) :element))\n                     (conj :group-end :element-newline-best-group :indent 1))\n               keyword-2 (conj :newline :element)\n               (not (empty? keyword-2-lists))\n                 (-> (conj :indent 2 :group-begin)\n                     (into (repeat (count keyword-2-lists) :element))\n                     (conj :group-end :element-newline-best-group)))]\n       (dbg-s options :guide \"odrguide:\" guide)\n       {:guide guide}))))\n\n;;\n;; Guide guide\n;;\n\n(def guide-arg-count\n  {:element 0,\n   :element-* 0,\n   :element-best 0,\n   :element-best-* 0,\n   :element-pair-group 0,\n   :element-pair-* 0,\n   :element-newline-best-group 0,\n   :element-newline-best-* 0,\n   :element-binding-group 0,\n   :element-binding-* 0,\n   :element-guide 1,\n   :element-binding-vec 0,\n   :newline 0,\n   :options 1,\n   :options-reset 0,\n   :indent 1,\n   :indent-reset 0,\n   :spaces 1,\n   :mark-at 2,\n   :mark-at-indent 2,\n   :mark 1,\n   :align 1,\n   :group-begin 0,\n   :group-end 0})\n\n(def guide-insert\n  {:group-begin {:after [:indent 3]}, :group-end {:before [:indent 1]}})\n\n(defn handle-args\n  \"Figure out the arg-count for a guide.\"\n  [[guide running-arg-count] command]\n  (if (zero? running-arg-count)\n    (let [command-arg-count (or (guide-arg-count command) 0)\n          before (:before (guide-insert command))\n          after (:after (guide-insert command))]\n      [(cond-> guide\n         before (into before)\n         (empty? guide) (conj :element)\n         (not (empty? guide)) (conj :newline :element)\n         after (into after)) command-arg-count])\n    [(conj guide :element) (dec running-arg-count)]))\n\n(defn guideguide\n  \"Print out a guide\"\n  ([] \"guideguide\")\n  ([options len sexpr]\n   (when (guide-arg-count (first sexpr))\n     {:guide (first (reduce handle-args [[] 0] sexpr))})))\n\n;;\n;; Real guide for defprotocol\n;;\n\n(declare signatureguide1)\n\n(defn defprotocolguide\n  \"Handle defprotocol with options.\"\n  ([] \"defprotocolguide\")\n  ([options len sexpr]\n   (when (= (first sexpr) 'defprotocol)\n     (let [third (nth sexpr 2 nil)\n           fourth (nth sexpr 3 nil)\n           fifth (nth sexpr 4 nil)\n           [docstring option option-value]\n             (cond (and (string? third) (keyword? fourth)) [third fourth fifth]\n                   (string? third) [third nil nil]\n                   (keyword? third) [nil third fourth]\n                   :else [nil nil nil])\n           guide (cond-> [:element :element-best :newline]\n                   docstring (conj :element :newline)\n                   option (conj :element :element :newline)\n                   :else (conj :element-newline-best-*))]\n       {:guide guide, :next-inner {:list {:option-fn nil}}}))))\n\n(defn signatureguide1\n  \"Handle defprotocol signatures with arities and doc string on their \n  own lines.\"\n  ([] \"signatureguide1\")\n  ([options len sexpr]\n   (let [vectors (filter vector? sexpr)\n         guide [:element :group-begin]\n         guide (apply conj guide (repeat (count vectors) :element))\n         guide (conj guide\n                     :group-end :element-newline-best-group\n                     :newline :element-*)]\n     {:guide guide})))\n\n(defn defprotocolguide-s\n  \"Handle defprotocol with options, uses extend.\"\n  ([] \"defprotocolguide\")\n  ([options len sexpr]\n   (when (= (first sexpr) 'defprotocol)\n     (let [remaining (nnext sexpr)\n           [docstring remaining] (if (string? (first remaining))\n                                   [(first remaining) (next remaining)]\n                                   [nil remaining])\n           pair-count (some identity\n                            (map-indexed (fn [idx item] (when (list? item) idx))\n                                         remaining))\n           pair-count (if (= pair-count 0) nil pair-count)\n           guide (cond-> [:element :element-best :newline]\n                   docstring (conj :element :newline)\n                   pair-count (conj :group-begin)\n                   pair-count (into (repeat pair-count :element))\n                   pair-count (conj :group-end :element-pair-group :newline)\n                   :else (conj :element-newline-extend-*))]\n       {:guide guide, :next-inner {:list {:option-fn nil}}}))))\n\n;;\n;; Temporary place to stash semantic3 to make collaboration easier\n;;\n;; -alt\n;;\n\n(def semantic3\n  ; version 0.1.6. Requires zprint 1.2.5\n  {:style-map\n     {:s1.0 {:doc \"Set up community indentation\",\n             :binding {:indent 0},\n             :list {:indent-arg 1},\n             :map {:indent 0},\n             :pair {:indent 0}},\n      :s1.1 {:doc \"defn and fn\",\n             :fn-map {\"defn\" [:force-nl-body {:style :rod-base}],\n                      \"defn-\" \"defn\",\n                      \"fn\" \"defn\"}},\n      :s1.2\n        {:doc \"defprotocol, defrecord, deftype, extend-type, extend-protocol\",\n         :fn-map {\"defprotocol\" [:arg1-extend-body\n                                 {:extend {:nl-count 2, :nl-separator? true},\n                                  :list {:option-fn defprotocolguide-s},\n                                  :fn-type-map {:fn :flow-body}}],\n                  \"defrecord\" [:arg2-extend-body {:style :s1.2-base}],\n                  \"deftype\" \"defrecord\",\n                  \"extend-type\" [:arg1-extend-body {:style :s1.2-base}],\n                  \"extend-protocol\" \"extend-type\"}},\n      :s1.2-base {:doc \"Common code for extend things\",\n                  :extend {:nl-count 2, :nl-separator? true, :indent 0},\n                  :fn-force-nl #{:fn},\n                  :fn-type-map {:fn [:force-nl-body {:style :rod-base}]},\n                  :next-inner {:next-inner {:fn-type-map {:fn nil}}}},\n      :s1.3 {:doc \"defmethod\",\n             :fn-map {\"defmethod\" [:guided-body\n                                   {:guide [:element :element-best\n                                            :element-best-first\n                                            :element-best-first :newline\n                                            :element-newline-best-*]}]}},\n      :s1.4 {:doc \"if, if-not, handled now in s1.5\"},\n      :s1.5\n        {:doc\n           \"Don't format on single line: case cond-> cond->> when \n            while when-not when-first locking let binding loop for doseq \n            dotimes when-let if-let when-some if-some testing go-loop\",\n         :binding {:force-nl? true},\n         :fn-force-nl #{:arg1-pair-body},\n         :fn-map {\"when\" :arg1-force-nl-body,\n                  \"when-not\" \"when\",\n                  \"while\" \"when\",\n                  \"locking\" \"when\",\n                  \"testing\" \"when\"}},\n      :s1.6 {:doc \"=, not=, or, and, <, >, <=, >=\",\n             :fn-force-nl #{:hang},\n             :fn-map {\"<\" \"=\", \">\" \"=\", \"<=\" \"=\", \">=\" \"=\"}},\n      :s1.7 {:doc \"->, ->>\", :remove {:fn-force-nl #{:noarg1-body}}},\n      :s1.8 {:doc \"try, catch, finally\",\n             :fn-map {\"try\" :flow-body,\n                      \"catch\" :arg2-force-nl-body,\n                      \"finally\" :flow-body}},\n      :s1.9 {:doc \"other stuff\", :fn-map {\"is\" :force-nl-body}},\n      :s1.10 {:doc \"cond do delay future comment alt! alt!! go thread\",\n              :pair-fn {:hang? false},\n              :fn-map {\"do\" :flow-body,\n                       \"delay\" \"do\",\n                       \"future\" \"do\",\n                       \"comment\" \"do\",\n                       \"go\" \"do\",\n                       \"thread\" \"do\"}},\n      :sall {:doc \"version 0.1.4\",\n             :style [:s1.0 :s1.1 :s1.2 :s1.3 :s1.4 :s1.5 :s1.6 :s1.7 :s1.8 :s1.9\n                     :s1.10]}}})\n\n\n"],"x_google_ignoreList":[0]}