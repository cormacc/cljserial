shadow$provide.module$node_modules$$supabase$realtime_js$dist$main$RealtimeClient = function(global, require, module, exports) {
  var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {enumerable:!0, get:function() {
        return m[k];
      }};
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    o[k2] = m[k];
  }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {enumerable:!0, value:v});
  } : function(o, v) {
    o["default"] = v;
  }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) {
      return mod;
    }
    var result = {};
    if (null != mod) {
      for (var k in mod) {
        "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      }
    }
    __setModuleDefault(result, mod);
    return result;
  };
  global = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {"default":mod};
  };
  Object.defineProperty(exports, "__esModule", {value:!0});
  const constants_1 = require("module$node_modules$$supabase$realtime_js$dist$main$lib$constants"), serializer_1 = global(require("module$node_modules$$supabase$realtime_js$dist$main$lib$serializer")), timer_1 = global(require("module$node_modules$$supabase$realtime_js$dist$main$lib$timer")), transformers_1 = require("module$node_modules$$supabase$realtime_js$dist$main$lib$transformers"), RealtimeChannel_1 = global(require("module$node_modules$$supabase$realtime_js$dist$main$RealtimeChannel")), noop = 
  () => {
  }, NATIVE_WEBSOCKET_AVAILABLE = "undefined" !== typeof WebSocket;
  class RealtimeClient {
    constructor(endPoint, options) {
      var _a;
      this.apiKey = this.accessTokenValue = null;
      this.channels = [];
      this.httpEndpoint = this.endPoint = "";
      this.headers = constants_1.DEFAULT_HEADERS;
      this.params = {};
      this.timeout = constants_1.DEFAULT_TIMEOUT;
      this.heartbeatIntervalMs = 30000;
      this.heartbeatTimer = void 0;
      this.pendingHeartbeatRef = null;
      this.ref = 0;
      this.logger = noop;
      this.conn = null;
      this.sendBuffer = [];
      this.serializer = new serializer_1.default();
      this.stateChangeCallbacks = {open:[], close:[], error:[], message:[]};
      this.accessToken = null;
      this._resolveFetch = customFetch => {
        let _fetch;
        _fetch = customFetch ? customFetch : "undefined" === typeof fetch ? (...args) => Promise.resolve().then(() => __importStar(require("module$node_modules$$supabase$node_fetch$browser"))).then(({default:fetch}) => fetch(...args)) : fetch;
        return (...args) => _fetch(...args);
      };
      this.endPoint = `${endPoint}/${constants_1.TRANSPORTS.websocket}`;
      this.httpEndpoint = (0,transformers_1.httpEndpointURL)(endPoint);
      this.transport = (null === options || void 0 === options ? 0 : options.transport) ? options.transport : null;
      if (null === options || void 0 === options ? 0 : options.params) {
        this.params = options.params;
      }
      if (null === options || void 0 === options ? 0 : options.headers) {
        this.headers = Object.assign(Object.assign({}, this.headers), options.headers);
      }
      if (null === options || void 0 === options ? 0 : options.timeout) {
        this.timeout = options.timeout;
      }
      if (null === options || void 0 === options ? 0 : options.logger) {
        this.logger = options.logger;
      }
      if (null === options || void 0 === options ? 0 : options.heartbeatIntervalMs) {
        this.heartbeatIntervalMs = options.heartbeatIntervalMs;
      }
      if (endPoint = null === (_a = null === options || void 0 === options ? void 0 : options.params) || void 0 === _a ? void 0 : _a.apikey) {
        this.apiKey = this.accessTokenValue = endPoint;
      }
      this.reconnectAfterMs = (null === options || void 0 === options ? 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : tries => [1000, 2000, 5000, 10000][tries - 1] || 10000;
      this.encode = (null === options || void 0 === options ? 0 : options.encode) ? options.encode : (payload, callback) => callback(JSON.stringify(payload));
      this.decode = (null === options || void 0 === options ? 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);
      this.reconnectTimer = new timer_1.default(async() => {
        this.disconnect();
        this.connect();
      }, this.reconnectAfterMs);
      this.fetch = this._resolveFetch(null === options || void 0 === options ? void 0 : options.fetch);
      if (null === options || void 0 === options ? 0 : options.worker) {
        if ("undefined" !== typeof window && !window.Worker) {
          throw Error("Web Worker is not supported");
        }
        this.worker = (null === options || void 0 === options ? void 0 : options.worker) || !1;
        this.workerUrl = null === options || void 0 === options ? void 0 : options.workerUrl;
      }
      this.accessToken = (null === options || void 0 === options ? void 0 : options.accessToken) || null;
    }
    connect() {
      this.conn || (this.transport ? this.conn = new this.transport(this.endpointURL(), void 0, {headers:this.headers}) : NATIVE_WEBSOCKET_AVAILABLE ? (this.conn = new WebSocket(this.endpointURL()), this.setupConnection()) : (this.conn = new WSWebSocketDummy(this.endpointURL(), void 0, {close:() => {
        this.conn = null;
      }}), Promise.resolve().then(() => __importStar(require("module$node_modules$$supabase$realtime_js$node_modules$ws$browser"))).then(({default:WS}) => {
        this.conn = new WS(this.endpointURL(), void 0, {headers:this.headers});
        this.setupConnection();
      })));
    }
    endpointURL() {
      return this._appendParams(this.endPoint, Object.assign({}, this.params, {vsn:constants_1.VSN}));
    }
    disconnect(code, reason) {
      this.conn && (this.conn.onclose = function() {
      }, code ? this.conn.close(code, null !== reason && void 0 !== reason ? reason : "") : this.conn.close(), this.conn = null, this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.reconnectTimer.reset());
    }
    getChannels() {
      return this.channels;
    }
    async removeChannel(channel) {
      channel = await channel.unsubscribe();
      0 === this.channels.length && this.disconnect();
      return channel;
    }
    async removeAllChannels() {
      const values_1 = await Promise.all(this.channels.map(channel => channel.unsubscribe()));
      this.disconnect();
      return values_1;
    }
    log(kind, msg, data) {
      this.logger(kind, msg, data);
    }
    connectionState() {
      switch(this.conn && this.conn.readyState) {
        case constants_1.SOCKET_STATES.connecting:
          return constants_1.CONNECTION_STATE.Connecting;
        case constants_1.SOCKET_STATES.open:
          return constants_1.CONNECTION_STATE.Open;
        case constants_1.SOCKET_STATES.closing:
          return constants_1.CONNECTION_STATE.Closing;
        default:
          return constants_1.CONNECTION_STATE.Closed;
      }
    }
    isConnected() {
      return this.connectionState() === constants_1.CONNECTION_STATE.Open;
    }
    channel(topic, params = {config:{}}) {
      topic = new RealtimeChannel_1.default(`realtime:${topic}`, params, this);
      this.channels.push(topic);
      return topic;
    }
    push(data) {
      const {topic, event, payload, ref} = data, callback = () => {
        this.encode(data, result => {
          var _a;
          null === (_a = this.conn) || void 0 === _a || _a.send(result);
        });
      };
      this.log("push", `${topic} ${event} (${ref})`, payload);
      this.isConnected() ? callback() : this.sendBuffer.push(callback);
    }
    async setAuth(token = null) {
      let tokenToSend = token || this.accessToken && await this.accessToken() || this.accessTokenValue;
      if (tokenToSend) {
        token = null;
        try {
          token = JSON.parse(atob(tokenToSend.split(".")[1]));
        } catch (_error) {
        }
        if (token && token.exp && !(0 > Math.floor(Date.now() / 1000) - token.exp)) {
          return this.log("auth", `InvalidJWTToken: Invalid value for JWT claim "exp" with value ${token.exp}`), Promise.reject(`InvalidJWTToken: Invalid value for JWT claim "exp" with value ${token.exp}`);
        }
        this.accessTokenValue = tokenToSend;
        this.channels.forEach(channel => {
          tokenToSend && channel.updateJoinPayload({access_token:tokenToSend});
          channel.joinedOnce && channel._isJoined() && channel._push(constants_1.CHANNEL_EVENTS.access_token, {access_token:tokenToSend});
        });
      }
    }
    async sendHeartbeat() {
      var _a;
      this.isConnected() && (this.pendingHeartbeatRef ? (this.pendingHeartbeatRef = null, this.log("transport", "heartbeat timeout. Attempting to re-establish connection"), null === (_a = this.conn) || void 0 === _a || _a.close(constants_1.WS_CLOSE_NORMAL, "hearbeat timeout")) : (this.pendingHeartbeatRef = this._makeRef(), this.push({topic:"phoenix", event:"heartbeat", payload:{}, ref:this.pendingHeartbeatRef}), this.setAuth()));
    }
    flushSendBuffer() {
      this.isConnected() && 0 < this.sendBuffer.length && (this.sendBuffer.forEach(callback => callback()), this.sendBuffer = []);
    }
    _makeRef() {
      let newRef = this.ref + 1;
      this.ref = newRef === this.ref ? 0 : newRef;
      return this.ref.toString();
    }
    _leaveOpenTopic(topic) {
      let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));
      dupChannel && (this.log("transport", `leaving duplicate topic "${topic}"`), dupChannel.unsubscribe());
    }
    _remove(channel) {
      this.channels = this.channels.filter(c => c._joinRef() !== channel._joinRef());
    }
    setupConnection() {
      this.conn && (this.conn.binaryType = "arraybuffer", this.conn.onopen = () => this._onConnOpen(), this.conn.onerror = error => this._onConnError(error), this.conn.onmessage = event => this._onConnMessage(event), this.conn.onclose = event => this._onConnClose(event));
    }
    _onConnMessage(rawMessage) {
      this.decode(rawMessage.data, msg => {
        let {topic, event, payload, ref} = msg;
        ref && ref === this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null);
        this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
        this.channels.filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));
        this.stateChangeCallbacks.message.forEach(callback => callback(msg));
      });
    }
    async _onConnOpen() {
      this.log("transport", `connected to ${this.endpointURL()}`);
      this.flushSendBuffer();
      this.reconnectTimer.reset();
      if (this.worker) {
        this.workerUrl ? this.log("worker", `starting worker for from ${this.workerUrl}`) : this.log("worker", "starting default worker");
        const objectUrl = this._workerObjectUrl(this.workerUrl);
        this.workerRef = new Worker(objectUrl);
        this.workerRef.onerror = error => {
          this.log("worker", "worker error", error.message);
          this.workerRef.terminate();
        };
        this.workerRef.onmessage = event => {
          "keepAlive" === event.data.event && this.sendHeartbeat();
        };
        this.workerRef.postMessage({event:"start", interval:this.heartbeatIntervalMs});
      } else {
        this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
      }
      this.stateChangeCallbacks.open.forEach(callback => callback());
    }
    _onConnClose(event) {
      this.log("transport", "close", event);
      this._triggerChanError();
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.reconnectTimer.scheduleTimeout();
      this.stateChangeCallbacks.close.forEach(callback => callback(event));
    }
    _onConnError(error) {
      this.log("transport", error.message);
      this._triggerChanError();
      this.stateChangeCallbacks.error.forEach(callback => callback(error));
    }
    _triggerChanError() {
      this.channels.forEach(channel => channel._trigger(constants_1.CHANNEL_EVENTS.error));
    }
    _appendParams(url, params) {
      if (0 === Object.keys(params).length) {
        return url;
      }
      const prefix = url.match(/\?/) ? "\x26" : "?";
      params = new URLSearchParams(params);
      return `${url}${prefix}${params}`;
    }
    _workerObjectUrl(url) {
      url || (url = new Blob(['\n  addEventListener("message", (e) \x3d\x3e {\n    if (e.data.event \x3d\x3d\x3d "start") {\n      setInterval(() \x3d\x3e postMessage({ event: "keepAlive" }), e.data.interval);\n    }\n  });'], {type:"application/javascript"}), url = URL.createObjectURL(url));
      return url;
    }
  }
  exports.default = RealtimeClient;
  class WSWebSocketDummy {
    constructor(address, _protocols, options) {
      this.binaryType = "arraybuffer";
      this.onclose = () => {
      };
      this.onerror = () => {
      };
      this.onmessage = () => {
      };
      this.onopen = () => {
      };
      this.readyState = constants_1.SOCKET_STATES.connecting;
      this.send = () => {
      };
      this.url = null;
      this.url = address;
      this.close = options.close;
    }
  }
};

//# sourceMappingURL=module$node_modules$$supabase$realtime_js$dist$main$RealtimeClient.js.map
