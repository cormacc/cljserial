{"version":3,"sources":["rewrite_clj/zip/subedit.cljc"],"mappings":";AAUA;;;;;;+BAAA,/BAAOA,sEAKJC;AALH,6PAMO,AAACC,kBAAQC,kCAAQF,zIACjB,AAACG,mDAAWD,lMACZ,AAACE,4CAAI,AAACC,6CAAKC,gBAAMC,lIACjB,OAACC;;AAER;;;oCAAA,pCAAOC,gFAEJC,IAAIC;AAFP,AAGE,OAACC,4CACC,AAACX,kBAAQY,qCAAW,AAACC,oCAAUJ,MAC/BC;;AAEJ;;;kCAAA,lCAAOI,4EAEJf,KAAKgB;AAFR,AAGE,IAAMC,4GAASjB,pCACAkB,jEACA,iEAAA,jEAACC,2GAAc,AAACC,iCAAiBpB;AAFhD,AAGE,OAACqB,+CAAOZ,kCAAUQ,KAAKD;;AAE3B;;;;;;;oCAAA,pCAAMM,gFAMHtB,KAAKuB;AANR,AAOE,IAAMC,oBAAM,CAACD,kCAAAA,wCAAAA,RAAEvB,qBAAAA;AAAf,AACE,GAAQ,GAAK,sBAAA,rBAAMwB;AAAnB;AAAA,AAAA,MAAA,KAAAC,MAAA,CAAA,kBAAA,gDAAA,KAAA;;;AACA,OAACV,gCAAQS,kBAAM,AAACzB,6BAAKC;;AAsBzB;;;;;iCAAA,jCAAM0B,0EAIH1B;AAJH,AAKE,IAAMwB,oBAAM,iBAAAG,WAAQ3B;IAAR2B,eAAA,EAAA,CAAAA,YAAA,OAAA,KAAA,oCAAAA,pCACQC;AADR,AAAA,GAAA,CAAAD,gBAAA;AAAA;;AAEQ,wEAAAA,jEAACR,8EAAc,AAACC,iCAAiBpB;;;AAFrD,AAGE,oBAAQwB;AAAR;AAAA,AAAA,MAAA,KAAAC,MAAA,CAAA,kBAAA,8BAAA,KAAA;;;AACAD;;AAEJ;;;;;;uCAAA,vCAAMK,sFAKH7B,KAAKuB;AALR,AAME,IAAMC,oBAAM,iBAAAM,WAAG,AAACJ,+BAAO1B;AAAX,AAAA,0EAAA8B,yBAAAA,3FAACP,kCAAAA,4CAAAA;;AAAb,AACE,GAAQ,GAAK,sBAAA,rBAAMC;AAAnB;AAAA,AAAA,MAAA,KAAAC,MAAA,CAAA,kBAAA,mDAAA,KAAA;;;AACA,OAACM,uCAAa/B,KAAK,AAACkB,oCAAUM","names":["rewrite-clj.zip.subedit/path","zloc","cljs.core/iterate","rewrite-clj.custom-zipper.core/up","cljs.core.take_while","cljs.core.map","cljs.core.comp","cljs.core/count","rewrite-clj.custom-zipper.core/lefts","cljs.core/reverse","rewrite-clj.zip.subedit/move-step","loc","n","cljs.core.nth","rewrite-clj.custom-zipper.core/right","rewrite-clj.custom-zipper.core/down","rewrite-clj.zip.subedit/move-to","path","root","rewrite-clj.custom-zipper.core/root","rewrite_clj.zip.base.of_node_STAR_","rewrite-clj.zip.options/get-opts","cljs.core.reduce","rewrite-clj.zip.subedit/edit-node","f","zloc'","js/Error","rewrite-clj.zip.subedit/subzip","G__68286","rewrite-clj.custom-zipper.core/node","rewrite-clj.zip.subedit/subedit-node","G__68292","rewrite-clj.custom-zipper.core/replace"],"sourcesContent":["(ns ^:no-doc rewrite-clj.zip.subedit\n  (:require [rewrite-clj.custom-zipper.core :as zraw]\n            [rewrite-clj.zip.base :as base]\n            [rewrite-clj.zip.options :as options])\n  #?(:cljs (:require-macros [rewrite-clj.zip.subedit])) )\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; ## Edit Scope\n\n(defn- path\n  \"Generate a seq representing a path to the current node\n   starting at the root. Each element represents one `z/down`\n   and the value of each element will be the number of `z/right`s\n   to run.\"\n  [zloc]\n  (->> (iterate zraw/up zloc)\n       (take-while zraw/up)\n       (map (comp count zraw/lefts))\n       (reverse)))\n\n(defn- move-step\n  \"Move one down and `n` steps to the right.\"\n  [loc n]\n  (nth\n    (iterate zraw/right (zraw/down loc))\n    n))\n\n(defn- move-to\n  \"Move to the node represented by the given path.\"\n  [zloc path]\n  (let [root (-> zloc\n                 zraw/root\n                 (base/of-node* (options/get-opts zloc)))]\n    (reduce move-step root path)))\n\n(defn edit-node\n  \"Return zipper applying function `f` to `zloc`. The resulting\n   zipper will be located at the same path (i.e. the same number of\n   downwards and right movements from the root) incoming `zloc`.\n\n   See also [[subedit-node]] for an isolated edit.\"\n  [zloc f]\n  (let [zloc' (f zloc)]\n    (assert (not (nil? zloc')) \"function applied in 'edit-node' returned nil.\")\n    (move-to zloc' (path zloc))))\n\n(defmacro edit->\n  \"Like `->`, threads `zloc` through forms.\n   The resulting zipper will be located at the same path (i.e. the same\n   number of downwards and right movements from the root) as incoming `zloc`.\n\n   See also [[subedit->]] for an isolated edit.\"\n  [zloc & body]\n  `(edit-node ~zloc #(-> % ~@body)))\n\n(defmacro edit->>\n  \"Like `->>`, threads `zloc` through forms.\n   The resulting zipper will be located at the same path (i.e. the same\n   number of downwards and right movements from the root) as incoming `zloc`.\n\n   See also [[subedit->>]] for an isolated edit.\"\n  [zloc & body]\n  `(edit-node ~zloc #(->> % ~@body)))\n\n;; ## Sub-Zipper\n\n(defn subzip\n  \"Create and return a zipper whose root is the current node in `zloc`.\n\n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).\"\n  [zloc]\n  (let [zloc' (some-> zloc\n                      zraw/node\n                      (base/of-node* (options/get-opts zloc)))]\n    (assert zloc' \"could not create subzipper.\")\n    zloc'))\n\n(defn subedit-node\n  \"Return zipper replacing current node in `zloc` with result of `f` applied to said node as an isolated sub-tree.\n   The resulting zipper will be located on the root of the modified sub-tree.\n\n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).\"\n  [zloc f]\n  (let [zloc' (f (subzip zloc))]\n    (assert (not (nil? zloc')) \"function applied in 'subedit-node' returned nil.\")\n    (zraw/replace zloc (zraw/root zloc'))))\n\n(defmacro subedit->\n  \"Like `->`, threads `zloc`, as an isolated sub-tree through forms, then zips\n   up to, and locates at, the root of the modified sub-tree.\n\n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).\"\n  [zloc & body]\n  `(subedit-node ~zloc #(-> % ~@body)))\n\n(defmacro subedit->>\n  \"Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\n      up to, and locates at, the root of the modified sub-tree.\n\n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).\"\n  [zloc & body]\n  `(subedit-node ~zloc #(->> % ~@body)))\n"],"x_google_ignoreList":[0]}