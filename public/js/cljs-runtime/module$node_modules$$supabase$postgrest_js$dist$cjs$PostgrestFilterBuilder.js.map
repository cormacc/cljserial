{
"version":3,
"file":"module$node_modules$$supabase$postgrest_js$dist$cjs$PostgrestFilterBuilder.js",
"lineCount":124,
"mappings":"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",
"sources":["node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$supabase$postgrest_js$dist$cjs$PostgrestFilterBuilder\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst PostgrestTransformBuilder_1 = __importDefault(require(\"./PostgrestTransformBuilder\"));\nclass PostgrestFilterBuilder extends PostgrestTransformBuilder_1.default {\n    /**\n     * Match only rows where `column` is equal to `value`.\n     *\n     * To check if the value of `column` is NULL, you should use `.is()` instead.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    eq(column, value) {\n        this.url.searchParams.append(column, `eq.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is not equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    neq(column, value) {\n        this.url.searchParams.append(column, `neq.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is greater than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    gt(column, value) {\n        this.url.searchParams.append(column, `gt.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is greater than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    gte(column, value) {\n        this.url.searchParams.append(column, `gte.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is less than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    lt(column, value) {\n        this.url.searchParams.append(column, `lt.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is less than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    lte(column, value) {\n        this.url.searchParams.append(column, `lte.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */\n    like(column, pattern) {\n        this.url.searchParams.append(column, `like.${pattern}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    likeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    likeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */\n    ilike(column, pattern) {\n        this.url.searchParams.append(column, `ilike.${pattern}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    ilikeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    ilikeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` IS `value`.\n     *\n     * For non-boolean columns, this is only relevant for checking if the value of\n     * `column` is NULL by setting `value` to `null`.\n     *\n     * For boolean columns, you can also set `value` to `true` or `false` and it\n     * will behave the same way as `.eq()`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    is(column, value) {\n        this.url.searchParams.append(column, `is.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is included in the `values` array.\n     *\n     * @param column - The column to filter on\n     * @param values - The values array to filter with\n     */\n    in(column, values) {\n        const cleanedValues = Array.from(new Set(values))\n            .map((s) => {\n            // handle postgrest reserved characters\n            // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n            if (typeof s === 'string' && new RegExp('[,()]').test(s))\n                return `\"${s}\"`;\n            else\n                return `${s}`;\n        })\n            .join(',');\n        this.url.searchParams.append(column, `in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * `column` contains every element appearing in `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */\n    contains(column, value) {\n        if (typeof value === 'string') {\n            // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n            // keep it simple and accept a string\n            this.url.searchParams.append(column, `cs.${value}`);\n        }\n        else if (Array.isArray(value)) {\n            // array\n            this.url.searchParams.append(column, `cs.{${value.join(',')}}`);\n        }\n        else {\n            // json\n            this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * every element appearing in `column` is contained by `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */\n    containedBy(column, value) {\n        if (typeof value === 'string') {\n            // range\n            this.url.searchParams.append(column, `cd.${value}`);\n        }\n        else if (Array.isArray(value)) {\n            // array\n            this.url.searchParams.append(column, `cd.{${value.join(',')}}`);\n        }\n        else {\n            // json\n            this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is greater than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeGt(column, range) {\n        this.url.searchParams.append(column, `sr.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or greater than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeGte(column, range) {\n        this.url.searchParams.append(column, `nxl.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is less than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeLt(column, range) {\n        this.url.searchParams.append(column, `sl.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or less than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeLte(column, range) {\n        this.url.searchParams.append(column, `nxr.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where `column` is\n     * mutually exclusive to `range` and there can be no element between the two\n     * ranges.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeAdjacent(column, range) {\n        this.url.searchParams.append(column, `adj.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for array and range columns. Match only rows where\n     * `column` and `value` have an element in common.\n     *\n     * @param column - The array or range column to filter on\n     * @param value - The array or range value to filter with\n     */\n    overlaps(column, value) {\n        if (typeof value === 'string') {\n            // range\n            this.url.searchParams.append(column, `ov.${value}`);\n        }\n        else {\n            // array\n            this.url.searchParams.append(column, `ov.{${value.join(',')}}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for text and tsvector columns. Match only rows where\n     * `column` matches the query string in `query`.\n     *\n     * @param column - The text or tsvector column to filter on\n     * @param query - The query text to match with\n     * @param options - Named parameters\n     * @param options.config - The text search configuration to use\n     * @param options.type - Change how the `query` text is interpreted\n     */\n    textSearch(column, query, { config, type } = {}) {\n        let typePart = '';\n        if (type === 'plain') {\n            typePart = 'pl';\n        }\n        else if (type === 'phrase') {\n            typePart = 'ph';\n        }\n        else if (type === 'websearch') {\n            typePart = 'w';\n        }\n        const configPart = config === undefined ? '' : `(${config})`;\n        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Match only rows where each column in `query` keys is equal to its\n     * associated value. Shorthand for multiple `.eq()`s.\n     *\n     * @param query - The object to filter with, with column names as keys mapped\n     * to their filter values\n     */\n    match(query) {\n        Object.entries(query).forEach(([column, value]) => {\n            this.url.searchParams.append(column, `eq.${value}`);\n        });\n        return this;\n    }\n    /**\n     * Match only rows which doesn't satisfy the filter.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to be negated to filter with, following\n     * PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */\n    not(column, operator, value) {\n        this.url.searchParams.append(column, `not.${operator}.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows which satisfy at least one of the filters.\n     *\n     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure it's properly sanitized.\n     *\n     * It's currently not possible to do an `.or()` filter across multiple tables.\n     *\n     * @param filters - The filters to use, following PostgREST syntax\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to filter on referenced tables\n     * instead of the parent table\n     * @param options.foreignTable - Deprecated, use `referencedTable` instead\n     */\n    or(filters, { foreignTable, referencedTable = foreignTable, } = {}) {\n        const key = referencedTable ? `${referencedTable}.or` : 'or';\n        this.url.searchParams.append(key, `(${filters})`);\n        return this;\n    }\n    /**\n     * Match only rows which satisfy the filter. This is an escape hatch - you\n     * should use the specific filter methods wherever possible.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to filter with, following PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */\n    filter(column, operator, value) {\n        this.url.searchParams.append(column, `${operator}.${value}`);\n        return this;\n    }\n}\nexports.default = PostgrestFilterBuilder;\n//# sourceMappingURL=PostgrestFilterBuilder.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","__importDefault","mod","__esModule","Object","defineProperty","value","PostgrestTransformBuilder_1","PostgrestFilterBuilder","default","eq","column","url","searchParams","append","neq","gt","gte","lt","lte","like","pattern","likeAllOf","patterns","join","likeAnyOf","ilike","ilikeAllOf","ilikeAnyOf","is","in","values","cleanedValues","Array","from","Set","map","s","RegExp","test","contains","isArray","JSON","stringify","containedBy","rangeGt","range","rangeGte","rangeLt","rangeLte","rangeAdjacent","overlaps","textSearch","query","config","type","typePart","undefined","configPart","match","entries","forEach","not","operator","or","filters","foreignTable","referencedTable","key","filter"]
}
