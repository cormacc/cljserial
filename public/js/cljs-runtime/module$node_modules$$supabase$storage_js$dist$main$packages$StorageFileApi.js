shadow$provide.module$node_modules$$supabase$storage_js$dist$main$packages$StorageFileApi = function(global, require, module, exports) {
  var Buffer = require("module$node_modules$buffer$index").Buffer;
  "use strict";
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", {value:!0});
  const errors_1 = require("module$node_modules$$supabase$storage_js$dist$main$lib$errors"), fetch_1 = require("module$node_modules$$supabase$storage_js$dist$main$lib$fetch"), helpers_1 = require("module$node_modules$$supabase$storage_js$dist$main$lib$helpers"), DEFAULT_SEARCH_OPTIONS = {limit:100, offset:0, sortBy:{column:"name", order:"asc"}}, DEFAULT_FILE_OPTIONS = {cacheControl:"3600", contentType:"text/plain;charset\x3dUTF-8", upsert:!1};
  class StorageFileApi {
    constructor(url, headers = {}, bucketId, fetch) {
      this.url = url;
      this.headers = headers;
      this.bucketId = bucketId;
      this.fetch = (0,helpers_1.resolveFetch)(fetch);
    }
    uploadOrUpdate(method, path, fileBody, fileOptions) {
      return __awaiter(this, void 0, void 0, function*() {
        try {
          let body;
          const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
          let headers = Object.assign(Object.assign({}, this.headers), "POST" === method && {"x-upsert":String(options.upsert)});
          const metadata = options.metadata;
          "undefined" !== typeof Blob && fileBody instanceof Blob ? (body = new FormData(), body.append("cacheControl", options.cacheControl), metadata && body.append("metadata", this.encodeMetadata(metadata)), body.append("", fileBody)) : "undefined" !== typeof FormData && fileBody instanceof FormData ? (body = fileBody, body.append("cacheControl", options.cacheControl), metadata && body.append("metadata", this.encodeMetadata(metadata))) : (body = fileBody, headers["cache-control"] = `max-age=${options.cacheControl}`, 
          headers["content-type"] = options.contentType, metadata && (headers["x-metadata"] = this.toBase64(this.encodeMetadata(metadata))));
          if (null === fileOptions || void 0 === fileOptions ? 0 : fileOptions.headers) {
            headers = Object.assign(Object.assign({}, headers), fileOptions.headers);
          }
          const cleanPath = this._removeEmptyFolders(path), _path = this._getFinalPath(cleanPath), res = yield this.fetch(`${this.url}/object/${_path}`, Object.assign({method, body, headers}, (null === options || void 0 === options ? 0 : options.duplex) ? {duplex:options.duplex} : {})), data = yield res.json();
          return res.ok ? {data:{path:cleanPath, id:data.Id, fullPath:data.Key}, error:null} : {data:null, error:data};
        } catch (error) {
          if ((0,errors_1.isStorageError)(error)) {
            return {data:null, error};
          }
          throw error;
        }
      });
    }
    upload(path, fileBody, fileOptions) {
      return __awaiter(this, void 0, void 0, function*() {
        return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
      });
    }
    uploadToSignedUrl(path, token, fileBody, fileOptions) {
      return __awaiter(this, void 0, void 0, function*() {
        const cleanPath = this._removeEmptyFolders(path);
        var _path = this._getFinalPath(cleanPath);
        _path = new URL(this.url + `/object/upload/sign/${_path}`);
        _path.searchParams.set("token", token);
        try {
          let body;
          const options = Object.assign({upsert:DEFAULT_FILE_OPTIONS.upsert}, fileOptions), headers = Object.assign(Object.assign({}, this.headers), {"x-upsert":String(options.upsert)});
          "undefined" !== typeof Blob && fileBody instanceof Blob ? (body = new FormData(), body.append("cacheControl", options.cacheControl), body.append("", fileBody)) : "undefined" !== typeof FormData && fileBody instanceof FormData ? (body = fileBody, body.append("cacheControl", options.cacheControl)) : (body = fileBody, headers["cache-control"] = `max-age=${options.cacheControl}`, headers["content-type"] = options.contentType);
          const res = yield this.fetch(_path.toString(), {method:"PUT", body, headers}), data = yield res.json();
          return res.ok ? {data:{path:cleanPath, fullPath:data.Key}, error:null} : {data:null, error:data};
        } catch (error) {
          if ((0,errors_1.isStorageError)(error)) {
            return {data:null, error};
          }
          throw error;
        }
      });
    }
    createSignedUploadUrl(path, options) {
      return __awaiter(this, void 0, void 0, function*() {
        try {
          let _path = this._getFinalPath(path);
          const headers = Object.assign({}, this.headers);
          if (null === options || void 0 === options ? 0 : options.upsert) {
            headers["x-upsert"] = "true";
          }
          const data = yield (0,fetch_1.post)(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, {headers}), url = new URL(this.url + data.url), token = url.searchParams.get("token");
          if (!token) {
            throw new errors_1.StorageError("No token returned by API");
          }
          return {data:{signedUrl:url.toString(), path, token}, error:null};
        } catch (error) {
          if ((0,errors_1.isStorageError)(error)) {
            return {data:null, error};
          }
          throw error;
        }
      });
    }
    update(path, fileBody, fileOptions) {
      return __awaiter(this, void 0, void 0, function*() {
        return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
      });
    }
    move(fromPath, toPath, options) {
      return __awaiter(this, void 0, void 0, function*() {
        try {
          return {data:yield (0,fetch_1.post)(this.fetch, `${this.url}/object/move`, {bucketId:this.bucketId, sourceKey:fromPath, destinationKey:toPath, destinationBucket:null === options || void 0 === options ? void 0 : options.destinationBucket}, {headers:this.headers}), error:null};
        } catch (error) {
          if ((0,errors_1.isStorageError)(error)) {
            return {data:null, error};
          }
          throw error;
        }
      });
    }
    copy(fromPath, toPath, options) {
      return __awaiter(this, void 0, void 0, function*() {
        try {
          return {data:{path:(yield (0,fetch_1.post)(this.fetch, `${this.url}/object/copy`, {bucketId:this.bucketId, sourceKey:fromPath, destinationKey:toPath, destinationBucket:null === options || void 0 === options ? void 0 : options.destinationBucket}, {headers:this.headers})).Key}, error:null};
        } catch (error) {
          if ((0,errors_1.isStorageError)(error)) {
            return {data:null, error};
          }
          throw error;
        }
      });
    }
    createSignedUrl(path, expiresIn, options) {
      return __awaiter(this, void 0, void 0, function*() {
        try {
          let _path = this._getFinalPath(path), data = yield (0,fetch_1.post)(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({expiresIn}, (null === options || void 0 === options ? 0 : options.transform) ? {transform:options.transform} : {}), {headers:this.headers});
          data = {signedUrl:encodeURI(`${this.url}${data.signedURL}${(null === options || void 0 === options ? 0 : options.download) ? `&download=${!0 === options.download ? "" : options.download}` : ""}`)};
          return {data, error:null};
        } catch (error) {
          if ((0,errors_1.isStorageError)(error)) {
            return {data:null, error};
          }
          throw error;
        }
      });
    }
    createSignedUrls(paths, expiresIn, options) {
      return __awaiter(this, void 0, void 0, function*() {
        try {
          const data = yield (0,fetch_1.post)(this.fetch, `${this.url}/object/sign/${this.bucketId}`, {expiresIn, paths}, {headers:this.headers}), downloadQueryParam = (null === options || void 0 === options ? 0 : options.download) ? `&download=${!0 === options.download ? "" : options.download}` : "";
          return {data:data.map(datum => Object.assign(Object.assign({}, datum), {signedUrl:datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null})), error:null};
        } catch (error) {
          if ((0,errors_1.isStorageError)(error)) {
            return {data:null, error};
          }
          throw error;
        }
      });
    }
    download(path, options) {
      return __awaiter(this, void 0, void 0, function*() {
        const renderPath = "undefined" !== typeof(null === options || void 0 === options ? void 0 : options.transform) ? "render/image/authenticated" : "object";
        var transformationQuery = this.transformOptsToQueryString((null === options || void 0 === options ? void 0 : options.transform) || {});
        transformationQuery = transformationQuery ? `?${transformationQuery}` : "";
        try {
          const _path = this._getFinalPath(path);
          return {data:yield (yield (0,fetch_1.get)(this.fetch, `${this.url}/${renderPath}/${_path}${transformationQuery}`, {headers:this.headers, noResolveJson:!0})).blob(), error:null};
        } catch (error) {
          if ((0,errors_1.isStorageError)(error)) {
            return {data:null, error};
          }
          throw error;
        }
      });
    }
    info(path) {
      return __awaiter(this, void 0, void 0, function*() {
        const _path = this._getFinalPath(path);
        try {
          const data = yield (0,fetch_1.get)(this.fetch, `${this.url}/object/info/${_path}`, {headers:this.headers});
          return {data:(0,helpers_1.recursiveToCamel)(data), error:null};
        } catch (error) {
          if ((0,errors_1.isStorageError)(error)) {
            return {data:null, error};
          }
          throw error;
        }
      });
    }
    exists(path) {
      return __awaiter(this, void 0, void 0, function*() {
        var _path = this._getFinalPath(path);
        try {
          return yield (0,fetch_1.head)(this.fetch, `${this.url}/object/${_path}`, {headers:this.headers}), {data:!0, error:null};
        } catch (error) {
          if ((0,errors_1.isStorageError)(error) && error instanceof errors_1.StorageUnknownError && (_path = error.originalError, [400, 404].includes(null === _path || void 0 === _path ? void 0 : _path.status))) {
            return {data:!1, error};
          }
          throw error;
        }
      });
    }
    getPublicUrl(path, options) {
      path = this._getFinalPath(path);
      const _queryString = [];
      var downloadQueryParam = (null === options || void 0 === options ? 0 : options.download) ? `download=${!0 === options.download ? "" : options.download}` : "";
      "" !== downloadQueryParam && _queryString.push(downloadQueryParam);
      downloadQueryParam = "undefined" !== typeof(null === options || void 0 === options ? void 0 : options.transform) ? "render/image" : "object";
      options = this.transformOptsToQueryString((null === options || void 0 === options ? void 0 : options.transform) || {});
      "" !== options && _queryString.push(options);
      options = _queryString.join("\x26");
      "" !== options && (options = `?${options}`);
      return {data:{publicUrl:encodeURI(`${this.url}/${downloadQueryParam}/public/${path}${options}`)}};
    }
    remove(paths) {
      return __awaiter(this, void 0, void 0, function*() {
        try {
          return {data:yield (0,fetch_1.remove)(this.fetch, `${this.url}/object/${this.bucketId}`, {prefixes:paths}, {headers:this.headers}), error:null};
        } catch (error) {
          if ((0,errors_1.isStorageError)(error)) {
            return {data:null, error};
          }
          throw error;
        }
      });
    }
    list(path, options, parameters) {
      return __awaiter(this, void 0, void 0, function*() {
        try {
          const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), {prefix:path || ""});
          return {data:yield (0,fetch_1.post)(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, {headers:this.headers}, parameters), error:null};
        } catch (error) {
          if ((0,errors_1.isStorageError)(error)) {
            return {data:null, error};
          }
          throw error;
        }
      });
    }
    encodeMetadata(metadata) {
      return JSON.stringify(metadata);
    }
    toBase64(data) {
      return "undefined" !== typeof Buffer ? Buffer.from(data).toString("base64") : btoa(data);
    }
    _getFinalPath(path) {
      return `${this.bucketId}/${path}`;
    }
    _removeEmptyFolders(path) {
      return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
    }
    transformOptsToQueryString(transform) {
      const params = [];
      transform.width && params.push(`width=${transform.width}`);
      transform.height && params.push(`height=${transform.height}`);
      transform.resize && params.push(`resize=${transform.resize}`);
      transform.format && params.push(`format=${transform.format}`);
      transform.quality && params.push(`quality=${transform.quality}`);
      return params.join("\x26");
    }
  }
  exports.default = StorageFileApi;
};

//# sourceMappingURL=module$node_modules$$supabase$storage_js$dist$main$packages$StorageFileApi.js.map
