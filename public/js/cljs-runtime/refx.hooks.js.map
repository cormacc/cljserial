{"version":3,"sources":["refx/hooks.cljs"],"mappings":";;;AAKA;;;;;;;uBAAA,vBAAOA,sDAMJC;AANH,AAOE,IAAMC,MAAI,AAACC,uCAAaF;AAAxB,AACE,GAAM,AAACG,gDAAK,AAAWF,YAAKD;AAA5B,AACE,CAAM,AAAWC,cAAKD;;AADxB;;AADF,QAGO,AAAWC;;AAEpB,GAAA,QAAAG,iCAAAC,uCAAAC;AAAA;AAAA,AAAA,AAAmBC,6BAAgB,6CAAA,7CAACC;;AAEpC;;;qBAAA,rBAAMC,kDAEHC;AAFH,AAME,IAAMG,MAAI,AAACC,cAASJ;IAApBC,aAEM,AAACM,wCACA;AAAA,AAAA,0FACG,WAAKC;AAAL,AACE,IAAMC,MAAI,CAAA,uDAAgB,AAACC,mDAAMb,2BAAgBc;AAAjD,AACE,AAACC,wBAAmBT,IAAIM,IAAID;;AAD9B;AAAA,AAEG,OAACK,2BAAsBV,IAAIM;;GAChC;AAAA,AACE,OAACK,iBAAYX;;GAClB,AAACd,qBAAUc;gBAVlB,AAAAD,4CAAAD,WAAA,IAAA,vEACOI;eADP,AAAAH,4CAAAD,WAAA,IAAA,tEACiBK;AADjB,AAaE,AAACS,8CAAoBf,QAAQgB;;AAC7B,OAACC,4EAAqBZ,UAAUC","names":["refx.hooks/cljs-deps","deps","ref","js/module$node_modules$react$index.useRef","cljs.core.not_EQ_","js/refx","js/refx.hooks","js/refx.hooks.use-sub-counter","refx.hooks/use-sub-counter","cljs.core.atom","refx.hooks/use-sub","query-v","vec__86674","cljs.core.nth","sub","refx.subs/sub","subscribe","snapshot","js/module$node_modules$react$index.useMemo","callback","key","cljs.core.swap_BANG_","cljs.core/inc","refx.subs/-add-listener","refx.subs/-remove-listener","refx.subs/-value","js/module$node_modules$react$index.useDebugValue","cljs.core/str","js/module$node_modules$use_sync_external_store$shim$index.useSyncExternalStore"],"sourcesContent":["(ns refx.hooks\n  (:require [\"react\" :as react]\n            [\"use-sync-external-store/shim\" :refer [useSyncExternalStore]]\n            [refx.subs :as subs]))\n\n(defn- cljs-deps\n  \"Uses a Ref to track ClojureScript values as dependencies, yielding\n   a new JavaScript array whenever the dependencies change.  This is\n   useful as React does not know about ClojureScript's equality semantics,\n   but will check for identical objects instead, leading to false\n   re-renders and possible infinite loops.\"\n  [deps]\n  (let [ref (react/useRef deps)]\n    (when (not= (.-current ref) deps)\n      (set! (.-current ref) deps))\n    #js [(.-current ref)]))\n\n(defonce ^:private use-sub-counter (atom 0))\n\n(defn use-sub\n  \"React hook to subscribe to signals.\"\n  [query-v]\n  ;; Subs are cached, so no need to memoize them again.  Retrieving them\n  ;; on every render allows us to pick up changes in dev workflows, where\n  ;; we use clear-subscription-cache! on refresh.\n  (let [sub (subs/sub query-v)\n        [subscribe snapshot]\n        (react/useMemo\n         (fn []\n           [(fn [callback]\n              (let [key (str \"use-sub-\" (swap! use-sub-counter inc))]\n                (subs/-add-listener sub key callback)\n                #(subs/-remove-listener sub key)))\n            (fn []\n              (subs/-value sub))])\n         (cljs-deps sub))]\n    ;; Expose the query vector in React DevTools.  The current value will\n    ;; be inspectable by `useSyncExternalStore` already.\n    (react/useDebugValue query-v str)\n    (useSyncExternalStore subscribe snapshot)))\n"],"x_google_ignoreList":[0]}