{"version":3,"sources":["replicant/asserts.cljc"],"mappings":"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","names":["replicant.asserts/camel->dash","s","cljs.core/re-seq","cljs.core.map","clojure.string/lower-case","clojure.string.join","replicant.asserts/camel->dash-k","k","cljs.core.keyword","cljs.core/name","replicant.asserts/has-bad-conditional-attrs?","vdom","headers","cljs.core/count","vec__61406","cljs.core.nth","vec__61409","new-selector","new-attrs","old-selector","old-attrs","cljs.core.not_EQ_","cljs.core/map?","replicant.asserts/abbreviate-map","m","n","cljs.core.take","cljs.core.mapv","p__61429","vec__61430","v","cljs.core.pr_str","replicant.asserts/abbreviate-node","x","replicant.hiccup/hiccup?","cljs.core/first","cljs.core/coll?","replicant.asserts/format-hiccup-part","cljs.core._EQ_","replicant.asserts/convey-bad-conditional-attributes","vec__61434","or__5002__auto__","cljs.core/not-empty","cljs.core/second"],"sourcesContent":["(ns ^:no-doc replicant.asserts\n  (:require [clojure.string :as str]\n            [replicant.assert :as assert]\n            [replicant.hiccup-headers :as hiccup]\n            [replicant.hiccup :as h]\n            [replicant.vdom :as vdom])\n  #?(:cljs (:require-macros replicant.asserts)))\n\n(defmacro assert-no-class-name [headers]\n  `(assert/assert\n    (not (contains? (hiccup/attrs ~headers) :className))\n    \"Use :class, not :className\"\n    \":className is not supported, please use :class instead. It takes a keyword, a string, or a collection of either of those.\"\n    (hiccup/sexp ~headers)))\n\n(defmacro assert-no-space-separated-class [headers]\n  `(assert/assert\n    (let [class# (:class (hiccup/attrs ~headers))]\n      (or (not (string? class#)) (< (.indexOf class# \" \") 0)))\n    \"Avoid space separated :class strings\"\n    (let [class# (:class (hiccup/attrs ~headers))]\n      (str \":class supports collections of keywords and/or strings as classes. These perform better, and are usually more convenient to work with. Solve by converting \"\n           (pr-str class#) \" to \" (pr-str (vec (.split class# \" \")))))\n    (hiccup/sexp ~headers)))\n\n(defmacro assert-no-string-style [headers]\n  `(assert/assert\n    (not (string? (:style (hiccup/attrs ~headers))))\n    \"Avoid string styles\"\n    \":style supports structured maps of CSS property/value pairs. Strings must be parsed, so they're both slower and harder to read and write.\"\n    (hiccup/sexp ~headers)))\n\n(defmacro assert-event-handler-casing [k]\n  `(assert/assert\n    (let [event# (name ~k)]\n      (or (= \"DOMContentLoaded\" event#)\n          (= event# (str/lower-case event#))))\n    (str \"Use \" (keyword (str/lower-case (name ~k))) \", not \" ~k)\n    (str \"Most event names should be in all lower-case. Replicant passes your event names directly to addEventListener, and mis-cased event names will fail silently.\")))\n\n(defmacro assert-style-key-type [k]\n  `(assert/assert\n    (keyword? ~k)\n    (str \"Style key \" ~k \" should be a keyword\")\n    (str \"Replicant expects your style keys to be keywords. While anything that supports `name` (strings, symbols) will \"\n         \"technically work, mixing types will hinder Replicant from recognizing changes properly. Rendering once with \"\n         (str ~k) \" and once with \" (keyword (str ~k))\n         \" may produce undesired results. Your safest option is to always use keywords.\")))\n\n(defmacro assert-non-empty-id [tag]\n  `(assert/assert\n    (not (re-find #\"#($|\\.)\" (str ~tag)))\n    (str \"Hiccup tag \" ~tag \" contains an empty id\")\n    \"Either complete the id or remove the # character.\"))\n\n(defmacro assert-valid-id [tag]\n  `(assert/assert\n    (not (re-find #\"#[^a-zA-Z_\\.]\" (str ~tag)))\n    (str \"Hiccup tag \" ~tag \" contains an invalid id\")\n    \"IDs must start with a letter.\"))\n\n(defmacro assert-non-empty-class [tag]\n  `(assert/assert\n    (not (re-find #\"\\.$\" (str ~tag)))\n    (str \"Hiccup tag \" ~tag \" contains an empty class\")\n    \"This may cause a DOMException and is considered a coding error. Replicant will not sacrifice performance to work around it.\"))\n\n(defn camel->dash [s]\n  (->> s\n       (re-seq #\"[A-Z][a-z0-9]*|[a-z0-9]+\")\n       (map str/lower-case)\n       (str/join \"-\")))\n\n(defn camel->dash-k [k]\n  (keyword (camel->dash (name k))))\n\n(defmacro assert-style-key-casing [k]\n  `(assert/assert\n    (let [name# (name ~k)]\n      (or (str/starts-with? name# \"--\")\n          (= name# (str/lower-case name#))))\n    (str \"Use \" (camel->dash-k ~k) \", not \" ~k)\n    \"Replicant passes style keys directly to `el.style.setProperty`, which expects CSS-style dash-cased property names.\"))\n\n(defmacro assert-no-event-attribute [k]\n  `(assert/assert\n    (not (str/starts-with? (name ~k) \"on\"))\n    \"Set event listeners in the :on map\"\n    (str \"Event handler attributes are not supported. Instead of \"\n         ~k \" set :on {\" (keyword (camel->dash (.substring (name ~k) 2))) \" ,,,}\")))\n\n(defmacro assert-valid-attribute-name [attr v]\n  `(assert/assert\n    (re-find #\"^[a-zA-Z\\-:_][a-zA-Z0-9\\-:\\._]*$\" (name ~attr))\n    (str \"Invalid attribute name \" (name ~attr))\n    (let [attr# (name ~attr)]\n      (str \"Tried to set attribute \" attr# \" to value \" ~v \". This will fail\"\n           \"horribly in the browser because \"\n           (cond\n             (re-find #\"^[0-9]\" attr#)\n             \" it starts with a number\"\n\n             (re-find #\"^\\.\" attr#)\n             \" it starts with a dot\"\n\n             :else\n             (str \" it contains the character \" (re-find #\"[^a-zA-Z0-9\\-:\\._]\" attr#)))\n           \", which isn't allowed as per the HTML spec.\"))))\n\n(defn has-bad-conditional-attrs? [vdom headers]\n  (if (or (< 0 (count (hiccup/children headers)))\n          (< 0 (count (vdom/children vdom))))\n    (let [[new-selector new-attrs] (hiccup/sexp headers)\n          [old-selector old-attrs] (vdom/sexp vdom)]\n      (cond\n        (not= new-selector old-selector) false\n        (nil? new-attrs) (map? old-attrs)\n        (map? new-attrs) (nil? old-attrs)\n        :else false))\n    false))\n\n(defn abbreviate-map [m n]\n  (str \"{\" (->> (take n m)\n                (mapv (fn [[k v]]\n                        (str k \" \" (if (map? v)\n                                     (abbreviate-map v n)\n                                     (pr-str v)))))\n                (str/join \", \"))\n       (when (< n (count m))\n         \" ,,,\")\n       \"}\"))\n\n(defn abbreviate-node [x]\n  (cond\n    (h/hiccup? x)\n    (str \"[\" (first x) \" ,,,]\")\n\n    (nil? x)\n    \"nil\"\n\n    (string? x)\n    (if (< 20 (count x))\n      (str (str/join (take 20 x)) \"...\")\n      x)\n\n    (coll? x)\n    (str \"(,,,)\")\n\n    :else\n    (pr-str x)))\n\n(defn format-hiccup-part [x]\n  (cond\n    (map? x)\n    (abbreviate-map x 2)\n\n    (h/hiccup? x)\n    (let [s (pr-str x)]\n      (if (< (count s) 20)\n        s\n        (abbreviate-node x)))\n\n    (coll? x)\n    (if (= 1 (count x))\n      (str \"(\" (abbreviate-node (first x)) \")\")\n      (str \"(\" (abbreviate-node (first x)) \" ,,,)\"))\n\n    :else\n    (pr-str x)))\n\n(defn convey-bad-conditional-attributes [vdom headers]\n  (let [[k v] (first (or (not-empty (vdom/attrs vdom))\n                         (not-empty (hiccup/attrs headers))))]\n    (str \"Replicant treats nils as hints of nodes that come and go. Wrapping \"\n         \"the entire attribute map in a conditional such that what used to be \"\n         (format-hiccup-part (second (vdom/sexp vdom))) \" is now \"\n         (format-hiccup-part (second (hiccup/sexp headers)))\n         \" can impair how well Replicant can match up child nodes without keys, and \"\n         \"may lead to undesirable behavior for life-cycle events and transitions.\\n\\n\"\n         \"Instead of:\\n[\" (first (hiccup/sexp headers))\n         \" (when something? {\"\n         (when k\n           (str k \" \" (pr-str v)))\n         \"}) ,,,]\\n\\nConsider:\\n[\"\n         (first (hiccup/sexp headers))\n         (if k\n           (str \"\\n  \"\n                \"(cond-> {}\\n    something? (assoc \" k \" \" (pr-str v) \"))\\n\")\n           \" {}\")\n         \" ,,,]\")))\n\n(defmacro assert-no-conditional-attributes [headers vdom]\n  `(assert/assert\n    (not (has-bad-conditional-attrs? ~vdom ~headers))\n    \"Avoid conditionals around the attribute map\"\n    (convey-bad-conditional-attributes ~vdom ~headers)))\n\n(defmacro assert-alias-exists [tag-name f available-aliases]\n  `(assert/assert\n    (fn? ~f)\n    (str \"Alias \" ~tag-name \" isn't defined\")\n    (str \"There's no available function to render this alias. Replicant will \"\n         \"render an empty element with data attributes in its place. Available \"\n         \"aliases are:\\n\" (str/join \"\\n\" ~available-aliases))))\n\n(defmacro assert-valid-alias-result [tag-name hiccup]\n  `(assert/assert\n    (or (string? ~hiccup) (h/hiccup? ~hiccup))\n    (str \"Aliases must return valid hiccup\")\n    (str \"Aliases must always represent a node in the document, and \"\n         \"cannot return \" (cond\n                            (nil? ~hiccup) \"nil\"\n                            (map? ~hiccup) \"a map\"\n                            (coll? ~hiccup) \"multiple nodes\"\n                            :else (pr-str ~hiccup))\n         \". Please check the implementation of \" ~tag-name \".\")))\n"],"x_google_ignoreList":[0]}