{"version":3,"sources":["zprint/zprint.cljc"],"mappings":";AA0CA;;;qBAAA,rBAAMA,kDAEHC;AAFH,AAGE,OAACC,8CAAMC,cAAI,iDAAA,jDAACC,+CAAOH;;AAWrB,AAAA;;;8BAAA,sCAAAI,pEAAMM;AAAN,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,iEAAA,CAAA,UAAA,MAAAF;;;AAAA,AAAA,CAAA,mEAAA,nEAAME,8EAEHM,GAAKC;AAFR,AAGE,OAACC,+CAAOC,qBAAMH,GAAGC;;;AAHnB,CAAA,sDAAA,tDAAMP;;AAAN;AAAA,CAAA,gDAAA,WAAAC,3DAAMD;AAAN,AAAA,IAAAE,WAAA,AAAAC,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;AAAA,AAAA,IAAAI,qBAAA;AAAA,AAAA,OAAAA,wDAAAH,SAAAD;;;AAAA,AAKA;;;;2BAAA,3BAAMS,8DAGHC;AAHH,AAIE,IAAAC,qBAAiB,wDAAA,xDAACE,sDAAwBH;AAA1C,AAAA,oBAAAC;AAAA,cAAAA,VAASC;AAAT,AAAA,0FACG,+CAAA,/CAACE,6CAAKJ,MAAIE,SAAS,AAACE,6CAAKJ,EAAE,WAAA,VAAKE;;AADnC,0FAEGF;;;AAEL,AAAA;;;;;;;;;6CAAA,qDAAAjB,lGAAMuB;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,yEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,yEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,2EAAA,3EAAMD,sFAQFE,QAAQC,QAAQC,UAAUC;AAR9B,AASG,IAAMA,sBAAU,mCAAA,oYAAA,rZAAMA,iBACJ,sUAAA,pTAAI,AAAA,kGAAeF,UACjB,qIAAA,AAAA,6DAAA,hLAAM,AAAA,yGAAkBD;IAF5CI,aAI6B,gEAAA,KAAA,rEAACK,0EAGkCT,QACAC,QACAE;kBAThE,AAAAE,4CAAAD,WAAA,IAAA,zEAIOE;QAJP,AAAAD,4CAAAD,WAAA,IAAA,/DAImBG;aAJnB,AAAAF,4CAAAD,WAAA,IAAA,pEAIqBI;IAMfA,aAAO,0BAAA,sKAAA,9KAAMA,QACJ,CAAA,iFAAA,XAA+BN,6EACJM;AAZ1C,AAaE,GAAI,GAAK,AAACE,uBAAOF;AACf,MAAO,KAAAT,MAECS;;AAHV,0FAIGF,YAAYL;;;;AA1BpB,CAAA,2EAAA,3EAAMH,sFA2BFE,QAAQC,QAAQC;AA3BpB,AA4BG,0GAAA,nGAACS,yEAA6BX,QAAQC,QAAQC;;;AA5BjD,CAAA,qEAAA,rEAAMJ;;AAAN,AA8BA;;;;;+BAAA,/BAAMc,sEAIHC;AAJH,AAKE,IAAA,AAAK,IAAME,iBAAe,CAACF,0CAAAA,4CAAAA;AAAtB,AACE,GAAM,OAASE;AAAf,AAA+B,QAAA,0BAAA,fAAgBA;;AAA/C;;gBADP,QAAAD,JAIOE;AAJP,AAAA;;AAQF;;;oCAAA,pCAAMC,gFAEHC;AAFH,AAGE,GAAM,yLAAA,zLAACC,6CAAE,CAACC,iDAAAA,uDAAAA,RAAKF,oCAAAA;AAAf,AAA6B,QAACG,0DAAAA,gEAAAA,RAAQH,6CAAAA;;AAAtC;;;AAEF;;;;2BAAA,3BAAMI,8DAGHJ;AAHH,AAIE,GAAM,yLAAA,zLAACC,6CAAE,CAACC,iDAAAA,uDAAAA,RAAKF,oCAAAA;AAAf,AAAA;;AAAA,GACM,yLAAA,zLAACC,6CAAE,CAACC,iDAAAA,uDAAAA,RAAKF,oCAAAA;AADf;;AAAA,GAEM,yLAAA,zLAACC,6CAAE,CAACC,iDAAAA,uDAAAA,RAAKF,oCAAAA;AAFf;;AAAA,GAGM,yLAAA,zLAACC,6CAAE,CAACC,iDAAAA,uDAAAA,RAAKF,oCAAAA;AAHf;;AAAA;;;;;;AAKF;;;0BAAA,1BAAMK,4DAEHvB,QAAQkB;AAFX,AAGE,IAAA,AACE,QAACO,mDAAAA,yDAAAA,RAAOP,sCAAAA;gBADV,QAAAM,JAIIR;AAJJ,AAKI,IACMxB,IAAE,CAACkC,oDAAAA,0DAAAA,RAAQR,uCAAAA;IACXS,QAAM,+CAAA,WAAAC,iBAAAC,3EAACxC;AAAD,AAAS,8BAAAuC,iBAAAC,iBAAA,zDAACC;GACRtC,EACA,AAAA,oHAAwB,AAAA,sFAAQQ;IAMxC+B,QACE,iBAAA,AACE,IAAM5D,IAAE,AAAC8D,gCAAe,AAACC,oBAAoBP;IACvCQ,WAAS,AAACC,4DAASjE;IACnB4D,QAAM,CAACN,mDAAAA,6DAAAA,ZAAOU,0CAAAA;AAFpB,AAGEJ;gBAJJ,YAAAC,RAOIhB;AAPJ,AAQI,MACE,KAAAjB,MAEC,CAAA,8EAAA,oEAAA,gDAAA,vHACiCP,gEACdwB;;AAxBlC,AA4BEe;;AAER;;;iCAAA,jCAAMM,0EAEHrC,QAAQkB;AAFX,AAGE,IAAA,AAAK,OAACK,wBAAUvB,QAAQkB;gBAAxB,QAAAoB,JAGOtB;AAHP,AAAA;;AAOF;;;;;+BAAA,/BAAMuB,sEAIHC,OAAOxC,QAAQa,UAAUK,KAAKuB,MAAMC;AAJvC,AAME,IAAME,YAAU,AAACrB,wBAAUvB,QAAQkB;IAG7BlB,cAAQ,6DAAA,6GAAA,6DAAA,6DAAA,pSAAC6C,qDAAM7C,8DACCkB,8GACCuB,6DACAC,gEACCF;IAClBjC,IAAE,kBAAA,AAAAuC,eAAA,iFAAA,8EAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,iCAAA,uBAAA,6BAAA,zTAAO/C,uNAAAA,uCAE0BwC,oBACb3B,uBACA+B;IAZ5BD,aAcQ,AAAChC,yEACCX,YACA,iBAAA,AAAK,oBAAA,AAAA,mFAAQA;AAAR,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,rHAAQnD,iJAAoC4C;;AAA5C;;AACA,IAAMQ,SAAO,iBAAAC,WAAWrD;IAAXsD,WAAmB,AAACE,gBAAMZ;IAA1BW,WAAqCX;AAArC,AAAA,0FAAAS,SAAAC,SAAAC,iCAAAF,SAAAC,SAAAC,vJAAC1C,0CAAAA,sEAAAA;;AAAd,AACE,oBAAA,AAAAiC,eAAA,iFAAA,8EAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,bAAO/C,sCAGAoD;;AAHP;;AAIAA;gBANP,QAAAF,JASOlC;AATP,AAUO,AAAI,oBAAA,AAAA8B,eAAA,iFAAA,uDAAA,+FAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,bAAO/C,qCAGA,kBAAOgB;;AAHd;;AAIA,MAAO,KAAAjB,MAEC,CAAA,6DAAA,4GAAA,pHAAcyC,2EACc,AAAC5B,6BACCC,+EACFG;mRArBjD,7QAsBE,qDAAA,mGAAA,3GAAKwB,kEACc,AAAC5B,6BAAeC,2FACK,AAAC2C,gBAAMZ;qBAtCzD,AAAAvC,4CAAAsC,WAAA,IAAA,5EAaOK;kBAbP,AAAA3C,4CAAAsC,WAAA,IAAA,zEAasBM;IA2BhBd,WAAS,AAAA,4FAAWa;IACpBS,YAAU,AAAA,8FAAYT;IACtBU,YAAU,AAAA,4FAAYV;AA1C5B,AA2CE,oBAAA,AAAA,mFAAQhD;AAAR,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,iCAAA,oEAAA,1NAAQnD,+IAEAwC,mCAGA,AAAC5B,6BAAeC,qCAEhBoC;;AAPR;;AA3CF,0FAmDG,qEAAA,4GAAA,sDAAA,8DAAA,uDAAA,gEAAA,uDAAA,ndAACU,sDAAOX,ieAQR,iBAAAY,mBAAIzB;AAAJ,AAAA,oBAAAyB;AAAAA;;AAAa1C;;KACb,iBAAA0C,mBAAIH;AAAJ,AAAA,oBAAAG;AAAAA;;AAAcnB;;KACd,iBAAAmB,mBAAIF;AAAJ,AAAA,oBAAAE;AAAAA;;AAAclB;;KAEd,kBAAM,iBAAAkB,mBAAIzB;AAAJ,AAAA,oBAAAyB;AAAAA;;AAAA,IAAAA,uBAAaH;AAAb,AAAA,oBAAAG;AAAAA;;AAAuBF;;;MAA7B,AAAA,KAAA;;AAEL;;;;;qCAAA,rCAAMG,kFAIHrB,OAAOxC,QAAQ8D,gBAAgB5C;AAJlC,AAKE,IAAM6C,cAAY,AAACxC,wBAAUvB,QAAQ,CAACgE,yDAAAA,+DAAAA,RAAa9C,4CAAAA;AAAnD,AACE,OAACP,yEACCX,QACA,iBAAA,AAAK,QAAC8D,gDAAAA,qEAAAA,vBAAgB9D,kDAAAA,1CAAQ+D,kDAAAA;gBAA9B,QAAAE,JAGOjD;AAHP,AAIO,MAAO,KAAAjB,MAEC,CAAA,4DAAA,wHAAA,mEAAA,nMAAayC,iFACqB,AAAC5B,6BACCkD,wEACrBC,8EACW/C;6PAZ3C,vPAaE,qDAAA,+GAAA,vHAAKwB,wEACoB,AAAC5B,6BAAekD,8EACpBC;;AAG3B;;;;;4BAAA,5BAAMG,gEAIH1B,OAAOxC;AAJV,AAKE,IAAMmE,eAAa,AAAA,iGAAcnE;AAAjC,AACE,oBAAMmE;AAAN,AACE,oBAAA,AAAArB,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,8BAAA,uGAAA,9IAAO/C,gCAEuBwC,gBACd,AAAA,qFAAQxC,kBACRmE;;AAJhB;;AAKA,GAAI,EAAK,AAAChD,6CAAEqB,OAAO,AAACxD,gBAAMmF,oBACjB,AAAChD,6CAAE,AAAA,qFAAQnB,SAAS,AAACoE,iBAAOD;AACnC,gEAAA,zDAAC9D,4CAAI8D;;AAFP;;;AANF;;;AAUJ,yBAAA,uCAAAE,SAAAC,zEAAMG,0DACHC;AADH,AAAA,IAAAH,aAAAF;UAAA,AAAAhE,4CAAAkE,WAAA,IAAA,jEACUI;yBADV,AAAAtE,4CAAAkE,WAAA,IAAA,hFACcK;oBADd,AAAAvE,4CAAAkE,WAAA,IAAA,3EACiCM;IADjCL,aAAAF;QAAA,AAAAjE,4CAAAmE,WAAA,IAAA,/DACiDhF;QADjD,AAAAa,4CAAAmE,WAAA,IAAA,/DACmDjE;WADnD,AAAAF,4CAAAmE,WAAA,IAAA,lEACqDM;cADrDN,VAC8DO;AAD9D,AAEE,IAAMC,YAAU,iIAAA,mIAAA,lQAAM,kDAAA,lDAAC7D,6CAAE2D,4DAAY,iBAAA,hBAAKD,uBACpB,kDAAA,lDAAC1D,6CAAE2D,8DAAa,iBAAA,hBAAKD,qBACfA;;IACtBI,sBAAc,CAAGJ,gBAAcH;IAC/BQ,4BAAoB,CAAGF,YAAUN;IACjCS,yBAAuB,EAAI,EAAIF,yBAAcC,6BACpB,6CAAKN,gEAAmBpF,aACxBoF;IACzBQ,0BACE,oDAAA,lDAAIF,2BAAoBC;AAThC,AAAA,0FAUG,wIAAA,8DAAA,8HAAA,mEAAA,rYAAM,EAAKF,yBAAc,GAAKC,+BACtB,AAACG,6CAAKV,IAAIQ,0BACZ,EAAKF,yBAAcC,6BAAqBP,MACxC,EAAK,GAAKM,2BAAe,GAAKC,+BAAsB,AAACG,6CAAKV,IACAI,WAC1D,EAAK,GAAKE,2BAAeC,6BAAqBP,IACxC,yGAAA,zGAAC5B;KAAiCqC,wBAC9CJ;;AAEL;;;+BAAA,/BAAMM,sEAEHZ,MAAMa;AAFT,AAGE,OAACvG,gBAAM,6HAAA,mFAAA,iCAAA,GAAA,pPAACK,+CAAO,AAACmG,gDAAQf,uBAASC,0IAAiBa;;AAc3C,AAAA,sBAAA,8BAAAhH,pDAAMmH;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,kDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,kDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA3F,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,oDAAA,pDAAM2F,+DACF1F,QAAQ2F,EAAEJ;AADd,AACoB,OAACK,4CAAID,EAAEJ;;;AAD3B,CAAA,oDAAA,pDAAMG,+DAEF1F,QAAQ2F,EAAEE,MAAMC;AAFpB,AAE2B,OAACF,4CAAID,EAAEE,MAAMC;;;AAFxC,CAAA,8CAAA,9CAAMJ;;AAAN,AAQT;;;;;oBAAA,pBAAMK,gDAIH/F,QAAQgG;AAJX,AAOWA;;AAMX,AAAKC,4BAAY,6CAAA,7CAACC;AAElB;;;;0BAAA,kCAAAC,5DAAMI,qEAGmDI,WAAWC,IACjEC;AAJH,AAAA,IAAAT,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;cAAAA,VAGgDpG;uBAHhD,AAAAsG,4CAAAF,eAAA,9EAGWI;iBAHX,AAAAF,4CAAAF,eAAA,xEAGsBK;qBAHtB,AAAAH,4CAAAF,eAAA,5EAGiCM;AAHjC,AAKE,oBAAMF;AAAN,AACE,oBAAIK;AACF,AAAI,+HAAA,iBAAA,hJAAC9D,yGAAQ0D,WAAWE,uCAAuCD;;AAC3D,OAACI,qGAAID;;AAET,sIAAA,/HAAC9D,yGAAQ0D,WAAWE;;;AALxB;;;AAWF;;;8BAAA,sCAAAI,pEAAME,6EAEkCtB;AAFxC,AAAA,IAAAqB,aAAAD;IAAAC,iBAAA,AAAAX,4BAAAW;cAAAA,VAE+BhH;aAF/B,AAAAsG,4CAAAU,eAAA,pEAEWE;mBAFX,AAAAZ,4CAAAU,eAAA,1EAEkBG;AAFlB,AAGE,oBAAM,iBAAAC,oBAAKD;AAAL,AAAA,oBAAAC;AAAY,UAAK,OAASzB;;AAA1ByB;;;AAAN,AACE,IAAMC,QAAM,4CAAK1B;IACXuB,aAAO,AAAA,sFAASlH;AADtB,AAEE,IAAA4D,mBAAI,CAACsD,2CAAAA,kDAAAA,TAAOG,+BAAAA;AAAZ,AAAA,oBAAAzD;AAAAA;;AAAA,IAAAA,uBACI,kBAAA,lBAAC0D,4BAAmBD;AADxB,AAAA,oBAAAzD;AAAAA;;AAEI,GAAI,cAAA2D,bAAS5B;AAKX,IAAA,AAAK,IAAA/B,uBAAI,kBAAA,lBAAC0D,4BACQ,4CAAK,AAAA,8EAAK,AAACG,eACc9B;AAFtC,AAAA,oBAAA/B;AAAAA;;AAGI,IAAA8D,WAAQ,AAACC,eAAKhC;AAAd,AAAA,4FAAA+B,kCAAAA,tHAACR,2CAAAA,qDAAAA;;gBAHV,QAAAM,JAMOxG;AANP,AAAA;;AALF;;;;;AALR;;;AAmBF;;;;oCAAA,4CAAA4G,hFAAME,yFAGuCnC;AAH7C,AAAA,IAAAkC,aAAAD;IAAAC,iBAAA,AAAAxB,4BAAAwB;cAAAA,VAGoC7H;kBAHpC,AAAAsG,4CAAAuB,eAAA,zEAGWE;mBAHX,AAAAzB,4CAAAuB,eAAA,1EAGuBV;AAHvB,AAIE,oBAAM,iBAAAC,oBAAKD;AAAL,AAAA,oBAAAC;AAAY,UAAK,OAASzB;;AAA1ByB;;;AAAN,AACE,IAAMC,QAAM,4CAAK1B;AAAjB,AACE,IAAA/B,mBAAI,AAAC0C,4CAAIyB,YAAYV;AAArB,AAAA,oBAAAzD;AAAAA;;AACI,GAAI,cAAA2D,bAAS5B;AAKX,IAAA,AAAK,IAAA/B,uBAAI,GAAK,AAAClD,uBAAO,4CAAK,AAAA,8EAAK,AAAC+G,eACc9B;AAD1C,AAAA,GAAA/B;AAAAA;;AAEI,OAAC0C,4CAAIyB,YAAY,AAACJ,eAAKhC;;gBAFhC,QAAAqC,JAKOhH;AALP,AAAA;;AALF;;;;AAHR;;;AAgBF,oCAAA,2CAAA,IAAA,IAAA,IAAA,IAAA,IAAA,nGAAKiH;AAML,AAAA,AACA,AAAA,AAEA;;;;;mCAAA,kDAAAC,sCAAAC,SAAAC,pIAAMO,8EAIHnG,gBAOcgH,SAASC,QAAQC;AAXlC,AAAA,IAAArB,aAAAH;IAAAG,iBAAA,AAAAhC,4BAAAgC;cAAAA,VAWQrI;IAXRsI,aAAA,AAAAhC,4CAAA+B,eAAA;IAAAC,iBAAA,AAAAjC,4BAAAiC;0BAAA,AAAAhC,4CAAAgC,eAAA,jFAMYS;IANZR,aAAA,AAAAjC,4CAAA+B,eAUM7F;IAVN+F,iBAAA,AAAAlC,4BAAAkC;IAAAC,aAAA,AAAAlC,4CAAAiC,eAAA;IAAAC,iBAAA,AAAAnC,4BAAAmC;gBAAA,AAAAlC,4CAAAkC,eAAA,vEAQaY;qBARb,AAAA9C,4CAAAkC,eAAA,5EAQuBa;sBARvB,AAAA/C,4CAAAkC,eAAA,7EAQsCc;gCARtC,AAAAhD,4CAAAkC,eAAA,vFAQsDe;kBARtD,AAAAjD,4CAAAiC,eAAA,zEAOYS;gBAPZ,AAAA1C,4CAAAiC,eAAA,vEAOwBU;gBAPxB,AAAA3C,4CAAAiC,eAAA,vEAOkCW;kBAPlC,AAAA5C,4CAAAiC,eAAA,zEAO4CY;YAP5C,AAAA7C,4CAAA+B,eAAA,nEAKWO;eALX,AAAAtC,4CAAA+B,eAAA,tEAKiBQ;iBALjB,AAAAvC,4CAAA+B,eAAA,xEAK0BS;IAL1BL,aAAAN;cAAA,AAAA9H,4CAAAoI,WAAA,IAAA,rEAYIkB;iBAZJ,AAAAtJ,4CAAAoI,WAAA,IAAA,xEAYYmB;mBAZZ,AAAAvJ,4CAAAoI,WAAA,IAAA,1EAYuBoB;aAZvB,AAAAxJ,4CAAAoI,WAAA,IAAA,pEAYoCqB;IAZpCpB,aAAAN;cAAA,AAAA/H,4CAAAqI,WAAA,IAAA,rEAY6CqB;iBAZ7C,AAAA1J,4CAAAqI,WAAA,IAAA,xEAYqDsB;QAZrD,AAAA3J,4CAAAqI,WAAA,IAAA,/DAYgEnI;aAZhE,AAAAF,4CAAAqI,WAAA,IAAA,pEAYkEuB;AAZlE,AAaE,IAAMC,kBAAgB,AAACC,eAAKN;IACtBZ,gBAAU,iBAAArF,mBAAIqF;AAAJ,AAAA,oBAAArF;AAAAA;;AAAA;;;IACVoF,kBAAY,iBAAApF,mBAAIoF;AAAJ,AAAA,oBAAApF;AAAAA;;AAAA;;;IACZuF,kBAAY,iBAAAvF,mBAAIuF;AAAJ,AAAA,oBAAAvF;AAAAA;;AAAgBmF;;;IAE5BqB,SAAO,AAAA,sFAASpK;IAChBoJ,gBAAU,iBAAAxF,mBAAIwF;AAAJ,AAAA,oBAAAxF;AAAAA;;AAAc,OAAA,4FAAYwG;;;IACpCf,qBAAe,iBAAAzF,mBAAIyF;AAAJ,AAAA,oBAAAzF;AAAAA;;AAAmB,OAAA,wGAAiBwG;;;IACnDd,sBAAgB,iBAAA1F,mBAAI0F;AAAJ,AAAA,oBAAA1F;AAAAA;;AAAoB,OAAA,wGAAkBwG;;;IACtDb,gCAAoB,iBAAA3F,mBAAI2F;AAAJ,AAAA,oBAAA3F;AAAAA;;AACI,OAAA,kHAAsBwG;;;IAQ9CpK,cAAQ,kBAAI,iBAAA4D,mBAAIkG;AAAJ,AAAA,oBAAAlG;AAAAA;;AAAWqG;;MAAQ,sDAAA,qDAAA,3GAACpH,8CAAM7C,mEAAoBA;IAC1DoD,SAAO,0BAAA,xBAAI,AAACiH,cAAIN,eAEP,iBAAA3C,oBAAKuC;AAAL,AAAA,oBAAAvC;AAAA,IAAAA,wBAGK,CAAI8C,mBAAgB,CAAGtB,QAAM,CAAC0B,2DAAAA,qEAAAA,ZAAazB,kDAAAA;AAHhD,AAAA,GAAAzB;AAAA,IAAAA,wBAMK,CAAIwC,cAAWhB;AANpB,AAAA,GAAAxB;AASK,IAAAxD,mBACE,aAAA,ZAAO+F;AADT,AAAA,GAAA/F;AAAAA;;AAEE,IAAAwD,wBACE,WAAA,VAAG2C;AADL,AAAA,GAAA3C;AAAA,IAAAA,wBAEE,WAAA,VAAGqC;AAFL,AAAA,GAAArC;AAKE,oBAAI,iBAAAA,wBAAK,AAACjG,6CAAEwI,QAAQI;AAAhB,AAAA,GAAA3C;AAAyBmC;;AAAzBnC;;;AAAJ;;AAIE,IAAAA,wBAAK,kCAAA,hCAAI,CAAIsC,eAAYT,qBAKlB,CAAI,CAAG,WAAA,VAAKU,iBAASF,YAAST;AALrC,AAAA,GAAA5B;AAAA,IAAAA,wBAMK,mDAAA,jCAAI8B,WAAU,CAAGS,UAAQT;AAN9B,AAAA,GAAA9B;AAOK,IAAMmD,SAAO,EAAI,sDAAA,tDAACpJ,6CAAEqI,iEACLH,mBACAD;AAFf,AAKE,GAAI,CAAGO,UAAQL;AACb,QAAI,WAAA,VAAKK,kBAASI;;AAYlB,QAAG,CAAG,CAAGJ,UAAQR,mBAAaY,WAC3BQ;;;AA1BZnD;;;AAAAA;;;;AATJA;;;AAAAA;;;;AAXPA;;;AAAAA;;;AAAAA;;;AArBf,AAoEE,oBAAA,AAAA,mFACEpH;AADF,AAAA,AAAA+C,yGAAA,AAAA,yJAAA,gBAAA,8BAAA,qBAAA,eAAA,qBAAA,+BAAA,uCAAA,+BAAA,tQACE/C,aACA,0BAAA,SAAA,jBAAIoD,oCACK0G,8BACctH,mBACXgH,kBACHZ,kBACGC,wBACGG,mCACIM,mCACJH,sDAEb,kBAAM,iBAAA/B,oBAAKuC;AAAL,AAAA,oBAAAvC;AAAA,IAAAA,wBAAa2C;AAAb,AAAA,oBAAA3C;AAAqB+B;;AAArB/B;;;AAAAA;;oDAZV,4JAAA,mBAAA,mBAAA,yBAAA,2BAAA,2BAAA,mCAAA,mBAAA,rXAYI,wCAAA,xCACE,CAAG,CAAGuC,UAAQR,mBAAaY,yBACrB,EAAI,sDAAA,tDAAC5I,6CAAEqI,iEAAgBH,mBAAeD,0BACrCK,mBACAE,sBACGC,0BACCF,yBACFT,iCACMiB,2BACRH,sBACGC;;AAtBhB;;AAuBA5G;;AAMJ;;;wBAAA,xBAAMoH,wDAEHxK;AAFH,AAGE,oBAAI,AAAA,4FAAWA;AACbA;;AACA,oBAAI,AAAA,kGAAcA;AAChB,6DAAA,tDAAC6C,8CAAM7C,sEAAkB,iBAAA4D,mBAAI,AAAA,qFAAQ5D;AAAZ,AAAA,oBAAA4D;AAAAA;;AAAA;;;;AACzB5D;;;;AAEN;;;;oCAAA,pCAAMyK,gFAGHlF;AAHH,AAIE,sBAAA,WAAAmF,1BAAC5H;AAAD,AAAO,GAAI,sBAAA4H,tBAACC;AAAS,8BAAAD,vBAAChK;;AAAU,QAAAgK,oBAAA;;GAAUnF;;AAe5C,AAAA;;;;wCAAA,gDAAAhH,xFAAMqM;AAAN,AAAA,IAAApM,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAoM,2EAAAjM;;;AAAA,AAAA,CAAA,6EAAA,7EAAMiM,wFAGDxL;AAHL,AAIE,IAAMgE,SAAO,AAAC/D,+CAAO,WAAK2L,EAAEC;AAAP,AACE,GAAI,AAACN,sBAAMM;AACT,GAAI,AAACvK,uBAAOuK;AAAG,yBAAA,lBAACC;;AAAa,OAAC7L,+CAAOC,qBAAM0L,EAAEC;;;AAC7C,GAAI,MAAA,LAAMA;AAAG,yBAAA,lBAACC;;AAAa,OAACC,mDAAMH,EAAEC;;;GAC9C,qBAAA,rBAACG,uDACDhM;AALf,AAME,oBAAMgE;AAAN,AAAa,OAACiI,2BAAYjI;;AAA1B;;;;AAVJ,CAAA,gEAAA,hEAAMwH;;AAAN;AAAA,CAAA,0DAAA,WAAAC,rEAAMD;AAAN,AAAA,IAAAE,qBAAA;AAAA,AAAA,OAAAA,wDAAA,AAAAC,cAAAF;;;AAAA,AAYA,AAAA,AACA,AAAA,AAEA,AAAA;;;;;;;;8BAAA,sCAAAtM,pEAAM+M;AAAN,AAAA,IAAA9M,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAA8M,iEAAA3M;;;AAAA,AAAA,CAAA,mEAAA,nEAAM2M,8EAODlM;AAPL,AAQE,IAAMgE,SAAO,AAAC/D,+CAAO,WAAK2L,EAAEC;AAAP,AACE,GAAI,AAACN,sBAAMM;AACT,GAAI,AAACvK,uBAAOuK;AAAG,yBAAA,lBAACC;;AAAa,OAAC7L,+CAAOC,qBAAM0L,EAAEC;;;AAC7C,GAAI,6CAAA,7CAAC9J,mGAAS8J;AAEZD;;AACA,GAAI,MAAA,LAAMC;AAAG,yBAAA,lBAACC;;AAAa,OAACC,mDAAMH,EAAEC;;;;GAChD,qBAAA,rBAACG,uDACDhM;AARf,AASE,oBAAMgE;AAAN,AACE,IAAMA,aAAO,AAACiI,2BAAYjI;AAA1B,AACE,GAAI,+BAAA,9BAAG,AAACI,gBAAMJ;AACZA;;AACA,IAAAoI,aAA4C,AAACG,eAAKvI;QAAlD,AAAA/C,4CAAAmL,WAAA,IAAA,/DAAOjL;YAAP,AAAAF,4CAAAmL,WAAA,IAAA,nEAASjL;WAAT,AAAAF,4CAAAmL,WAAA,IAAA,lEAAW1G;gBAAX,AAAAzE,4CAAAmL,WAAA,IAAA,vEAAgBC;mBAAhBD,fAA8BE;AAA9B,AACE,GAAI,kDAAA,lDAACvK,6CAAE2D;AAEL,IAAM+G,iBAAe,+BAAA,9BAAG,AAACrI,gBAAMJ;IAA/BwI,aAC8B,AAACvL,4CAAI+C,WAAOyI;QAD1C,AAAAxL,4CAAAuL,WAAA,IAAA,/DACOpM;YADP,AAAAa,4CAAAuL,WAAA,IAAA,nEACSE;oBADT,AAAAzL,4CAAAuL,WAAA,IAAA,3EACeG;AADf,AAEE,GAAI,EAAI,2DAAA,3DAAC5K,6CAAE4K,+EAAwB,2DAAA,3DAAC5K,6CAAE4K;AAEpC,GAAI,AAAC5K,6CAAE,CAAC6K,iEAAAA,oEAAAA,LAAmBxM,iDAAAA,IAAGiM;AAE5BrI;;AACA,mBAAA,fAAM6I,kGAAc,6CAAK,CAACC,2DAAAA,8DAAAA,LAAa1M,2CAAAA,iDACd,AAAC2M,sBAAOV,sBAAYK,MACzBC;AAFpB,AAGE,OAAClJ,8CAAMO,WAAOyI,eAAeI;;;AACjC7I;;;AACJA;;;;AAnBV;;;;AAjBJ,CAAA,sDAAA,tDAAMkI;;AAAN;AAAA,CAAA,gDAAA,WAAAC,3DAAMD;AAAN,AAAA,IAAAR,qBAAA;AAAA,AAAA,OAAAA,wDAAA,AAAAC,cAAAQ;;;AAAA,AAuCA,AAAA;;;;wCAAA,gDAAAhN,xFAAM6N;AAAN,AAAA,IAAA5N,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAA4N,2EAAAzN;;;AAAA,AAAA,CAAA,6EAAA,7EAAMyN,wFAGDhN;AAHL,AAIE,IAAMgE,SAAO,AAAC/D,+CAAO,WAAK2L,EAAEC;AAAP,AACE,GAAI,AAACN,sBAAMM;AACT,GAAI,AAACvK,uBAAOuK;AAAG,yBAAA,lBAACC;;AAAa,OAAC7L,+CAAOC,qBAAM0L,EAAEC;;;AAC7C,GAAI,6CAAA,7CAAC9J,mGAAS8J;AAEZD;;AACA,GAAI,MAAA,LAAMC;AAAG,yBAAA,lBAACC;;AAAa,OAACC,mDAAMH,EAAEC;;;;GAChD,qBAAA,rBAACG,uDACDhM;AARf,AASE,oBAAMgE;AAAN,AAAa,OAACiI,2BAAYjI;;AAA1B;;;;AAbJ,CAAA,gEAAA,hEAAMgJ;;AAAN;AAAA,CAAA,0DAAA,WAAAC,rEAAMD;AAAN,AAAA,IAAAtB,qBAAA;AAAA,AAAA,OAAAA,wDAAA,AAAAC,cAAAsB;;;AAAA,AAeA;;;2BAAA,3BAAMC,8DAEH9M,EAAE+M;AAFL,AAGE,OAACC,+CAAO,AAACC,6CAAKF,MAAM/M,GAAG,AAACkN,6CAAK,SAAA,RAAKH,aAAO/M;;AAE3C;;;6BAAA,7BAAMmN,kEAEHpH;AAFH,AAGE,GAAI,AAACqH,wBAAQrH;AAAMA;;AAAK,oDAAA,7CAACsH,8EAAQtH;;;AAEnC;;;;kCAAA,lCAAMuH,4EAGH9M,QAAQR;AAHX,AAIE,IAAAuN,aAAmB,qDAAA,rDAACG,mDAAqB1N;WAAzC,AAAAa,4CAAA0M,WAAA,IAAA,lEAAOC;YAAP,AAAA3M,4CAAA0M,WAAA,IAAA,nEAAYE;AAAZ,AACE,oBAAMA;AAAN,AAAY,IAAAE,eAAC,AAAA,sFAASnN;AAAV,AAAA,QAAAmN,6CAAAA,oDAAAA,TAAmBF,iCAAAA;;AAA/B;;;AAEJ;;;;;+BAAA,uCAAAG,tEAAME;AAAN,AAAA,IAAAD,aAAAD;IAAAC,iBAAA,AAAAhH,4BAAAgH;cAAAA,VAIQrN;iBAJR,AAAAsG,4CAAA+G,eAAA,xEAIwBE;YAJxB,AAAAjH,4CAAA+G,eAAA,nEAImC3I;AAJnC,AAKE,oBAAM6I;AAAN,AACE,GAAI,AAACX,wBAAQW;AACX,OAAClN,4CAAIkN,WAAW,iBAAAC,kBAAK,SAAA,RAAK9I;IAAV+I,kBAAiB,+BAAA,9BAAK,AAACjK,gBAAM+J;AAA7B,AAAA,SAAAC,kBAAAC,mBAAAD,kBAAAC;;;AAChBF;;;AAHJ;;;AAKF;;;;;;8BAAA,9BAAMG,oEAKH1N;AALH,AAME,6DAAA,iEAAA,vHAAC6C,8CAAM7C;;AAQT;;;;;;;;;;;8BAAA,2DAAA2N,zFAAME,oEAUHC,8BAA4DtO,EAAE2O,IAAIC;AAVrE,AAAA,IAAAR,aAAAD;UAAA,AAAAtN,4CAAAuN,WAAA,IAAA,jEAUmBjJ;cAVnB,AAAAtE,4CAAAuN,WAAA,IAAA,rEAUuBG;sBAVvB,AAAA1N,4CAAAuN,WAAA,IAAA,7EAU+BI;0BAV/B,AAAA3N,4CAAAuN,WAAA,IAAA,jFAUyCK;UAVzCL,NAU2DM;AAV3D,AAWE,IAAMG,iBAAS,EAAI,iDAAA,jDAAClN,6CAAEgN,oEAAc,iDAAA,jDAAChN,6CAAEgN;IACjCG,UAAQ,+DAAA,7DAAI,EAAKD,oBAAS,AAAChE,cAAIyD,6BAAmB,AAACtK,gBAAMhE;AAD/D,AAEE,oBAIE,iBAAAoE,mBAAI,iBAAAwD,oBAAKgH;AAAL,AAAA,oBAAAhH;AAAU,OAACiD,cAAI,iBAAAjD,wBAAK4G;AAAL,AAAA,oBAAA5G;AAAe,oBAAA,ZAAOkH;;AAAtBlH;;;;AAAfA;;;AAAJ,AAAA,oBAAAxD;AAAAA;;AAAqDyK;;;AAJvD,gKAAA,IAAA,1EAKK,AAAChJ,6CAAKV,IAAI,CAAGoJ,UAAQO,mBAAiBD;;AAL3C,AAAA,kHAAA,xBASS1J,IAAI,CAAGoJ,UAAQO,cAAaD;;;;AAEzC,4BAAA,yDAAAE,SAAAC,9FAAMG,gEACHb;AADH,AAAA,IAAAW,aAAAF;UAAA,AAAAlO,4CAAAoO,WAAA,IAAA,jEACmB9J;cADnB,AAAAtE,4CAAAoO,WAAA,IAAA,rEACuBV;sBADvB,AAAA1N,4CAAAoO,WAAA,IAAA,7EAC+BT;0BAD/B,AAAA3N,4CAAAoO,WAAA,IAAA,jFACyCR;UADzCQ,NAC2DP;IAD3DQ,aAAAF;QAAA,AAAAnO,4CAAAqO,WAAA,IAAA,/DAEIlP;QAFJ,AAAAa,4CAAAqO,WAAA,IAAA,/DAEMnO;UAFN,AAAAF,4CAAAqO,WAAA,IAAA,jEAEQP;cAFRO,VAEgB3J;AAFhB,AAGE,IAAA6J,aAAY,EAAI,2HAAA,zHAAI,iDAAA,jDAACzN,6CAAEgN,8EAAiB,iDAAA,jDAAChN,6CAAEgN,mEAAa,iDAAA,jDAAChN,6CAAEgN,qEAC7C,AAAC5O,yBAAWC,GACZ,KAAAuP,eAAA,OAAA,KAAA,IAAA,XAAMvP;QAFpB,AAAAa,4CAAAuO,WAAA,IAAA,/DAAOC;QAAP,AAAAxO,4CAAAuO,WAAA,IAAA,/DAASE;IAQHZ,UAAG,AAACL,4BAAcC,qBAAeI,IAAGW,EAAEV,IAAI,GAAK,MAAA,LAAMW;IACrDZ,UAAG,EAAI,AAACxN,uBAAOoO,IAAGZ,QAAG,+DAAA,/DAACL,4BAAcC,qBAAeI,QAAGY,EAAEX;AAT9D,AAUED;;AAGJ;;;;;;;;;;;;;;;;;kCAAA,lCAAMc,4EAgBHhP,QAAQ4G,IAAIC;AAhBf,AAiBE,IAAMiH,uBAAe,AAAA,uFAAS,AAAA,wFAAU9N;IAClC4G,UAAI,EAAI,AAAC+D,sBAAM/D,MAAK,AAAC5H,gBAAM4H,KAAKA;AADtC,AAEE,oBAAA,AAAA,mFAAQ5G;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD,iJAAwC6G;;AAAhD;;AACA,IAAOoI,WAASpI;qBAAhB,jBACOqI;IACAC,cAAYvI;8BAFnB,1BAGOwI;UAHP,NAIOzK;;AAJP,AAKE,GAAQ,EAAK,AAACjE,uBAAOuO,eAAU,AAACvO,uBAAOwO;AAErC,GAAM,EAAK,iBAAA,hBAAOC,0BAAa,AAAC9E,cAAI+E;AAAoBzK;;AAAxD,oBACMyK;AAAkB,6HAAA,tHAAC/J,oDAAKV,IAAIwK;;AADlC,AAEY,OAAC9J,6CAAKV,IAAIwK;;;;;AACtB,IAAMI,iBAAS,AAAC7O,uBAAOwO;IAAvBG,aAC0B,kBAAA,0BAAA,1CAAME,gBAAS,AAACvQ,gBAAMiQ;kBADhD,AAAA5O,4CAAAgP,WAAA,IAAA,zEACOG;QADP,AAAAnP,4CAAAgP,WAAA,IAAA,/DACmB9O;UADnB,AAAAF,4CAAAgP,WAAA,IAAA,jEACqBlB;IACfE,iBAAS,EAAI,iDAAA,jDAAClN,6CAAEgN,oEAAc,iDAAA,jDAAChN,6CAAEgN;IACjC3O,IAAE,EAAI+P,gBAASC,YAAYN;IAHjCI,aAIY,qBAAA,HAAM9P,GAGJ,+DAAA,mFAAA,WAAA,3JAAM,EAAK6O,oBAAS,AAAChE,cAAIyD,yIACnB,iBAAAlK,mBAAI,EAAK2L,oBACA,2HAAA,zHAAI,iDAAA,jDAACpO,6CAAEgN,8EACH,iDAAA,jDAAChN,6CAAEgN,qEACH,iDAAA,jDAAChN,6CAAEgN;AAHhB,AAAA,GAAAvK;AAAAA;;AAIIsL;;kCALV,AAAA,5BAMQ,AAAC3P,yBAAWC,sFACPA;GAVf;QAJZ,AAAAa,4CAAAiP,WAAA,IAAA,/DAIOT;QAJP,AAAAxO,4CAAAiP,WAAA,IAAA,/DAISR;IAoBHW,uBAAe,iBAAArI,oBAAKgI;AAAL,AAAA,oBAAAhI;AAAuB,UAAK,AAAC1G,uBAAOmO;;AAApCzH;;;IAKf0H,QAAE,kBAAIW,sBAAe,6CAAKZ,+CAAEC,aAAGA;IAC/BD,QAAE,wCAAA,tBAAIY,2BAAmBZ;IACzBa,kBAAgB,CAAGP,cAAY,AAAC3L,gBAAMqL;AA/B5C,AAuCE,eAAO,EAAIU,gBAAS,AAACtQ,eAAKgQ,UAAUA;eAC7BH;eACA,yBAAA,PAAIA,WAAIY;eACRrB;eACA,kBAAIS,OAAE,AAACzJ,6CAAKV,IAAI+K,iBAAiB/K;;;;;;;;;;;AAElD;;;;;;;;;;;;;;;;6BAAA,7BAAMgL,kEAeH3P,QAAQ4G,IAAIC;AAff,AAgBE,IAAM+I,aAAW,AAAC5Q,gBAEC,iBAAM8O,uBAAe,AAAA,uFAAS,AAAA,wFAAU9N;IAAxC6P,aAEQ,+IAAA,mFAAA,yFAAA,KAAA,hUAACxQ,+CAAO,AAACmG,gDAAQmJ,0BAAYb,0IACvB,EAAI,AAACnD,sBAAM/D,MAAK,AAAC5H,gBAAM4H,KAAKA,uBAChCC;QAJV,AAAAxG,4CAAAwP,WAAA,IAAA,/DACOtP;YADP,AAAAF,4CAAAwP,WAAA,IAAA,nEACStP;sBADT,AAAAF,4CAAAwP,WAAA,IAAA,7EACW7B;0BADX,AAAA3N,4CAAAwP,WAAA,IAAA,jFACqB5B;aADrB4B,TACuCzM;AADvC,AAKE,oBAAI,iBAAAgE,oBAAK4G;AAAL,AAAA,oBAAA5G;AAAe,OAACiD,cAAI4D;;AAApB7G;;;AACFhE;;AACA,uHAAA,GAAA,KAAA,xHAACyK,4BAAcC,qBACA,qDAAA,IAAA,zDAACjL,8CAAMO;;;AAV7C,AAcE,oBAAA,AAAA,mFAAQpD;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,qCAAA,WAAA,jKAAQnD,4IAC2B6G,iBACpBD,kBACOgJ;;AAHtB;;AAIAA;;AAEJ;;;;;mCAAA,nCAAME,8EAIHjJ;AAJH,AAME,OAACwD,cAAI,+CAAA,WAAA0F,iBAAAC,3EAAC3Q;AAAD,AAAS,IAAAuE,mBAAAmM;AAAA,AAAA,oBAAAnM;AAAAA;;AAAAoM;;GAAT,MAEE,4CAAA,WAAAC,vDAACrK;AAAD,AAAM,wEAAA,jEAACsK,+BAAyB,gBAAAD,hBAACjR;GAAe6H;;AAEzD;;;;0BAAA,1BAAMsJ,4DAGHtJ;AAHH,AAIE,IAAOuJ,QAAMvJ;;AAAb,AACE,oBAAMuJ;AAAN,AACE,IAAAC,aAAoB,AAACrR,gBAAMoR;WAA3B,AAAA/P,4CAAAgQ,WAAA,IAAA,lEAAOvL;QAAP,AAAAzE,4CAAAgQ,WAAA,IAAA,/DAAY9P;YAAZ,AAAAF,4CAAAgQ,WAAA,IAAA,nEAAcC;AAAd,AACE,GAAI,mDAAA,nDAACnP,6CAAEmP;AAAexL;;AAAK,eAAO,AAAC7F,eAAKmR;;;;;AAF5C;;;;;AAIJ;;;;gCAAA,hCAAMG,wEAGH1J;AAHH,AAIE,IAAA2J,aAAqB,AAACxR,gBAAM6H;QAA5B,AAAAxG,4CAAAmQ,WAAA,IAAA,/DAAOhR;YAAP,AAAAa,4CAAAmQ,WAAA,IAAA,nEAAS1E;WAAT,AAAAzL,4CAAAmQ,WAAA,IAAA,lEAAe1L;AAAf,AACE,SAAI,kDAAA,lDAAC3D,6CAAE2D,sEAAe,kDAAA,lDAAC3D,6CAAE2D;;AAE7B;;;;;2BAAA,3BAAM2L,8DAIHzQ,QAAQ4G,IAAIrB;AAJf,AAKE,0HAAA,mFAAA,uNAAA,qDAAA,yDAAA,3gBAACmL,yRAAgB,CAAA,iDAAU,AAACvE,sBAAO,uCAAA,rCAAI,AAACoE,8BAAUhL,WAAQqB,mJAE3CrB;;AAMjB;;;;;;;;;;4BAAA,5BAAMoL,gEASH3Q,QAAQ4G,IAAIC;AATf,AAUE,oBAAM,iBAAAO,oBAAKP;AAAL,AAAA,oBAAAO;AAAA,SAAe,GAAK,AAAC1G,uBAAOmG,kBAAY,AAACwD,cAAI,AAACI,kCAAc5D;;AAA5DO;;;AAAN,AACE,IACMwJ,UAAQ,AAAC5B,gCAAkBhP,QAAQ4G,IAAIC;IACvCgK,gBAAc,AAACrN,gBAAMoN;aAF3B,TAGMxN,4FAAQyN,cAAc,2BAAA,zBAAI,mBAAA,lBAAOA,4BAAiB,AAACzS,8CAAM0S,cAAIF,UACrDA;IACRG,SAAO,AAAA,sFAAS/Q;IAChB8E,OAAK,kBAAM,iBAAAsC,oBAAK2J;AAAL,AAAA,oBAAA3J;AAAY,OAACjG,6CAAE,AAACgP,wBAAUtJ,WAAWkK;;AAArC3J;;MAAN,OAAA,PAAoD2J;AAN/D,AAQE,oBAAIjM;AAAK,OAACO,6CAAKjC,OAAO0B;;AAAM1B;;;AAThC;;;AAWF;;;;;;qCAAA,rCAAM4N,kFAKHhR,QAAQ4G,IAAIqK;AALf,AAME,oBAAM,iBAAA7J,oBAAK6J;AAAL,AAAA,oBAAA7J;AAAA,SACK,GAAK,AAAC1G,uBAAOuQ,2BACb,AAAC5G,cAAI,AAACI,kCAAcwG;;AAFzB7J;;;AAAN,AAGE,IAAM8J,aAAW,AAACC,6CAAK/M,iBAAO6M;IACxBG,kBAAgB,AAACD,6CAAK,AAAC3L,gDAAQmL,0BAAY3Q,QAAQ4G,KAAKsK;IACxDN,UAAQ,6CAAA,7CAAC/D,8EAAQ,AAACwE,kBAAQ,6CAAA,WAAAC,xDAACH;AAAD,AAAO,mDAAAG,iBAAA,7DAACjR;GAAS+Q;IAC3C7D,aAAW,AAACnP,8CAAM0S,cAAIF;AAH5B,AAAA,0FAIG,AAACpN,gBAAMoN,SAASrD,WAAWqD;;AAPhC;;;AASF;;;;sBAAA,8BAAAW,SAAAC,7DAAMG;AAAN,AAAA,IAAAF,aAAAF;IAAAE,iBAAA,AAAApL,4BAAAoL;cAAAA,VAGqCzR;YAHrC,AAAAsG,4CAAAmL,eAAA,nEAGW7I;eAHX,AAAAtC,4CAAAmL,eAAA,tEAGiB5I;iBAHjB,AAAAvC,4CAAAmL,eAAA,xEAG0B3I;IAH1B4I,aAAAF;iBAAA,AAAAnR,4CAAAqR,WAAA,IAAA,xEAIIE;gBAJJ,AAAAvR,4CAAAqR,WAAA,IAAA,vEAIeG;yBAJfH,rBAI6BI;AAJ7B,AAKE,oBAAA,AAAA,mFAAK9R;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,2MAAA,yBAAA,uBAAA,pQAAK/C,kCACyB,CAACsK,2DAAAA,qEAAAA,ZAAazB,kDAAAA,yBACzB+I,wBACDC,mBACJjJ;;AAJd;;AAKA,oBAAMkJ;AAAN,AACE,GAAI,CAAID,aAAU,CAAGjJ,QAAM,CAAC0B,2DAAAA,qEAAAA,ZAAazB,kDAAAA;AAAY+I;;AAArD;;;AADF;;;AAGF;;;;+BAAA,/BAAMG,sEAGH/R,QAAQ8R;AAHX,AAIE,IAAME,QAAM,AAACL,oBAAM3R,QAAQ8R;AAA3B,AACE,SAAK,OAASE,wBAAO,mDAAA,nDAAC7Q,6CAAE6Q;;AAM5B;;;0BAAA,1BAAMC,4DAEHjS;AAFH,AAGE,6DAAA,tDAAC6C,8CAAM7C,oEAAkB,0GAAA,zGAAK,AAAA,kGAAA,RAAWA;;AAE3C;;;8BAAA,9BAAMkS,oEAEHlS;AAFH,AAGE,8DAAA,vDAAC2D,+CAAO3D;;AAEV;;;;;;;;yBAAA,zBAAMmS,0DAOHC,cAAQC,sBAAgBC,iBAAWtS;AAPtC,AAQE,GAAA,AAAAqK,cAAQiI;AACN,OAACJ,4BAAclS;;AACf,oBAAIqS;AACFrS;;AACA,oBAAIoS;AACF,OAACH,wBAAU,AAACC,4BAAclS;;AAC1B,OAACkS,4BAAclS;;;;;AAEvB;;;6BAAA,7BAAMsK,kEAEHzB;AAFH,AAGE,GAAI,OAASA;AAAUA;;AAAvB;;;AAUF,4BAAA,wCAAA,IAAA,IAAA,IAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,IAAA,IAAA,KAAA,MAAA,2DAAA,uDAAA,uDAAA,sEAAA,6EAAA,2DAAA,kEAAA,uDAAA,kEAAA,wDAAA,wDAAA,2DAAA,yDAAA,x5BAAK0J;AAiBL;;;;2BAAA,mCAAAC,9DAAME,uEAGqCE;AAH3C,AAAA,IAAAH,aAAAD;IAAAC,iBAAA,AAAApM,4BAAAoM;cAAAA,VAGkCzS;gBAHlC,AAAAsG,4CAAAmM,eAAA,vEAGWE;mBAHX,AAAArM,4CAAAmM,eAAA,1EAGqBtL;AAHrB,AAKE,oBAAIA;AACF,IAAA0L,WAAW,EAAI,uBAAAC,tBAAUF,0CAAYA,WAAW,CAACL,0DAAAA,sEAAAA,dAASK,mDAAAA;AAA1D,AAAA,0FAAAC,iCAAAA,nHAACF,0CAAAA,oDAAAA;;AADH;;;AASF,AAAA,AACA,AAAA,AAEA;;;;;yBAAA,zBAAMI,0DAIHC,gBAAUC,aAAapM;AAJ1B,AAKE,oBAAMA;AAAN,AAAgB,oBAAImM;AAAJ,0FAAeC,aAAapM;;AAAWA;;;AAAvD;;;AAEF;;;;;;yCAAA,zCAAMqM,0FAKHlT,QAAQmT,QAAQC,QAAQC,KAAKnS;AALhC,AAME,oBAAA,AAAA,mFAAKlB;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,6CAAA,mBAAA,zEAAK/C,8CACqCmT,mBAC1BC,gBACH,iBAAAE,WAAS,CAACC,mDAAAA,yDAAAA,RAAOrS,sCAAAA;AAAjB,AAAA,8GAAAoS,2CAAAA,jJAAC5R,oDAAAA,8DAAAA;;;AAHd;;AAMA,IAAM8R,UAAQ,oEAAA,lEAAM,AAACC,gDAAKN,QAAQC,UAClB,iBAAAM,WAAM,AAAClJ,sBAAQxK;IAAf2T,WAAwBR;IAAxBS,WAAgC1S;AAAhC,AAAA,gFAAAwS,SAAAC,SAAAC,4BAAAF,SAAAC,SAAAC,xIAACP,qCAAAA,iEAAAA;KADH;AAAd,AAEE,IAAAQ,uBAGE,kBAAI,iBAAAzM,oBAAKoM;AAAL,AAAA,oBAAApM;AAAa,OAACuK,oBAAM3R,QAAQ,AAAC2Q,0BAAY3Q,QAAQmT,QAAQK;;AAAzDpM;;MAAJ,mFAAA,sDACSoM,gBAEP;AAAI,oBAAA,AAAA,mFAAKxT;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,TAAK/C;;AAAL;;AAAJ,0FAAA,oDAEK,AAACyQ,yBAAWzQ,QAAQoT,QAAQ,CAACC,qCAAAA,2DAAAA,xBAAKrT,wCAAAA,hCAAQoT,wCAAAA,hCAAQlS,wCAAAA;;;AAR3D,AAAA,oBAAA,AAAA,mFACElB;AADF,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,kCAAA,AAAAI,wGAAA0Q,nJACE7T;;AADF;;AAAA6T;;AAUJ;;;;8BAAA,9BAAMC,oEAGHC,YAAYlN;AAHf,AAIE,GAAI,wEAAA,xEAAC1F,6CAAE,AAACqC,gBAAMqD;AACZ,IAAAmN,aAA+BnN;IAA/BoN,aAAA,AAAA5T,4CAAA2T,WAAA,IAAA;aAAA,AAAA3T,4CAAA4T,WAAA,IAAA,pEAAQC;YAAR,AAAA7T,4CAAA4T,WAAA,IAAA,nEAAenI;cAAf,AAAAzL,4CAAA4T,WAAA,IAAA,rEAAqBlP;AAArB,AAAA,0FAAA,mFAA4CmP,OAAOH,YAAYhP;;AAC/D8B;;;AAEJ,AAAA,AACA,AAAA,AAEA;;;;gCAAA,+CAAAsN,/EAAMG,wEAGH9R,gBAGcoE,IAAI8N,WAAWC;AANhC,AAAA,IAAAP,aAAAD;IAAAC,iBAAA,AAAA/N,4BAAA+N;cAAAA,VAMQpU;IANRqU,aAAA,AAAA/N,4CAAA8N,eAK0D5R;IAL1D6R,iBAAA,AAAAhO,4BAAAgO;kBAAA,AAAA/N,4CAAA+N,eAAA,zEAKYE;sBALZ,AAAAjO,4CAAA+N,eAAA,7EAKwBG;sBALxB,AAAAlO,4CAAA+N,eAAA,7EAKwCI;YALxC,AAAAnO,4CAAA8N,eAAA,nEAIW1P;YAJX,AAAA4B,4CAAA8N,eAAA,nEAIiBxL;AAJjB,AAOE,oBAAM,iBAAAxB,oBAAKuN;AAAL,AAAA,oBAAAvN;AAAA,IAAAA,wBAAwBmN;AAAxB,AAAA,oBAAAnN;AAAoC,qBAAA,bAAMsN;;AAA1CtN;;;AAAAA;;;AAAN,AAEE,IAAMmN,kBAAY,CAAA,CAAGA,cACA,CAAG7P,QAAM8P,oBACT,CAAG,CAAG5N,MAAIgC,SAAO6L;IAChCrR,SAAO,CAAI,CAAG,sBAAA,rBAAKuR,4BAAoBD,eAAYH;AAHzD,AAYEnR;;AAdJ;;;AAyBF;;;;;;;;;;;+BAAA,8CAAAwR,8GAAAC,3LAAMI,sEAUHzS,gBAMcoE,IAAIwL,cAAQ6D,cAAcC,gBAAgBC,aACxD9D,sBAAgB+D;AAjBnB,AAAA,IAAAtB,aAAAF;IAAAE,iBAAA,AAAAzO,4BAAAyO;cAAAA,VAgBQ9U;IAhBR+U,aAAA,AAAAzO,4CAAAwO,eAeMtS;IAfNuS,iBAAA,AAAA1O,4BAAA0O;kBAAA,AAAAzO,4CAAAyO,eAAA,zEAYYM;kBAZZ,AAAA/O,4CAAAyO,eAAA,zEAYwDW;iBAZxD,AAAApP,4CAAAyO,eAAA,xEAY6CU;wBAZ7C,AAAAnP,4CAAAyO,eAAA,/EAa4Ce;sBAb5C,AAAAxP,4CAAAyO,eAAA,7EAaYa;aAbZ,AAAAtP,4CAAAyO,eAAA,pEAYsCS;cAZtC,AAAAlP,4CAAAyO,eAAA,rEAa8DgB;4BAb9D,AAAAzP,4CAAAyO,eAAA,nFAcYiB;sBAdZ,AAAA1P,4CAAAyO,eAAA,7EAa4Bc;qBAb5B,AAAAvP,4CAAAyO,eAAA,5EAY6BQ;uBAZ7B,AAAAjP,4CAAAyO,eAAA,9EAYkBO;gBAZlB,AAAAhP,4CAAAyO,eAAA,vEAY8DY;sBAZ9D,AAAArP,4CAAAwO,eAAA,7EAWWI;iBAXX,AAAA5O,4CAAAwO,eAAA,xEAWqBhM;iBAXrB,AAAAxC,4CAAAwO,eAAA,xEAW0BrO;qBAX1B,AAAAH,4CAAAwO,eAAA,5EAWqCpO;wBAXrC,AAAAJ,4CAAAwO,eAAA,/EAW8CK;gBAX9C,AAAA7O,4CAAAwO,eAAA,vEAW0DM;IAX1DJ,aAAAH;WAAA,AAAAxU,4CAAA2U,WAAA,IAAA,lEAiBgCqB;WAjBhC,AAAAhW,4CAAA2U,WAAA,IAAA,lEAiBqCsB;WAjBrC,AAAAjW,4CAAA2U,WAAA,IAAA,lEAiB0CuB;WAjB1CvB,PAiBmDwB;AAjBnD,AAkBE,oBAAIjB;AAAS,yGAAA,yBAAA,oBAAA,tJAACxS,2HAA0BP,eAAe6S,mBAAavM;;AAApE;;AACA,oBAAA,AAAAhG,eAAA,iFAAA,gEAAA,uDAAA,8DAAA,8FAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,qRAAA,+BAAA,uGAAA,+HAAA,niBAAO/C,2BAEkB,AAACmD,wGAAO,CAACzB,oDAAAA,0DAAAA,RAAQ2U,uCAAAA,8BAClBJ,uBACR,AAAA,qFAAQjW,kCACQ,AAAA,qFAAQkW,iCACjB,AAAC1S,gBAAMgT;;AAN9B;;AAOA,oBAAI,iBAAA5S,mBAAIkF;AAAJ,AAAA,oBAAAlF;AAAAA;;AAAS0R;;;AACX,AAACvS,yGAAQ,iBAAAa,mBAAI6C;AAAJ,AAAA,oBAAA7C;AAAAA;;AAAA;;KAAT,6BAES,CAAA,iDAAU,iBAAAA,mBAAI6C;AAAJ,AAAA,oBAAA7C;AAAAA;;AAAA;;gBACV,wGAAA,uKAAA,mJAAA,iBAAA,+BAAA,WAAA,iBAAA,yBAAA,+BAAA,6BAAA,qBAAA,0BAAA,gCAAA,oBAAA,gCAAA,wBAAA,9tBAACT,0HACmB,CAACzB,oDAAAA,0DAAAA,RAAQ2U,uCAAAA,cACpB,CAACjV,iDAAAA,uDAAAA,RAAKiV,oCAAAA,iBACH7T,gBACD,AAACgB,gBAAMgT,aACT5P,cACG4O,qBACIC,4BACGQ,2BACJf,yBACJG,uBACE3O,6BACGyO,0BACNO,0BACMU,4BACJhE,gCACQC;;AApB/B;;AAqBA,IAAMqD,kBAAM,iBAAA9R,mBAAI8R;AAAJ,AAAA,oBAAA9R;AAAAA;;AAAUwS;;;IAChBQ,oBAAY,iBAAAhT,mBAAIsR;AAAJ,AAAA,oBAAAtR;AAAAA;;AAAcyR;;;IAC1BG,aAAO,iBAAA5R,mBAAI4R;AAAJ,AAAA,oBAAA5R;AAAAA;;AAAW6R;;;IAUlBoB,sBAAoB7W;IACpBA,cAAQkW;IACRY,gBACE,EAAI,AAACzM,cAAIuM,oBAAa,0DAAA,+DAAA,zHAAC/T,8CAAM7C,iFAAyBA;IACxDO,IAAE,kBAAA,AAAAuC,eAAA,iFAAA,uDAAA,4FAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,uDAAA,2QAAA,2GAAA,6IAAA,9xBAAO/C,uNAAAA,8CAEiCqS,8BACzB,AAAClP,wGAAO,CAACzB,oDAAAA,0DAAAA,RAAQ2U,uCAAAA,sBAChB,AAAA,qFAAQrW,+BACC,AAAA,wGAAiBA;IAC5C+W,WAAS,2DAAA,3DAAC5E,uBAASC,cACAC,2BAEA,kBAAI8D,cACF,0DAAA,1DAACtT,8CAAM7C,mEAAemW,cACtBnW;IACrBgX,sBAAoB,2DAAA,3DAAC7E,uBAASC,cAAQC,2BAAoBrS;IAC1D4I,QAAM,AAAA,qFAAQ5I;IACdiX,WAAS,2DAAA,3DAAC9E,uBAASC,cAAQC,oFAA2BrS;IAEtDkX,uBACE,2DAAA,3DAAC/E,uBAASC,cAAQC,oFAA2BwE;IAC/CM,iBACE,2DAAA,3DAAChF,uBAASC,cAAQC,oFAA2ByE;IAO/CM,kBAAgB,iBAAAhQ,oBAAKyO;AAAL,AAAA,oBAAAzO;AAAA,IAAAA,wBACK,yBAAA,xBAAG,AAAC5D,gBAAMgT;AADf,AAAA,GAAApP;AAAA,IAAAA,wBAEK,CAAC/F,0DAAAA,gEAAAA,RAAQgV,6CAAAA;AAFd,AAAA,oBAAAjP;AAGK,IAAAiQ,WAAiB,AAAC9V,wBAAUvB,YAAQqW;AAApC,AAAA,sGAAAgB,uCAAAA,rIAACxB,gDAAAA,0DAAAA;;AAHNzO;;;AAAAA;;;AAAAA;;;IAIhB+P,qBAAe,kBAAIC,iBACF,+HAAA,2CAAA,1KAACE,gHAAWH,yHACYC,8BACxBD;IACjBF,eAAS,kBAAIG,iBACF,yHAAA,2CAAA,pKAACE,gHAAWL,mHAAqBG,8BACjCH;IAIXM,oBAAkB,iBAAAnQ,oBAAK0O;AAAL,AAAA,oBAAA1O;AAAA,IAAAA,wBACK,yBAAA,xBAAG,AAAC5D,gBAAMgT;AADf,AAAA,GAAApP;AAAA,IAAAA,wBAEK,CAAC/F,0DAAAA,gEAAAA,RAAQgV,6CAAAA;AAFd,AAAA,oBAAAjP;AAGK,IAAAoQ,WAAmB,AAACjW,wBAAUvB,YAAQqW;AAAtC,AAAA,0GAAAmB,yCAAAA,3IAAC1B,kDAAAA,4DAAAA;;AAHN1O;;;AAAAA;;;AAAAA;;;IAIlB+P,qBAAe,kBAAII,mBACF,AAACD,gHAAWH,mBAAeI,wBAC3BJ;IACjBF,eAAS,kBAAIM,mBACF,AAACD,gHAAWL,aAASM,wBACrBN;IAMXQ,eAAa,AAAA,2FAAY,CAACzX,4CAAAA,oDAAAA,VAAQwC,iCAAAA;IAClCkV,kBAAU,iBAAA9T,mBAAI,iBAAAwD,oBAAKqQ;AAAL,AAAA,oBAAArQ;AAAA,IAAAA,wBACK,iBAAAuQ,WAAc,CAACjW,oDAAAA,0DAAAA,RAAQ2U,uCAAAA;AAAvB,AAAA,gGAAAsB,oCAAAA,5HAACF,6CAAAA,uDAAAA;;AADN,AAAA,oBAAArQ;AAEK,gCAAA,xBAAG,AAAC5D,gBAAMgT;;AAFfpP;;;AAAAA;;;AAAJ,AAAA,oBAAAxD;AAAAA;;AAGI,QAACgU,oEAAAA,sFAAAA,pBAAgB5X,mEAAAA,vDAAQsW,mEAAAA;;;IAGvCvC,cAAY,AAACzN,4CAAIsP,gBAAgB,aAAA,ZAAKR;IAGtCrB,kBAAY,kBAAI,iBAAA3M,oBAAKuO;AAAL,AAAA,oBAAAvO;AAAA,IAAAA,wBAAe,yBAAA,xBAAG,AAAC5D,gBAAMgT;AAAzB,AAAA,GAAApP;AAAkC,QAAC/F,0DAAAA,gEAAAA,RAAQgV,6CAAAA;;AAA3CjP;;;AAAAA;;MACF,iBAAAyQ,WAAW,AAACtW,wBAAUvB,YAAQqW;AAA9B,AAAA,0FAAAwB,iCAAAA,nHAAClC,0CAAAA,oDAAAA;KACD5B;IASdxT,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,uDAAA,sGAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,qRAAA,4BAAA,uHAAA,5oBAAO/C,uNAAAA,+BAEkB,AAACmD,wGAAO,CAACzB,oDAAAA,0DAAAA,RAAQ2U,uCAAAA,yBACvBnB,kCACM,AAAA,qFAAQ6B;IACnCe,QAAM,CAACC,4DAAAA,+EAAAA,rBAAShB,4DAAAA,nDAASnQ,4DAAAA,xDAAIyP,4DAAAA;IAK7B9V,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,uDAAA,4FAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,4RAAA,4BAAA,WAAA,iHAAA,gEAAA,xtBAAO/C,uNAAAA,sCAEyB,AAACmD,wGAAO,CAACzB,oDAAAA,0DAAAA,RAAQ2U,uCAAAA,yBAC9BnB,uBACLtO,sBACW,AAAA,qFAAQmQ,mBACjB,AAACpG,0BAAY3Q,YAAQ4G,IAAIkR;IAC3CA,YAAM,kBAAI,iBAAA1Q,oBAAK,UAAA,TAAM0Q;AAAX,AAAA,GAAA1Q;AAAA,IAAAA,wBAAkB6O;AAAlB,AAAA,oBAAA7O;AAAgC+O;;AAAhC/O;;;AAAAA;;MACF;AAAI,oBAAA,AAAAtE,eAAA,iFAAA,uDAAA,4FAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,kSAAA,4BAAA,3UAAO/C,4CAE+B,AAACmD,wGAAO,CAACzB,oDAAAA,0DAAAA,RACC2U,uCAAAA,yBAC7BnB,kCACM,AAAA,qFAAQ6B;;AALjC;;AAUA,QAACgB,4DAAAA,0FAAAA,hCAASf,uEAAAA,nDAAoBpQ,uEAAAA,nEAAIyP,uEAAAA;;CACtCyB;IACRE,aAAW,AAAA,+FAAajC;IAIxBkC,uBAAe,iBAAA7Q,oBAAK,mEAAA,nEAACjG,6CAAE,AAACqC,gBAAMgT;AAAf,AAAA,GAAApP;AAAwB,QAAC8Q,4DAAAA,kEAAAA,RAAU7B,+CAAAA;;AAAnCjP;;;IACf0Q,YAAM,kBAAI/D,iBAAY,AAACD,4BAAcC,gBAAY+D,WAAOA;IA/H9DrB,aAoIQ,AAAC9F,0BAAY3Q,YAAQ4G,IAAIkR;uBApIjC,AAAAzX,4CAAAoW,WAAA,IAAA,9EAmIO0B;sBAnIP,AAAA9X,4CAAAoW,WAAA,IAAA,7EAmIwB2B;kBAnIxB3B,dAmI4C4B;IAKtCD,sBAAgB,AAACzM,eAAK,wDAAA,xDAACtL,4CAAIgY;IAG3B9X,QAAE,kBAAA,AAAA,iGAAA,AAAA,AAAAwC,yGAAA,AAAA,4GAAA,qEAAA,6CAAA,rVAAK/C,sNAAAA,iEAEEmY,oCACiBC;IAC1BV,sBAAU,kBAAI,iBAAA9T,mBAAI,iBAAAwD,oBAAK+Q;AAAL,AAAA,oBAAA/Q;AAAsB,2BAAA,nBAAG+Q;;AAAzB/Q;;;AAAJ,AAAA,oBAAAxD;AAAAA;;AACIqU;;MADR,KAGEP;IAGZY,iBAAe,kBAAIZ,qBACF,6HAAA,mFAAA,uFAAA,qDAAA,kEAAA,9ZAAChH,mHAAcoH,gLACE,+IACF,iBAAAS,WAAU,AAAC/N,sBAAQuM;IAAnByB,WACU,CAAG5R,MAAIwR;IADjBK,WAEUnC;AAFV,AAAA,8HAAAiC,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAACV,4DAAAA,wFAAAA;WAGhBD;IAEjBA,YAAM,kBAAIQ,gBAAeA,eAAeR;IAExCJ,sBAAU,sDAAA,pCAAIY,gBAAeZ;IA/JnChB,aAkKQ,kBAAI4B,gBAAe,AAAC3H,0BAAY3Q,YAAQ4G,IAAIkR,WAAOO;2BAlK3D,AAAAhY,4CAAAqW,WAAA,IAAA,lFAiKOyB;0BAjKP,AAAA9X,4CAAAqW,WAAA,IAAA,jFAiKwB0B;sBAjKxB1B,lBAiK4C2B;IAGtCD,sBAAgB,AAACzM,eAAK,4DAAA,5DAACtL,4CAAIgY;IAC3B9X,QAAE,kBAAA,AAAA,iGAAA,AAAA,AAAAwC,yGAAA,AAAA,4GAAA,wEAAA,6CAAA,xVAAK/C,sNAAAA,gEAEEmY,wCACiBC;IAC1B/B,WAAK,kBAAIqB,qBAAUpB,KAAKD;IACxBC,WAAK,kBAAIoB,qBAAUnB,KAAKD;IAIxBoC,2BAAmB,iBAAAtR,oBAAK,AAACiD,cAAIqL;AAAV,AAAA,GAAAtO;AACK,oBAAI4O;AAAJ;;AAIE,OAACjE,6BAAegF,SAASsB;;;AALhCjR;;;IAMnBuR,mBAAW,AAAChH,oBAAMoF,SAASsB;IAG3BO,cAAY,CAAG,iBAAAhV,mBAAIwU;AAAJ,AAAA,oBAAAxU;AAAAA;;AAAA;;OAAuBgD;IAEtCiS,oBAAY5C;IAIZA,oBAAc,iCAAA,fAAMA,eACJ,kBAAI,iBAAArS,mBAAI,CAAGgV,cAAY3C;AAAnB,AAAA,GAAArS;AAAAA;;AACI,oBAAMoU;AAAN,AAAiB,IAAAc,WAAY,AAACC,iBAAOjB;AAApB,AAAA,4FAAAgB,kCAAAA,tHAACd,2CAAAA,qDAAAA;;AAAlB;;;0BAFV,pBACE,KAGE/B;IAjMxBU,aAsMQ,kBAAI,iBAAAvP,oBAAKyR;AAAL,AAAA,oBAAAzR;AAAA,IAAAA,wBACK,AAACiD,cAAI4L;AADV,AAAA,GAAA7O;AAAA,IAAAA,wBAEK+O;AAFL,AAAA,oBAAA/O;AAAA,SAGK,GAAK,AAAC2K,6BAAegF,SAASsB,wBAC9B,yHAAA,zHAAClX,6CAAE,uEAAA,vEAACd,4CAAI,AAACrB,gBAAM8Y;;AAJpB1Q;;;AAAAA;;;AAAAA;;MAQF,iBAAM0Q,YAAM,iBAAAkB,WAAU,uDAAA,vDAACnW,8CAAMkU,gEAAgBnO;IAAjCqQ,WAAwCrS;IAAxCsS,WAA4C7C;AAA5C,AAAA,8HAAA2C,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAACnB,4DAAAA,wFAAAA;;IACPM,kBAAY,AAAC1H,0BAAY3Q,YAAQ4G,IAAIkR;IACrCM,sBAAgB,AAACzM,eAAK,4DAAA,5DAACtL,4CAAIgY;IAC3BO,kBAAY,CAAG,iBAAAhV,mBAAIwU;AAAJ,AAAA,oBAAAxU;AAAAA;;AAAA;;OAAuBgD;AAH5C,AAIE,oBAAA,AAAA9D,eAAA,iFAAA,uDAAA,wEAAA,4FAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,+SAAA,5TAAO/C,iDAEoC,AAACmD,wGAAO,CAACzB,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA,gCACtCgC;;AAHtB;;AAJF,0FAAA,KAQOP,UAAMO,gBAAYO;KAhB3B,mFAiBGzC,aAAa2B,UAAMO,gBAAYO;uBAvN1C,AAAAvY,4CAAAsW,WAAA,IAAA,9EAqMOR;gBArMP,AAAA9V,4CAAAsW,WAAA,IAAA,vEAqMoBmB;sBArMpB,AAAAzX,4CAAAsW,WAAA,IAAA,7EAqM0B0B;sBArM1B,AAAAhY,4CAAAsW,WAAA,IAAA,7EAqMsCiC;AArMtC,AAwNE,oBAAA,AAAA9V,eAAA,iFAAA,uDAAA,+EAAA,4FAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,iLAAA,mCAAA,iCAAA,8BAAA,sCAAA,UAAA,8BAAA,8BAAA,+CAAA,3bAAO/C,iCAEoB,CAAC0B,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA,4BACZJ,kCACDE,+BACFyC,kCACIR,0BACZxR,kBACQyR,6BACDM,kCACI,AAACtO,cAAI3D,mCACH,AAAA,qFAAQ1G;;AAXlC;;AAeA,oBAAA,AAAA,mFAAQA;AAAR,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,rHAAQnD,8IAAiC8X;;AAAzC;;AACA,oBAAMA;AAAN,AAEE,oBAEEG;AAFF,0FAEkB,qCAAA,oDAAA,vEAAI7B,8HAAyB0B;;AAF/C,GAME,mEAAA,nEAAC3W,6CAAE,AAACqC,gBAAMgT;AANZ,0FAMsB,qCAAA,oDAAA,vEAAIJ,8HACJ,CAAC2B,4DAAAA,uFAAAA,7BAASd,oEAAAA,vDAASrQ,oEAAAA,hEAAIyP,oEAAAA;;AAP7C,oBAQE,iBAAAzS,mBAAI,mEAAA,nEAACzC,6CAAE,AAACqC,gBAAMgT;AAAd,AAAA,GAAA5S;AAAAA;;AAAuB,IAAAwD,oBAAKsQ;AAAL,AAAA,oBAAAtQ;AAAe,0EAAA,nEAACjG,6CAAE,AAACqC,gBAAMgT;;AAAzBpP;;;;AASrB,IAAM+R,gBAAc,kBAAIlD,mBAAcA,kBAAc2C;IAK9CQ,kBAAgB,iBAAAxV,mBAAIqS;AAAJ,AAAA,oBAAArS;AAAAA;;AAAA;;;IAChByV,gBAAc,iBAAAzV,mBAAIgV;AAAJ,AAAA,oBAAAhV;AAAAA;;AAAA;;;IACd0V,iBACE,+EAAA,7DAAIrD,mBAAc,qCAAA,pCAAK,CAAGmD,kBAAgBC;IAC5CE,iBAAe,CAAA,CAAA,MAAKJ,iBAAcvS;IAClC4S,cAAY,CAAGhE,aAAO5O;AAV5B,AAWE,oBAAI,iBAAAQ,oBAAK,CAAC1F,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA;AAAd,AAAA,oBAAAjP;AAAA,IAAAA,wBACK,AAAC0F,gCAAY9M,YAAQ,CAAC0B,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA;AADnC,AAAA,oBAAAjP;AAEK,UAAK,oDAAA,pDAACjG,6CAAEqB;;AAFb4E;;;AAAAA;;;AAKF,oBAAI,CAACqS,2DAAAA,qEAAAA,ZAASnD,kDAAAA;AAKZ,IAAAoD,aAA+B,AAACxG,uCACC6D,SACAwC,eACAC,YACAG,kCACArD;mBALjC,AAAAjW,4CAAAqZ,WAAA,IAAA,1EAAOzG;gBAAP,AAAA5S,4CAAAqZ,WAAA,IAAA,vEAAoB7S;IAMdiR,YAAM,EAAI,0DAAA,1DAAC3W,6CAAE8R,qEACL,6HAAA,mFAAA,yHAAA,qDAAA,kEAAA,hcAACvC,mHAAcoH,gLACE,AAAC3L,sBAAOmN,iKAEzBxB;AAVd,AAAA,0FAWG7E,aAAa,AAACvC,mHAAcoH,UAAMjR;;AACrC,IAAA+S,aAA+B,AAAC1G,uCACC6D,SACAwC,eACAC,YACAzB,4BACAzB;mBALjC,AAAAjW,4CAAAuZ,WAAA,IAAA,1EAAO3G;gBAAP,AAAA5S,4CAAAuZ,WAAA,IAAA,vEAAoB/S;IAMdiR,YAAM,EAAI,0DAAA,1DAAC3W,6CAAE8R,qEACL,6HAAA,mFAAA,yHAAA,qDAAA,kEAAA,hcAACvC,mHAAcoH,gLACE,AAAC3L,sBAAOmN,iKAEzBxB;AAVd,AAAA,0FAWG7E,aAAa,AAACvC,mHAAcoH,UAAMjR;;;AAMvC,IAMMtG,QAAE,kBAAA,AAAA,iGAAA,AAAA,AAAAwC,yGAAA,AAAA,4GAAA,+JAAA,lYAAK/C,sNAAAA,4DAEA,EAAI0Y,8BACA,EAAK,AAACrO,cAAIqL,sBACL,CAAI8D,eAAYD;IAShC/F,UAAQ,6GAAA,3GAAM,EAAIkF,8BACA,EAAK,AAACrO,cAAIqL,sBACL,CAAI8D,eAAYD,qBAC7B,iBAAAM,WAAU,EAAI,CAAGL,cAAYD,iBACjB,AAAC/O,sBAAQ2M,oBACTA;IAFZ2C,WAGUP;IAHVQ,WAIUzD;AAJV,AAAA,8HAAAuD,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAAChC,4DAAAA,wFAAAA;KAHH;IAQRrD,aAAW,CAACsF,mDAAAA,6DAAAA,ZAAO1D,0CAAAA;IACnB/V,QAAE,oCAAA,pCAACgG,wBAAUvG,uCAEAuZ,eACA/F;IACbyG,gBAAc,AAACtJ,0BAAY3Q,YAAQuZ,eAAe/F;IAClDjT,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,gEAAA,uDAAA,8FAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,+KAAA,mCAAA,gCAAA,8CAAA,4BAAA,oBAAA,iCAAA,mIAAA,sIAAA,91BAAO/C,uNAAAA,+BAEkB,CAAC0B,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA,4BACVJ,gCACH4C,uCACOH,qCACTxD,wBACJG,8BACUkE,yCACQ,AAAA,qFAAQpC,8BACxB,AAAChU,wGAAOqQ;IAC3B0G,aAAK,AAACnI,6BAAeoF,mBAAe8C;IACpCA,oBAAc,EAAIC,YACFD,cACA,kBAAM,iBAAA7S,oBAAK,AAACiD,cAAI6K;AAAV,AAAA,GAAA9N;AAAqBiO;;AAArBjO;;MAAN,cAAA,dACE6S;IAClBtF,qBAAmB,AAAC3V,gBAAMib;IAI1B1Z,QAAE,kBAAA,AAAA,iGAAA,AAAA,AAAAwC,yGAAA,AAAA,4GAAA,kCAAA,yCAAA,9SAAK/C,sNAAAA,oCACuBka,4BACND;IACxB1Z,QAAE,oCAAA,pCAACgG,wBAAUvG,yCAEAuZ,eACA/F;IACb2G,iBAAS,EAAI,AAAC9P,cAAI4P,wBAIL,EAAK,EAAI,EAAK,AAAC5P,cAAI4P,wBACL,AAAC5P,cAAI6K,wBACV,AAAC7K,cAAI,iBAAAzG,uBAAIsW;AAAJ,AAAA,GAAAtW;AAAAA;;AAASsR;;aAQlB,EAAI,CAAGsE,cAAYD,qBACf,AAAClP,cAAI4P;IAK3BE,qBAAS,uGAAA,rFAAI,AAAC7F,8BAAU9R,OACAxC,YACA4G,IACA8N,WACAC,2BAEbwF;IAEX5Z,SAAE,kBAAA,AAAAuC,eAAA,iFAAA,uDAAA,uFAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,iEAAA,rSAAO/C,uNAAAA,qDAGAma;IACTC,OAAK,sBAAA,uOAAA,3PAAMD,oBAAS,CAACpC,4DAAAA,+FAAAA,rCAASd,4EAAAA,/DAASuC,4EAAAA,hEAAYlD,4EAAAA;IACnD/V,SAAE,oCAAA,pCAACgG,wBAAUvG,oCAEA,CAAGwV,aAAO5O,KACVwT;IACbC,aAAW,AAAC1J,0BAAY3Q,YAAQ,CAAGwV,aAAO5O,KAAKwT;AAjGrD,AAkGE,oBAAM9E;AAAN,AACE,qGAAA,rGAACxO,mIAAkC8P;;AACnC,qGAAA,rGAAC9P,kIAAiCoO;;AAClC,qGAAA,rGAACpO,uIAAsCyS;;AACvC,qGAAA,rGAACzS,sIAAqCmT;;AACtC,qGAAA,rGAACnT,8HAA6B4O;;AAC9B,qGAAA,rGAAC5O,oIAAmCsP;;AACpC,qGAAA,rGAACtP,iIAAgCqT;;AACjC,qGAAA,rGAACrT,6HAA4BoT;;AAC7B,qGAAA,rGAACpT,oIAAmC0S;;AACpC,qGAAA,rGAAC1S,gIAA+B,CAACpF,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA,WAAM7C;;AAC/C,qGAAA,rGAAC1M,uIAAsC,CAAG0O,aAAO5O;;AACjD,qGAAA,rGAACE,6HAA4B,CAACpF,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA,WAAM+D;;AAZ9C;;AAaA,oBAAA,AAAA,mFAAKpa;AAAL,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,bAAK/C;;AAAL;;AACA,oBAAA,AAAA8C,eAAA,iFAAA,gEAAA,uDAAA,uFAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,iLAAA,mCAAA,yBAAA,mCAAA,gCAAA,7TAAO/C,iCAEoB,CAAC0B,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA,4BACZ4D,gCACHI,4BACGpE,gCACH4C,yBACPqB;;AAPd;;AAQA,GAAIA;AACF,AAAI,oBAAA,AAAApX,eAAA,iFAAA,uDAAA,8FAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,+KAAA,mCAAA,gCAAA,gCAAA,/RAAO/C,+BAGA,CAAC0B,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA,4BAETJ,gCAEA4C,iCAEA1C;;AATP;;AAAJ,0FAAA,sDAYK,6HAAA,mFAAA,yHAAA,qDAAA,kEAAA,hcAACzF,mHAAcoH,gLACE,AAAC3L,sBAAOmN,2JAEV9F;;AACpB,oBAAM,iBAAA5P,mBAAIqW;AAAJ,AAAA,oBAAArW;AAAAA;;AAAkByW;;;AAAxB,AACE,oBAAA,AAAAvX,eAAA,iFAAA,uDAAA,uFAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,qEAAA,kCAAA,8EAAA,lMAAO/C,iEAGEmW,iCACcF,yCACO,AAAClE,6BAAegF,SACAsB,yBAC/B,uEAAA,vEAAChY,4CAAI,AAACrB,gBAAM8Y;;AAP3B;;AAQA,oBAAI,gHAAA,hHAACnP,iCAAanG,OACA,kBACEyT,mBACAgB,aACAC,yFAEFxC,WACA,CAAG6E,iBAAeC,aAClBS,kBACAI;AAChB,AAAI,oBAAA,AAAAvX,eAAA,iFAAA,uDAAA,8FAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,+KAAA,mCAAA,gCAAA,/PAAO/C,+BAGA,CAAC0B,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA,4BAETJ,gCAEA4C;;AAPP;;AAAJ,0FAAA,sDAUK,6HAAA,mFAAA,yHAAA,qDAAA,kEAAA,hcAACnI,mHAAcoH,gLACE,AAAC3L,sBAAOmN,2JAEV9F;;AACpB,AAKE,oBAAI,iBAAApM,oBAAKyR;AAAL,AAAA,oBAAAzR;AAAiB6O;;AAAjB7O;;;AACF,AAAI,oBAAA,AAAAtE,eAAA,iFAAA,mFAAA,gEAAA,uDAAA,8FAAA,AAAA,oFACE9C;AADF,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,+KAAA,mCAAA,gCAAA,8CAAA,4BAAA,+BAAA,mCAAA,yBAAA,oBAAA,0CAAA,KAAA,veACE/C,+BAGA,CAAC0B,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA,4BAETJ,gCAEA4C,uCAEAH,qCAEAxD,+BAEAmD,iCAEA4B,gCAEAI,mBAEAhF;;AApBF;;AAwBA,oBAAA,AAAAvS,eAAA,iFAAA,mFAAA,gEAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,+KAAA,5LAAO/C,+BAEkB,CAAC0B,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA,gBACtB,yNAAA,zNAAC1N,iCACCnG,OACA,sHAAA,qDAAA,3KAACK,8CAAM,kBAAIoT,mBACFgB,aACAC,oJAGTxC,WACA,CAAG6E,iBAAeC,aAClBS,kBACAI;;AAbd;;AAxBJ;;AAkDA,IAAM9Z,SAAE,kBAAA,AAAAuC,eAAA,iFAAA,uDAAA,uFAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,mDAAA,8EAAA,0FAAA,/bAAO/C,uNAAAA,+CAGEmW,wCAEA,AAACpE,6BAAegF,SAASsB,yBACnB,uEAAA,vEAAChY,4CAAI,AAACrB,gBAAM8Y;IAC7BA,YACE,kBAAI,iBAAA1Q,oBAAK+O;AAAL,AAAA,oBAAA/O;AAAA,SACK,GAAK,AAAC2K,6BAAegF,SACAsB,wBACrB,yHAAA,zHAAClX,6CAAE,uEAAA,vEAACd,4CAAI,AAACrB,gBAAM8Y;;AAHpB1Q;;MAIF;AAAI,oBAAA,AAAAtE,eAAA,iFAAA,uDAAA,uFAAA,AAAA,oFACE9C;AADF,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,bACE/C;;AADF;;AAIA,QAAC+X,4DAAAA,8FAAAA,pCAASf,2EAAAA,vDAAoBpQ,2EAAAA,vEAAIyP,2EAAAA;;CACtCyB;IACJvX,SAAE,kBAAA,AAAAuC,eAAA,iFAAA,uDAAA,uFAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,0FAAA,9TAAO/C,uNAAAA,4CAGA,AAAC2Q,0BAAY3Q,YAAQ4G,IAAIkR;AArBxC,AAAA,0FAAA,oDAuBG,AAACpH,mHAAcoH,UACA,AAACrH,yBAAWzQ,YACA,CAAGwV,aAAO5O,KACVwT;;;;AAnHtC;;;;;AA5MZ,AAgUQ,oBAAI,iBAAAhT,oBAAK6O;AAAL,AAAA,oBAAA7O;AAAmB,gCAAA,xBAAG,AAAC5D,gBAAMgT;;AAA7BpP;;;AAaF,AACE,oBAAA,AAAAtE,eAAA,iFAAA,gEAAA,uDAAA,8FAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,+KAAA,mCAAA,gCAAA,qCAAA,oEAAA,mMAAA,3iBAAO/C,+BAGA,CAAC0B,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA,4BAETJ,gCAEA4C,iCAEA,AAACrV,gBAAMgT,yBAEP,AAAC1T,eAAKwX,4BAAU9D,qBAEhB,AAACrT,wGAAO,AAACyC,4CAAIlE,oBAAQ8U;;AAb5B;;AAeA,oBAAI,AAAC1T,eAAKwX,4BAAU9D;AAApB,0FAAA,oDAMG,AAAC9F,mHAAcoH,UACA,iBAAAyC,WACE/X;IADFgY,WASEvD;IATFwD,WAUE,CAAGjF,aAAO5O;IAVZ8T,WAWE,kBAAIhD,qBAAU,AAACoD,gBAAMtE,MAAM,AAACvX,eAAKuX;IAXnCmE,WAAA;IAAAC,WAAA;AAAA,AAAA,oIAAAL,SAAAC,SAAAC,SAAAC,SAAAC,SAAAC,sDAAAL,SAAAC,SAAAC,SAAAC,SAAAC,SAAAC,5QAACC,+DAAAA,sHAAAA;;;AAcjB,AAAI,oBAAA,AAAA/X,eAAA,iFAAA,mFAAA,gEAAA,uDAAA,8FAAA,AAAA,oFACE9C;AADF,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,+KAAA,mCAAA,gCAAA,qCAAA,oEAAA,mMAAA,3iBACE/C,+BAGA,CAAC0B,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA,4BAETJ,gCAEA4C,iCAEA,AAACrV,gBAAMgT,yBAEP,AAAC1T,eAAKwX,4BAAU9D,qBAEhB,AAACrT,wGAAO,AAACyC,4CAAIlE,oBAAQ8U;;AAdvB;;AAAJ;;;AAkBJ,AACE,oBAAA,AAAA1T,eAAA,iFAAA,gEAAA,uDAAA,8FAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,+KAAA,mCAAA,gCAAA,qCAAA,pSAAO/C,+BAGA,CAAC0B,oDAAAA,8DAAAA,ZAAQ2U,2CAAAA,4BAETJ,gCAEA4C,iCAEA,AAACrV,gBAAMgT;;AATd;;AADF,0FAAA,oDAkBG,AAAC9F,mHAAcoH,UACA,iBAAAiD,WACEvY;IADFwY,WASE/D;IATFgE,WAUE,CAAGzF,aAAO5O;IAVZsU,WAWE,kBAAIxD,qBAAU,AAACoD,gBAAMtE,MAAM,AAACvX,eAAKuX;IAXnC2E,WAAA;IAAAC,WAAA;AAAA,AAAA,oIAAAL,SAAAC,SAAAC,SAAAC,SAAAC,SAAAC,sDAAAL,SAAAC,SAAAC,SAAAC,SAAAC,SAAAC,5QAACP,+DAAAA,sHAAAA;;;;;;;;AAzZ/B;;;AA4aJ;;;;;;;;sCAAA,qDAAAQ,3FAAMG,oFAOHhZ,gBAAwEoE,IACxEuP,aAAa5Q;AARhB,AAAA,IAAA+V,aAAAD;IAAAC,iBAAA,AAAAjV,4BAAAiV;cAAAA,VAOkEtb;IAPlEub,aAAA,AAAAjV,4CAAAgV,eAOsD9Y;IAPtD+Y,iBAAA,AAAAlV,4BAAAkV;qBAAA,AAAAjV,4CAAAiV,eAAA,5EAOmBE;cAPnB,AAAAnV,4CAAAiV,eAAA,rEAO4BxF;4BAP5B,AAAAzP,4CAAAiV,eAAA,nFAOoCvF;AAPpC,AASE,IAAM0F,iBAAe,AAACC,+CAAOC,qBAAK,4CAAA,WAAAC,vDAACjW;AAAD,AAAM,GAAM,qCAAA,pCAAG,gBAAAiW,hBAACrY;AAAV,AAAAqY;;AAAA;;GAAyBtW;AAAjE,AACE,oBAAA,AAAAzC,eAAA,iFAAA,6EAAA,uDAAA,4FAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,TAAO/C,uDAGA,AAAC4F,4CAAIpC,gBAAMkY,gBACX,4CAAA,WAAAI,vDAAClW;AAAD,AAAM,uEAAAkW,hEAAClW,4CAAIlE;GAAWga;;AAJ7B;;AAOA,GAAI,EAAI,oCAAA,nCAAI,AAAClY,gBAAMkY,6BAEX,CAAG,AAAA,qFAAQ1b,WAAS,iBAAA4D,uBAAI,AAAA,4FAAYmS;AAAhB,AAAA,oBAAAnS;AAAAA;;AAAA;;;AAF5B;;AAIE,IAAMmY,sBAAoB,AAAA,iHAAsBhG;IAC1CiC,aAAW,AAAA,+FAAajC;IAIxBiG,SACE,4CAAA,WAAAC,vDAACrW;AAAD,AAAM,IAAMsW,gBAAc,gCAAA,dAAM/F,cACJ,iBAAAgG,WAAU,AAACjK,4BACC,sDAAA,tDAACrP,8CAAM7C,+DACEmW;IAFrBiG,WAGUxV;IAHVyV,WAIU,gBAAAJ,hBAACjd;AAJX,AAAA,8HAAAmd,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAACtE,4DAAAA,wFAAAA;KADH;IAad3U,SACE,kBAAI8Y,eACFA,cAEA,iBAAAI,WAAU,AAACpK,4BAAclS;IAAzBuc,WAAkC3V;IAAlC4V,WAAsC,gBAAAP,hBAACjd;AAAvC,AAAA,8HAAAsd,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAACzE,4DAAAA,wFAAAA;;AAjBX,AAkBE3U;GACNsY;IAQJM,aACE,kBAAIhE,YAAW,+CAAA,WAAAyE,1DAACd;AAAD,AAAS,IAAAe,WAAY,iBAAAD,jBAAC1D;AAAb,AAAA,4FAAA2D,kCAAAA,tHAAC1E,2CAAAA,qDAAAA;GAAuBgE,QAAQA;AAlChE,AAuCE,oBAAM,iBAAA5U,oBAAK,AAACiD,cAAI,AAACI,kCAAcuR;AAAzB,AAAA,GAAA5U;AACK,IAAAxD,mBAAI,AAACyG,cAAI8L;AAAT,AAAA,GAAAvS;AAAAA;;AACI,OAACd,eAAK6Z,sBAAM,6CAAA,WAAAC,xDAACzL;AAAD,AAAO,uIAAA,hIAAChQ,6CAAE,8EAAA,9EAACd,4CAAI,gBAAAuc,hBAAC5d;GAAmBgd;;;AAFxD5U;;;AAAN,AASE,IAAM4U,aAAO,kBAAID,qBACF,+CAAA,WAAAc,1DAAClB;AAAD,AAAS,IAAAmB,WAAqB,iBAAAD,jBAAC9D;AAAtB,AAAA,8GAAA+D,2CAAAA,jJAACf,oDAAAA,8DAAAA;GAAgCC,YAC1CA;IACTe,YAAU,AAAC5L,6CAAK,AAAC3L,gDAAQmL,0BAAY3Q,QAAQ4G,KAAKoV;IAKlDgB,uBACE,yCAAA,vBAAIhH,4BAEF,+CAAA,WAAAiH,iBAAAC,3EAAC7d;AAAD,AAAS,oBAAA4d;AAAA,AAAS,sFAAA,/EAAC9b,6CAAE,gBAAA+b,hBAACle;;AAAb;;GAAT,KAAyC+d;IAG7CI,qBAAmB,AAAA,yFAAUpH;IAC7BqH,kBAAgB,iBAAAxZ,mBAAIuZ;AAAJ,AAAA,oBAAAvZ;AAAAA;;AAAA;;;IAChByZ,UAAQ,kBAAIF,oBACF,iBAAMG,SAAO,AAACnM,6CAAK/M,iBAAO2Y;AAA1B,AACE,GAAI,GAAK,AAACrc,uBAAO4c;AACf,IAAMzL,YAAU,AAACzT,8CAAM0S,cAAIwM;IACrBC,YAAU,AAACnf,8CAAMof,cAAIF;AAD3B,AAGE,kCAAA,1BAAK,CAAGzL,YAAU0L;;AAJtB;;KAFJ;IAURE,oBAAY,CAAIJ,WAAQD;IACxBM,eAAa,AAAA,mGAAe3H;IAM5B4H,YAAU,kBAAM,iBAAAvW,oBAAK4V;AAAL,AAAA,oBAAA5V;AAAoBqW;;AAApBrW;;MAAN,AACE,AAACwW,kCACCF,aAEA,0IAAA,xHAAI,AAAA,8GAAqB3H,6FACtB,AAAC8H,cAAI,4CAAA,WAAAC,vDAAClY;AAAD,AAAM,QAAG,AAAC+F,eAAK,4CAAAmS,iBAAA,7DAACzd,qEAAUuG;uBADlC,pBAEUmW,uGACP,AAACc,cAAI,4CAAA,WAAAE,vDAACnY;AAAD,AAAM,QAAG,iBAAAmY,jBAAC3Z,qCAAUwC;6BAPhC,LACE,rBAMmCmW;IAE/Cxc,IAAE,kBAAA,AAAAuC,eAAA,iFAAA,mFAAA,gEAAA,uDAAA,4FAAA,AAAA,+FAAA,AAAA,AAAAC,yGAAA,AAAA,wGAAA,oNAAA,6BAAA,WAAA,2CAAA,wBAAA,4BAAA,4IAAA,sCAAA,6BAAA,twBAAO/C,mNAAAA,iCAEwB,AAACmD,wGAAO,6CAAA,7CAACsJ,iDAAO,AAACzN,gBAAMgd,mCAE/B0B,oBACT9W,2BACgBmV,iCACV/D,0BACE7B,kCACM,AAAA,8GAAqBJ,0BACzBiH,kCACJW;IAMtB1H,gBAAc,wCAAA,2BAAA,jDAAM+G,sBAAe,AAAChe,gBAAM2e;AA3DhD,AA4DE1H;;AArEJ;;;;AAuER,AAAA;;;;;;;kCAAA,0CAAA1X,5EAAM0f;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,8DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,8DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAle,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,gEAAA,hEAAMke,2EAMFC,KAAK3Y,KAAKb;AANd,AAOG,OAACrF,+CAAO,WAAK6e,SAAKnZ;AAAV,AACE,IAAAnB,mBAAI,EAAI,mDAAA,nDAACzC,6CAAEuD,YACL,AAACyZ,8DAAYD,SAAKnZ,QAAQ,SAAA,RAAKL,cAC/B,iBAAM0Z,YAAU,CAAGF,WAAK,AAAC1a,gBAAM,CAAC9B,oDAAAA,6DAAAA,XAAQqD,0CAAAA;AAAxC,AACE,GAAM,aAAA,ZAAMqZ;AAAZ,AAAuBA;;AAAvB;;;AAHR,AAAA,oBAAAxa;AAAAA;;AAII,yBAAA,lBAACsH;;GACbgT,KACA3Y;;;AAdL,CAAA,gEAAA,hEAAM0Y,2EAeFC,KAAK3Y;AAfT,AAee,+EAAA,xEAAC4Y,8DAAYD,KAAK3Y;;;AAfjC,CAAA,0DAAA,1DAAM0Y;;AAAN,AAiBA;;;gCAAA,hCAAMI,wEAEHC;AAFH,AAGE,oBAAMA;AAAN,AAAmB,OAAC1Y,4CAAIxB,iBAAOka;;AAA/B;;;AAEF;;;;6BAAA,7BAAMC,kEAGHve,QAAQ4G,IAAIxD;AAHf,AAIE,OAAC+N,6CAAK,AAACqN,6CAAK,AAAChZ,gDAAQmL,0BAAY3Q,QAAQ4G,KAAKxC,kBAAQhB;;AAExD;;;;oCAAA,mDAAAqb,vFAAMG,gFAGHpc,gBAGcoE,IAAIqP,cAAcC,gBAAgBC,aAAa/D,cAC7DgE,kBAAY7Q;AAPf,AAAA,IAAAmZ,aAAAD;IAAAC,iBAAA,AAAArY,4BAAAqY;cAAAA,VAMQ1e;IANR2e,aAAA,AAAArY,4CAAAoY,eAIiDlc;IAJjDmc,iBAAA,AAAAtY,4BAAAsY;qBAAA,AAAArY,4CAAAqY,eAAA,5EAIYlD;sBAJZ,AAAAnV,4CAAAqY,eAAA,7EAIqBE;4BAJrB,AAAAvY,4CAAAqY,eAAA,nFAI+B3I;YAJ/B,AAAA1P,4CAAAoY,eAAA,nEAKW9V;eALX,AAAAtC,4CAAAoY,eAAA,tEAKiB7V;sBALjB,AAAAvC,4CAAAoY,eAAA,7EAK0BxJ;sBAL1B,AAAA5O,4CAAAoY,eAAA,7EAKoCI;AALpC,AAQE,IAAMC,MAAI,AAACvb,gBAAM+B;IAEXyZ,iBAAe,AAACC,cAAI1Z;IAQpB2Z,sBACE,+HAAA,7GAAIhK,iBAAU,AAACiJ,8DAAY,CAAGvV,QAAMhC,KAAKoY;IAC3Cze,IAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,gDAAA,iDAAA,5TAAK/C,kNAAAA,2CACkC,CAAG4I,QAAMhC,4BACpBsY;IAC9BC,YAAU,uCAAA,yTAAA,9UAAMD,qBACJ,AAACE,kDAAMpf,QACA,kNAAA,lNAACwF,uDAAQyP,6BACAzS,OACAxC,QACA4G,sDACAwL,cACA6D,cACAC,gBACAC,kBAEAC,wBACT4I;IACnBG,gBAAU,gEAAA,9CAAI,AAAC1U,kCAAc0U,iBAAeA;eA5BlD,XA6BME,8FAAU,AAAC1T,eAAKpG;IAGhB+Z,gBACE,kBAAIpK,iBACF,iBAAA9N,oBAAK+X;AAAL,AAAA,oBAAA/X;AACK,OAAC+W,8DAAY,CAAGe,sBAAoB,iBAAAtb,mBAAIiF;AAAJ,AAAA,oBAAAjF;AAAAA;;AAAA;;MAAiByb;;AAD1DjY;;KADF;IAIF7G,QAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,gEAAA,qBAAA,qCAAA,rVAAK/C,kNAAAA,qDAC4Ckf,gCAChCrW,0BACKyW;IACxBC,MAAI,iCAAA,fAAMD,eACJ,iBAAAE,qBAAsB,yGAAA,zGAACvK,6BAAezS,OACAxC,QACA4G,IACAwL,cACA6D,cACAC,gBACAC,qFAEAC,kBACA,AAACpX,gBAAMqgB;AAT7C,AAAA,oBAAAG;AAAA,AAAA,iBAAAA,bAAWC;AAAX,AAAA,0FAUGA;;AAVH;;KADF;IAYJrc,SAAO,6DAAA,3DAAM,iDAAA,jDAACjC,6CAAE4d,UAAOQ,IACJ,AAAC7O,mHAAcyO,cAAUI;;AAtDlD,AAuDE,oBAAA,AAAAzc,eAAA,iFAAA,uDAAA,8FAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,2DAAA,4BAAA,2HAAA,8CAAA,2IAAA,sCAAA,qDAAA,/eAAO/C,8CAEqC,AAACwD,gBAAM+B,oBAC9B,QAAA,PAAMga,sBACX,AAACpc,wGAAOoc,gCACK,kBAAA,jBAAMJ,sCACb,AAAChc,wGAAOgc,qCACN,AAAC3b,gBAAM+b,2BACF,AAAC/b,gBAAM2b,gCACZlJ;;AATxB;;AAUA7S;;AAEJ;;;;;;;;;;;;;;;;;;mCAAA,kDAAAsc,rFAAMG,8EAiBHrd,gBAGcoE,IAAIwL,cAAQ7M;AApB7B,AAAA,IAAAoa,aAAAD;IAAAC,iBAAA,AAAAtZ,4BAAAsZ;cAAAA,VAoBQ3f;IApBR4f,aAAA,AAAAtZ,4CAAAqZ,eAkByDnd;IAlBzDod,iBAAA,AAAAvZ,4BAAAuZ;qBAAA,AAAAtZ,4CAAAsZ,eAAA,5EAkBYnE;sBAlBZ,AAAAnV,4CAAAsZ,eAAA,7EAkBqBf;4BAlBrB,AAAAvY,4CAAAsZ,eAAA,nFAkB+B5J;cAlB/B,AAAA1P,4CAAAsZ,eAAA,rEAkB+C7J;YAlB/C,AAAAzP,4CAAAqZ,eAAA,nEAmBW/W;eAnBX,AAAAtC,4CAAAqZ,eAAA,tEAmBiB9W;sBAnBjB,AAAAvC,4CAAAqZ,eAAA,7EAmB0BzK;sBAnB1B,AAAA5O,4CAAAqZ,eAAA,7EAmBoCb;AAnBpC,AAsBE,IAAMvZ,WAAK,6CAAA,7CAACsH,8EAAQtH;IACdwZ,MAAI,AAACvb,gBAAM+B;AADjB,AAIE,GAAM,AAAC8E,cAAI,iBAAAjD,oBAAK8N;AAAL,AAAA,oBAAA9N;AAAA,IAAAA,wBAAeyX;AAAf,AAAA,oBAAAzX;AAAyB,cAAA,NAAG2X;;AAA5B3X;;;AAAAA;;;AAAX,AACE,IAAM4Y,iBAAe,CAAChgB,wCAAAA,gDAAAA,VAAQwC,6BAAAA;IAGxBiZ,qBAAS,2NAAA,zMAAI,AAAA,mFAAQ,CAACjZ,uCAAAA,gDAAAA,XAAOxC,6BAAAA,iBAAcyb;IAHjDqE,aAQQ,sCAAA,23BAAA,/4BAAMrE,oBASJ,q3BAAA,r3BAAC9a,yEACC,wHAAA,xHAAC2W,gHAAWtX,wDAASwC,OAAO,6FAAA,kGAAA,9LAACwd,+CAAAA,qHAAAA,yGAC7B,6FAAA,sGAAA,lMAACA,+CAAAA,yHAAAA,qGACD,CAAA,8EAAuCxd;sBApBnD,AAAAnC,4CAAAyf,WAAA,IAAA,7EAOO5J;QAPP,AAAA7V,4CAAAyf,WAAA,IAAA,/DAOuBvf;IAiBjB0f,aAAW,iBAAArc,mBAAI,AAAA,+FAAamS;AAAjB,AAAA,oBAAAnS;AAAAA;;AAAA;;;IAsBXsc,oBAAY,iBAAA9Y,oBAAK,sBAAA,rBAAG,cAAA,bAAG6Y;AAAX,AAAA,GAAA7Y;AAAA,IAAAA,wBAA+BqU;AAA/B,AAAA,oBAAArU;AAAwC4O;;AAAxC5O;;;AAAAA;;;IACZ+O,eAAa,qCAAA,qIAAA,xJAAM+J,mBACJ,gIAAA,/HAAK,CAAG,CAAG,CAAG,AAAA,qFAAQlgB,WAAS4G,OAAKqZ,cAC5BrZ;IACvBuZ,uBACE,kBAAM,iBAAA/Y,oBAAKqU;AAAL,AAAA,oBAAArU;AAAA,IAAAA,wBAAc+O;AAAd,AAAA,oBAAA/O;AAA2B,OAACiD,cAAI6K;;AAAhC9N;;;AAAAA;;MAAN,sFAAA,tFACE,AAACoU,oCAAsBhZ,OACA0T,gBACAtP,IACAuP,aACA5Q;IAE3B0Q,gBACE,kBAAM,iBAAA7O,oBAAKqU;AAAL,AAAA,oBAAArU;AAAc,OAACiD,cAAI6K;;AAAnB9N;;MAAN,8EAAA,9EACE,+DAAA,/DAACoU,oCAAsBhZ,OAAO0T,gBAAgBtP,SAAQrB;IAC1DhF,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,uDAAA,8DAAA,4FAAA,AAAA,+FAAA,AAAA,AAAAC,yGAAA,AAAA,wGAAA,sBAAA,lPAAO/C,mNAAAA,yCAIAwC,OACA,iBAAA4d,WAAS,AAACphB,gBAAM,AAACA,gBAAMuG;AAAvB,AAAA,8GAAA6a,2CAAAA,jJAAC1e,oDAAAA,8DAAAA;KALR,yBAAA,6CAAA,qCAAA,7FAMqBue,mCACUE,sCACPlK;IAC1B1V,QAAE,kBAAA,iBAAAqD,mBAAA,AAAA,mFAAW5D;AAAX,AAAA,oBAAA4D;AAAAA;;AAAA,OAAA,+FAAW5D;;MAAX,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,sIAAA,qCAAA,pLAAW/C,yCACgC,AAAA,6FAAYA,qBAChCyb;wBAxE/B,pBAyEMrF;IACAiK,yBAAiB,AAAA,4GAAmBL;IAEpCM,gBAAc,wCAAA,iJAAA,vKAAMH,sBAKJ,AAACvB,kCAAoBpc,OACAxC,QACA4G,IACAuZ,qBACAjK,gBACAC,aACA/D,cACAgE,kBACA7Q;IACrCnC,SAAO,iCAAA,mIAAA,lJAAM6S,eAIJ,AAAC2I,kCAAoBpc,OACAxC,QACA4G,IACAqP,cACAC,gBACAtN,MACAwJ,cACAgE,kBACA7Q;IAE9BnC,aAAO,kBAAI,iBAAAgE,oBAAKhE;AAAL,AAAA,oBAAAgE;AAAYkZ;;AAAZlZ;;MAEF,iBAAMmZ,eACE,AAACvP,mCAAqBhR,QAAQ4G,IAAIxD;IACpCod,sBACE,AAACxP,mCAAqBhR,QAAQ4G,IAAI0Z;AAH1C,AAQE,oBAAA,AAAAxd,eAAA,iFAAA,uDAAA,8DAAA,8FAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,+BAAA,xCAAO/C,kDAIAwC,OACA,iBAAAie,WAAS,AAACzhB,gBAAM,AAACA,gBAAMuG;AAAvB,AAAA,8GAAAkb,2CAAAA,jJAAC/e,oDAAAA,8DAAAA;KALR,yBAAA,6BAAA,xCAMqBue,2BACEM,oCACOC;;AAR9B;;AAcA,GAAI,CAAG,AAACxhB,gBAAMwhB,uBAAqB,AAACxhB,gBAAMuhB;AACxCnd;;AACAkd;;KAEJ,iBAAA1c,mBAAIR;AAAJ,AAAA,oBAAAQ;AAAAA;;AAAW0c;;;IACpBld,aAAO,kBAAIA,YACFA,WAMA,qDAAA,rDAACwb,kCAAoBpc,OACAxC,QACA4G,SAEA5G,QACA4I,MACAwJ,cACAgE,kBACA7Q;IApJpCwa,aAwJQ,kBAAIM,wBACF,iBAAMM,gBAAc,AAACC,cAAI,AAACzP,6CAAKnS,gBAAMoE;AAArC,AACE,GAAI,mCAAA,lCAAI,AAACI,gBAAMmd;AAAf,0FAAA,MACSvd,WAAOud;;AADhB,0FAAA,KAAA,KAEYA;;KAJhB,mFAAA,iBAAA,XAKSvd;kCA7JjB,AAAA/C,4CAAA0f,WAAA,IAAA,zFAuJOW;iBAvJP,AAAArgB,4CAAA0f,WAAA,IAAA,xEAuJ6B3c;oBAvJ7B,AAAA/C,4CAAA0f,WAAA,IAAA,3EAuJoCY;IAO9Bvd,aAAO,kBAAIsd,6BAOF,qDAAA,iCAAA,tFAAC9B,kCAAoBpc,OACAxC,QACA4G,SAEA5G,QACA4I,MACAwJ,mBAEA7M,UACrBnC;IACT7C,QAAE,+CAAA,7BAAMmgB,6BACJ,iBAAMC,oBAAc,AAACC,cAAI,AAACzP,6CAAKnS,gBAAMoE;AAArC,AACE,GAAM,sCAAA,rCAAG,AAACI,gBAAMmd;AAAhB,AACE,oBAAA,AAAA,mFAAQ3gB;AAAR,AAAA,OAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,oDAAA,8CAAA,nNAAQnD,qOAGkB2gB;;AAH1B;;;AADF;;KAFJ;AA/KR,AAsLE,oBAAA,AAAA,mFAAQ3gB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,+BAAA,+BAAA,0CAAA,oDAAA,7QAAQnD,4IAC2B+e,qBACV9I,iCACEoK,+CACKK,6CACPC;;AALzB;;AAMA,oBAAA,AAAA,mFAAK3gB;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,TAAK/C,uCAEA,iBAAA6gB,WAAA;IAAAC,WAAuB1d;IAAvB2d,eAAC,AAAA,yFAAU/gB;AAAX,AAAA,QAAA+gB,6CAAAA,2CAAAF,SAAAC,YAAAC,wBAAAF,SAAAC;;;AAFL;;AAGA,AAQI1d;;AAxMR;;;AA8MJ;;;;6BAAA,7BAAM4d,kEAGHC,EAAEC;AAHL,AAIE,GAAM,EAAK,OAASD,oBAAG,OAASC;AAAI,OAACC,kBAAQF,EAAEC;;AAA/C,AACY,OAACC,kBAAQ,4CAAKF,GAAG,4CAAKC;;;;AAEpC;;;;qCAAA,rCAAME,kFAGHC,UAAUC,cAAcC,WAAWN,EAAEC;AAHxC,AAIE,oBAAM,iBAAA9Z,oBAAK,CAACia,0CAAAA,6CAAAA,LAAUJ,0BAAAA;AAAhB,AAAA,oBAAA7Z;AAAmB,QAACia,0CAAAA,6CAAAA,LAAUH,0BAAAA;;AAA9B9Z;;;AAAkC,OAAC+Z,kBAAQ,CAACE,0CAAAA,6CAAAA,LAAUJ,0BAAAA,IAAG,CAACI,0CAAAA,6CAAAA,LAAUH,0BAAAA;;AAA1E,oBACM,CAACG,0CAAAA,6CAAAA,LAAUJ,0BAAAA;AAAG,GAAI,CAAG,CAACI,0CAAAA,6CAAAA,LAAUJ,0BAAAA,MAAGK;AAArB;;AAAA;;;AADpB,oBAEM,CAACD,0CAAAA,6CAAAA,LAAUH,0BAAAA;AAAG,GAAI,CAAG,CAACG,0CAAAA,6CAAAA,LAAUH,0BAAAA,MAAGI;AAArB;;AAAA;;;AAFpB,GAGM,AAACngB,6CAAEogB,WAAWN;AAHpB;;AAAA,GAIM,AAAC9f,6CAAEogB,WAAWL;AAJpB;;AAAA,AAKY,OAACF,2BAAaC,EAAEC;;;;;;;;AAE9B;;;;;;;;;;0BAAA,yCAAAM,nEAAMG,4DASHnf,gBAGcwf,OAAOrd;AAZxB,AAAA,IAAA8c,aAAAD;IAAAC,iBAAA,AAAApb,4BAAAob;cAAAA,VAYQzhB;IAZR0hB,aAAA,AAAApb,4CAAAmb,eAUsDjf;IAVtDkf,iBAAA,AAAArb,4BAAAqb;kBAAA,AAAApb,4CAAAob,eAAA,zEAUYE;0BAVZ,AAAAtb,4CAAAob,eAAA,jFAUkBG;gBAVlB,AAAAvb,4CAAAob,eAAA,vEAUgCI;gBAVhC,AAAAxb,4CAAAob,eAAA,vEAU0CL;qBAV1C,AAAA/a,4CAAAmb,eAAA,5EAWWM;AAXX,AAaE,oBAAA,AAAA,mFAAQ/hB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,2BAAA,uBAAA,oBAAA,oCAAA,0BAAA,rPAAQnD,qIACoBwC,oBACPsf,kBACLF,4BACQC,+BACLE,4BACEV;;AANrB;;AAOA,IAAMA,gBAAU,iBAAAzd,mBAAIyd;AAAJ,AAAA,oBAAAzd;AAAAA;;AAAA;;;IACV0d,gBAAc,iBAAA1d,mBAAI,2FAAA,2EAAA,rKAACyd,8CAAAA,8FAAAA;AAAL,AAAA,oBAAAzd;AAAAA;;AAAmB,+BAAA,vBAAK,AAACJ,gBAAMmB;;;AADnD,AAEE,oBAAI,iBAAAyC,oBAAKwa;AAAL,AAAA,oBAAAxa;AAAW,oBAAI2a;AAASF;;AAAb;;;AAAXza;;;AACF,oDAAA,WAAA6a,iBAAAC,zEAACC;AAAD,AACG,OAAC,AAAC3c,gDAAQ4b,mCAAqBC,cAAUC,cAAc,CAACc,uDAAAA,yDAAAA,sCACrD,AAAC7gB,wBAAUvB,QAAQ,6EAAAiiB,sCAAAA,lHAACD,uCAAAA,yDAAAA,sCACpB,AAACzgB,wBAAUvB,QAAQ,6EAAAkiB,sCAAAA,lHAACF,uCAAAA,yDAAAA;GACxBrd;;AACFA;;;AAEN;;;;;;;oCAAA,pCAAM0d,gFAMHnhB;AANH,AAOE,IAAA0C,mBAAI,CAAC0W,4DAAAA,kEAAAA,RAAUpZ,+CAAAA;AAAf,AAAA,oBAAA0C;AAAAA;;AAAA,IAAAA,uBAAqB,CAAC0e,2DAAAA,iEAAAA,RAASphB,8CAAAA;AAA/B,AAAA,oBAAA0C;AAAAA;;AAAqC,QAACsU,4DAAAA,kEAAAA,RAAUhX,+CAAAA;;;;AAElD;;;;8BAAA,9BAAMqhB,oEAGHC,YAAYthB;AAHf,AAIE,oBAAMshB;AAAN,AACE,IAAApb,oBAAK,yLAAA,zLAACjG,6CAAE,CAACC,iDAAAA,uDAAAA,RAAKF,oCAAAA;AAAd,AAAA,GAAAkG;AACK,IAAM5H,IAAE,CAACkC,oDAAAA,0DAAAA,RAAQR,uCAAAA;AAAjB,AACE,IAAA0C,mBAAI,CAAC4e,4CAAAA,+CAAAA,LAAYhjB,4BAAAA;AAAjB,AAAA,oBAAAoE;AAAAA;;AACI,IAAM6e,YAAU,AAACC,+CAAO,AAAClE,6CAAKnU,cAAIsY,yBAASH;AAA3C,AACE,GAAM,GAAK,AAAC9hB,uBAAO+hB;AAAnB,AACE,sBAAA,WAAAG,1BAAC9f;AAAD,AAAO,yBAAA8f,lBAACtb,mCAAU9H;GAAGijB;;AADvB;;;;AAJbrb;;;AADF;;;AASF;;;;;sCAAA,8CAAAyb,pFAAMjL,6FAI6B1W;AAJnC,AAAA,IAAA4hB,aAAAD;IAAAC,iBAAA,AAAAzc,4BAAAyc;cAAAA,VAI0B9iB;qBAJ1B,AAAAsG,4CAAAwc,eAAA,5EAIWf;AAJX,AAME,GAAM,4DAAA,5DAAC5gB,6CAAE4gB;AAAT,AAA2B,yMAAA,lMAAC5gB,6CAAE,CAACO,oDAAAA,0DAAAA,RAAQR,uCAAAA;;AAAvC;;;AAMF;;;;+BAAA,/BAAM6hB,sEAGHC,EAAEC;AAHL,AAIE,GAAI,AAACtY,sBAAMsY;AACT,IAAMC,WAAS,AAAClkB,gBAAMikB;IAChBE,WAAS,AAAClkB,eAAKgkB;AADrB,AAEE,GAAIE;AACF,IAAMC,cAAY,iBAAAC,WAAgB,AAAC/c,4CAAI0c,EAAEE;IAAvBI,WAAiC,AAACrkB,eAAKgkB;AAAvC,AAAA,gIAAAI,SAAAC,oDAAAD,SAAAC,9LAACP,6DAAAA,gFAAAA;;AAAnB,AACE,GAAI,AAACriB,uBAAO0iB;AACV,OAACzf,+CAAOqf,EAAEE;;AACV,OAACrgB,8CAAMmgB,EAAEE,SAASE;;;AACtB,OAACzf,+CAAOqf,EAAEE;;;AACd,OAACvf,+CAAOqf,EAAEC;;;AAEd;;;;;sCAAA,tCAAMM,oFAIHP,EAAEC;AAJL,AAKE,GAAI,AAACtY,sBAAMsY;AACT,GAAI,+KAAA,/KAAC9hB,6CAAE,oDAAA,pDAACqiB,+CAAOR,EAAEC;AACfD;;AACA,OAACD,6BAAeC,EAAEC;;;AACpB,GAAI,4KAAA,5KAAC9hB,6CAAE,iDAAA,jDAACmF,4CAAI0c,EAAEC;AAAyCD;;AAAE,OAACrf,+CAAOqf,EAAEC;;;;AAEvE;;;;;+BAAA,/BAAMQ,sEAIHT,EAAEC;AAJL,AAKE,GAAI,AAACtY,sBAAMsY;AACT,GAAI,+KAAA,/KAAC9hB,6CAAE,oDAAA,pDAACqiB,+CAAOR,EAAEC;AACfD;;AACA,+BAAA,xBAACU,mBAASV,EAAEC;;;AACd,GAAI,4KAAA,5KAAC9hB,6CAAE,iDAAA,jDAACmF,4CAAI0c,EAAEC;AACZD;;AACA,0DAAA,nDAACngB,8CAAMmgB,EAAEC;;;;AAEf;;;;2BAAA,0CAAAU,rEAAMG,8DAGHthB,gBAAoEtB;AAHvE,AAAA,IAAA0iB,aAAAD;IAAAC,iBAAA,AAAAvd,4BAAAud;cAAAA,VAG8D5jB;IAH9D6jB,aAAA,AAAAvd,4CAAAsd,eAGkDphB;IAHlDqhB,iBAAA,AAAAxd,4BAAAwd;iBAAA,AAAAvd,4CAAAud,eAAA,xEAGmBE;wBAHnB,AAAAzd,4CAAAud,eAAA,/EAG8BG;AAH9B,AAIE,IAAMC,iBAAe,kBAAID,mBACF,AAAC3kB,+CAAOkkB,oCAAsBriB,KAAK8iB,mBACnC9iB;IACjBgjB,UAAQ,kBAAIH,YACF,AAAC1kB,+CAAOokB,6BAAeQ,eAAeF,YACtCE;AALhB,AAMEC;;AAMJ;;;;;;;;;;;;;mCAAA,nCAAMC,8EAYH3hB,OAAOxC,QAAQuF;AAZlB,AAaE,GAAU,AAAC7E,uBAAO6E;AAAlB;;AAAA,AACE,IAAMgI,aAAW,AAACD,6BAAetN;IAC3BwiB,cAAY,AAAA,kGAAc,CAAChgB,uCAAAA,gDAAAA,XAAOxC,6BAAAA;AADxC,AAEE,IAAOoe,YAAU7Y;qBAAjB,jBACO6e;YADP,RAEO7X;IACA5H,MAAI,qBAAA,rBAACyG;;AAHZ,AAIE,oBAAA,AAAA,mFAAQpL;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,mCAAA,2BAAA,/KAAQnD,8IAC6BuM,kBACjB6X,kCAEO,iBAAAC,WAAS,AAACrlB,gBAAMof;AAAhB,AAAA,8GAAAiG,2CAAAA,jJAAC3iB,oDAAAA,8DAAAA;KAJ5B,oBAK4B,iBAAA4iB,WAAS,AAAClgB,iBAAOga;AAAjB,AAAA,8GAAAkG,2CAAAA,jJAAC5iB,oDAAAA,8DAAAA;;;AAL7B;;AAMA,GAAA,AAAA2I,cAAQ+T;AAAR,0FACGgG,eAAS,AAAC/Y,2BAAY1G;;AACvB,IAAA4f,aACQ,iFAAA,6GAAA,sHAAA,aAAA,/SAAM,AAAClC,kCAAc,AAACrjB,gBAAMof,gGACnB,AAACnf,eAAKmf,8FAAY,AAACpf,gBAAMof,kDAC5B,iBAAAxa,mBAAI,AAACye,kCAAc,AAACje,iBAAOga;AAA3B,AAAA,oBAAAxa;AAAAA;;AACI,OAACgU,oCAAgB5X,QAAQ,AAACoE,iBAAOga;;MACnC,iBAAAuG,aAGQ,qBAAA,rBAACI;kBAADD;AAAA,AAAa,IAAAlhB,mBAAI,kCAAAkhB,lCAACzC;AAAL,AAAA,oBAAAze;AAAAA;;AACI,mDAAAkhB,5CAAClN,oCAAgB5X;;;CACtB,AAACf,eAAKmf;kBAL1B,AAAA/d,4CAAAskB,WAAA,IAAA,zEAAOC;eAAP,AAAAvkB,4CAAAskB,WAAA,IAAA,tEAAmBE;AAAnB,AAME,oBAAI,AAAC7lB,gBAAM6lB;AAAX,uiBAAA,7cAGG,AAAC5lB,eAAK4lB,UACN,6CAAA,7CAAChY,8EACK,sDAAA,oLAAA,1OAACL,yIAAQ,AAACxN,gBAAMof,mBACRwG,iJACC,AAAC5lB,gBAAM6lB;;AAPzB,oHAAA,sHAAA,hJAWG,AAAC5lB,eAAKmf,8FAAY,AAACpf,gBAAMof;;KArBtC,gFAAA,6GAAA,sHAAA,aAAA,AAAA,6HAAA,kJAAA,7kBAsBM,wEAAA,xEAACjd,6CAAE,AAACqC,gBAAM4a,oGAAe,AAACnf,eAAKmf,8FACL,AAACpf,gBAAMof,mHAC1B,AAACnf,eAAK,AAACA,eAAKmf,+FACX,AAACpf,gBAAMof,WAAW,AAACha,iBAAOga;;oBA1BhD,AAAA/d,4CAAAkkB,WAAA,IAAA,3EAAOC;eAAP,AAAAnkB,4CAAAkkB,WAAA,IAAA,tEAAqBE;yBAArB,AAAApkB,4CAAAkkB,WAAA,IAAA,hFAA8BG;IA2BxBA,yBAAa,iBAAA9gB,mBAAI8gB;AAAJ,AAAA,oBAAA9gB;AAAAA;;AACI,OAAC2e,4BAAQC,YAAY,AAACxjB,gBAAMof;;;AA5BnD,AA+BE,oBAAA,AAAA,mFAAQpe;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD,wJACuC,iBAAAglB,WAAS,AAAChmB,gBACCylB;AADX,AAAA,8GAAAO,2CAAAA,jJAACtjB,oDAAAA,8DAAAA;KADhD,aAGqB,iBAAAujB,WAAM,AAACjmB,gBAAMylB;AAAb,AAAA,wGAAAQ,wCAAAA,xIAAC7jB,iDAAAA,2DAAAA;KAHtB,mCAAA,1BAIiB,AAACoC,gBAAMihB,kBACR,iBAAAS,WAAS,AAAC/a,eAAKsa;AAAf,AAAA,8GAAAS,2CAAAA,jJAACxjB,oDAAAA,8DAAAA;;;AALjB;;AAMA,eAAO,8CAAA,5CAAM,CAAG,SAAA,RAAK6K,eAAOgB,aAAYiX,gCAC3B,iBAAApd,oBAAK,AAACjG,6CAAE,SAAA,RAAKoL,aAAOgB;AAApB,AAAA,GAAAnG;AAAgCod;;AAAhCpd;;qMADN,AAAA,/LAEQ,KAAA2H,eAAA,2JAAA,KAAA,IAAA,/JAAM,CAACqT,uDAAAA,yDAAAA;;eAEf,iBAAAxe,mBAAIwgB;AAAJ,AAAA,oBAAAxgB;AAAAA;;AAAa8gB;;;eACb,SAAA,RAAKnY;eACL,AAACpB,mDAAMxG,IAAI8f;;;;;;;;;;;AAM9B;;;;;;2BAAA,3BAAMU,8DAKH5f;AALH,AAME,oBAAI,iBAAA3B,mBAAI,iBAAAwhB,WAAU,AAACpmB,gBAAMuG;AAAjB,AAAA,4HAAA6f,kDAAAA,tKAACC,2DAAAA,qEAAAA;;AAAL,AAAA,oBAAAzhB;AAAAA;;AAA4B,IAAA0hB,WAAwB,AAACtmB,gBAAMuG;AAA/B,AAAA,wJAAA+f,gEAAAA,hNAACC,yEAAAA,mFAAAA;;;AAE/B,YAAAxW,eAAA,UAAA,KAAA,IAAA,dAAMxJ;;AACN,IAAMkgB,UAAQ,AAACC,kBAAQngB;IAAvBigB,aAGQ,qBAAA,WAAAI,hCAACb;AAAD,AAAa,OAAC1a,cAAI,iBAAAzG,mBAAI,iHAAAgiB,wDAAAA,xKAACC,yDAAAA,2EAAAA;AAAL,AAAA,oBAAAjiB;AAAAA;;AAAe,oJAAAgiB,sEAAAA,lNAACE,uEAAAA,yFAAAA;;;GAA0BL;qBAHpE,AAAAplB,4CAAAmlB,WAAA,IAAA,5EACOG;QADP,AAAAtlB,4CAAAmlB,WAAA,IAAA,/DACsBjlB;IAIhBolB,qBAAe,AAAC/f,4CAAImgB,eAAK,AAACL,kBAAQC;IAClCK,YAAU,AAACvZ,6CAAK,CAAG,AAACjJ,gBAAM+B,QAAM,AAAC/B,gBAAMmiB,qBAAiBpgB;AAN9D,AAOE,GAAI,AAAC7E,uBAAOslB;AACVL;;AACA,OAACnZ,+CAAO,KAAAuC,eAAA,eAAA,KAAA,IAAA,nBAAMiX,0BAAWL;;;;AAEjC;;;;;;;;;;;;;;kCAAA,lCAAMM,4EAaHjmB,QAAQyX,aAAalS;AAbxB,AAeE,oBAAA,AAAA,mFAAQvF;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD,sIAA6ByX;;AAArC;;AAEA,oBAAA,AAAA,mFAAKzX;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,TAAK/C,oCAAmC,AAAC4F,4CAAIlE,oBAAQ6D;;AAArD;;AACA,IAAM2gB,WAAS,qDAAA,WAAAC,hEAACC;AAAD,AACG,IAAAxiB,mBAAI,qHAAAuiB,0DAAAA,9KAACd,2DAAAA,6EAAAA;AAAL,AAAA,oBAAAzhB;AAAAA;;AAAA,IAAAA,uBAAiB,+GAAAuiB,uDAAAA,rKAACE,wDAAAA,0EAAAA;AAAlB,AAAA,oBAAAziB;AAAAA;;AAA2B,wJAAAuiB,wEAAAA,xNAACZ,yEAAAA,2FAAAA;;;GAC7BhgB;IACXogB,iBAAe,AAACW,sDAAOnB,2EAAWe;AAHxC,AAME,IAAO9H,YAAUuH;IACVhhB,MAAI,qBAAA,rBAACyG;;AADZ,AAIE,GAAI,AAAC1K,uBAAO0d;AACV,IAAMhb,SAAO,AAACiI,2BAAY1G;AAA1B,AAEEvB;;AACF,IAAAmjB,aACQ,kBAAM,iBAAAnf,oBAAK,iBAAAxD,mBAAI,iBAAA8iB,WAAU,AAAC3N,iBAAOqF;AAAlB,AAAA,4HAAAsI,kDAAAA,tKAACrB,2DAAAA,qEAAAA;;AAAL,AAAA,oBAAAzhB;AAAAA;;AAAA,IAAAA,uBACI,iBAAA+iB,WAAO,AAAC5N,iBAAOqF;AAAf,AAAA,sHAAAuI,+CAAAA,7JAACN,wDAAAA,kEAAAA;;AADL,AAAA,oBAAAziB;AAAAA;;AAEI,IAAAgjB,WAAwB,AAAC7N,iBAAOqF;AAAhC,AAAA,wJAAAwI,gEAAAA,hNAACrB,yEAAAA,mFAAAA;;;;AAFV,AAAA,oBAAAne;AAAA,IAAAA,wBAGK,GAAK,AAAC1G,uBAAO,AAAC0D,iBAAOga;AAH1B,AAAA,GAAAhX;AAQK,IAAAxD,mBAAI,GAAK,EAAI,AAACzC,6CAAE,iBAAA0lB,WAAM,AAAC7nB,gBAAM,AAACoF,iBAAOga;AAArB,AAAA,wGAAAyI,wCAAAA,xIAACzlB,iDAAAA,2DAAAA;KAAJ,gEAEA,AAACD,6CAAE,iBAAA2lB,WAAM,AAAC9nB,gBAAM,AAACoF,iBAAOga;AAArB,AAAA,wGAAA0I,wCAAAA,xIAAC1lB,iDAAAA,2DAAAA;KAAJ;AAFb,AAAA,GAAAwC;AAAAA;;AAII,IAAAmjB,WAAQ,AAAC5c,eAAK,AAAC/F,iBAAOga;AAAtB,AAAA,wHAAA2I,gDAAAA,hKAAClB,yDAAAA,mEAAAA;;;AAZVze;;;AAAAA;;MAkBE,EAAI,yFAAA,zFAACjG,6CAAE,AAACqC,gBAAM,AAACxE,gBAAMof,kBAEnB,AAAA,mFAKK,4BAAA,5BAAC4I,kBAAQ5I,eACT,AAACjT,mDAAMxG,IACA,AAAC6H,+CAAO,AAACxN,gBAAMof,WACP,AAACha,iBAAOga,qBAC5B,AAEE,kBAAI,iBAAAhX,oBAAKqQ;AAAL,AAAA,oBAAArQ;AACK,IAAA6f,WAAc,iBAAAC,WAAS,AAACnO,iBACCqF;AADX,AAAA,8GAAA8I,2CAAAA,jJAACxlB,oDAAAA,8DAAAA;;AAAf,AAAA,gGAAAulB,oCAAAA,5HAACxP,6CAAAA,uDAAAA;;AADNrQ;;ypCA/BhB,AAAA,/SA+BY,p2BAGE,EAAI,yFAAA,zFAACjG,6CAAE,AAACqC,gBAAM,AAACxE,gBAAMof,kBASnB,AAAA,mFACK,4BAAA,5BAAC4I,kBAAQ5I,eACT,AAACjT,mDAAMxG,IACA,AAAC6H,+CAAO,AAACxN,gBAAMof,WACP,AAACha,iBAAOga,qBAU5B,AAAA,mFACK,EAAI,AAACnf,eAAK,AAACA,eAAK,AAACD,gBAAMof,cACrB,AAAC+I,eAAK,AAACloB,eAAK,AAACA,eAAK,AAACD,gBAAMof,aACnB,AAACnf,eAAKmf,YACZ,AAACnf,eAAKmf,YACR,AAACjT,mDAAMxG,IACA,KAAAoK,eAAA,iCAAA,KAAAA,eAAA,kDAAA,KAAA,IAAA,OAAA,IAAA,tHAAM,AAACgK,iBAAOqF,oCACR,AAACha,iBAAO,AAACpF,gBACCof,oIAI7B,AAAC+I,eAAK,AAACloB,eAAK,AAACD,gBAAMof,YAAY,AAACnf,eAAKmf,YACrC,AAACjT,mDAAMxG,IAAI,KAAAoK,eAAA,iCAAA,KAAA,IAAA,rCAAM,AAACgK,iBAAOqF,yHAC3B,AAACnf,eAAKmf,WAAW,AAACjT,mDAAMxG,IAAI,AAAC3F,gBAAMof;;qBAxExD,AAAA/d,4CAAAkmB,WAAA,IAAA,5EAAOC;cAAP,AAAAnmB,4CAAAkmB,WAAA,IAAA,rEAAsBE;AAAtB,AAyEE,eAAOD;eAAeC;;;;;;;;AAEhC,AAAA;;;;yBAAA,iCAAAloB,1DAAM8oB;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,qDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,qDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAtnB,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,uDAAA,vDAAMsnB,kEAGFrnB,QAAQ4G,IAAI1F,KAAKwB,MAAM4kB;AAH3B,AAAA,0FAAA,mFAIK5kB,MAAM,AAACgQ,yBAAW1S,QAAQ,iBAAA4D,mBAAI0jB;AAAJ,AAAA,oBAAA1jB;AAAAA;;AAAWlB;;MAAQ,iBAAAkB,mBAAI0jB;AAAJ,AAAA,oBAAA1jB;AAAAA;;AAAA;;KAAmBgD;;;AAJrE,CAAA,uDAAA,vDAAMygB,kEAKFrnB,QAAQ4G,IAAI1F,KAAKwB;AALrB,AAK4B,mFAAA,5EAAC6kB,qDAASvnB,QAAQ4G,IAAI1F,KAAKwB;;;AALvD,CAAA,iDAAA,jDAAM2kB;;AAAN,AAOA,AAAA,AACA,AAAA,AAEA,oCAAA,4CAAAG,hFAAM7N,yFAC6C/S,IAAI1F;AADvD,AAAA,IAAAumB,aAAAD;IAAAC,iBAAA,AAAAphB,4BAAAohB;cAAAA,VAC0CznB;IAD1C0nB,aAAA,AAAAphB,4CAAAmhB,eAAA;IAAAC,iBAAA,AAAArhB,4BAAAqhB;0BAAA,AAAAphB,4CAAAohB,eAAA,jFACYC;AADZ,AAEE,oBAAA,AAAA,mFAAK3nB;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,gCAAA,zCAAK/C,qCAAoC4G,YAAY,iBAAAghB,WAAS,CAACrU,mDAAAA,yDAAAA,RAAOrS,sCAAAA;AAAjB,AAAA,8GAAA0mB,2CAAAA,jJAAClmB,oDAAAA,8DAAAA;;;AAAtD;;AACA,IAAM1B,cAAQ,AAACiS,wBAAUjS;YAAzB,RACMyC;YADN,RAEMC;gBAFN,mFAAA,qIAAA,pOAGMmlB,kLAAYplB,MAAM,AAACiQ,yBAAW1S,YAAQyC;IACtCqlB,YAAU,AAACP,qDAASvnB,YAAQ4G,IAAI1F,KAAKwB;AAJ3C,AAKE,IAAAmR,uBAEU,EAAI,+LAAA,/LAAC1S,6CAAE,CAAC6Y,mDAAAA,yDAAAA,RAAO9Y,sCAAAA,aACb,AAACwP,mHAAcmX,UAAUC,gBACzB,AAACpX,mHACCmX,UACA,iBAAAE,WACE,AAAA,wFAAU/nB;IADZgoB,WAEE,OAAA,NAAKphB;IAFPqhB,WAGE,iCAAA,kFAAA,nHAACpI,2FAEC7f,YACA,OAAA,NAAK4G,iBAEL,AAACxC,iBACC,iCAAA,jCAAC+f,2FAECnkB,YAkBA,qIAAA,2HAAA,/PAACmoB,mEAAAA,8IAAAA,pBAA6BnoB,2HAAAA,/GAAQkB,2HAAAA;AA7B9C,AAAA,kIAAA6mB,SAAAC,SAAAC,qDAAAF,SAAAC,SAAAC,nNAACC,8DAAAA,0FAAAA;KA8BDJ;AApCd,AAAA,oBAAA,AAAA,mFAAU9nB;AAAV,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,4BAAA,AAAAI,wGAAA0Q,jJAAU7T;;AAAV;;AAAA6T;;AAsCJ;;;;;;;6BAAA,qCAAAuU,lEAAME,2EAMgD9lB,OAAO2Q,QAAQC,QAClEC,KAAKmV,WAAWtnB;AAPnB,AAAA,IAAAmnB,aAAAD;IAAAC,iBAAA,AAAAhiB,4BAAAgiB;cAAAA,VAM6CroB;sBAN7C,AAAAsG,4CAAA+hB,eAAA,7EAMWnT;8BANX,AAAA5O,4CAAA+hB,eAAA,rFAMqBE;AANrB,AAQE,oBAAA,AAAA,mFAAKvoB;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,TAAK/C,iCAAgCwC;;AAArC;;AACA,IAAMgR,UAAQ,kBAAM,iBAAApM,oBAAK,AAACqM,gDAAKN,QAAQC;AAAnB,AAAA,GAAAhM;AAAA,IAAAA,wBACK,iBAAAqhB,eAAC,CAACzoB,wCAAAA,gDAAAA,VAAQwC,6BAAAA;AAAV,AAAA,QAAAimB,6CAAAA,2CAAA,0DAAAA,wBAAA;;AADL,AAAA,oBAAArhB;AAIK,OAACiD,cAAI,iBAAAqe,WAAW,AAAC1pB,gBAAMkC;AAAlB,AAAA,8HAAAwnB,mDAAAA,zKAACxQ,4DAAAA,sEAAAA;;;AAJX9Q;;;AAAAA;;MAAN,AAKE,mHAAA,mFAAA,uFAAA,qDAAA,kEAAA,pZAACsJ,yRAAgB,+IACF,iBAAAiY,WAAM,AAACne,sBAAQxK;IAAf4oB,WAAwBzV;IAAxB0V,WAAgC3nB;AAAhC,AAAA,gFAAAynB,SAAAC,SAAAC,4BAAAF,SAAAC,SAAAC,xIAACxV,qCAAAA,iEAAAA;WANlB;IAQR9S,IAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,+BAAA,1PAAK/C,kNAAAA,iCACwBwC,eAChB,iBAAAsmB,eAAC,CAAC9oB,wCAAAA,gDAAAA,VAAQwC,6BAAAA;AAAV,AAAA,QAAAsmB,6CAAAA,2CAAA,0DAAAA,wBAAA;WAFb;IAGFtV,cAAQ,uMAAA,QAAA,7MAAM,2HAAA,3HAACC,gDAAK,sEAAA,tEAACpT,4CAAI,AAAC+D,iBAAOoP,wFAA6BA;IAC9DkB,aAAW,iBAAA9Q,mBAAI4kB;AAAJ,AAAA,oBAAA5kB;AAAAA;;AAAe,QAACoW,mDAAAA,yDAAAA,RAAO9Y,sCAAAA;;;IAClC6nB,WAAS,AAACpY,0BAAY3Q,QAAQ,WAAA,VAAKmT,eAASK;AAblD,AAgBE,oBAAI,iBAAA5P,mBAAI,AAACmO,6BAAe/R,QAAQ+oB;AAA5B,AAAA,GAAAnlB;AAAAA;;AAAsCsR;;;AACxC1B;;AACA,IAAM4G,OAAK,iBAAMhX,SAAO,CAACiQ,qCAAAA,2DAAAA,xBAAKrT,wCAAAA,hCAAQoT,wCAAAA,hCAAQlS,wCAAAA;AAAnC,AACE,OAACwP,mHAKC,0GAAA,mFAAA,wFAAA,qDAAA,yDAAA,qBAAA,mFAAA,+KAAA,qDAAA,yDAAA,tvBAAI,2CAAA,zBAAI6X,8BAAsB,AAAChY,8BAAUnN,gLACrC,8SACA,CAAA,iDAAU,AAAC+I,sBAAOiH,uJACtBhQ;;IACT7C,QAAE,gCAAA,hCAACgG,wBAAUvG,8BAA8BoT,QAAQgH;IACnD4O,WAAS,AAACrY,0BAAY3Q,QAAQoT,QAAQgH;IACtC7Z,QAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,+CAAA,uBAAA,yBAAA,laAAQnD,kNAAAA,qJACoC0U,sBACzBlB,oBACH4G;IAClB6O,iBAAS,+BAAA,kKAAA,/KAAMzV,aACJ,gDAAA,hDAAC7K,iCAAanG,OACAxC,wEAEA0U,WACA,CAAGvB,UAAQC,SACX2V,SACAC;AAvB/B,AAwBE,oBAAIC;AAASzV;;AAAQ4G;;;;AAE7B,AAAA;;;;8BAAA,sCAAA7b,pEAAM4qB;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,0DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,0DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAppB,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,4DAAA,WAAAqpB,vEAAMD,gFAGuDviB,IAAI4iB,SAC7DhnB;AAJJ,AAAA,IAAA6mB,aAAAD;IAAAC,iBAAA,AAAAhjB,4BAAAgjB;cAAAA,VAGoDrpB;IAHpDspB,aAAA,AAAAhjB,4CAAA+iB,eAAA;IAAAC,iBAAA,AAAAjjB,4BAAAijB;0BAAA,AAAAhjB,4CAAAgjB,eAAA,jFAGa3B;wBAHb,AAAArhB,4CAAAgjB,eAAA,/EAG2BC;AAH3B,AAKG,oBAAA,AAAA,mFAAQvpB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD,kIACiB,iBAAAypB,WAAS,AAACzqB,gBAAMwqB;AAAhB,AAAA,8GAAAC,2CAAAA,jJAAC/nB,oDAAAA,8DAAAA;KAD1B,YAEoB,AAAA,0FAAW1B;;AAF/B;;AAGA,IAAA6T,uBAEU,iBAAA6V,WACE,CAAClnB,uCAAAA,gDAAAA,XAAOxC,6BAAAA;IADV2pB,WAEE/iB;IAFFgjB,WAGE,oDAAA,pDAAC/J,iCACCrd,OACAxC,QACA4G,UAEA,iBAAAijB,aAAe,AAAC1F,iCAAmB3hB,OAAOxC,QAAQwpB;QAAlD,AAAAnpB,4CAAAwpB,WAAA,IAAA,/DAAOtpB;WAAP,AAAAF,4CAAAwpB,WAAA,IAAA,lEAASC;AAAT,AAEE,oBAAA,AAAA,mFAAQ9pB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,gKAAA,jRAAQnD,6IAC4B,AAAC4F,4CAAI,AAAC4Y,6CAAK9c,oBAAQ1C,iBACjB8qB,oBAChBP;;AAHtB;;AAIAO;;AAdN,AAAA,kIAAAJ,SAAAC,SAAAC,qDAAAF,SAAAC,SAAAC,nNAAC1B,8DAAAA,0FAAAA;;AAFX,AAAA,oBAAA,AAAA,mFAAUloB;AAAV,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,uBAAA,AAAAI,wGAAA0Q,xIAAU7T;;AAAV;;AAAA6T;;;AARH,CAAA,4DAAA,5DAAMsV,uEAyBFnpB,QAAQ4G,IAAI4iB;AAzBhB,AAyB0B,sFAAA,/EAACO,0DAAc/pB,QAAQ4G,IAAI4iB;;;AAzBrD,CAAA,sDAAA,tDAAML;;AAAN,AA2BA;;;sCAAA,tCAAMa,oFAEHR;AAFH,AAIE,IAAOjkB,OAAKikB;;AAAZ,AACE,GAAA,AAAAnf,cAAQ9E;AAAR;;AAEE,IAAMrE,OAAK,AAAClC,gBAAMuG;AAAlB,AAEE,oBAAM,CAAC2S,4DAAAA,kEAAAA,RAAUhX,+CAAAA;AAAM,eAAO,AAACjC,eAAKsG;;;;AAApC,oBACM,CAACsgB,yDAAAA,+DAAAA,RAAO3kB,4CAAAA;AADd;;AAAA,oBAEM,CAACmkB,2DAAAA,iEAAAA,RAASnkB,8CAAAA;AAFhB;;AAAA,oBAGM,CAACmlB,wDAAAA,8DAAAA,RAAMnlB,2CAAAA;AAHb;;AAAA,AAKY,eAAO,AAACjC,eAAKsG;;;;;;;;;;;;AAEjC;;;;;4CAAA,5CAAM0kB,gGAIHC;AAJH,AAKE,OAACpnB,eAAKknB,oCAAgBE;;AAExB,AAAA,AAEA;;;;+BAAA,uCAAAC,tEAAMG,+EAG4C1jB,IAAI4iB;AAHtD,AAAA,IAAAY,aAAAD;IAAAC,iBAAA,AAAA/jB,4BAAA+jB;cAAAA,VAGyCpqB;IAHzCqqB,aAAA,AAAA/jB,4CAAA8jB,eAAA;IAAAC,iBAAA,AAAAhkB,4BAAAgkB;0BAAA,AAAA/jB,4CAAA+jB,eAAA,jFAGY1C;AAHZ,AAKE,oBAAA,AAAA,mFAAK3nB;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,TAAK/C,2BAA0B,iBAAAuqB,WAAS,AAACvrB,gBAAMwqB;AAAhB,AAAA,8GAAAe,2CAAAA,jJAAC7oB,oDAAAA,8DAAAA;;;AAAhC;;AACA,IAAMooB,OACE,AAAC7D,gCAAkBjmB,QAAQ,AAAA,2FAAY,AAAA,uFAASA,UAAUwpB;AADlE,AAGE,oBAAA,AAAA,mFAAKxpB;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,TAAK/C,sCAAqC,4CAAA,WAAAwqB,vDAAC5kB;AAAD,AAAM,uEAAA4kB,hEAAC5kB,4CAAIlE;GAAWooB;;AAAhE;;AAIA,oBAAI,AAACG,0CAAsBH;AAGzB,IAAAjW,uBAEU,iBAAMzQ,SAAO,iBAAAqnB,WAAA;IAAAC,WACwB,sDAAA,6DAAA,nHAAC7nB,8CAAM7C;IAD/B2qB,WAGwB/jB;IAHxBgkB,WAIwBhkB;IAJxBikB,WAKwBrB;IALxBsB,WAAA;AAAA,AAAA,gJAAAL,SAAAC,SAAAC,SAAAC,SAAAC,SAAAC,4DAAAL,SAAAC,SAAAC,SAAAC,SAAAC,SAAAC,9RAACC,qEAAAA,4HAAAA;;AAAd,AAUE,GAAI,EAAK,EAAI,sHAAA,tHAAC5pB,6CAAE,oEAAA,pEAACd,4CAAI,AAACrB,gBAAMoE,4EACf,sHAAA,tHAACjC,6CAAE,oEAAA,pEAACd,4CAAI,AAACrB,gBAAMoE,gFACnB,2DAAA,3DAAC4nB,kCAA4B,AAACjS,iBAAO3V;AAC5C,OAACnE,eAAKmE;;AACNA;;;AAhBd,AAAA,oBAAA,AAAA,mFAAUpD;AAAV,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,+CAAA,AAAAI,wGAAA0Q,hKAAU7T;;AAAV;;AAAA6T;;AAiBA,IAAAA,uBAEU,iBAAAoX,WAAiB,AAAA,uFAASjrB;IAA1BkrB,WACiBtkB;IADjBukB,WAEiB,iCAAA,mOAAA,pQAACtL,0FACmB,sDAAA,6DAAA,nHAAChd,8CAAM7C,wHAEP4G,UAEAkjB;AAPrC,AAAA,kIAAAmB,SAAAC,SAAAC,qDAAAF,SAAAC,SAAAC,nNAACjD,8DAAAA,0FAAAA;;AAFX,AAAA,oBAAA,AAAA,mFAAUloB;AAAV,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,wBAAA,AAAAI,wGAAA0Q,zIAAU7T;;AAAV;;AAAA6T;;;AAWN,AAAA;;;;8BAAA,sCAAAtV,pEAAM6sB;AAAN,AAAA,IAAA5sB,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAA4sB,iEAAA,CAAA,UAAA,MAAAzsB;;;AAAA,AAAA,CAAA,mEAAA,nEAAMysB,8EAGHpgB,EAAI5L;AAHP,AAIE,IAAOmsB,OAAKnsB;IACLuF,MAAIqG;;AADX,AAEE,oBAAIugB;AACF,eAAO,AAACtsB,eAAKssB;eACN,iBAAOC,MAAI,AAACxsB,gBAAMusB;IACX5mB,UAAIA;;AADX,AAEE,oBAAI6mB;AAAI,eAAO,AAACvsB,eAAKusB;eAAK,AAACrgB,mDAAMxG,QAAI,AAAC3F,gBAAMwsB;;;;;AAAO7mB;;;;;;;;;AAC5DA;;;;;;AAXN,CAAA,sDAAA,tDAAMymB;;AAAN;AAAA,CAAA,gDAAA,WAAAC,3DAAMD;AAAN,AAAA,IAAAE,WAAA,AAAAtsB,gBAAAqsB;IAAAA,eAAA,AAAApsB,eAAAosB;AAAA,AAAA,IAAAnsB,qBAAA;AAAA,AAAA,OAAAA,wDAAAosB,SAAAD;;;AAAA,AAaA;;;;iCAAA,jCAAMI,0EAGHzrB,QAAQ4G,IAAI4iB;AAHf,AAIE,oBAAA,iBAAA5lB,mBAAA,AAAA,mFAAW5D;AAAX,AAAA,oBAAA4D;AAAAA;;AAAA,OAAA,+FAAW5D;;;AAAX,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,TAAW/C;;AAAX;;AACA,IAAM0rB,YAAUlC;IACVzK,MAAI,AAACvb,gBAAMkoB;IACXC,aAAW,OAAA,NAAK5M;IAChB6M,cAAM,8BAAA,7BAAG,AAACpoB,gBAAMkoB;IAChB1rB,cAAQ,sDAAA,+DAAA,rHAAC6C,8CAAM7C;AAJrB,AAKE,IAAOwpB,eAASkC;IACTG,UAAQ,AAACC,gBAAKllB;YADrB,RAEO2F;IACA5H,MAAI,qBAAA,rBAACyG;;AAHZ,AAIE,GAAI,AAAC1K,uBAAO8oB;AACV,AAAI,oBAAA,AAAA,mFAAKxpB;AAAL,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,bAAK/C,gDAA2C,AAACwD,gBAAMmB;;AAAvD;;AACA,OAAC0G,2BAAY1G;;AACjB,IAAMsnB,YAAU,AAACjtB,gBAAMwqB;IAAvBuC,aAEQ,kEAAA,0bAAA,2DAAA,mFAAA,sDAAA,AAAA,mFAAA,mFAAA,mFAAA,IAAA,qDAAA,kEAAA,ljCAGE,AAAC5qB,6CAAEoL,MAAMof,gGAAa,EAAA,sBAAA,mFAAA,mFAAA,IAAA,qDAAA,kEAAA,oBAAA,xUAAQ,WAAA,VAAOpf,6UACgBvM,sBACrD,mDAAA,nDAACmB,6CAAEoL,oGAAc,AAAC2F,4BAAclS,6ZACG,AAACkS,4BAAclS;;UAR5D,AAAAK,4CAAA0rB,WAAA,IAAA,jEACOG;mBADP,AAAA7rB,4CAAA0rB,WAAA,IAAA,1EACWI;IAQLC,WAAS,CAACrU,4DAAAA,4FAAAA,lCAASoU,yEAAAA,5DAAaN,yEAAAA,jEAAQI,yEAAAA;IACxC1rB,IAAE,oCAAA,pCAACgG,wBAAUvG,gCAA4B6rB,QAAQO;IAVvDJ,aAYQ,AAACrb,0BAAY3Q,YAAQ6rB,QAAQO;iBAZrC,AAAA/rB,4CAAA2rB,WAAA,IAAA,xEAWOpa;gBAXP,AAAAvR,4CAAA2rB,WAAA,IAAA,vEAWkBna;iBAXlBma,bAWgCK;AAXhC,AAaE,GAAA,GAAQ,AAACta,6BAAeoa,aAAaE;AACnC,AAAI,oBAAA,AAAA,mFAAKrsB;AAAL,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,bAAK/C;;AAAL;;AAAJ;;AAGA,eAAO,AAACf,eAAKuqB;eACN,8BAAA,7BAAK,AAACsC,gBAAKja;eACX,SAAA,RAAKtF;eACL,AAAC+f,iEAAS3nB,sDAAIunB,IAAIE;;;;;;;;;;;AAErC;;;;;;;;;;4BAAA,5BAAMG,gEASHvsB,QAAQ4G,IAAI4iB;AATf,AAUE,IAAMjc,aAAW,AAACD,6BAAetN;IAC3B+e,MAAI,AAACvb,gBAAMgmB;IACXA,eAAS,EAAI,CAAGzK,MAAIxR,aACT,AAACf,+CAAO,AAACC,6CAAKc,WAAWic,UAAU,KAAAza,eAAA,2JAAA,KAAA,IAAA,/JAAM,CAACqT,uDAAAA,yDAAAA,sDAC1CoH;IACXzK,UAAI,AAACvb,gBAAMgmB;AALjB,AAME,oBAAA,AAAA,mFAAKxpB;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,yCAAA,yBAAA,3EAAK/C,0CACiC+e,sBACnBxR,kBACP3G;;AAHZ;;AAIA,GAAM,AAAClG,uBAAO8oB;AAAd;;AAAA,GACM,gBAAA,fAAOjc;AADb,0FAAA,mFAAA,mFAAA,kGAAA,5FACkC,iCAAA,jCAACmF,yBAAW1S;;AAD9C,AAEY,IAAMgN,OAAK,0DAAA,WAAAwf,iBAAAC,tFAACrN,kDAAMpf;AAAP,AACQ,IAAA0sB,WAAU,AAACxa,4BAAclS;IAAzB2sB,WAAAH;IAAAI,WAAAH;AAAA,AAAA,8HAAAC,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAAC7U,4DAAAA,wFAAAA;GACF,EAAI,AAACpN,sBAAM/D,MAAKA,IAAI,AAACtI,+CAAOsI,MAC5B,AAACimB,kBAAQrD;YAH3B,RAIMvc,2FAAO,iBAAA6f,WAAU9sB;IAAV+sB,WACU,EAAI,AAACpiB,sBAAM/D,MAAK,AAACuD,eAAKvD,KAAKA;IADrComB,WAEU,AAAC7iB,eAAKqf;AAFhB,AAAA,8HAAAsD,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAACjV,4DAAAA,wFAAAA;;AAJd,AAOE,GAAM,qDAAA,rDAAC5W,6CAAE4d;AAAO9R;;AAAhB,AACY,OAACyD,mHAAc1D,KAAKC;;;;;;;AAElD,AAAA,AAEA,AAAA;;;;;;;;;;;;;;;iCAAA,yCAAA1O,1EAAMsc;AAAN,AAAA,IAAAoS,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAApS,6DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,6DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,6DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA9a,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,+DAAA,kBAAAmtB,jFAAMrS,0EAcFrY,gBAAgDoE,IAAI4iB,SAAS3K,gBAC7DyO;AAfJ,AAAA,IAAAH,aAAAD;IAAAC,iBAAA,AAAA9mB,4BAAA8mB;cAAAA,VAc2CntB;IAd3CotB,aAAA,AAAA9mB,4CAAA6mB,eAc+B3qB;IAd/B4qB,iBAAA,AAAA/mB,4BAAA+mB;eAAA,AAAA9mB,4CAAA8mB,eAAA,tEAcoBC;AAdpB,AAgBG,oBAAA,AAAA,mFAAQrtB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,8DAAA,4BAAA,4BAAA,vOAAQnD,qJACoC,AAACwD,gBAAMgmB,sBAC/B8D,4BACAzO,4BACA,AAACjZ,4CAAIlE,oBAAQ8nB;;AAJjC;;AAKA,IAAM+D,aAAW,AAAChB,0BAAYvsB,QAAQ4G,IAAI4iB;IAEpCgE,WAAS,AAACpvB,8CAAMkN,4BACL,kDAAA,mFAAA,mFAAA,IAAA,qDAAA,kEAAA,nVAACmiB,uWAAsCF;IAClDhtB,IAAE,gCAAA,hCAACgG,wBAAUvG,4BAA4B4G,IAAI4mB;IAC7CE,iBAAe,AAAC/c,0BAAY3Q,QAAQ4G,IAAI4mB;AAL9C,AAME,oBAAA,AAAA,mFAAQxtB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD,iJAAwCutB;;AAAhD;;AACA,IAAA1Z,uBAGE,EAAI,EAAK,AAACxJ,cAAIwU,sBAAW,AAAC9M,6BAAe/R,QAAQ0tB,mBAC/CF,SACA,EAAI,GAAK,AAAC9sB,uBAAO6sB,eACf,AAACnvB,8CAAMkN,4BACL,iBAAAqiB,WAAc3tB;IAAd4tB,WAAsBhnB;IAAtBinB,WAA0BN;IAA1BO,WAAqC,AAACzjB,cAAIijB;IAA1CS,WAAqDV;AAArD,AAAA,4HAAAM,SAAAC,SAAAC,SAAAC,SAAAC,kDAAAJ,SAAAC,SAAAC,SAAAC,SAAAC,9OAACC,2DAAAA,yGAAAA;MAFL;AALJ,AAAA,oBAAA,AAAA,mFACEhuB;AADF,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,0BAAA,AAAAI,wGAAA0Q,3IACE7T;;AADF;;AAAA6T;;;AA5BL,CAAA,+DAAA,/DAAMgH,0EAqCFrY,OAAOxC,QAAQ4G,IAAI4iB;AArCvB,AAsCG,gGAAA,KAAA,9FAACyE,6DAAiBzrB,OAAOxC,QAAQ4G,IAAI4iB;;;AAtCxC,CAAA,+DAAA,/DAAM3O,0EAuCFrY,OAAOxC,QAAQ4G,IAAI4iB,SAAS3K;AAvChC,AAwCG,gHAAA,zGAACoP,6DAAiBzrB,OAAOxC,QAAQ4G,IAAI4iB,SAAS3K;;;AAxCjD,CAAA,yDAAA,zDAAMhE;;AAAN,AA0CA;;;;;;;;;iCAAA,gDAAAqT,jFAAMG,0EAQH7rB,gBACA2Q,QAAQC,QAAQlS;AATnB,AAAA,IAAAitB,aAAAD;IAAAC,iBAAA,AAAA9nB,4BAAA8nB;cAAAA,VAQqEnuB;IARrEouB,aAAA,AAAA9nB,4CAAA6nB,eAQyD3rB;IARzD4rB,iBAAA,AAAA/nB,4BAAA+nB;iBAAA,AAAA9nB,4CAAA8nB,eAAA,xEAQ4CE;sBAR5C,AAAAhoB,4CAAA6nB,eAAA,7EAQkBjZ;YARlB,AAAA5O,4CAAA6nB,eAAA,nEAQ4BvlB;AAR5B,AAUE,oBAAA,AAAA,mFAAQ5I;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,yKAAA,oBAAA,9SAAQnD,qIACoB,CAAC0B,oDAAAA,0DAAAA,RAAQR,uCAAAA,mBACjBiS,mBACDC;;AAHnB;;AAIA,oBAAM,AAAA,4FAAWpT;AAAjB,AACE,8NAAA,9NAAC+C,yGAAQ,AAAC7E,mBAAK,AAAA,wFAAS8B,uBAEfwC,OACA,iBAAA+rB,WAAS,kBAAI,CAAC1I,yDAAAA,+DAAAA,RAAO3kB,4CAAAA,QAAM,CAACqS,mDAAAA,yDAAAA,RAAOrS,sCAAAA,OAAMA;AAAzC,AAAA,8GAAAqtB,2CAAAA,jJAAC7sB,oDAAAA,8DAAAA;;;AAJZ;;AAKA,IAAMoV,gBAAc,EAAI,EAAK,AAACzM,cAAI6K,sBAAW,AAAC7K,cAAI,AAAA,qFAAQ,CAAC7H,uCAAAA,gDAAAA,XAAOxC,6BAAAA,eAC5C,sDAAA,+DAAA,rHAAC6C,8CAAM7C,6EACPA;IAGhBmT,cAAQ,iBAAAvP,mBAAIuP;AAAJ,AAAA,oBAAAvP;AAAAA;;AAAYwP;;;IACpBsB,aAAW,CAACsF,mDAAAA,yDAAAA,RAAO9Y,sCAAAA;IAInBsS,UAAQ,wKAAA,tKAAM,EAAK,AAACC,gDAAKN,YAAQC,cACd,EAAI,AAAC/I,cAAIikB,iBACL,CAAG5Z,aAAW,CAAG,CAAG9L,QAAMuK,eAASmb,kBAChD,iBAAAE,WAAU,AAAChkB,sBAAQsM;IAAnB2X,WAAkCtb;IAAlCub,WAA0CxtB;AAA1C,AAAA,8HAAAstB,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAAC3W,4DAAAA,wFAAAA;KAHH;IAIRvE,cAAQ,mHAAA,mFAAA,mFAAA,IAAA,qDAAA,kEAAA,pZAAC9C,waAA0C8C;IACnDjT,IAAE,gCAAA,hCAACgG,wBAAUvG,qCAAqC,eAAA,dAAKmT,mBAASK;IAChEuV,WAAS,AAACpY,0BAAY3Q,QAAQ,eAAA,dAAKmT,mBAASK;AAhBlD,AAiBEjT;AACA,oBAAA,AAAA,mFAAKP;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,uCAAA,hDAAK/C,uCAC8B+oB,uBAChBrU;;AAFnB;;AA8BA,oBAAI,iBAAA9Q,mBAAI,AAACmO,6BAAe/R,QAAQ+oB;AAA5B,AAAA,GAAAnlB;AAAAA;;AAAsCsR;;;AACxC1B;;AACA,IAAM4G,OAAK,AAAC3J,yBAAWzQ,QAAQoT,QAAQ,CAAC2E,4DAAAA,kFAAAA,xBAAS/X,+DAAAA,vDAAQoT,+DAAAA,vDAAQlS,+DAAAA;IAC3DX,QAAE,gCAAA,hCAACgG,wBAAUvG,kCAAkCoT,QAAQgH;IACvD4O,WAAS,AAACrY,0BAAY3Q,QAAQoT,QAAQgH;IACtC7Z,QAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,6CAAA,xQAAK/C,kNAAAA,uCAAsCgpB;IAE7CzoB,QAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,mDAAA,qIAAA,iIAAA,phBAAK/C,kNAAAA,iDACwC0U,sBAC7B,AAACvR,wGAAOqQ,0BACX,AAACrQ,wGAAOiX;IACvB6O,iBAAS,iBAAA7hB,oBAAK,AAAA,qFAAQ,CAAC5E,uCAAAA,gDAAAA,XAAOxC,6BAAAA;AAArB,AAAA,oBAAAoH;AAAA,IAAAA,wBAEK2hB;AAFL,AAAA,oBAAA3hB;AAGK,uDAAA,hDAACuB,iCAAanG,OACAxC,gFAEA0U,WACA,CAAGvB,cAAQC,SACX2V,SACAC;;AATnB5hB;;;AAAAA;;;AATf,AAoBE,oBAAI6hB;AAASzV;;AAAQ4G;;;;AAM7B,AAAA,AAyFA;;;;;;;;;;;;;;;;qCAAA,rCAAMuU,kFAeH3uB,QAAQ4uB,iBAAiBpF;AAf5B,AAgBE,IAAOqF,eAAa,AAACnJ,kBAAQ8D;oBAA7B,hBACOsF;2BADP,vBAEOC;+BAFP,3BAIOC;gBAJP,ZAKOC;uBALP,nBAMOC;;AANP,AAOE,IAAMnqB,UAAQ,AAAC/F,gBAAM6vB;AAArB,AAOE,GAAI,AAACnuB,uBAAOmuB;AAAZ,0FAGG,CAAGC,gBAAcG,WAAW,CAAGF,uBAAqBG;;AACrD,IAAMC,4BAAoB,CAACC,yEAAAA,kFAAAA,XAAqBrqB,+DAAAA;AAAhD,AAGE,oBAAI,iBAAAqC,oBAAK,AAACiD,cAAI8kB;AAAV,AAAA,GAAA/nB;AAAA,IAAAA,wBACK4nB;AADL,AAAA,oBAAA5nB;AAEK,oBAAIwnB;AAEF,OAACvkB,cAAI,gMAAA,9KAAM,CAAChJ,0DAAAA,mEAAAA,XAAQ0D,gDAAAA,WACb,iBAAAsqB,WAAkB,AAAC9tB,wBAAUvB,QAAQ+E;AAArC,AAAA,wGAAAsqB,wCAAAA,xIAACT,iDAAAA,2DAAAA;KADH;;AAEL,OAACvkB,cAAI,CAACilB,6DAAAA,sEAAAA,XAAWvqB,mDAAAA;;;AANxBqC;;;AAAAA;;;AAAJ,0FASG,CAAG0nB,gBAAcG,WACjB,CAAGF,uBAAqBG;;AACzB,eAAO,AAACjwB,eAAK4vB;eACN,iBAAA,hBAAKC;eACL,kBAAIK,2BACFJ,qBACA,wBAAA,vBAAKA;eACP,kBAAII,2BACFH,yBACA,AAAC3kB,cAAI2kB;eACP,kBAAI,iBAAA5nB,oBAAK4nB;AAAL,AAAA,oBAAA5nB;AAAwB,OAACiD,cAAI8kB;;AAA7B/nB;;MAAJ,IAGE,aAAA,ZAAK6nB;eACP,kBAAI,iBAAA7nB,oBAAK4nB;AAAL,AAAA,oBAAA5nB;AAAwB,OAACiD,cAAI8kB;;AAA7B/nB;;MAAJ,IAGE,kBAAI+nB,2BAEFD,iBACA,oBAAA,nBAAKA;;;;;;;;;;;;;AAE5B;;;;;8BAAA,6CAAAK,3EAAMG,oEAIHltB,gBAEcgnB;AANjB,AAAA,IAAAgG,aAAAD;IAAAC,iBAAA,AAAAnpB,4BAAAmpB;cAAAA,VAMQxvB;IANRyvB,aAAA,AAAAnpB,4CAAAkpB,eAKgEhtB;IALhEitB,iBAAA,AAAAppB,4BAAAopB;2BAAA,AAAAnpB,4CAAAmpB,eAAA,lFAKYE;uBALZ,AAAArpB,4CAAAmpB,eAAA,9EAK2Bb;wBAL3B,AAAAtoB,4CAAAmpB,eAAA,/EAK4CG;AAL5C,AAQE,oBAAID;AACF,IAAAE,aACQ,AAAClB,mCAAqB3uB,QAAQ4uB,iBAAiBpF;wBADvD,AAAAnpB,4CAAAwvB,WAAA,IAAA,/EAAOC;0BAAP,AAAAzvB,4CAAAwvB,WAAA,IAAA,jFAAyBE;IAEnBC,wBAAsB,CAAG,AAACxsB,gBAAMgmB,YAAUsG;IAC1CvvB,IAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,yDAAA,uCAAA,iDAAA,5WAAK/C,kNAAAA,4CACmCgwB,2CACdF,yCACEC;IAC9BE,WAAS,8CAAA,6EAAA,zHAAM,CAAIF,uBAAoBH,oBAC5B,AAACljB,6CAAKsjB,sBAAsBxG;AAR7C,AAAA,0FASGyG,SAASD;;AAVd,0FAAA,KAWO,AAACxsB,gBAAMgmB;;;AAMhB,AAAA,AAEA;;;2CAAA,3CAAM4F,8FAEHluB;AAFH,AAGE,IAAA0C,mBAAI,CAAC0W,4DAAAA,kEAAAA,RAAUpZ,+CAAAA;AAAf,AAAA,oBAAA0C;AAAAA;;AAAqB,QAACsU,4DAAAA,kEAAAA,RAAUhX,+CAAAA;;;AAElC;;;;;kCAAA,lCAAMgvB,4EAIHtpB,IAAIC;AAJP,AAOE,IAAMspB,eAAa,uEAAA,vEAAC9vB,4CAAI,AAACrB,gBAAM6H;AAA/B,AAEE,GAAI,EAAI,0DAAA,1DAAC1F,6CAAEgvB,8EAAuB,0DAAA,1DAAChvB,6CAAEgvB;AACnCtpB;;AAGA,0HAAA,mFAAA,2KAAA,qDAAA,yDAAA,/dAAC6J,yRAAgB,CAAA,iDAAU,AAACvE,sBAAOvF,kJAAwBC;;;AAEjE;;;;gCAAA,hCAAMupB,wEAGHxpB,IAAIC;AAHP,AAME,IAAMspB,eAAa,sEAAA,tEAAC9vB,4CAAI,AAAC8J,eAAKtD;AAA9B,AAEE,GAAI,EAAI,0DAAA,1DAAC1F,6CAAEgvB,8EAAuB,0DAAA,1DAAChvB,6CAAEgvB;AACnCtpB;;AACA,oIAAA,mFAAA,2KAAA,qDAAA,yDAAA,zeAAC6J,mHAAc7J,gLAAY,CAAA,iDAAU,AAACsF,sBAAOvF;;;AAMnD,AAAA;;;;;;;;;;;;uCAAA,+CAAArI,tFAAMwsB;AAAN,AAAA,IAAAsF,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAtF,mEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,mEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAhrB,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,qEAAA,kBAAAuwB,vFAAMvF,gFAWFvoB,gBAKc2Q,QAAQC,QAAQoW,SAAShgB,SAASgf;AAhBpD,AAAA,IAAA+H,aAAAD;IAAAC,iBAAA,AAAAlqB,4BAAAkqB;cAAAA,VAgBSvwB;IAhBTwwB,aAAA,AAAAlqB,4CAAAiqB,eAeO/tB;IAfPguB,iBAAA,AAAAnqB,4BAAAmqB;kBAAA,AAAAlqB,4CAAAkqB,eAAA,zEAaanb;2BAbb,AAAA/O,4CAAAkqB,eAAA,lFAamBb;wBAbnB,AAAArpB,4CAAAkqB,eAAA,/EAakCZ;iBAblC,AAAAtpB,4CAAAkqB,eAAA,xEAaoDlC;kBAbpD,AAAAhoB,4CAAAkqB,eAAA,zEAa+DxnB;gBAb/D,AAAA1C,4CAAAkqB,eAAA,vEAcavnB;0BAdb,AAAA3C,4CAAAkqB,eAAA,jFAcuB7I;wBAdvB,AAAArhB,4CAAAkqB,eAAA,/EAcqCjH;iBAdrC,AAAAjjB,4CAAAiqB,eAAA,xEAYYznB;YAZZ,AAAAxC,4CAAAiqB,eAAA,nEAYiB3nB;AAZjB,AAiBG,oBAAM,AAAA,4FAAW5I;AAAjB,AACE,8NAAA,9NAAC+C,yGAAQ,AAAC7E,mBAAK,AAAA,wFAAS8B,gBAAgB,iBAAAywB,WAAS,AAACzxB,gBAAMwqB;AAAhB,AAAA,8GAAAiH,2CAAAA,jJAAC/uB,oDAAAA,8DAAAA;;;AAD3C;;AAEA,oBAAA,AAAA,mFAAQ1B;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD,iJACgC,iBAAA0wB,WAAS,AAAC1xB,gBAAMwqB;AAAhB,AAAA,8GAAAkH,2CAAAA,jJAAChvB,oDAAAA,8DAAAA;KADzC,mBAAA,mBAAA,iBAAA,qCAAA,jFAEmByR,mBACAC,kBACD5Q,wBACOmlB,wCACG,AAACnkB,gBAAMgmB;;AANnC;;AAQA,IAAMkC,YAAUlC;IACVkC,gBAAU,kBAAIlD,YAAW,AAAC/b,6CAAK+b,WAAWkD,WAAWA;AAD3D,AAEE,GAAI,AAAChrB,uBAAOgrB;AAAZ;;AAEE,IAAAiF,aACQ,AAACjB,4BAAcltB,OAAOxC,QAAQ0rB;eADtC,AAAArrB,4CAAAswB,WAAA,IAAA,tEAAOV;4BAAP,AAAA5vB,4CAAAswB,WAAA,IAAA,nFAAgBX;IAEVzvB,IAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,yEAAA,pSAAK/C,kNAAAA,kDAEA,AAACwD,gBAAMysB;IAgCd1vB,QAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,kDAAA,wBAAA,mBAAA,mBAAA,oDAAA,oFAAA,ndAAK/C,kNAAAA,+CACsCqV,yBACzBiZ,sBACFlb,mBACAD,6BACU,AAAC3P,gBAAMkoB,wBACnB,8BAAA,iCAAA,7CAAM4C,YAAW,CAAG,CAAG1lB,QAAMuK,WAASmb;IACtDjZ,kBAAM,iBAAAjO,oBACEiO;AADF,AAAA,oBAAAjO;AAAA,SAME,AAACqM,gDAAKN,QAAQC,cAMd,EAAI,AAAC/I,cAAIikB,iBACL,CAAG,AAAC9qB,gBAAMkoB,iBAAW,CAAG,CAAG9iB,QAAMuK,WAASmb;;AAbhDlnB;;;IAsBN7G,QAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,6DAAA,xRAAK/C,kNAAAA,gDAA+CqV;IACtD7B,UACE,AAGC,iBAAMud,cACE,mCAAA,jBAAM1b,iBACJ,EAAA,AAAAhL,cAAQ4lB,WAEN,yHAAA,6DAAA,tLAAChC,6DAAiBzrB,OACA,AAACgI,sBAAQxK,SACTmT,QACAuY,iFAIlB,EAAI,GAAK,2BAAA,1BAAOsE,kCACd,AAACtf,mHAEC,iBAAAmD,uBAEU,AAACuc,8BACCjd,QACA,0NAAA,6DAAA,vRAAC8a,6DACCzrB,OACA,AAAC0P,4BAAc,AAAC1H,sBAAQxK,UACxBmT,QACA,AAAC1G,6CAAKujB,sBACAtE;AATpB,AAAA,oBAAA,AAAA,mFAAU1rB;AAAV,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,gCAAA,AAAAI,wGAAA0Q,jJAAU7T;;AAAV;;AAAA6T;KAcA,iBAAAA,uBAGE,AAACkW,0DAAc,AAACvf,sBAAQxK,SACTmT,QACA8c;AALjB,AAAA,oBAAA,AAAA,mFACEjwB;AADF,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,wCAAA,AAAAI,wGAAA0Q,zJACE7T;;AADF;;AAAA6T;wHA3BR,7GAkCM,AAACkW,0DAAc,AAACvf,sBAAQxK,SACTmT,QACA8c;AArC7B,AAAA,0FAsCGc,YAAY,AAACpgB,0BAAY3Q,QAAQmT,QAAQ4d;;IA5GrDH,aAmHuD,AAAC7qB,kBAAI/F,QACAwT;kBApH5D,AAAAnT,4CAAAuwB,WAAA,IAAA,zEAmHOpd;IAnHPqd,aAAA,AAAAxwB,4CAAAuwB,WAAA,IAAA;yBAAA,AAAAvwB,4CAAAwwB,WAAA,IAAA,hFAmHgBlc;oBAnHhBkc,hBAmHuC5W;IAEjCvF,aAAW,AAAClR,gBAAMkoB;IAClBhW,cAAM,AAACrL,cAAI,AAACiK,8BAAU9R,OACAxC,QACAmT,QACAuB,WACAC;IAEtByF,OACE,eAAA,bAAM1E,aACJ,AAGC,iBAAMsb,cACE,EAAA,AAAA3mB,cAAQ4lB,WAEN,kGAAA,6DAAA,/JAAChC,6DAAiBzrB,OACAxC,QACAoT,QACAsY,yIAGlB,EAAI,GAAK,2BAAA,1BAAOsE,kCAId,AAACtf,mHACC,AAAC0f,8BAAgBhd,QACA,mMAAA,6DAAA,hQAAC6a,6DACCzrB,OACA,AAAC0P,4BAAclS,SACfoT,QACA,AAAC3G,6CAAKujB,sBACAtE,2IAIzB,AAAC3B,0DAAc/pB,QAAQoT,QAAQ6c,gBAGjC,AAAClG,0DAAc/pB,QAAQoT,QAAQ6c;AA3B3C,AAAA,0FA+BGe,YACA,AAACrgB,0BACC3Q,QACAoT,QAcA4d;KApDR;IA7HRF,aAkLwB,wBAAA,gCAAA,tCAAM1W,MAAK,AAACrU,kBAAI/F,QAAQoa;eAlLhD,AAAA/Z,4CAAAywB,WAAA,IAAA,tEAkLO1W;iBAlLP,AAAA/Z,4CAAAywB,WAAA,IAAA,xEAkLYzW;IACN9Z,QAAE,gCAAA,hCAACgG,wBAAUvG,2CAEAmT,QACAK;IACbjT,QAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,uDAAA,+BAAA,jTAAK/C,kNAAAA,kDACyCia,4BAC3BvF;AAzL3B,AA0LE,oBAAA,AAAA,mFAAK1U;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,TAAK/C,+CAA8Cqa;;AAAnD;;AACA,oBAAMvR;AAAN,AACE,GAAI,gBAAA,fAAO4L;AACT,yGAAA,zGAAC3R,2HAA0B,4CAAK,AAAC6C,4CAAIlE,oBAAQ8nB;;AAD/C;;AADF;;AAGA,gCAAA,hCAACjjB,wBAAUvG,uCAAuCoT,QAAQgH;;AAE1D,oBAAI,iBAAAhT,oBAAK6S;AAAL,AAAA,oBAAA7S;AAAmB,OAACiD,cAAIgQ;;AAAxBjT;;;AACF,GAAI,AAACmJ,8BAAUiD;AACbA;;AACA,0HAAA,mFAAA,mFAAA,IAAA,qDAAA,kEAAA,pZAAC9C,yaAA2C8C;;;AAC9C,oBAAM6G;AAAN,AACE,oBAGE,iBAAAjT,oBAAK6S;AAAL,AAAA,oBAAA7S;AACK,OAACuB,iCACCnG,OACAxC,QACAwJ,SACAkL,WACA,CAAGvB,UAAQC,SACX6G,cAeA,wEAAA,tEAAI,EAAK,AAAC5P,cAAI4lB,eAAU,+BAAA,9BAAG,AAACjxB,gBAAMqb,yGAC/B,+BAAA,9BAAK,AAACrb,gBAAMqb,mBAAa,AAACjW,iBAAOiW,YACjC,uDAAA,vDAACha,4CAAIga,wBACNA;;AAzBTjT;;;AA4BA,GAAI,AAACmJ,8BAAUiD;AACbA;;AACA,0HAAA,mFAAA,mFAAA,IAAA,qDAAA,kEAAA,pZAAC9C,yaAA2C8C;;;AAC9C,OAAC0c,gCAAkB9c,QAAQgH;;;AAnC/B;;;;;;AAnOX,CAAA,qEAAA,rEAAM2Q,gFAuQFvoB,OAAOxC,QAAQmT,QAAQC,QAAQlS,KAAKsI;AAvQxC,AAwQG,uHAAA,hHAACynB,mEAAuBzuB,OAAOxC,QAAQmT,QAAQC,QAAQlS,KAAKsI;;;AAxQ/D,CAAA,+DAAA,/DAAMuhB;;AAAN,AAkeA;;;qCAAA,rCAAM5C,kFAEH3lB,OAAOxC,QAAQkB;AAFlB,AAGE,IAAM8e,iBAAe,CAACxd,uCAAAA,gDAAAA,XAAOxC,6BAAAA;IACvBwpB,WAAS,oUAAA,oUAAA,tnBAAM,AAAA,gGAAcxJ,iBAAgB,CAACkR,sDAAAA,+EAAAA,3BAAUC,4DAAAA,zCAASjwB,4DAAAA,yBAClD,AAAA,gGAAc8e,iBAAgB,CAACoR,sDAAAA,+EAAAA,3BAAUD,4DAAAA,zCAASjwB,4DAAAA,OAC5C,CAACmwB,iDAAAA,0EAAAA,3BAAKF,uDAAAA,pCAASjwB,uDAAAA;;AAH1C,AAIE,oBAAA,AAAA,mFAAQlB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD,yIAAgC,AAAC4F,4CAAIlE,oBAAQ8nB;;AAArD;;AACAA;;AAEJ,AAAA,AAEA;;;;;6BAAA,7BAAM8H,kEAIH9uB,OAAOxC,QAAQuxB,QAAQxsB;AAJ1B,AAKE,oBAAI,CAACysB,yDAAAA,kEAAAA,XAAOzsB,+CAAAA;AACV,IAAMqZ,YAAU,iBAAAqT,WACE,AAACtJ,mCAAqB3lB,OAAOxC,QAAQ+E;AADvC,AAAA,gKAAA0sB,oEAAAA,5NAACC,6EAAAA,uFAAAA;;AAAjB,AAGE,GAAI,AAACvwB,6CAAE,iBAAAwwB,WAAM,AAAC3yB,gBAAMof;AAAb,AAAA,wGAAAuT,wCAAAA,xIAACvwB,iDAAAA,2DAAAA;KAAJ;AAEF,IAAAwwB,WAAcpvB;IAAdqvB,WAAqB7xB;IAArB8xB,WAA6B,AAACzsB,6CAAKksB,QAAQxsB;IAA3CgtB,WAAoD,AAAC/yB,gBAAMof;AAA3D,AAAA,4HAAAwT,SAAAC,SAAAC,SAAAC,kDAAAH,SAAAC,SAAAC,SAAAC,5NAACT,2DAAAA,gGAAAA;;AACD,OAAClzB,8CAAM4zB,eAAK,AAAC3sB,6CAAKksB,QAAQxsB,SAASqZ;;;AACvC,OAAC/Y,6CAAKksB,QAAQxsB;;;AAElB;;;;;;0CAAA,1CAAMktB,4FAKHzvB,OAAOxC,QAAQwpB;AALlB,AAME,IAAMpmB,SAAO,kBAAI,AAAA,wFAAS,AAAA,mFAAOpD,WAClB,0IAAA,1IAACX,+CAAO,AAACmG,gDAAQ8rB,2BAAa9uB,OAAOxC,0CAAYwpB,UACjDA;AAFf,AAGE,oBAAA,AAAA,mFAAQxpB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,yNAAA,kFAAA,5ZAAQnD,qJACoC,AAAA,wFAAS,AAAA,mFAAOA,oBAC1C,AAAC4F,4CAAIlE,oBAAQ0B,gBACf,AAACwC,4CAAIxE,iBAAKgC;;AAH1B;;AAIAA;;AAEJ;;;0CAAA,1CAAM8uB,4FAEHhxB;AAFH,AAGE,oBAAMA;AAAN,AACE,IAAMixB,WAAS,CAAC/wB,iDAAAA,uDAAAA,RAAKF,oCAAAA;AAArB,AACE,SAAI,sDAAA,tDAACC,6CAAEgxB,0EAAmB,sDAAA,tDAAChxB,6CAAEgxB;;AAFjC;;;AAIF;;;;;;;oCAAA,pCAAMC,gFAMHC;AANH,AAQE,IAAMC,iBAAe,AAACnoB,eAAKkoB;AAA3B,AACE,GAAA,GAAQ,6HAAA,7HAAClxB,6CAAE,2EAAA,3EAACd,4CAAI,AAAC8J,eAAKmoB;AACpBD;;AACA,IAAME,WAAS,AAAC/uB,gBAAM8uB;IAChBE,YAAU,AAAChvB,gBAAM6uB;IACjBI,aACE,AAACjmB,+CAAO,AAACqgB,kBAAQwF,KACT,8DAAA,5DAAI,sDAAA,tDAAClxB,6CAAEoxB,gDAAe,KAAAG,2BAAA,KAAA,EAAA,IAAA,AAAAA,sCAAA,oCAAA,nCAAQ,AAAC7F,kBAAQyF;AAJvD,AAKE,GAAI,AAAC5xB,uBAAO+xB;AAAZ,0FAAA,mFAAA,mFAAA,GAAA,qDAAA;;AAA6CA;;;;AAErD;;;;mCAAA,nCAAME,8EAGH9rB;AAHH,AAKE,IAAMyrB,iBAAe,AAACnoB,eAAKtD;AAA3B,AACE,GAAA,GAAQ,6GAAA,7GAAC1F,6CAAE,2DAAA,3DAACd,4CAAIiyB;AACdzrB;;AACA,IAAMuX,YAAU,AAACyO,kBAAQhmB;AAAzB,AACE,GAAI,AAACnG,uBAAO0d;AAAZ;;AAA8BA;;;;AAEtC;;;;;;uCAAA,vCAAMwU,sFAIHpd,OAAOqd;AAJV,AAKE,IAAMC,WAAS,kFAAA,lFAACzyB,4CAAI,AAACrB,gBAAM6zB;AAA3B,AACE,GAAI,EAAI,sDAAA,tDAAC1xB,6CAAE2xB,yEAAmB,sDAAA,tDAAC3xB,6CAAE2xB;AAC/B,2EAAA,mFAAA,8KAAA,qDAAA,2DAAA,rbAACtmB,+CAAOqmB,2LAAkB,CAAA,iDAAU,AAAC1mB,sBAAOqJ;;AAC5Cqd;;;AAEN;;;;uCAAA,vCAAME,sFAGHvJ;AAHH,AAIE,IAAOwJ,WAASxJ;UAAhB,NACO7kB;iBADP,bAEOsuB;;AAFP,AAGE,GAAI,AAAC5oB,cAAI,AAAC6nB,wCAAoB,AAAClzB,gBAAMg0B;AAArC,0FACGruB,IAAI,AAAC3F,gBAAMg0B,UAAUC;;AACtB,eAAO,AAACh0B,eAAK+zB;eAAU,AAAC3tB,6CAAKV,IAAI,AAAC3F,gBAAMg0B;eAAW,cAAA,bAAKC;;;;;;;;;AAE9D;;;;;wCAAA,mEAAAC,3GAAME,wFAIH5wB,OAAOxC,QAAQ4G;AAJlB,AAAA,IAAAusB,aAAAD;QAAA,AAAA7yB,4CAAA8yB,WAAA,IAAA,/DAIuB5yB;YAJvB,AAAAF,4CAAA8yB,WAAA,IAAA,nEAIyB5yB;oBAJzB,AAAAF,4CAAA8yB,WAAA,IAAA,3EAI2BE;eAJ3B,AAAAhzB,4CAAA8yB,WAAA,IAAA,tEAIyC3J;gBAJzC2J,ZAIsDG;AAJtD,AAKE,IAAMC,iBAAe,iBAAA,hBAAKF;IACpBL,WAAS,AAAChM,kBAAQwC,SAAS+J;AADjC,AAEE,oBAAA,AAAA,mFAAQvzB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,0DAAA,3KAAQnD,4JAC2CuzB,2BAC/B,AAAC3tB,4CAAIlE,oBAAQ8nB;;AAFjC;;AAGA,GAAA,GAAQ,2IAAA,3IAACroB,6CAAE,AAAA,qFAAQnB;AAAnB,0FAAA,sDACU,AAAChB,gBAAMg0B,UAAUO,eAAe/J;;AACxC,IAAAgK,aAA+C,AAACT,qCACCC;wBADjD,AAAA3yB,4CAAAmzB,WAAA,IAAA,/EAAOC;gBAAP,AAAApzB,4CAAAmzB,WAAA,IAAA,vEAAyBvH;iBAAzB,AAAA5rB,4CAAAmzB,WAAA,IAAA,xEAAmCP;IAE7BA,iBAAW,CAAGM,iBAAeN;AAFnC,AAGE,oBAAA,AAAA,mFAAQjzB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,sDAAA,vKAAQnD,wJACuCizB,oCAClB,AAACrtB,4CAAIlE,oBAAQ+xB;;AAF1C;;AAGA,GAAI,AAAC/yB,uBAAO+yB;AAAZ,0FAAA,sDAEUxH,UAAUgH,eAAWzJ;;AAG7B,IAAM+D,aACE,AAACU,6DAAiBzrB,OAAOxC,QAAQ4G,IAAI6sB;IAIvClG,iBAAW,AAACpc,6CAAKuiB,iBAAOnG;IAKxBA,iBAAW,EAAI,+DAAA,/DAAC9Z,gDAAK8f,qBACR,AAACnB,kCAAoB7E,gBACrBA;IACboG,WAAS,AAACv1B,8CAAMkN,4BAAciiB;IAI9BoG,eAAS,EAAI,iBAAAvsB,oBAAK,+DAAA,/DAACqM,gDAAK8f;AAAX,AAAA,GAAAnsB;AACK,IAAMwsB,aAAW,sEAAA,tEAACvzB,4CAAI,AAACrB,gBAAM20B;AAA7B,AACE,SAAI,wDAAA,xDAACxyB,6CAAEyyB,2EACH,wDAAA,xDAACzyB,6CAAEyyB;;AAHdxsB;;MAIF,AAAC8oB,gCAAkBtpB,IAAI+sB,UACvBA;IAGXA,eAAS,EAAI,+DAAA,/DAAClgB,gDAAK8f,qBACRI,aACA,AAACvD,8BAAgBxpB,IAAI+sB;AA3BtC,AAAA,0FAkCGA,aAAS1H,UAAUgH,eAAWzJ;;;;AAE3C;;;;;yCAAA,zCAAMqK,0FAIHrxB,OAAOxC,QAAQ4G,IAAI1F;AAJtB,AAKE,oBAAA,AAAA,mFAAQlB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD;;AAAR;;AACA,GAAA,GAAQ,2IAAA,3IAACmB,6CAAE,AAAA,qFAAQnB;AAAnB,0FAAA,4EAAA,tBACU,AAAChB,gBAAMkC,UAAQA;;AACvB,IAAMsoB,WAAS,AAACrB,mCAAqB3lB,OAAOxC,QAAQkB;IAC9CsoB,eAAS,AAACyI,wCAA0BzvB,OAAOxC,QAAQwpB;AADzD,AAIE,gEAAA,mFAAA,KAAA,KAAA,tJAAC4J,sCAAwB5wB,OAAOxC,QAAQ4G,sGAAgB4iB;;;AAE9D;;;;;;;mCAAA,2CAAAsK,9EAAME;AAAN,AAAA,IAAAD,aAAAD;QAAA,AAAAzzB,4CAAA0zB,WAAA,IAAA,/DAMIxzB;YANJ,AAAAF,4CAAA0zB,WAAA,IAAA,nEAMMxzB;iBANN,AAAAF,4CAAA0zB,WAAA,IAAA,xEAMQd;eANR,AAAA5yB,4CAAA0zB,WAAA,IAAA,tEAMmBvK;iBANnBuK,bAMgCE;AANhC,AAOE,GAAI,CAAIhB,cAAW,AAACzvB,gBAAMgmB;AACxB,MAAO,KAAAzpB,MAEC,CAAA,0FAAmDk0B;;AAC3D,IAAMzK,eAAS,AAACxC,kBAAQwC,SAAS,cAAA,bAAKyJ;AAAtC,AAGEzJ;;;AAON;;;;kCAAA,lCAAM0K,4EAGHhzB;AAHH,AAIE,IAAMizB,WAAS,CAAC/yB,iDAAAA,uDAAAA,RAAKF,oCAAAA;AAArB,AAA4B,SAAI,sDAAA,tDAACC,6CAAEgzB,yEAAmB,sDAAA,tDAAChzB,6CAAEgzB;;AAE3D;;;;;6BAAA,7BAAMC,kEAIHlzB;AAJH,AAKE,IAAOmzB,OAAKnzB;YAAZ,RACOqL;;AADP,AAGE,IAAM+nB,aAAW,AAACC,4BAAOF;AAAzB,AACE,oBAAIC;AACF,GAAI,AAACJ,gCAAYG;AAAjB,0FACG9nB,MAAM8nB;;AACP,eAAO,AAACE,4BAAOF;eACR,EAAA,GAAQ,AAACG,+BAAyBH,SAAM,SAAA,RAAK9nB,aAAOA;;;;;;AAJ/D,0FAKGA,MAAM8nB;;;;;AAGf;;;;4BAAA,5BAAMI,gEAGHvzB;AAHH,AAKE,IAAOmzB,OAAKnzB;;AAAZ,AACE,GAAA,AAAAmJ,cAAQgqB;AACNA;;AACA,IAAMK,YAAU,AAACC,uBAAuBN;IAClCO,WAAS,AAACC,oBAAIH;AADpB,AAKE,GAAA,GAAQ,EAAI,sDAAA,tDAACvzB,6CAAEyzB,0EAAmB,sDAAA,tDAACzzB,6CAAEyzB;AACnCF;;AACA,eAAOA;;;;;;;;AAEjB;;;;6BAAA,7BAAMI,kEAGH5zB;AAHH,AAIE,GAAI,AAACgzB,gCAAYhzB;AAAM,OAACuzB,0BAAYvzB;;AAAMA;;;AAE5C;;;;;;;;;;;;iCAAA,jCAAM6zB,0EAWH7zB;AAXH,AAaE,IAAMA,WAAK,AAAC4zB,2BAAa5zB;IAAzB8zB,aACuC,AAACZ,2BAAalzB;6BADrD,AAAAb,4CAAA20B,WAAA,IAAA,pFACOC;cADP,AAAA50B,4CAAA20B,WAAA,IAAA,rEAC8BE;AAD9B,AAME,GAAI,0BAAA,zBAAGD;AAAP;;AAGE,IAAME,iBAAe,AAACR,uBACC,EAAI,AAACH,+BAAyBtzB,WAC5B,AAACyzB,uBAAuBzzB,UACxBA;IACnBk0B,gBAAc,AAACC,6BAAcF;IAC7BG,gBAAc,AAACb,0BAAYU;IAC3BI,eAAa,AAACF,6BAAcC;AANlC,AAYE,IAAAluB,oBAAK+tB;AAAL,AAAA,oBAAA/tB;AAAA,IAAAA,wBAAoBkuB;AAApB,AAAA,oBAAAluB;AAAkC,OAACjG,6CAAEi0B,cAAcG;;AAAnDnuB;;;AAAAA;;;;AAER;;;;;;;;;6BAAA,7BAAMouB,kEAQHhzB,OAAOxC,QAAQ4G,IAAI6uB,WAAWC;AARjC,AASE,IAAMC,YAAUF;AAAhB,AACE,oBAAA,AAAA,mFAAQz1B;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,yBAAA,yBAAA,uBAAA,1LAAQnD,sIACqB4G,kBACP6uB,wBACDE,kBACLD;;AAJhB;;AAKA,IAAOE,UAAQF;IACRG,UAAQJ;UADf,NAEO9wB;;AAFP,AAGE,GAAA,AAAA0F,cAAQurB;AACNjxB;;AACA,IAAMoxB,WAAS,AAAC/2B,gBAAM42B;IAChBI,UAAQ,EAAI,AAACppB,wBAAQ,AAAC5N,gBAAM+2B,YAElB,CAACP,2DAAAA,gGAAAA,vCAAahzB,6EAAAA,tEAAOxC,6EAAAA,rEAAQ4G,6EAAAA,zEAAIivB,6EAAAA,rEAAQE,6EAAAA,WACzC,iBAAAE,aAAqBF;QAArB,AAAA11B,4CAAA41B,WAAA,IAAA,/DAAOz2B;YAAP,AAAAa,4CAAA41B,WAAA,IAAA,nEAASnqB;WAAT,AAAAzL,4CAAA41B,WAAA,IAAA,lEAAeC;IACTC,WAAS,AAACn3B,gBAAM,AAACC,eAAK22B;IACtBQ,aAAW,kBAAI,iBAAAhvB,oBAAK+uB;AAAL,AAAA,oBAAA/uB;AAAA,SACK,GAAK,AAACwF,wBAAQ,AAAC5N,gBACCm3B,kBAChB,uGAAA,vGAACh1B,6CAAE,qDAAA,rDAACd,4CAAI81B;;AAHb/uB;;MAAJ,IAKEuuB;AAPnB,AAQE,GAAM,kDAAA,lDAACx0B,6CAAE+0B;AAAT,8OAAA,pJAAwB,6CAAK12B,+CAAE,AAAC2M,sBAAOiqB,uBACftqB,MAAMoqB;;AAD9B,GAEM,kDAAA,lDAAC/0B,6CAAE+0B;AAFT,0FAEuB12B,EAAEsM,MAAMoqB,KAAKP;;AAFpC,AAGYI;;;;;IACxBx1B,IAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,iCAAA,qBAAA,+BAAA,xZAAQnD,kNAAAA,0IACyB61B,oBACbE,oBACDC;IAnB3BF,aAqBgC,0CAAA,1CAACnlB,0BAAY3Q,QAAQ61B,2FAASG;cArB9D,AAAA31B,4CAAAy1B,WAAA,IAAA,rEAqBOO;gBArBP,AAAAh2B,4CAAAy1B,WAAA,IAAA,vEAqBejkB;YArBf,AAAAxR,4CAAAy1B,WAAA,IAAA,nEAqByB9jB;IAEnBskB,aAAW,AAACnsB,eAAK6H;AAvBvB,AAwBE,oBAAA,AAAA,mFAAQhS;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,uCAAA,xJAAQnD,6IAC4Bs2B,sBACjBN;;AAFnB;;AAIA,eAAO,AAAC/2B,eAAK22B;eAASU;eAAW,AAACjxB,6CAAKV,IAAIqxB;;;;;;;;;AAErD,AAAA,AAEA,AAAA;;;;;;;;;;;;;;;;4BAAA,oCAAAz3B,hEAAMi4B;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,wDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,wDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAz2B,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,0DAAA,kBAAA02B,5EAAMD,qEAeFh0B,gBAEAoE,IAAI6uB,WAAWlI,WAAW/X,OAAOqhB;AAjBrC,AAAA,IAAAH,aAAAD;IAAAC,iBAAA,AAAArwB,4BAAAqwB;cAAAA,VAgBqE12B;IAhBrE22B,aAAA,AAAArwB,4CAAAowB,eAgByDl0B;IAhBzDm0B,iBAAA,AAAAtwB,4BAAAswB;8BAAA,AAAArwB,4CAAAqwB,eAAA,rFAgBqCC;YAhBrC,AAAAtwB,4CAAAowB,eAAA,nEAgBY9tB;eAhBZ,AAAAtC,4CAAAowB,eAAA,tEAgBkB7tB;AAhBlB,AAkBG,IAAM0kB,iBAAW,CAACuJ,gEAAAA,4EAAAA,dAAkBvJ,yDAAAA;IAC9B5B,aAAW,mCAAA,lCAAK,AAACnoB,gBAAM+pB;IACvB1kB,eAAS,AAACyB,2BAAazB;IACvBkuB,gBAAc,CAAGnwB,MAAI4O;AAH3B,AAIE,oBAAA,AAAA,mFAAQxV;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,wBAAA,yBAAA,8CAAA,iBAAA,+BAAA,hQAAQnD,qIACoB4G,kBACN6uB,gCACOoB,mCACXrhB,wBACOuhB,4BACHxJ;;AANtB;;AAOA,IAAOqI,UAAQrI;IACRsI,UAAQJ;YADf,RAEOlpB;uBAFP,nBAGOyqB;0BAHP,tBAKOC;UALP,NAMOtyB;;AANP,AAOE,GAAA,AAAA0F,cAAQurB;AACNjxB;;AACA,IAAMoxB,WAAS,AAAC/2B,gBAAM42B;AAAtB,AACE,oBAAMG;AAAN,AACE,IAAMoB,eAAO,6BAAA,5BAAG,AAAC3zB,gBAAMuyB;IACjBx1B,IAAE,gCAAA,hCAACgG,wBAAUvG,uBAAuB4G,IAAImvB;IACxCx1B,QAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,qCAAA,sBAAA,8CAAA,qBAAA,uBAAA,xdAAQnD,kNAAAA,8IAC6B61B,iBACpBsB,iCACW,AAAC3zB,gBAAMuyB,sBACfA,gBACLpxB;IACjBoxB,eACE,EAAIoB,cACF,AAAC3B,2BAAahzB,OAAOxC,QAAQy1B,WAAWI,QAAQE,UAChDA;IAXVmB,aAaQ,AAACvmB,0BAAY3Q,QAAQ61B,QAAQE;cAbrC,AAAA11B,4CAAA62B,WAAA,IAAA,rEAYOb;gBAZP,AAAAh2B,4CAAA62B,WAAA,IAAA,vEAYerlB;YAZf,AAAAxR,4CAAA62B,WAAA,IAAA,nEAYyBllB;IAGnBskB,aAAW,AAACnsB,eAAK6H;IAKjBolB,UAAQ,yEAAA,zEAAC/2B,4CAAI,AAAC8J,eAAK4rB;IAGnBhX,MAAI,CAAGuX,aAAWT;IAClBt1B,QAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,mBAAA,yBAAA,WAAA,sBAAA,xSAAK/C,kNAAAA,oBACWq2B,sBACGC,kBACPvX,YACCqY;IACfrY,UAAI,iBAAAsY,kBAAA;IAAAC,kBAAOvY;AAAP,AAAA,SAAAsY,kBAAAC,mBAAAD,kBAAAC;;IAIJC,iBAAS,qDAAA,rDAACp2B,6CAAEi2B;IACZI,eAAO,qDAAA,rDAACr2B,6CAAEi2B;IACVK,iBAAS,AAAC/2B,uBAAO,AAAC1B,gBAAM,AAACA,gBAAM+2B;IAC/B1nB,iBAAS,EAAI,qDAAA,rDAAClN,6CAAEi2B,wEACH,qDAAA,rDAACj2B,6CAAEi2B;IAKhBH,0BAAc,EAAKA,yBAAc,EAAI5oB,oBAASkpB;IAC9CR,oBAAc,kBAAI,iBAAA3vB,oBAAK,SAAA,RAAGmF;AAAR,AAAA,GAAAnF;AAAiByvB;;AAAjBzvB;;MACFR,IACA,CAAGA,MAAI4O;IACvB5M,YAAM,EAAI,AAACzH,6CAAEoL,MAAMof,aAAY,CAAG/iB,QAAMC,cAAUD;IASlDsR,aAAK,CAAI,CAAG2b,UAAQ9W,YAAKnW;IAEzBijB,UAAQ,oCAAA,lCAAM0L,gBAASR,kBACH,CAAA,WAAA,VAAGlB,iBAAU9W;;AA1DvC,AA2DE,oBAAA,AAAA,mFACE/e;AADF,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,gCAAA,eAAA,mBAAA,sBAAA,mBAAA,2BAAA,2BAAA,uBAAA,yCAAA,8CAAA,mCAAA,eAAA,+BAAA,uBAAA,yBAAA,eAAA,mBAAA,2BAAA,mBAAA,mBAAA,pmBACEnD,oIACmB+1B,sBACV/jB,iBACEqkB,iBACFc,wBACEC,oBACCG,2BACAlpB,yBACFmpB,8BACOP,6CACIJ,0CACJE,2BACRxqB,oBACKyqB,8BACDnlB,wBACCykB,kBACPvX,mBACI8W,oBACC4B,0BACD5L,iBACFjjB,iBACFsR;;AAtBT;;AAuBA,eACE,AAACjb,eAAK22B;eACN/J;eACA,SAAA,RAAKtf;eAGL,gDAAA,9CAAI,EAAKkrB,oBAAST,0BAAYO,oBAAS,qDAAA,rDAACp2B,6CAAEi2B;eAE1CH;eAEA,EAAIQ,gBACF9yB,IAEA,AAAC6H,+CAAO7H,IACA,kBAAA,mFAAA,nGAGE4yB,sLAAW,CAAA,iDAEE,iBAAMpB,WAAS,AAACn3B,gBAAM,AAACC,eAAK22B;IAEtB8B,sBACE,4BAAA,oLAAA,9LAAMvB,UACJ,wHAAA,xHAACh1B,6CAAE,sEAAA,tEAACd,4CAAI,AAACrB,gBAAMm3B;AAJzB,AAME,oBAAIuB;AAAJ;;AAEE,OAACvrB,sBAAO,EAAI8qB,yBACFxB,WACAsB;;gBAf7B,qDAAA,yDAAA,qBAAA,gCAAA,9BAkBE,WAAA,VAAOxqB,gBAAOwpB,aACR,EAAI,EAAIiB,sBAAWQ,gBACjBzB,aACA,mHAAA,mFAAA,mFAAA,IAAA,qDAAA,kEAAA,pZAACrlB,yaACcqlB;;;;;;;;;;AAvHzC;;;;;;;AAvCX,CAAA,0DAAA,1DAAMS,qEA+JFh0B,OAAOxC,QAAQ4G,IAAI6uB,WAAWlI,WAAW/X;AA/J7C,AAgKG,+GAAA,xGAACmiB,wDAAYn1B,OAAOxC,QAAQ4G,IAAI6uB,WAAWlI,WAAW/X;;;AAhKzD,CAAA,oDAAA,pDAAMghB;;AAAN,AAkKA;;;;mCAAA,nCAAMoB,8EAGHC;AAHH,AAIE,IAAMC,qBAAmB,6CAAA,WAAAC,xDAAC5mB;AAAD,AAAO,2EAAA,pEAAC6Z,kCAA4B,gBAAA+M,hBAAC/4B;GACnC64B;IAErBG,WAAS,AAACC,iDAASH;AAHzB,AAIE,SAAK,uEAAA,vEAAC32B,6CAAE,AAACqC,gBAAMw0B,oBAAa,uEAAA,vEAAC72B,6CAAE,AAACnC,gBAAMg5B;;AAE1C;;;;;;kCAAA,lCAAMlB,4EAKHoB;AALH,AAME,oDAAA,7CAACrrB,8EACK,+CAAA,WAAAsrB,iBAAAC,3EAAC/4B;AAAD,AAAS,GAAI,iCAAA+4B,jCAACR;AACH,oDAAA,7CAAC/qB,8EAAQ,+CAAAsrB,/CAAC3rB,gEAAU,8DAAA4rB,9DAACjnB,6CAAKuiB;;AAC1B,oDAAAyE,iBAAAC,9DAAC/yB;;GAFZ,iCAIE6yB;;AAEV,AAAA;;;;;;;;;;;;;;;+BAAA,uCAAA35B,tEAAM+5B;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,2DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,2DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAv4B,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,6DAAA,7DAAMu4B,wEAcF91B,OAAOC,MAAMC,MAAM1C,QAAQ4G,IAAI1F,KAAKsI,SAAS+uB,aAC7C1B;AAfJ,AAgBG,IAAMrd,cAAY,AAAA,uFAAS,CAAChX,uCAAAA,gDAAAA,XAAOxC,6BAAAA;IAC7Bw4B,YAAU,AAACh1B,gBAAMf;IAGjB+W,kBAAY,CAAGA,cAAY,aAAA,ZAAGgf;IAG9Bhf,kBAAY,EAAI,oDAAA,pDAACrY,6CAAEqB,4DAAa,AAACgB,gBAAMf,OAAO+W;IAC9CA,kBAAY,EAAI,EAAK,CAAGA,kBAAYgf,gBAAW,oDAAA,pDAACr3B,6CAAEqB,+DAGpC,kBAAI+1B,cAAa/e,gBAAYgf,WAC7Bhf;IACdic,aAAW,CAAG7uB,MAAI4xB;IAElBhP,WAAS,kBAAI,AAAA,uFAAS,CAAChnB,uCAAAA,gDAAAA,XAAOxC,6BAAAA,YACnB,CAACy4B,4DAAAA,qFAAAA,3BAAgBtH,kEAAAA,/CAASjwB,kEAAAA,OAC1B,CAACgwB,sDAAAA,+EAAAA,3BAAUC,4DAAAA,zCAASjwB,4DAAAA;IAC/BX,IAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,iCAAA,uBAAA,WAAA,qBAAA,6BAAA,+BAAA,yBAAA,qNAAA,4JAAA,iGAAA,l8BAAQnD,kNAAAA,2IAC0BwC,oBACbg2B,iBACN5xB,gBACK4C,yBACI+uB,4BACD/e,8BACDic,oBACL,AAAA,uFAAS,CAACjzB,uCAAAA,gDAAAA,XAAOxC,6BAAAA,kBACnB,CAAC0B,oDAAAA,0DAAAA,RAAQR,uCAAAA,kBACL,AAAC0E,4CAAIlE,oBAAQ8nB;IAClC+D,aAAW,AAAChB,0BAAYvsB,QAAQ4G,IAAI4iB;IACpCjpB,QAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,qDAAA,xXAAQnD,kNAAAA,+IAAsCutB;IAChDmL,oBAAkB,AAAA,4GAAoB,CAACl2B,uCAAAA,gDAAAA,XAAOxC,6BAAAA;IAG9C24B,sBAAc,kBAAM,iBAAAvxB,oBAAKsxB;AAAL,AAAA,oBAAAtxB;AACK,sEAAA,/DAACjG,6CAAEu3B;;AADRtxB;;MAAN,iEAAA,jEAEE,AAAC2tB,+BAAW,AAAC6D,2BAAM13B;IACnC23B,aAAW,kBAAI,iBAAAzxB,oBAAKmxB;AAAL,AAAA,oBAAAnxB;AAAkBuxB;;AAAlBvxB;;MACF,CAAGmxB,eAAa3xB,KAChB4S;IACbhE,SAAOqjB;IACPC,iCAAyB,AAACruB,kCAAc8iB;IACxChtB,QAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,uKAAA,WAAA,qBAAA,uCAAA,qCAAA,6BAAA,oCAAA,yBAAA,yBAAA,2DAAA,6BAAA,jyBAAQnD,kNAAAA,mIACkB,CAAC0B,oDAAAA,0DAAAA,RAAQR,uCAAAA,cACpB0F,gBACK4C,8BACSkvB,mCACJC,oCACDJ,0BACH,AAAC/0B,gBAAMf,qBACNgzB,yBACAoD,uCACcC,yCAClBtjB;IACpB+X,iBAAW,kDAAA,KAAA,rCAAUuL,qCAAyBvL;AAtDpD,AA0DE,IAAMwL,SAAO,AAACpB,wDAAYn1B,OACAxC,QACA4G,IACA6uB,WACAlI,eACA/X,OACAqhB;AAN1B,AAOE,oBAAA,AAAA,mFAAQ72B;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD,2IAAkC+4B;;AAA1C;;AACAA;;;AAlFP,CAAA,6DAAA,7DAAMT,wEAmFF91B,OAAOC,MAAMC,MAAM1C,QAAQ4G,IAAI1F,KAAKsI,SAAS+uB;AAnFjD,AAoFG,4HAAA,rHAACS,2DAAex2B,OACAC,MACAC,MACA1C,QACA4G,IACA1F,KACAsI,SACA+uB;;;AA3FnB,CAAA,uDAAA,vDAAMD;;AAAN,AA8FA;;;;;0BAAA,1BAAMW,4DAIHC,cAAQ1P;AAJX,AAKE,IAAO6K,OAAK7K;QAAZ,JACO2P;;AADP,AAEE,GAAM,GAAK,SAAA,RAAM9E;AAAjB,AACE,oBAAI,iBAAA+E,WAAS,AAACp6B,gBAAMq1B;AAAhB,AAAA,kGAAA+E,qCAAAA,/HAACF,8CAAAA,wDAAAA;;AAAsBC;;AAAE,eAAO,AAACl6B,eAAKo1B;eAAM,KAAA,JAAK8E;;;;;;AADvD;;;;;AAYJ,yBAAA,kFAAA,qEAAA,uDAAA,qEAAA,0DAAA,gEAAA,uEAAA,6EAAA,uFAAA,4EAAA,gEAAA,kFAAA,+DAAA,oEAAA,sFAAA,yEAAA,8DAAA,oEAAA,nxCAAKE;AAUL,yBAAA,wCAAA,gEAAA,kEAAA,wEAAA,kFAAA,uEAAA,6EAAA,+DAAA,iFAAA,oEAAA,+DAAA,6EAAA,oDAAA,yDAAA,8DAAA,uEAAA,6DAAA,mEAAA,oDAAA,uEAAA,yDAAA,qDAAA,56CAAKC;AAkBL,2BAAA,iFAAA,8DAAA,1KAAKC;AAEL,2BAAA,2CAAA,oDAAA,qDAAA,8DAAA,2DAAA,mEAAA,yDAAA,qDAAA,oDAAA,gEAAA,7kBAAKC;AAOL;;;uBAAA,vBAAMC,sDAEHz5B,QAAQ05B;AAFX,AAGE,oBAAI,CAACH,yDAAAA,kEAAAA,XAAWG,+CAAAA;AAAS,6DAAA,6DAAA,nHAAC72B,8CAAM7C;;AAAwBA;;;AAK1D,oCAAA,wCAAA,mEAAA,gEAAA,2DAAA,yDAAA,mEAAA,8DAAA,wEAAA,6EAAA,0DAAA,6EAAA,yDAAA,qDAAA,qDAAA,yDAAA,yDAAA,qDAAA,qDAAA,yDAAA,0DAAA,ltCAAK25B;AAYL;;;;8BAAA,9BAAMC,oEAGH55B,QAAQ4G,IAAIzI,EAAEwG,IAAIkC;AAHrB,AAIE,IAAMmL,QAAM,AAACrB,0BAAY3Q,QAAQ4G,IAAIC;IAC/BqT,aAAK,AAACnI,6BAAe/R,QAAQgS;AADnC,AAEE,OAAC3M,6CAAKV,IAAI,cAAA,ZAAIuV,gBAAO/b;;AAEzB;;;;;oCAAA,pCAAM07B,gFAIH75B,QAAQ4G,IAAIymB,SAASE;AAJxB,AAKE,wJAAA,jJAACluB,+CAAO,AAACmG,gDAAQo0B,4BAAc55B,QAAQ4G,IAAIymB,2CAAaE;;AAE1D;;;;;;mCAAA,nCAAMuM,8EAUH95B,QAAQwC,OAAOu3B;AAVlB,AAWE,IAAM/Z,iBAAe,CAACxd,uCAAAA,gDAAAA,XAAOxC,6BAAAA;IACvBupB,oBAAY,2DAAA,kEAAA,7HAACjjB,4CAAI0Z;IACjBga,oBAAY,2DAAA,kEAAA,7HAAC1zB,4CAAI0Z;IACjBia,qBAAa,2DAAA,oEAAA,/HAAC3zB,4CAAI0Z;AAHxB,AAAA,0FAIG,EAAI,kEAAA,lEAACvM,gDAAK8V,2EAAoBA,kBAAY,AAAA,gGAAc,CAACwQ,uCAAAA,gDAAAA,XAAO/5B,6BAAAA,YAChE,EAAI,kEAAA,lEAACyT,gDAAKumB,2EAAoBA,kBAAY,AAAA,gGAAc,CAACD,uCAAAA,gDAAAA,XAAO/5B,6BAAAA,YAChE,EAAI,mEAAA,nEAACyT,gDAAKwmB,4EACRA,mBACA,AAAA,kGAAe,CAACF,uCAAAA,gDAAAA,XAAO/5B,6BAAAA;;AAE9B;;;sCAAA,8CAAAk6B,pFAAME,6FAEgErb,IACnEvV;AAHH,AAAA,IAAA2wB,aAAAD;IAAAC,iBAAA,AAAA9zB,4BAAA8zB;cAAAA,VAE6Dn6B;kBAF7D,AAAAsG,4CAAA6zB,eAAA,zEAEWE;sBAFX,AAAA/zB,4CAAA6zB,eAAA,7EAEuBG;sBAFvB,AAAAh0B,4CAAA6zB,eAAA,7EAEuCI;AAFvC,AAIE,OAAClwB,cAAI,iBAAAzG,mBAAI,CAACy2B,4CAAAA,sDAAAA,ZAAY7wB,mCAAAA;AAAjB,AAAA,oBAAA5F;AAAAA;;AAAA,IAAAA,uBACI,iBAAAwD,oBAAK,OAAA,NAAG2X;AAAR,AAAA,GAAA3X;AAAe,QAACkzB,gDAAAA,0DAAAA,ZAAgB9wB,uCAAAA;;AAAhCpC;;;AADJ,AAAA,oBAAAxD;AAAAA;;AAAA,IAAAA,uBAEI,iBAAAwD,oBAAK,OAAA,NAAG2X;AAAR,AAAA,GAAA3X;AAAe,QAACmzB,gDAAAA,0DAAAA,ZAAgB/wB,uCAAAA;;AAAhCpC;;;AAFJ,AAAA,oBAAAxD;AAAAA;;AAGI,IAAAnE,qBAAuB,CAACk6B,kEAAAA,4EAAAA,ZAAiBnwB,yDAAAA;AAAzC,AAAA,oBAAA/J;AAAA,oBAAAA,hBAAS+6B;AAAT,AACE,IAAMC,aAAW,CAACD,8CAAAA,uDAAAA,XAAcx6B,oCAAAA;AAAhC,AACE,IAAA4D,uBAAI,AAAA,mFAAQ62B;AAAZ,AAAA,oBAAA72B;AAAAA;;AAAwB,OAAA,8FAAY62B;;;AAFxC;;;;;;;AAIX;;;;;;;;mCAAA,nCAAMC,8EAOHl4B,OAAOxC,QAAQkB;AAPlB,AAQE,IAAAy5B,aACQ,AAAA,oHAAwB,CAACn4B,uCAAAA,gDAAAA,XAAOxC,6BAAAA;YADxC,AAAAK,4CAAAs6B,WAAA,IAAA,nEAAOj2B;qBAAP,AAAArE,4CAAAs6B,WAAA,IAAA,5EAAaC;gBAAb,AAAAv6B,4CAAAs6B,WAAA,IAAA,vEAA4BE;kCAA5BF,9BAA0CG;AAA1C,AAEE,oBAAA,AAAA,mFAAK96B;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,oCAAA,sGAAA,nJAAK/C,sCAC6BwC,eACrB,AAAA,qFAAQxC,wCACe86B;;AAHpC;;AAIA,GAAI,EAAI,8IAAA,9IAACrnB,gDAAK,AAAA,qFAAQzT,wEAAkB,gCAAA,/BAAM86B;AAC5C55B;;AACA,IAAM65B,iBAAS,iBAAA3zB,oBAAK,EAAI,UAAA,TAAM1C,oBAAO,AAACvD,6CAAE,AAAA,qFAAQnB,SAAS0E;AAA1C,AAAA,GAAA0C;AAAA,IAAAA,wBACK,iBAAAxD,mBAAI,AAACyG,cAAIuwB;AAAT,AAAA,GAAAh3B;AAAAA;;AACI,IAAAwD,wBAAK,iBAAA4zB,WAAU,CAACznB,mDAAAA,yDAAAA,RAAOrS,sCAAAA;AAAlB,AAAA,4HAAA85B,kDAAAA,tKAAC3V,2DAAAA,qEAAAA;;AAAN,AAAA,oBAAAje;AACK,OAACjG,6CAAEy5B,eAAe,iBAAAK,WAAQ,CAAC1nB,mDAAAA,yDAAAA,RAAOrS,sCAAAA;AAAhB,AAAA,4GAAA+5B,0CAAAA,9IAACx5B,mDAAAA,6DAAAA;;;AADxB2F;;;;AAFT,AAAA,oBAAAA;AAIKyzB;;AAJLzzB;;;AAAAA;;;AAAf,AAKE,oBAAA,AAAA,mFAAKpH;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,gLAAA,zLAAK/C,oCAC2B,CAAC0B,oDAAAA,0DAAAA,RAAQR,uCAAAA,kBACzB65B;;AAFhB;;AAGA,oBAAIA;AACF,IAAMG,UAAO,CAACL,0CAAAA,+DAAAA,vBAAUr4B,4CAAAA,rCAAOxC,4CAAAA,pCAAQkB,4CAAAA;AAAvC,AACE,oBAAA,AAAA,mFAAKlB;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,TAAK/C,sCAAqC,CAAC0B,oDAAAA,6DAAAA,XAAQw5B,0CAAAA;;AAAnD;;AACAA;;AACFh6B;;;;AAEV,AAAA,AACA,AAAA,AACA,AAAA,AAEA,AAAA;;;;8BAAA,sCAAA3C,pEAAM68B;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,0DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,0DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAr7B,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,4DAAA,5DAAMq7B,uEAGFl0B,OAAOm0B,OAAOC;AAHlB,AAIG,oBAAI,CAACA,2CAAAA,mDAAAA,VAAWD,gCAAAA;AACd,MAAO,KAAAt7B,MAEC,CAAA,yFAAA,0CAAA,lDACKs7B,0HAGAC;;AACb,IAAMl4B,SAAO,CAAC8D,uCAAAA,+CAAAA,VAAOm0B,4BAAAA;AAArB,AACE,oBAAMj4B;AAAN,AACE,GAAI,OAASA;AACX,OAACm4B,0DAAcr0B,OAAO9D,OAAO,AAACiC,6CAAKi2B,WAAWD;;AAC9Cj4B;;;AAHJ;;;;;AAbP,CAAA,4DAAA,5DAAMg4B,uEAiBFl0B,OAAOm0B;AAjBX,AAiBmB,+EAAA,xEAACE,0DAAcr0B,OAAOm0B;;;AAjBzC,CAAA,sDAAA,tDAAMD;;AAAN,AAmBA;;;;;wCAAA,xCAAMI,wFAIHx7B,QAAQwJ;AAJX,AAKE,GAAI,AAACoD,wBAAQpD;AACX,GAAI,uEAAA,vEAACrI,6CAAE,AAACqC,gBAAMgG;AAAd,0FAEG,AAACxK,gBAAMwK,UAAU,AAACpF,iBAAOoF;;AAF5B,0FAIG,AAACxK,gBAAMwK,UACP,EAAI,6CAAA,7CAACrI,sGAAU,AAAA,qFAAQnB,WAAU,AAACoE,iBAAOoF,UAAU,qDAAA,rDAACnJ,4CAAImJ;;;AAN7D,mGAAA,TAQGA;;;AAEL,AAAA,AAEA,AAAA;;;;;mCAAA,2CAAAjL,9EAAMm9B;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,+DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,+DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA37B,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,iEAAA,jEAAM27B,4EAMF17B,QAAQ05B,QAAQiC;AANpB,AAOG,oBAAI,CAACA,4CAAAA,qDAAAA,XAAYjC,kCAAAA;AACf,MAAO,KAAA35B,MAEC,CAAA,gGAAA,0CAAA,nDACK25B,4HAGAiC;;AACb,IAAMnyB,WAAS,iBAAAoyB,eAAC,AAAA,gGAAc57B;AAAf,AAAA,QAAA47B,6CAAAA,sDAAAA,XAAwBlC,mCAAAA;;AAAvC,AACE,oBAAIlwB;AAEF,IAAAqyB,WAAiB77B;IAAjB87B,WAAyBtyB;IAAzBuyB,WAAkC,AAAC12B,6CAAKs2B,YAAYjC;AAApD,AAAA,kIAAAmC,SAAAC,SAAAC,qDAAAF,SAAAC,SAAAC,nNAACC,8DAAAA,0FAAAA;;AAFH,0FAGGh8B,QAAQ05B;;;;;AAnBlB,CAAA,iEAAA,jEAAMgC,4EAoBF17B,QAAQ05B;AApBZ,AAoBqB,8EAAA,vEAACuC,+DAAmBvC;;;AApBzC,CAAA,2DAAA,3DAAMgC;;AAAN,AAsBA,AAAA;;;;;;;;gCAAA,wCAAAn9B,xEAAMy9B;AAAN,AAAA,IAAAE,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAF,4DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,4DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAj8B,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,8DAAA,9DAAMi8B,yEAOFh8B,QAAQwJ,SAASmyB;AAPrB,AAQG,oBAAInyB;AAEF,IAAA2yB,aAAgC,AAACX,sCAAwBx7B,QAAQwJ;kBAAjE,AAAAnJ,4CAAA87B,WAAA,IAAA,zEAAOE;kBAAP,AAAAh8B,4CAAA87B,WAAA,IAAA,zEAAmBG;IAAnBF,aAEQ,+HAAA,7GAAIC,aACF,AAACJ,+DAAmBj8B,QAAQq8B,YAAYV,gGACvC37B,QAAQq8B;kBAJnB,AAAAh8B,4CAAA+7B,WAAA,IAAA,zEACOn5B;qBADP,AAAA5C,4CAAA+7B,WAAA,IAAA,5EACmBG;AADnB,AAKE,oBAAA,AAAAz5B,eAAA,iFAAA,uDAAA,8FAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,uCAAA,0BAAA,gCAAA,kDAAA,iDAAA,7MAAO/C,uCAE8BwJ,uBAChB6yB,6BACGE,oCACI,AAAC/4B,gBAAMP,iCACR,AAACO,gBAAM84B,mBACrB,AAAA,gFAAK,AAAA,gGAAct8B;;AAPhC;;AAQA,oBAAIs8B;AAAJ,0FACG,AAACt9B,gBAAM,gEAAA,YAAA,6BAAA,zGAACyB,iFAEkCwC,YACAq5B,mBAEMC;;AANnD,0FAOGt5B,YAAYs5B;;;AAtBnB,0FAwBGv8B,QAAQwJ;;;;AAhCd,CAAA,8DAAA,9DAAMwyB,yEAiCFh8B,QAAQwJ;AAjCZ,AAiCsB,oFAAA,7EAACgzB,4DAAgBx8B,QAAQwJ;;;AAjC/C,CAAA,wDAAA,xDAAMwyB;;AAAN,AAmCA;;;;;;;;;oCAAA,pCAAMS,gFAQHj6B,OAAOxC,QAAQwJ,SAAStC,OAAOa,YAAYlH;AAR9C,AASE,IAAM67B,eAAa,iBAAMA,eAAa,AAAA,2FAAW18B;AAA9B,AACE,GAAM,AAACyT,gDAAKipB,aAAalzB;AAAzB,AAAmCkzB;;AAAnC;;;IAEf18B,cAAQ,uDAAA,vDAAC2D,+CAAO3D;AAHtB,AAIE,oBAAI08B;AACF,GAAI,OAASA;AACX,IAAMC,iBAAe,iBAAA/4B,mBAAI,AAAC23B,0DAAcr0B,OAAOw1B;AAA1B,AAAA,oBAAA94B;AAAAA;;AACI,OAAC23B,0DAAcxzB,YAAY20B;;;AADpD,AAEE,oBAAA,AAAA55B,eAAA,iFAAA,uFAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,yDAAA,tEAAO/C,yDAE4C08B,+BAC1BC;;AAHzB;;AAIA,oBAAIA;AAEF,OAACH,4DAAgBx8B,YAAQ28B;;AAEzB,MAAO,KAAA58B,MAEC,CAAA,6DAAA,6GAAA,gCAAA,+BAAA,pLACKyC,4EAEA,AAAC5B,6BAAeC,8DAGhB67B;;;AAIjB,OAACF,4DAAgBx8B,YAAQ08B;;;AAxB7B,0FA2BG18B,YAAQwJ;;;AAEf,AAAA;;;;;;;wCAAA,gDAAAjL,xFAAMs+B;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,oEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,oEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA98B,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,sEAAA,tEAAM88B,iFAMFr6B,OAAOxC,QAAQwJ,SAAStI,KAAKuB,MAAMC,MAAMo6B;AAN7C,AAOG,oBAAA,AAAAh6B,eAAA,iFAAA,8EAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,oCAAA,qBAAA,lEAAO/C,sCAE6BwC,mBACjBgH,0BACKszB;;AAJxB;;AAKA,IAAM51B,SAAO,AAAA,sFAASlH;IAChB+H,cAAY,AAAA,iGAAc/H;IADhC+8B,aAGyB,AAACP,4DAAgBx8B,QAAQwJ;kBAHlD,AAAAnJ,4CAAA08B,WAAA,IAAA,zEAGO/8B;mBAHP,AAAAK,4CAAA08B,WAAA,IAAA,1EAGevzB;IAET3I,YAAU,AAAA,6FAAY,CAACb,4CAAAA,oDAAAA,VAAQwC,iCAAAA;IAE/BjC,IAAE,gKAAA,qSAAA,nbAAM,CAACu8B,8CAAAA,yDAAAA,bAAcj8B,sCAAAA,aACnB,kBAAO,KAAAd,MAEC,CAAA,kGAAA,uDAAA,lEACKc,iJAGAi8B;IAdvBE,aAmBQ,yGAAA,gHAAA,vMAAIn8B,WACF,AAAC0B,6BAAeC,OAAOxC,YAAQa,UAAUK,KAAKuB,MAAMC,0FACnD1C,YAAQkB,KAAKuB,MAAMC;kBArB9B,AAAArC,4CAAA28B,WAAA,IAAA,zEAkBOh9B;eAlBP,AAAAK,4CAAA28B,WAAA,IAAA,tEAkBe97B;gBAlBf,AAAAb,4CAAA28B,WAAA,IAAA,vEAkBoBv6B;gBAlBpB,AAAApC,4CAAA28B,WAAA,IAAA,vEAkB0Bt6B;qBAlB1B,AAAArC,4CAAA28B,WAAA,IAAA,5EAkBgCG;IAlBhCF,aAuByB,AAACR,kCAAoBj6B,OACAxC,YACAwJ,aACAtC,OACAa,YACAlH;kBA5B9C,AAAAR,4CAAA48B,WAAA,IAAA,zEAuBOj9B;mBAvBP,AAAAK,4CAAA48B,WAAA,IAAA,1EAuBezzB;IAvBf0zB,aAgCQ,iBAAMG,gBAAc,AAAA,6FAAY,CAAC76B,uCAAAA,oDAAAA,fAAOxC,iCAAAA;AAAxC,AACE,oBAAI,iBAAAoH,oBAAKi2B;AAAL,AAAA,oBAAAj2B;AAAmB,OAACqM,gDAAK5S,UAAUw8B;;AAAnCj2B;;;AACF,OAACk2B,oEAAmB96B,OACAxC,YACAwJ,aACAtI,SACAuB,UACAC,UACA,AAAC2C,6CAAKy3B,cAAcj8B;;AAP1C,gJAAA,tDASGb,YAAQwJ,aAAStI,SAAKuB,UAAMC;;;kBA1CzC,AAAArC,4CAAA68B,WAAA,IAAA,zEA+BOl9B;mBA/BP,AAAAK,4CAAA68B,WAAA,IAAA,1EA+Be1zB;eA/Bf,AAAAnJ,4CAAA68B,WAAA,IAAA,tEA+BwBh8B;gBA/BxB,AAAAb,4CAAA68B,WAAA,IAAA,vEA+B6Bz6B;gBA/B7B,AAAApC,4CAAA68B,WAAA,IAAA,vEA+BmCx6B;yBA/BnC,AAAArC,4CAAA68B,WAAA,IAAA,hFA+ByCE;IAYnCD,qBAAS,iBAAAv5B,mBAAIu5B;AAAJ,AAAA,oBAAAv5B;AAAAA;;AAAaw5B;;;AA3C5B,AAAA,0FA4CGp9B,YAAQwJ,aAAStI,SAAKuB,UAAMC,UAAMy6B;;;AAxDxC,CAAA,sEAAA,tEAAMN,iFAyDFr6B,OAAOxC,QAAQwJ,SAAStI,KAAKuB,MAAMC;AAzDvC,AA0DG,oHAAA,7GAAC46B,oEAAmB96B,OAAOxC,QAAQwJ,SAAStI,KAAKuB,MAAMC;;;AA1D1D,CAAA,gEAAA,hEAAMm6B;;AAAN,AA4DA,AAAA,AAEA;;;;;mCAAA,8DAAAU,jGAAME,8EAIHj7B,OAAOC,MAAMC,eAKCkE,IAAI1F;AATrB,AAAA,IAAAs8B,aAAAD;IAAAC,iBAAA,AAAAn3B,4BAAAm3B;cAAAA,VASQx9B;aATR,AAAAsG,4CAAAk3B,eAAA,pEAQWt2B;kBARX,AAAAZ,4CAAAk3B,eAAA,zEAQkBz1B;sBARlB,AAAAzB,4CAAAk3B,eAAA,7EAQ8BtoB;eAR9B,AAAA5O,4CAAAk3B,eAAA,tEAQwCh0B;qBARxC,AAAAlD,4CAAAk3B,eAAA,5EAQiDE;kBARjD,AAAAp3B,4CAAAk3B,eAAA,zEAQ0DnD;mBAR1D,AAAA/zB,4CAAAk3B,eAAA,1EAQsEG;AARtE,AAUE,oBAAA,AAAA76B,eAAA,iFAAA,qEAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,0BAAA,qBAAA,gOAAA,xRAAO/C,+BAEsB4G,gBACV4C,sBACC,AAAA,6FAAY,CAACxJ,wCAAAA,gDAAAA,VAAQwC,6BAAAA,sBACtB,AAAA,0FAAWxC;;AAL9B;;AAMA,GAAI,8IAAA,9IAACmB,6CAAE,AAAA,wFAASnB;AACd,QAAC49B,+DAAAA,yFAAAA,5BAAiBn7B,sEAAAA,hEAAMC,sEAAAA,hEAAM1C,sEAAAA,9DAAQkB,sEAAAA;;AAItC,IAAMqM,aAAW,AAACD,6BAAetN;IAO3BkB,WAAK,AAACw5B,iCAAmBl4B,OAAOxC,QAAQkB;IAGxC6d,MAAI,CAAC/E,mDAAAA,6DAAAA,ZAAO9Y,0CAAAA;IACZA,WAAK,EAAI,CAAG6d,MAAIxR,aAAY,iBAAA4wB,WAAc5wB;IAAd6wB,WAAyBl9B;IAAzBm9B,WAAA,AAAA;AAAA,AAAA,wHAAAF,SAAAC,SAAAC,gDAAAF,SAAAC,SAAAC,pMAACC,yDAAAA,qFAAAA;KAAmCp9B;IAChE6d,UAAI,CAAC/E,mDAAAA,6DAAAA,ZAAO9Y,0CAAAA;IACZs3B,YAAU,AAACh1B,gBAAMf;IACjB+S,SAAO,AAAA,uFAAS,CAACxV,wCAAAA,gDAAAA,VAAQwC,6BAAAA;IAd/Bq7B,aAmBQ,AAAChK,uCAAyBrxB,OAAOxC,QAAQ,CAAG4G,MAAI4xB,WAAWt3B;0BAnBnE,AAAAb,4CAAAw9B,WAAA,IAAA,jFAkBOU;iBAlBP,AAAAl+B,4CAAAw9B,WAAA,IAAA,xEAkB2BW;kBAlB3B,AAAAn+B,4CAAAw9B,WAAA,IAAA,zEAkBsCY;eAlBtC,AAAAp+B,4CAAAw9B,WAAA,IAAA,tEAkBkDrU;iBAlBlDqU,bAkB+Da;IAGzDC,oBAAY,AAACt0B,cAAI,iBAAAzG,mBAAI,CAACg7B,4DAAAA,wEAAAA,dAAUJ,qDAAAA;AAAf,AAAA,oBAAA56B;AAAAA;;AAA2B,QAACyhB,2DAAAA,uEAAAA,dAASmZ,oDAAAA;;;IAMtDK,0BAAkB,iBAAAz3B,oBAAKu3B;AAAL,AAAA,GAAAv3B;AAAiBoC;;AAAjBpC;;;IAElBi0B,SAAO,EAAA,yLAAA,tLAAQsD,qBAAY,CAACj9B,oDAAAA,gEAAAA,dAAQ88B,6CAAAA;IAMpC9E,UAAQ,0BAAA,KAAA,bAAU2B,aACR,mMAAA,oDAAA,gMAAA,mDAAA,yMAAA,yDAAA,gMAAA,kDAAA,AAAA,58BAAM,CAACyD,yDAAAA,qEAAAA,dAAON,kDAAAA,oFACR,CAACO,wDAAAA,oEAAAA,dAAMP,iDAAAA,mFACP,CAAC/kB,2DAAAA,uEAAAA,dAAS+kB,oDAAAA,yFACV,CAACQ,wDAAAA,oEAAAA,dAAMR,iDAAAA;;IAvC7BV,aA6CQ,kBAAI,iBAAA12B,oBAAKu2B;AAAL,AAAA,oBAAAv2B;AACK,SAAI,gNAAA,hNAACqM,gDAAK,mDAAA,uDAAA,1GAACnN,4CAAIY,+KACX,qNAAA,rNAACuM,gDAAK,wDAAA,uDAAA,/GAACnN,4CAAIyB;;AAFpBX;;MAAJ,mFAAA,KAAA,KAAA,+DAAA,mFAIGoC,SAAS6xB,OAAO3B;mBAjD3B,AAAAr5B,4CAAAy9B,WAAA,IAAA,1EA4COt0B;iBA5CP,AAAAnJ,4CAAAy9B,WAAA,IAAA,xEA4CgBzC;kBA5ChB,AAAAh7B,4CAAAy9B,WAAA,IAAA,zEA4CuBpE;IAQjBlwB,eAAS,iBAAA5F,mBAAI4F;AAAJ,AAAA,oBAAA5F;AAAAA;;AAAA,IAAAA,uBAGI,AAAC23B,0DAAcr0B,OAAOm0B;AAH1B,AAAA,oBAAAz3B;AAAAA;;AAAA,IAAAA,uBAII,AAAC23B,0DAAcxzB,YAAYszB;AAJ/B,AAAA,oBAAAz3B;AAAAA;;AAAA,IAAAA,uBAMI,CAACsD,uCAAAA,oDAAAA,fAAOwyB,iCAAAA;AANZ,AAAA,oBAAA91B;AAAAA;;AAOI,QAACmE,4CAAAA,yDAAAA,fAAY2xB,sCAAAA;;;;;;IAK1BlwB,eAAS,kBAAI,iBAAApC,oBAAK,AAACiD,cAAIb;AAAV,AAAA,GAAApC;AAAoBi0B;;AAApBj0B;;MACF,iBAAMi0B,aAAO,AAAClxB,eAAK,8DAAA,9DAAC+C,mDAAqBmuB;AAAzC,AAGE,IAAAz3B,mBAAI,AAAC23B,0DAAcr0B,OAAOm0B;AAA1B,AAAA,oBAAAz3B;AAAAA;;AACI,OAAC23B,0DAAcxzB,YAAYszB;;KACjC7xB;IAGXA,eAAS,kBAAI,iBAAApC,oBAAKi0B;AAAL,AAAA,oBAAAj0B;AAAY,wBAAA,hBAAMoC;;AAAlBpC;;MACF,AAAA,0GAAmBF,QACnBsC;IAIXA,eAAS,mHAAA,jHAAI,0DAAA,1DAACrI,6CAAEqI,yEAAoBA;IACpCA,eAAS,kBAAI,iBAAApC,oBAAKi0B;AAAL,AAAA,oBAAAj0B;AAAY,wBAAA,hBAAMoC;;AAAlBpC;;MAA6B,AAAA,0FAAUF,QAAQsC;IAM5Dy1B,yBAAiB,AAACryB,wBAAQpD;IAtFhCu0B,aA0FQ,AAACT,oEAAmB96B,OAAOxC,QAAQwJ,aAAStI,SAAKuB,MAAMC;kBA1F/D,AAAArC,4CAAA09B,WAAA,IAAA,zEAyFO/9B;mBAzFP,AAAAK,4CAAA09B,WAAA,IAAA,1EAyFev0B;eAzFf,AAAAnJ,4CAAA09B,WAAA,IAAA,tEAyFwB78B;gBAzFxB,AAAAb,4CAAA09B,WAAA,IAAA,vEAyF6Bt7B;gBAzF7B,AAAApC,4CAAA09B,WAAA,IAAA,vEAyFmCr7B;qBAzFnC,AAAArC,4CAAA09B,WAAA,IAAA,5EAyFyCZ;IAGnC3E,gBAAU,kBAAI2E,gBAAS,AAAC35B,gBAAMf,WAAO+1B;IAErCzZ,UAAI,kBAAIoe,gBAAS,CAACnjB,mDAAAA,6DAAAA,ZAAO9Y,0CAAAA,WAAM6d;IAC/BmgB,QAAM,iBAAAt7B,mBAAI,AAAA,qFAAQ5D;AAAZ,AAAA,oBAAA4D;AAAAA;;AAAqB,OAACM,0BAAY1B,OAAOxC;;;IAG/CA,cAAQ,kEAAA,yGAAA,3KAAC2D,sDAAO3D;IAEhBO,IAAE,yBAAA,+dAAA,teAAM2+B,OAAM,kBAAA,AAAA,iGAAA,AAAA,AAAAn8B,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,yCAAA,pXAAQnD,sNAAAA,4IAA+Bk/B;IApG3DlB,aA6GQ,kBAAI,iBAAAp6B,mBAAIu5B;AAAJ,AAAA,oBAAAv5B;AAAAA;;AAAaq7B;;MACf,AAACpL,uCAAyBrxB,OAAOxC,YAAQ,CAAG4G,MAAI4xB,eAAWt3B,UAC3Dw9B;8BA/GV,AAAAr+B,4CAAA29B,WAAA,IAAA,rFA4GOO;qBA5GP,AAAAl+B,4CAAA29B,WAAA,IAAA,5EA4G2BQ;sBA5G3B,AAAAn+B,4CAAA29B,WAAA,IAAA,7EA4GsCS;mBA5GtC,AAAAp+B,4CAAA29B,WAAA,IAAA,1EA4GkDxU;qBA5GlDwU,jBA4G+DU;IAOzDl1B,eAAS,EAAI,AAACoD,wBAAQpD,eAAU,AAACxK,gBAAMwK,cAAUA;IAnHvDy0B,aAyHQ,AAAC7K,sCAAwB5wB,OACAxC,YAEA,CAAG4G,MAAI4O,QACPkpB;0BA7HjC,AAAAr+B,4CAAA49B,WAAA,IAAA,jFAsHOkB;iBAtHP,AAAA9+B,4CAAA49B,WAAA,IAAA,xEAsH2BmB;kBAtH3B,AAAA/+B,4CAAA49B,WAAA,IAAA,zEAsHsCoB;YAtHtC,AAAAh/B,4CAAA49B,WAAA,IAAA,nEAsHkD19B;kBAtHlD09B,dAsHwDqB;IASlDvgB,UAAI,CAACwgB,mEAAAA,iFAAAA,hBAAuB/V,8DAAAA;IA/HlC0U,aA2IQ,kBAAI,iBAAA92B,oBAAK,0DAAA,1DAACjG,6CAAEqI;AAAR,AAAA,GAAApC;AAAA,IAAAA,wBACK,AAAA,gHAAqB,CAACpH,4CAAAA,oDAAAA,VAAQwC,iCAAAA;AADnC,AAAA,oBAAA4E;AAEK,4DAAA,rDAACjG,6CAAE4d;;AAFR3X;;;AAAAA;;MAAJ,ijCAAA,GAAA,mEAAA,piCAGG,kTAAA,lTAACvE,8CAAM,8DAAA,mHAAA,jLAAC28B,kDAAUx/B,+FAASwC,eAAQi9B,gKACvB,0GAAA,zGAAK,AAAA,0FAAWz/B,qBAAWo/B,WACvC,AAAA,gHAAqB,CAACp/B,4CAAAA,oDAAAA,VAAQwC,iCAAAA,UAC9B,AAACgB,gBAAM,AAAA,gHAAqB,CAACxD,4CAAAA,oDAAAA,VAAQwC,iCAAAA,kBACrC,AAAC8J,yBAAWkd,aAASiV,4GACrBz+B,YAAQw+B,eAAW/7B,UAAM+1B,cAAU91B,UAAMqc,QAAIyK;kBAnJxD,AAAAnpB,4CAAA69B,WAAA,IAAA,zEA0IOl+B;qBA1IP,AAAAK,4CAAA69B,WAAA,IAAA,5EA0IeM;gBA1If,AAAAn+B,4CAAA69B,WAAA,IAAA,vEA0I0Bz7B;oBA1I1B,AAAApC,4CAAA69B,WAAA,IAAA,3EA0IgC1F;gBA1IhC,AAAAn4B,4CAAA69B,WAAA,IAAA,vEA0I0Cx7B;cA1I1C,AAAArC,4CAAA69B,WAAA,IAAA,rEA0IgDnf;mBA1IhD,AAAA1e,4CAAA69B,WAAA,IAAA,1EA0IoD1U;IAgB9ChU,aAAO,AAAA,uFAAS,CAACxV,4CAAAA,oDAAAA,VAAQwC,iCAAAA;IACzBiT,aAAW,AAAA,6FAAa,CAACzV,4CAAAA,oDAAAA,VAAQwC,iCAAAA;IACjCy3B,qBAAa,AAAA,kGAAe,CAACj6B,4CAAAA,oDAAAA,VAAQwC,iCAAAA;IAErCgT,aAAO,kBAAI,CAAC6jB,uDAAAA,qEAAAA,hBAAS7vB,kDAAAA,gBAAUgM,WAAO,iBAAA5R,mBAAI6R;AAAJ,AAAA,oBAAA7R;AAAAA;;AAAe4R;;;IACrDA,aAAO,CAAGA,aAAO,iBAAA,hBAAKgjB;IAOtBhvB,eAAS,yBAAA,PAAI01B,gEAAc11B;IAC3Bk2B,qBAAa,AAACtF,oCAAgBp6B,YAAQ+e,QAAIvV;IAC1Ck2B,yBAAa,sCAAA,KAAA,zBAAUzF,yBAAayF;IACpCA,yBAAa,uHAAA,rHAAI,0DAAA,1DAACv+B,6CAAEqI,6EAAsBk2B;IAC1CA,yBAAa,kIAAA,hIAAI,wEAAA,xEAACjsB,gDAAK8qB,qFAAgCmB;IAKvDA,yBAAa,EAAI,0DAAA,1DAACv+B,6CAAEqI,yEACL,iBAAApC,oBAAKs4B;AAAL,AAAA,oBAAAt4B;AACK,qNAAA,9MAACgzB,oCAAgBp6B,YACA,CAACga,mDAAAA,+DAAAA,dAAOolB,4CAAAA;;AAF9Bh4B;;KAIAs4B;IACfA,yBAAa,mPAAA,jOAAI,AAAA,8FAAY,CAAC1/B,4CAAAA,oDAAAA,VAAQwC,iCAAAA,gBAAak9B;IAGnDA,yBAAa,kIAAA,hHAAI,AAAA,kGAAe1/B,mBAAc0/B;IAI9Cl2B,gBAAS,iBAAA5F,mBAAI,CAAC01B,uDAAAA,qEAAAA,hBAAS9vB,kDAAAA;AAAd,AAAA,oBAAA5F;AAAAA;;AAAwB4F;;;IAGjCA,gBACE,kBAAI,iBAAApC,oBAAK,2DAAA,3DAACjG,6CAAEqI;AAAR,AAAA,GAAApC;AAAsB,QAAC03B,yDAAAA,qEAAAA,dAAOM,kDAAAA;;AAA9Bh4B;;MAAJ,oDAAqDoC;IAKvDA,gBAAS,kBAAI,iBAAAm2B,eAAA,iFAAA,kFAAA,yDAAA,+DAAA,2DAAA,yDAAA,oEAAA;AAAA,AAAA,QAAAA,6CAAAA,4DAAAA,jBAECn2B,yCAAAA;MACHA,cACA,mBAAA,jBAAI,WAAA,VAAGuV,qBAAWvV;IAG7BA,gBAAS,kBAAIk0B,gBAAS,iBAAA95B,mBAAI,CAAC41B,yDAAAA,wEAAAA,jBAAWhwB,qDAAAA;AAAhB,AAAA,oBAAA5F;AAAAA;;AAA0B4F;;KAAUA;IAE1DxJ,cAAQ,kBAAI09B,gBAAS,2DAAA,3DAAC/5B,+CAAO3D,0EAAmBA;IAIhD4/B,aAAW,iBAAA,hBAAKpH;IAahBqH,iBAAe,kBAAI,CAACf,yDAAAA,yEAAAA,lBAAON,sDAAAA,kBAAYhpB,WAAOgjB;IAO9CD,eAAa,EAAA,oPAAA,jPAAQoG,qBACN,CAAA,CAAG/3B,MAAI,iBAAA,hBAAK4xB,wBAAW,AAACh1B,gBAAM,CAAC9B,oDAAAA,oEAAAA,lBAAQ88B,iDAAAA;IAGtDjG,mBAAa,iBAAA30B,mBAAI20B;AAAJ,AAAA,oBAAA30B;AAAAA;;AAAiB,oBAAMi7B;AAAN,AAAwB,QAAGrpB,aAAO5O;;AAAlC;;;;IAI9B2xB,mBAAa,EAAI,iEAAA,jEAACp3B,6CAAEg+B,4EACL5G,iBACA,oCAAA,mBAAA,rCAAMA,kBAAa,CAAG/iB,aAAO5O;IAI5C5G,cAAQ,EAAI,GAAK2+B,qBAMP,0DAAA,1DAAC97B,8CAAM7C,wEAAkBq7B,YACzBr7B;IACVA,cAAQ,0DAAA,1DAAC6C,8CAAM7C,sEAAgB,CAAK,AAAC8rB,gBAAK,iBAAAloB,mBAAI,AAAA,wFAAS5D;AAAb,AAAA,oBAAA4D;AAAAA;;AAAA;;QAAX;IAC/BrD,QAAE,4HAAA,yPAAA,nWAAM,AAAA,4FAAWP,cACf,kOAAA,lOAAC+C,yGAAQ,AAAC7E,mBAAK,AAAA,wFAAS8B,oBAAgBq7B;IAC5CxP,UAAQ,CAAGrW,aAAO5O;IAClBk5B,eAAa,CAAGtH,gBAAU5xB;IAC1B5G,cAAQ,kBAAIwJ,eAAS,2DAAA,3DAAC7F,+CAAO3D,0EAAmBA;IAahD+W,WAAS,AAAC7E,4BAAclS;IACxBiX,WAASjX;gBA/Qf,mFAAA,6IAAA,5OAgRM6nB,kLAAYplB,UAAM,AAACiQ,yBAAW1S,YAAQyC;IAEtCqlB,YACE,AAACP,qDAASvnB,YAAQ,CAAG4G,MAAI,iBAAAywB,kBAAA;IAAAC,kBAAO,iBAAA,hBAAKkB;AAAZ,AAAA,SAAAnB,kBAAAC,mBAAAD,kBAAAC;MAAyBp2B,SAAKwB;IACzDnC,QAAE,kBAAA,AAAA,iGAAA,AAAA,AAAAwC,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,8KAAA,oBAAA,0BAAA,eAAA,WAAA,qBAAA,iCAAA,sCAAA,gCAAA,iCAAA,uLAAA,+CAAA,mFAAA,2BAAA,uBAAA,yBAAA,4BAAA,kCAAA,kHAAA,mHAAA,mQAAA,uOAAA,wHAAA,v+DACEnD,sNAAAA,sIACiB,CAAC0B,oDAAAA,8DAAAA,ZAAQR,2CAAAA,oBACjBm6B,uBACG7xB,qBACLuV,eACAnY,cACG4O,6BACQqqB,8BACHH,qCACDf,kCACEpG,+BACF,CAAC72B,oDAAAA,oEAAAA,lBAAQ88B,iDAAAA,wCACAD,iCACd,CAAA,2DAAA,XAAS97B,sCACL+1B,2BACA1Q,wBACC8X,uBACF1qB,+BACG+kB,8BACJ,AAAA,0FAAWj6B,yBACV,AAAA,0FAAWA,mCACD,AAAA,gHAAqB,CAACwC,uCAAAA,oDAAAA,fAAOxC,iCAAAA,2BACvC,AAAA,8FAAY,CAACwC,uCAAAA,oDAAAA,fAAOxC,iCAAAA,yBACtB,AAAA,qFAAQA;IACtBwtB,WAAS,0JAAA,xJAAI,EAAK,aAAA,ZAAOzO,sBAAK,qEAAA,rEAAC5d,6CAAEo9B,wIAEtB,0CAAA,sEAAA,9FAAMmB,wBACJ,AAACjU,+BAAiBzrB,YAAQ8/B,aAAatW;IAIpDxpB,cAAQ,2DAAA,3DAAC2D,+CAAO3D;AApTtB,AAqTE,GACE,sDAAA,tDAACmB,6CAAEqsB;AAAiB,OAAC9c,mHAAcmX,UAAUC;;AAD/C,oBAEEmS;AAAa,OAACvpB,mHAAcmX,UACA,AAACmR,2DAAex2B,OACAC,UACAC,UACA1C,YACA4G,IACA1F,SACAsI,cACA+uB,kBAChBzQ;;AAX9B,oBAYE0F;AAAS,OAAC9c,mHAAcmX,UAAU2F,SAAS1F;;AAZ7C,GAeE,2DAAA,3DAAC3mB,6CAAEqI;AACD,IAAMgf,aAAW,AAAChlB,gBAAMgmB;IAIlBuW,eACE,kBAAIxH,kBAAa/iB,WAAO,CAAGqqB,iBAAeD;AALlD,AAOE,OAAClvB,mHAAcmX,UACA,CAACmY,4DAAAA,iIAAAA,vEAAcx9B,8GAAAA,vGACAxC,8GAAAA,lGAGA4G,8GAAAA,1GAGAk5B,8GAAAA,jGACAC,8GAAAA,jGACAb,8GAAAA,xGACA1V,8GAAAA,eACf1B;;AAnCrB,oBA0CE5S;AACE,oBAAA,AAAA,mFAAKlV;AAAL,AAAA,OAAA+C,yGAAA,AAAA,4GAAA,4BAAA,zCAAK/C,8BAAyBq7B;;AAA9B;;;AA3CJ,oBA+CE,kBAAA,AAAA,iGAAA,AAAA,AAAAt4B,yGAAA,AAAA,4GAAA,+CAAA,lRAAK/C,sNAAAA,wCAAmCwJ;AA/C1C;;AAAA,GAgDE,EAAK,qDAAA,rDAACrI,6CAAE4d,kBAAO,qEAAA,rEAAC5d,6CAAEo9B;AAA6B,OAAC7tB,mHAAcmX,UACAC;;AAjDhE,GAkDE,qDAAA,rDAAC3mB,6CAAE4d;AAKD,OAACrO,mHACCmX,UACA,AAACoG,6DAAiBzrB,OAAOyU,SAAS6oB,aAAatW,cAC/C1B;;AA1DN,oBA+DE,iBAAA1gB,oBAAK,2DAAA,3DAACjG,6CAAEqI;AAAR,AAAA,GAAApC;AAAA,IAAAA,wBAA2B,WAAA,VAAG2X;AAA9B,AAAA,GAAA3X;AAAqC,QAACqS,2DAAAA,uEAAAA,dAAS2lB,oDAAAA;;AAA/Ch4B;;;AAAAA;;;AACE,IAAA64B,aACQ,AAAC/sB,uCAAyB6D,SACA,iBAAAnT,mBAAI20B;AAAJ,AAAA,oBAAA30B;AAAAA;;AAAiB,QAAG4R,aAAO5O;;KAC3B,CAAG4O,aAAO5O,KACV+S,kCACAylB;mBALlC,AAAA/+B,4CAAA4/B,WAAA,IAAA,1EAAOhtB;wBAAP,AAAA5S,4CAAA4/B,WAAA,IAAA,/EAAoBC;IAMdA,wBAAkB,EAAI,0DAAA,1DAAC/+B,6CAAE8R,qEACL,mHAAA,mFAAA,mFAAA,IAAA,qDAAA,kEAAA,pZAACvC,yaACcwvB,wBACfA;AAT1B,AAUE,OAACxvB,mHAAcmX,UACA0W,wBAEA,iBAAA4B,WAAUppB;IAAVqpB,WAAmB,OAAA,NAAKx5B;IAAxBy5B,WAA6B7B;AAA7B,AAAA,8HAAA2B,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAACtoB,4DAAAA,wFAAAA;KACDonB,oBACAe,sBACA,AAACxvB,mHAMC,0KAAA,1KAACugB,mEAAuBzuB,OACAxC,YACA,CAAGwV,aAAO5O,KACV,CAAG4O,aAAO5O,KACV,AAACotB,iCACCsL,wEAE1BxX;;AA7FvB,GA8FE,2DAAA,3DAAC3mB,6CAAEqI;AACD,IAAM82B,uBAAqB,AAACtM,iCAAmB0K;IACzClW,aAAW,AAAChlB,gBAAMgmB;AADxB,AAEE,OAAC9Y,mHAAcmX,UACA0W,wBACA,iBAAAgC,WAAUxpB;IAAVypB,WAAmB,OAAA,NAAK55B;IAAxB65B,WAA6BjC;AAA7B,AAAA,8HAAA+B,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAAC1oB,4DAAAA,wFAAAA;KAKD,uCAAA,vCAACuQ,2BAAatoB,uEAKAu4B,iBACA,CAAG/iB,aAAO5O,KACVuiB,4BACAX,WACA8X,sBACdxY;;AAlHrB,GAmHE,2DAAA,3DAAC3mB,6CAAEqI;AACD,IAAM82B,uBAAqB,AAACtM,iCAAmB0K;AAA/C,AACE,OAAChuB,mHAAcmX,UACA0W,wBACA,iBAAAmC,WAAU3pB;IAAV4pB,WAAmB,OAAA,NAAK/5B;IAAxBg6B,WAA6BpC;AAA7B,AAAA,8HAAAkC,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAAC7oB,4DAAAA,wFAAAA;KACD,AAACtH,yBAAWzQ,YACA,CAAGwV,aAAO5O,KAIV,AAAC0jB,6BAAetqB,YACA,CAAGwV,aAAO5O,KACV05B,uBAC5BxY;;AAhIrB,GAkIE,6TAAA,wHAAA,0IAAA,8HAAA,3rBAAI,EAAK,2DAAA,3DAAC3mB,6CAAEqI,sEAAc,AAACa,cAAI,CAACy0B,yDAAAA,qEAAAA,dAAOM,kDAAAA,uBACnC,2DAAA,3DAACj+B,6CAAEqI,2EACH,2DAAA,3DAACrI,6CAAEqI,6FACH,2DAAA,3DAACrI,6CAAEqI,iFACH,2DAAA,3DAACrI,6CAAEqI,oFACH,2DAAA,3DAACrI,6CAAEqI;AACL,IAAAq3B,aAGQ,AAACzN,sCAAwB5wB,OACAxC,YAGA,CAAG4G,MAAI4O,YACP8pB;0BARjC,AAAAj/B,4CAAAwgC,WAAA,IAAA,jFAAOE;iBAAP,AAAA1gC,4CAAAwgC,WAAA,IAAA,xEAA2BG;kBAA3B,AAAA3gC,4CAAAwgC,WAAA,IAAA,zEAAsCI;YAAtC,AAAA5gC,4CAAAwgC,WAAA,IAAA,nEAAkDtgC;iBAAlDsgC,bAAwDK;IAelDC,uBAAqB,AAACnN,iCAAmBkN;IACzC/L,iBAAe,AAAC9G,+BACC7rB,OACA,EAAI,AAAC6H,cAAI22B,aAAYhhC,YAAQ+W,UAE7BwhB,iBACA,CAAG/iB,aAAO5O,KACVw4B;IAtBvB0B,aAyBQ,AAACnwB,0BAAYoG,SAASwhB,iBAAapD;iBAzB3C,AAAA90B,4CAAAygC,WAAA,IAAA,xEAuBOlvB;gBAvBP,AAAAvR,4CAAAygC,WAAA,IAAA,vEAuBkBjvB;IAGZuvB,cACE,kCAAA,hBAAMjM,gBACJ,iBAAMkM,yBACE,AAAC3wB,mHACC,iBAAA4wB,WAAUvqB;IAAVwqB,WAAmB,CAAG/rB,aAAO5O;IAA7B46B,WAAkChD;AAAlC,AAAA,8HAAA8C,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAACzpB,4DAAAA,wFAAAA;KACDonB,oBACAhK,eACA4L;IACJjqB,gBACE,EAAI,AAACzM,cAAI82B,uBAAsBnhC,YAAQ+W;IACzC0qB,4BAAoB,AAAC1vB,6BACC+E,cACA,AAACnG,0BACCmG,cACA,CAAGlQ,MAAI4O,YACP6rB;IAIxBK,YAAU,AAAChxB,mHAAc6tB,wBACA8C;AAlB/B,AAmBE,GAAUI;AAAV;AAAA,AACE,oBAAA,AAAA,mFAAQzhC;AAAR,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,rHAAQnD,oKAEA0hC;;AAFR;;;AAGF,OAAChxB,mHACCgxB,UACA,kBAAI,iBAAA99B,mBAAI,2DAAA,3DAACzC,6CAAEqI;AAAP,AAAA,GAAA5F;AAAAA;;AAAA,IAAAA,uBACI,2DAAA,3DAACzC,6CAAEqI;AADP,AAAA,GAAA5F;AAAAA;;AAAA,IAAAA,uBAEI,2DAAA,3DAACzC,6CAAEqI;AAFP,AAAA,GAAA5F;AAAAA;;AAAA,IAAAA,uBAGI,2DAAA,3DAACzC,6CAAEqI;AAHP,AAAA,GAAA5F;AAAAA;;AAAA,IAAAA,uBAII,2DAAA,3DAACzC,6CAAEqI;AAJP,AAAA,GAAA5F;AAAAA;;AAKI,IAAAwD,oBAAK,CAACqS,2DAAAA,uEAAAA,dAASunB,oDAAAA;AAAf,AAAA,oBAAA55B;AAA2B,+DAAA,xDAACjG,6CAAEyQ;;AAA9BxK;;;;;;;MACN,AAACinB,+BACC7rB,OACA,EAAI,AAAC6H,cAAI82B,uBAAsBnhC,YAAQ+W,UACvC,EAAI,EAAK,iEAAA,jEAAC5V,6CAAE4/B,gFACHU,6BAEP5vB,UAEA,CAAG2D,aAAO5O,MACZ,CAAG4O,aAAO5O,KACVo6B,YACF,AAACvwB,yBAAWzQ,YACA,CAAGwV,aAAO5O,KACV,iBAAA+6B,WAAU,EAAI,AAACt3B,cAAI82B,uBACPnhC,YACA+W;IAFZ6qB,WAGU,CAAGpsB,aAAO5O;IAHpBi7B,WAIUb;AAJV,AAAA,8HAAAW,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAAC9pB,4DAAAA,wFAAAA;;KA7CrB;AA3BR,AA6EE,oBAAMqpB;AAAN,AACE,GAAI,AAAC/2B,cAAI82B;AAEP,OAACzwB,mHAAcmX,UAAUuZ,YAAYtZ;;AAErC,OAACpX,mHACCmX,UACAuZ,YACA,uSAAA,6QAAA,ljBAAM,2DAAA,3DAACjgC,6CAAEqI,gFACD,AAACiH,yBAAWzQ,YACA,CAAGwV,aAAO5O,KACV,AAACmjB,0DAAc/pB,YACA,CAAGwV,aAAO5O,KACVu6B,yBAC7B,2DAAA,3DAAChgC,6CAAEqI,mFACD,AAACiH,yBAAWzQ,YACA,CAAGwV,aAAO5O,KACV,AAAC0jB,6BAAetqB,YACA,CAAGwV,aAAO5O,KACVu6B,uBACxB,AAAClQ,mEAAuBzuB,OAEA,EAAI,2DAAA,3DAACrB,6CAAEqI,2EACL,0DAAA,6DAAA,vHAAC3G,8CAAM7C,4HAEPA,aACF,CAAGwV,aAAO5O,KAEV,CAAG4O,aAAO5O,KACVu6B,qBACA33B;GACpCse;;;AA/BN;;;AArNN,GAqPE,EAAK,2DAAA,3DAAC3mB,6CAAEqI,qFAAsB,WAAA,VAAGuV;AAC/B,IAAA+iB,aACQ,AAAC1O,sCAAwB5wB,OACAxC,YACA,CAAG4G,MAAI4O,YACP8pB;0BAJjC,AAAAj/B,4CAAAyhC,WAAA,IAAA,jFAAOf;iBAAP,AAAA1gC,4CAAAyhC,WAAA,IAAA,xEAA2Bd;kBAA3B,AAAA3gC,4CAAAyhC,WAAA,IAAA,zEAAsCb;YAAtC,AAAA5gC,4CAAAyhC,WAAA,IAAA,nEAAkDvhC;iBAAlDuhC,bAAwDZ;IAAxDa,aAMQ,AAAC3O,sCAAwB5wB,OACAxC,YACA,CAAG4G,MAAI4O,YACP0rB;0BATjC,AAAA7gC,4CAAA0hC,WAAA,IAAA,jFAKOC;iBALP,AAAA3hC,4CAAA0hC,WAAA,IAAA,xEAK2BE;kBAL3B,AAAA5hC,4CAAA0hC,WAAA,IAAA,zEAKsCG;YALtC,AAAA7hC,4CAAA0hC,WAAA,IAAA,nEAKkDxhC;kBALlDwhC,dAKwDI;IAKlDC,gBAAc,iBAAAx+B,mBAAI,wBAAA,WAAAy+B,nCAACpJ;AAAD,AAAY,IAAAr1B,mBAAI,qHAAAy+B,0DAAAA,9KAAC5oB,2DAAAA,6EAAAA;AAAL,AAAA,oBAAA7V;AAAAA;;AACI,oBAAM,iHAAAy+B,wDAAAA,xKAACvD,yDAAAA,2EAAAA;AAAP,AACE,IAAAwD,WAAU,qGAAAD,kDAAAA,tJAAC9uB,mDAAAA,qEAAAA;AAAX,AAAA,4HAAA+uB,kDAAAA,tKAAC7oB,2DAAAA,qEAAAA;;AADH;;;GAEL+P;AAHf,AAAA,oBAAA5lB;AAAAA;;AAAA;;;IAKd2+B,oBAAY,OAAS,AAAClgC,+BAAiBrC,YAAQghC;IAC/CwB,cAAY,EAAID,mBAAYL,YAAYjB;IACxCwB,eAAa,CAAA,gCAAA,/BAAGL,gBAAcI;IAC9BE,gBAAQ,gBAAA,fAAMD;IACdE,aAAW,qBAAA,iGAAA,pHAAMJ,mBACJ,AAAClU,+BAAiB7rB,OACAuU,SACA,CAAGvB,aAAO5O,KAEV,CAAG4O,aAAO5O,KACVo6B;IAgB/B4B,SACE,iBAAA,fAAMF,eACJ,iBAAMI,iBAAe,AAACzU,+BAAiB7rB,OACAuU,SACA,CAAGvB,aAAO5O,KAEV,CAAG4O,aAAO5O,KACV,EAAI27B,mBACFN,WACAjB;IAPzC6B,aAQ6B,AAAClyB,0BAAYoG,SACA,CAAGvB,aAAO5O,KACVk8B;iBAV1C,AAAAziC,4CAAAwiC,WAAA,IAAA,xEAQOjxB;gBARP,AAAAvR,4CAAAwiC,WAAA,IAAA,vEAQkBhxB;AARlB,AAWE,OAACnB,mHACC,EAAI6xB,mBAAYP,oBAAoBjB,qBACpC+B,eACA,AAAC7R,mEACCzuB,OACAuU,SAMA,aAAA,ZAAKlF,iBACL,qCAAA,pCAAK,CAAA,CAAG2D,aAAOA,cAAO5O,YACtB,AAACotB,iCACC,kBAAI2O,YAAWR,YAAYjB,aAC7B13B,cACAi5B;KA5BR;AA1CR,AAuEE,OAAC/xB,mHACCmX,UACA0W,wBACA,iBAAAwE,WAAUhsB;IAAVisB,WAAmB,OAAA,NAAKp8B;IAAxBq8B,WAA6BzE;AAA7B,AAAA,8HAAAuE,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAAClrB,4DAAAA,wFAAAA;KACDonB,oBACA,AAAC9Q,+BAAiB7rB,OACA,EAAI,qDAAA,rDAACrB,6CAAE4d,cAAO/e,YAAQ+W,UACtBwhB,iBACA,CAAG/iB,aAAO5O,KACVw4B,YAClB,6OAAA,6KAAA,0DAAA,AAAA,ldAAM,EAAKmD,uBAAYG,iBAAS,AAAChyB,mHAAcqwB,oBACA4B,WACA,AAAChQ,iCACCiQ,gBAC3CL,mBAAY,AAAC7xB,mHAAcqwB,oBAAoB4B,mBAC/CD,eAAQ,AAAC/P,iCAAmBiQ;IAElC,AAAC3R,mEACCzuB,OACA,AAACi3B,qBAAOz5B,YAAQwJ,eAChB,CAAGgM,aAAO5O,KAEV,CAAG4O,aAAO5O,KACV,AAACogB,kBAAQwC,aACA,EAAIkZ,eACFN,cACA,EAAIG,mBAAYL,YAAYjB,eACvCz3B,eACFse;;AAzVR,GA0VE,iIAAA,uHAAA,tPAAI,2DAAA,3DAAC3mB,6CAAEqI,oFACH,2DAAA,3DAACrI,6CAAEqI,0EACH,2DAAA,3DAACrI,6CAAEqI,2FACH,2DAAA,3DAACrI,6CAAEqI;AACL,OAACkH,mHACCmX,UACA0W,wBACA,iBAAA2E,WAAUnsB;IAAVosB,WAAmB,OAAA,NAAKv8B;IAAxBw8B,WAA6B5E;AAA7B,AAAA,8HAAA0E,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAACrrB,4DAAAA,wFAAAA;KACDonB,oBACA,AAAC9Q,+BAAiB7rB,OACA,EAAI,qDAAA,rDAACrB,6CAAE4d,cAAO/e,YAAQ+W,UACtBwhB,iBACA,CAAG/iB,aAAO5O,KACVw4B,YAIlB,EAAI,2DAAA,3DAACj+B,6CAAEqI,8EACL,AAACiH,yBAAWzQ,YACA,CAAGwV,aAAO5O,KACV,AAACmjB,0DAAc/pB,YACA,CAAGwV,aAAO5O,KACV,AAACotB,iCAAmBsL,eAC/C,AAACrO,mEAAuBzuB,OACA,AAACi3B,qBAAOz5B,YAAQwJ,eAChB,CAAGgM,aAAO5O,KAEV,CAAG4O,aAAO5O,KACV,AAACotB,iCAAmBsL,aACpB91B,gBAC1Bse;;AAxXN,GA0XE,2DAAA,3DAAC3mB,6CAAEqI;AACD,IAAM65B,wBAAsB,AAACrP,iCAAmBsL;AAAhD,AACE,oBAAM,CAAC7lB,2DAAAA,uEAAAA,dAAS2lB,oDAAAA;AAOR,OAAC1uB,mHACCmX,UACA0W,wBACA,iBAAA+E,WAAUvsB;IAAVwsB,WAAmB,CAAG/tB,aAAO5O;IAA7B48B,WAAkChF;AAAlC,AAAA,8HAAA8E,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAACzrB,4DAAAA,wFAAAA;KACDonB,oBACA,AAAC1uB,yBAAWzQ,YACA,CAAGwV,aAAO5O,KACV,iBAAA68B,WAAU1sB;IAAV2sB,WAAmB,CAAGluB,aAAO5O;IAA7B+8B,WAAkCvE;AAAlC,AAAA,8HAAAqE,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAAC5rB,4DAAAA,wFAAAA;MACb,AAACtH,yBAAWzQ,YACA,CAAGwV,aAAO5O,KACV,AAAC0jB,6BAAetqB,YACA,CAAGwV,aAAO5O,KACVy8B,wBAC5Bvb;;AApBV,AAqBY,OAACpX,mHACCmX,UACA0W,wBACA,iBAAAqF,WAAU7sB;IAAV8sB,WAAmB,OAAA,NAAKj9B;IAAxBk9B,WAA6BtF;AAA7B,AAAA,8HAAAoF,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAAC/rB,4DAAAA,wFAAAA;KACDonB,oBACA,AAAC9Q,+BAAiB7rB,OACA,EAAI,qDAAA,rDAACrB,6CAAE4d,cAAO/e,YAAQ+W,UACtBwhB,iBACA,CAAG/iB,aAAO5O,KACVw4B,YAClB,AAAC3uB,yBAAWzQ,YACA,CAAGwV,aAAO5O,KACV,AAAC0jB,6BAAetqB,YACA,CAAGwV,aAAO5O,KACVy8B,wBAC5Bvb;;;;AAhapB,oBAiaE,iBAAAlkB,mBAAI,2DAAA,3DAACzC,6CAAEqI;AAAP,AAAA,GAAA5F;AAAAA;;AAAuB,OAAA,sFAAQ,CAACpB,uCAAAA,oDAAAA,fAAOxC,iCAAAA;;;AACrC,IAAM6rB,cAAQ,CAAGrW,aAAO5O;IAClB2mB,aAAW,AAAChB,0BAAYvsB,YAAQ6rB,YAAQrC;IACxCjpB,QAAE,kBAAA,AAAA,iGAAA,AAAA,AAAAwC,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,0DAAA,rYAAQnD,sNAAAA,wJAA2CutB;IACrDwW,mBAAW,AAAA,8FAAa,CAACvhC,uCAAAA,oDAAAA,fAAOxC,iCAAAA;AAHtC,AAKE,oBAAI,iBAAAoH,oBAAK,AAACiD,cAAI05B;AAAV,AAAA,GAAA38B;AAAsB,QAAC48B,+DAAAA,iGAAAA,pCAAWhkC,8EAAAA,lEAAQ6rB,8EAAAA,lEAAQ3qB,8EAAAA;;AAAlDkG;;;AACF,OAACsJ,mHAAcmX,UACA,AAACzpB,8CAAMkN,4BACL,iBAAA24B,WAAcjkC;IAAdkkC,WACcrY;IADdsY,WAEc5W;IAFd6W,WAAA;IAAAC,WAIc,AAAA,4FAAW,CAAC7hC,uCAAAA,oDAAAA,fAAOxC,iCAAAA;AAJjC,AAAA,4HAAAikC,SAAAC,SAAAC,SAAAC,SAAAC,kDAAAJ,SAAAC,SAAAC,SAAAC,SAAAC,9OAACrW,2DAAAA,yGAAAA;MAKHlG;;AAOf,OAACpX,mHAAcmX,UACA;AAAI,oBAAA,AAAA,mFAAQ7nB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,rHAAQnD,uJAEAutB;;AAFR;;AAGA,IAAA+W,WAAW9hC;IAAX+hC,WACWvkC;IADXwkC,WAEW,CAAG59B,MAAI4xB;IAFlBiM,WAGW5Y;IAHX6Y,WAIWnX;AAJX,AAAA,sHAAA+W,SAAAC,SAAAC,SAAAC,SAAAC,+CAAAJ,SAAAC,SAAAC,SAAAC,SAAAC,rOAACC,wDAAAA,sGAAAA;;CAKL7c;;;AA/bvB,oBAmcE,iBAAAlkB,mBAAI,2DAAA,3DAACzC,6CAAEqI;AAAP,AAAA,GAAA5F;AAAAA;;AAAuB,OAAA,sFAAQ,CAACpB,uCAAAA,oDAAAA,fAAOxC,iCAAAA;;;AACrC,IAAM6rB,cAAQ,CAAGrW,aAAO5O;IAClB2mB,aAAW,AAAChB,0BAAYvsB,YAAQ6rB,YAAQrC;IACxCjpB,QAAE,kBAAA,AAAA,iGAAA,AAAA,AAAAwC,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,0DAAA,rYAAQnD,sNAAAA,wJAEAutB;AAJhB,AAKE,oBAAI,AAAC9iB,kCAAc8iB;AAAnB;;AAEE,oBAAI,AAAA,qGAAgB,CAAC/qB,uCAAAA,oDAAAA,fAAOxC,iCAAAA;AAO1B,IAAMqtB,WAAS,iBAAAzpB,mBAAI,AAAA,4FAAW,CAACpB,uCAAAA,oDAAAA,fAAOxC,iCAAAA;AAAvB,AAAA,oBAAA4D;AAAAA;;AAAA;;;IACTypB,eAAS,qCAAA,nCAAI,AAACzgB,wBAAQygB,eAAYA;IAClCuX,kBAAgB,AAAC/K,kCAAoB75B,YACA6rB,YACAwB,aACAE;IACrChtB,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,uDAAA,wEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,gDAAA,mCAAA,iBAAA,qPAAA,7jBAAO/C,uNAAAA,iCAEoB,AAACwD,gBAAM+pB,+BACRqX,0BACTpiC,6BACY,AAAA,4FAAW,CAACA,uCAAAA,oDAAAA,fACCxC,iCAAAA;AAZlD,AAaE,OAAC0Q,mHAAcmX,UACA,AAACzpB,8CAAMkN,4BACL,wJAAA,gKAAA,vTAAC0iB,2DAAAA,mLAAAA,1HAAahuB,gKAAAA,pJACA6rB,gKAAAA,pJACA0B,gKAAAA,jFAEAqX,gKAAAA,mBAChB9c;;AAIjB,OAACpX,mHAAcmX,UACA,AAACzpB,8CAAMkN,4BACL,iBAAAu5B,WAAc7kC;IAAd8kC,WACcjZ;IADdkZ,WAEcxX;IAFdyX,WAAA;IAAAC,WAIc,AAAA,4FAAW,CAACziC,uCAAAA,oDAAAA,fAAOxC,iCAAAA;AAJjC,AAAA,4HAAA6kC,SAAAC,SAAAC,SAAAC,SAAAC,kDAAAJ,SAAAC,SAAAC,SAAAC,SAAAC,9OAACjX,2DAAAA,yGAAAA;MAKHlG;;;;AAjfzB,AA6fQ,OAACpX,mHACCmX,UACA0W,wBAGA,EAAI,GAAK,aAAA,ZAAOxf,oBACd,iBAAAmmB,WAAUnuB;IAAVouB,WAAmB,CAAG3M,gBAAU5xB;IAAhCw+B,WAAqC5G;AAArC,AAAA,8HAAA0G,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAACrtB,4DAAAA,wFAAAA;KADH,uDAIA,EAAI,GAAK,aAAA,ZAAOgH,oBACd,iBAAMuhB,uBAAqB,AAACtM,iCAAmB0K;AAA/C,AACE,oBAAI4B;AAEF,oBAAI/H;AAIF,IAAMn1B,SAAO,AAAC6tB,mEACCzuB,OACA,AAACi3B,qBAAOz5B,YAAQwJ,eAChB,EAAI,2DAAA,3DAACrI,6CAAEqI,oEAIL,CAAGgM,aAAO5O,KACV2xB,kBAIF,CAAG/iB,aAAO5O,KAIV05B,qBAEA92B;AAlBf,AAmBE,oBAAA,AAAA,mFAAQxJ;AAAR,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,sCAAA,3JAAQnD,iJAC4B8nB,oBAClB1kB;;AAFlB;;AAGAA;;AAKF,IAAM28B,eAAa,CAAA,CAAGF,iBAAej5B,OAAIg5B;AAAzC,AACE,OAAClvB,mHAEC,sJAAA,6DAAA,nNAACud,6DAAiBzrB,OACA,AAACi3B,qBAAOz5B,YAAQwJ,eAChBu2B,aAGAO;;;AAzC1B;;KAFJ,uDAiDAxY;;;;;;;;;;;;;;;;;;;;;AAEhB;;;6BAAA,7BAAMud,kEAEHrlC,QAAQ4G,IAAI1F;AAFf,AAGE,oBAAA,AAAA,mFAAQlB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD;;AAAR;;AACA,wCAAA,oDAAA,IAAA,zFAACy9B,6FAA4B,AAACxrB,wBAAUjS,SAAS4G,IAAI1F;;AAEvD;;;gCAAA,hCAAMokC,wEAEHtlC,QAAQ4G,IAAI1F;AAFf,AAGE,oBAAA,AAAA,mFAAQlB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD;;AAAR;;AACA,wCAAA,oDAAA,KAAA,1FAACy9B,8FAA6B,AAACxrB,wBAAUjS,SAAS4G,IAAI1F;;AAExD;;;iCAAA,jCAAM8iC,0EAEHhkC,QAAQ4G,IAAI1F;AAFf,AAGE,IAAMqkC,kBAAU,CAAClU,iDAAAA,gFAAAA,jCAAKxL,6DAAAA,pCAAO3kB,6DAAAA;AAA7B,AAAoC,sDAAA,WAAAskC,iBAAAC,3EAACpmC;AAAD,AAAS,IAAAuE,mBAAA4hC;AAAA,AAAA,oBAAA5hC;AAAAA;;AAAA6hC;;GAAT,KAAwBF;;AAM9D;;;;;;0BAAA,yCAAAG,nEAAMf,4DAQHniC,gBAGcqzB,QAAQjvB,IAAI2mB;AAX7B,AAAA,IAAAoY,aAAAD;IAAAC,iBAAA,AAAAt/B,4BAAAs/B;cAAAA,VAWQ3lC;IAXR4lC,aAAA,AAAAt/B,4CAAAq/B,eAU0DnjC;IAV1DojC,iBAAA,AAAAv/B,4BAAAu/B;8BAAA,AAAAt/B,4CAAAs/B,eAAA,rFAUYhP;wBAVZ,AAAAtwB,4CAAAs/B,eAAA,/EAU8Brc;oBAV9B,AAAAjjB,4CAAAs/B,eAAA,3EAU0CC;YAV1C,AAAAv/B,4CAAAq/B,eAAA,nEASW/8B;eATX,AAAAtC,4CAAAq/B,eAAA,tEASiB98B;AATjB,AAaE,IAAM8iB,aAAW,+BAAA,9BAAK,AAACnoB,gBAAM+pB;IACvB1kB,eAAS,AAACyB,2BAAazB;AAD7B,AAEE,IAAO+sB,UAAQrI;IACRsI,cAAQA;YADf,RAEOtpB;8BAFP,1BAGOu5B;UAHP,NAKOnhC;;AALP,AAME,GAAA,AAAA0F,cAAQurB;AACN,AAAI,oBAAA,AAAA,mFAAQ51B;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD,mIAA0B2E;;AAAlC;;AAAuDA;;AAC3D,IAAMwxB,WAAS,AAACn3B,gBAAM42B;AAAtB,AACE,oBAAMO;AAAN,AACE,IAAMgB,eAAO,6CAAA,5CAAG,AAAC3zB,gBAAM,AAACxE,gBAAM42B;IACxBG,WAAS,AAAC/2B,gBAAM42B;IAChBr1B,IAAE,gCAAA,hCAACgG,wBAAUvG,qBAAqB4G,IAAImvB;IACtCx1B,QAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,sBAAA,iCAAA,1XAAQnD,kNAAAA,mIAA0B4G,gBAAgBmvB;IAH1DgQ,aAIgC,AAACp1B,0BAAY3Q,QAAQ4G,IAAImvB;cAJzD,AAAA11B,4CAAA0lC,WAAA,IAAA,rEAIO1P;gBAJP,AAAAh2B,4CAAA0lC,WAAA,IAAA,vEAIel0B;YAJf,AAAAxR,4CAAA0lC,WAAA,IAAA,nEAIyB/zB;IACnBskB,aAAW,AAACnsB,eAAK6H;IACjB+M,MAAI,CAAGuX,aAAW1vB;IAClBmY,UAAI,iBAAAsY,kBAAA;IAAAC,kBAAOvY;AAAP,AAAA,SAAAsY,kBAAAC,mBAAAD,kBAAAC;;IAEJ2O,yBAAiB,iCAAA,fAAMJ,eACJ,iBAAAK,WAAe,AAAClnC,gBAAM,AAACA,gBAAM+2B;AAA7B,AAAA,kGAAAmQ,qCAAAA,/HAACL,8CAAAA,wDAAAA;KADH;IAIjBM,WAAS,kBAAM,iBAAA/+B,oBAAK6+B;AAAL,AAAA,oBAAA7+B;AAAsB,OAAChD,iBAAOwxB;;AAA9BxuB;;MAAN,AACE,iBAAAg/B,aACQ,AAACz1B,0BAAY3Q,QAAQ4G,IAAI,AAACxC,iBAAOwxB;kBADzC,AAAAv1B,4CAAA+lC,WAAA,IAAA,zEAAO/P;oBAAP,AAAAh2B,4CAAA+lC,WAAA,IAAA,3EAAev0B;gBAAf,AAAAxR,4CAAA+lC,WAAA,IAAA,vEAAyBp0B;IAEnBskB,iBAAW,AAACnsB,eAAK6H;AAFvB,AAGE,IAAAqlB,kBAAA;IAAAC,kBAAO,CAAGhB,iBAAW1vB;AAArB,AAAA,SAAAywB,kBAAAC,mBAAAD,kBAAAC;KAJJ;IAOT+O,eAAatnB;IApBnBinB,aAqBkB,4BAAA,sIAAA,hJAAIG,6FAGD,CAAA,uBAAA,tBAAGpnB,UAAIonB,iBAAY,SAAA,RAAK55B,wGACxBwS,QAAIxS;cAzBzB,AAAAlM,4CAAA2lC,WAAA,IAAA,rEAqBOjnB;gBArBP,AAAA1e,4CAAA2lC,WAAA,IAAA,vEAqBWz5B;IAKLgrB,iBAAS,wHAAA,xHAACp2B,6CAAE,sEAAA,tEAACd,4CAAI,AAACrB,gBAAM+2B;IACxB1nB,iBACE,qCAAA,nBAAIkb,wBAAgB,wHAAA,xHAACpoB,6CAAE,sEAAA,tEAACd,4CAAI,AAACrB,gBAAM+2B;IACrCuQ,wBAAgB,qCAAA,nBAAI/c,wBAEF,wHAAA,xHAACpoB,6CAAE,sEAAA,tEAACd,4CAAI,AAACrB,gBAAM+2B;IAEjCntB,YAAM,EAAI,AAACzH,6CAAEoL,UAAMof,aAAY,CAAG/iB,QAAMC,cAAUD;IAGlDsR,aAAK,iBAAA9S,oBAAK,GAAKmwB;AAAV,AAAA,GAAAnwB;AAAA,IAAAA,wBACK,EAAI,eAAA,dAAOmF,wBAAO,AAAClC,cAAIgE;AAD5B,AAAA,GAAAjH;AAEK,IAAAxD,mBAAI,eAAA,dAAO2I;AAAX,AAAA,GAAA3I;AAAAA;;AACI,IAAAwD,wBAAK,0EAAA,xEAAI+vB,cAAO,qDAAA,rDAACh2B,6CAAEk1B;AAAnB,AAAA,GAAAjvB;AACK,QAAI,CAAGyuB,cAAQ9W,YAAKnW;;AADzBxB;;;;AAHTA;;;AAAAA;;;IAKL7G,QAAE,0CAAA,mnBAAA,3oBAAM0lC,wBACJ,kBAAA,AAAA,6FAAA,AAAA,AAAAljC,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,yEAAA,6BAAA,qBAAA,mBAAA,yBAAA,8BAAA,xgBAAQnD,kNAAAA,+IAC8B,AAAChB,gBAAM,AAACA,gBACC+2B,2BACvBsQ,yBACJF,kBACH55B,sBACG1D,oBACLqR;IACnB2R,UAAQ,kBAEE,iBAAAjoB,mBAAIyK;AAAJ,AAAA,oBAAAzK;AAAAA;;AAAa0iC;;wBAFf,mGAAA,8CAAA,sBAAA,zLAEgC,aAAA,ZAAK19B,mBACnC,oBAAA,lBAAKuuB,oBAAO,WAAA,VAAGd,oBAAW,AAAChsB,cAAIusB,8BAC7BhuB,YACFsR,YAAK,CAAA,0BAAA,zBAAG2b,cAAQ9W,kBAChBwY,gBAAS3wB,IACH,CAAA,kBAAA,jBAAGA,MAAImY;;AAzD7B,AAkFE,eAAO,AAAC9f,eAAK22B;eACN/J;eACA,aAAA,ZAAKtf;eACLgrB;eAEA,AAAC/qB,+CACC7H,IACA,EAAIuV,YACF,EAAI,GAAK,EAAI4rB,6BAAkB,eAAA,dAAOv5B,wBACpC,mHAAA,mFAAA,mFAAA,IAAA,qDAAA,kEAAA,pZAACmE,yaAA2CqlB,eAC5CA,UACF,kBAAA,mFAAA,nGAAIwB,sLACA,CAAA,iDAWK,AAACprB,sBAEC,iBAAMo6B,gBAAc,AAACvnC,gBAAM,AAACC,eAAK22B;IAC3B8B,sBACE,iCAAA,yLAAA,xMAAM6O,eACJ,6HAAA,7HAACplC,6CAAE,2EAAA,3EAACd,4CAAI,AAACrB,gBAAMunC;AAHzB,AAOE,oBAAI7O;AAAJ;;AAAoB7L;;iBArBjC,qDAAA,yDAAA,qBAyBE,EAAIia,yBACF/P,SACA,AAACtlB,yBAAWzQ,QAAQ4G,IAAImvB;;;;;;;;AAzH3C;;;;;;AA2HV;;;;;4CAAA,5CAAMyQ,gGAIHjZ;AAJH,AAKE,IAAOqI,UAAQrI;8BAAf,1BACOne;8BADP,1BAEO02B;gCAFP,5BAGOW;;AAHP,AAIE,GAAA,AAAAp8B,cAAQurB;AACN6Q;;AACA,IAAMtW,eAAa,sEAAA,tEAAC9vB,4CAAI,AAAC0Y,iBAAO6c;IAC1BvnB,iBAAS,EAAI,0DAAA,1DAAClN,6CAAEgvB,6EACH,0DAAA,1DAAChvB,6CAAEgvB;IAChBoH,iBAAS,0DAAA,1DAACp2B,6CAAEgvB;AAHlB,AAIE,GAAA,GAAQ,EAAIoH,oBAASlpB;AACnBo4B;;AACA,eAAO,AAACxnC,eAAK22B;eACNvnB;eACAkpB;eACA,EAAIlpB,gBACF,EAAIy3B,yBAEF,6BAAA,5BAAKW,iCACLA,2BACF,6BAAA,5BAAKA;;;;;;;;;;;AAExB;;;;;6CAAA,7CAAMC,kGAIHld;AAJH,AAKE,IAAOoM,UAAQpM;8BAAf,1BACOpa;8BADP,1BAEO02B;gCAFP,5BAGOW;;AAHP,AAIE,GAAA,AAAAp8B,cAAQurB;AACN6Q;;AACA,IAAMt4B,MAAI,iBAAAw4B,WAAM,AAAC3nC,gBAAM42B;AAAb,AAAA,wGAAA+Q,wCAAAA,xIAACvlC,iDAAAA,2DAAAA;;IACLiN,iBAAS,iDAAA,jDAAClN,6CAAEgN;IACZopB,iBAAS,iDAAA,jDAACp2B,6CAAEgN;AAFlB,AAGE,GAAA,GAAQ,EAAIopB,oBAASlpB;AACnBo4B;;AACA,eAAO,AAACxnC,eAAK22B;eACNvnB;eACAkpB;eACA,EAAIlpB,gBACF,EAAIy3B,yBAEF,6BAAA,5BAAKW,iCACLA,2BACF,6BAAA,5BAAKA;;;;;;;;;;;AAExB;;;;2CAAA,3CAAMG,8FAGHC;AAHH,AAIE,GAAI,0HAAA,1HAAC1lC,6CAAE,wEAAA,xEAACd,4CAAI,AAACrB,gBAAM6nC;AACjB,IAAAC,aAAY,AAAC9nC,gBAAM6nC;QAAnB,AAAAxmC,4CAAAymC,WAAA,IAAA,/DAAOtnC;QAAP,AAAAa,4CAAAymC,WAAA,IAAA,/DAASC;gBAAT,uFAAA,nGACMC,+FAAWxnC,EAAEunC;AADnB,AAEE,GAAI,+BAAA,9BAAG,AAACvjC,gBAAMqjC;AAAd,0FAA8BG,UAAU,AAAC/nC,eAAK4nC;;AAA9C,0FAA4DG;;;AAC9DH;;;AAEJ;;;;;8BAAA,6CAAAI,uFAAAC,kBAAAC,pLAAMK,oEAMHhlC,gBAGctB,KAAKwmC,sBAAgBC,WAAWC,UAAUC,UACxDC,cAAcv7B,eAGE+7B,kBAEsB3jC;AAfzC,AAAA,IAAAyiC,aAAAH;IAAAG,iBAAA,AAAA/gC,4BAAA+gC;cAAAA,VASQpnC;IATRqnC,aAAA,AAAA/gC,4CAAA8gC,eAQwD5kC;IARxD6kC,iBAAA,AAAAhhC,4BAAAghC;8BAAA,AAAA/gC,4CAAA+gC,eAAA,rFAQYzQ;wBARZ,AAAAtwB,4CAAA+gC,eAAA,/EAQ8BI;wBAR9B,AAAAnhC,4CAAA+gC,eAAA,/EAQ0C9d;YAR1C,AAAAjjB,4CAAA8gC,eAAA,nEAOWx+B;eAPX,AAAAtC,4CAAA8gC,eAAA,tEAOiBv+B;sBAPjB,AAAAvC,4CAAA8gC,eAAA,7EAO0BlyB;IAP1BoyB,aAAAJ;IAAAI,iBAAA,AAAAjhC,4BAAAihC;gBAAAA,ZAaQe;UAbR,AAAA/hC,4CAAAghC,eAAA,jEAYW1gC;cAZX,AAAAN,4CAAAghC,eAAA,rEAWyEzR;aAXzE,AAAAvvB,4CAAAghC,eAAA,pEAYe9xB;kCAZf,AAAAlP,4CAAAghC,eAAA,zFAWWS;mBAXX,AAAAzhC,4CAAAghC,eAAA,1EAWgEz+B;gBAXhE,AAAAvC,4CAAAghC,eAAA,vEAY0Ca;qBAZ1C,AAAA7hC,4CAAAghC,eAAA,5EAYoDc;qBAZpD,AAAA9hC,4CAAAghC,eAAA,5EAWiDW;aAXjD,AAAA3hC,4CAAAghC,eAAA,pEAYsBY;mBAZtB,AAAA5hC,4CAAAghC,eAAA,1EAY6BxH;gBAZ7B,AAAAx5B,4CAAAghC,eAAA,vEAWuCU;IAXvCT,aAAAJ;8BAAA,AAAA9mC,4CAAAknC,WAAA,IAAA,rFAcIzB;qCAdJ,AAAAzlC,4CAAAknC,WAAA,IAAA,5FAcsBgB;kCAdtB,AAAAloC,4CAAAknC,WAAA,IAAA,zFAc+CiB;8BAd/C,AAAAnoC,4CAAAknC,WAAA,IAAA,rFAeIn4B;oBAfJm4B,hBAe0BkB;AAf1B,AAkBE,oBAAA,AAAA3lC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,TAAO/C,gCAAsC,AAACmD,wGAAO,CAACzB,oDAAAA,0DAAAA,RAAQR,uCAAAA;;AAA9D;;AACA,oBAAI,iBAAAkG,oBAAK+gC;AAAL,AAAA,oBAAA/gC;AAAA,SAAe,AAAC1G,uBAAOynC,gBAAW,AAAC99B,cAAInJ;;AAAvCkG;;;AAAJ,0FAGG,yDAAA,zDAACzD,+CAAO0kC,0EAAsBI,cAAc9jC;;AAC7C,IAAMwjC,gBAAU,kBAAI,iBAAA/gC,oBAAK,AAAC1G,uBAAOynC;AAAb,AAAA,GAAA/gC;AAAwBlG;;AAAxBkG;;MAAJ,KAAsC+gC;IAChDW,gBAAQ,yLAAA,zLAAC3nC,6CAAE,CAACC,iDAAAA,uDAAAA,RAAKF,oCAAAA;IACjB6nC,wBAAgB,wDAAA,xDAAC5nC,6CAAEwmC;IAEnBqB,kBAAU,6HAAA,3HAAI,wDAAA,xDAAC7nC,6CAAEwmC,gFACH,wDAAA,xDAACxmC,6CAAEwmC,kGACH,wDAAA,xDAACxmC,6CAAEwmC;IACjB3nC,cAAQ,EAAI,wDAAA,xDAACmB,6CAAEwmC,mFACL,sDAAA,tDAAC9kC,8CAAM7C,+DAAe,AAACoE,iBAAOyjC,YAC9B7nC;mBAThB,fAWMipC;IAGAA,mBAAa,yBAAA,mFAAA,mFAAA,KAAA,qDAAA,vPAAIF,kUAAwCE;IAYzDjpC,cAAQ,kBAAI0nC,uBAAgB1nC,YAAQ,AAACkS,4BAAclS;IACnDkpC,YAAU,6BAAA,gEAAA,3EAAMlB,WAAU,AAAC1hC,4CAAIgiC,SAASN;IAExCkB,gBAAU,6BAAA,0DAAA,rEAAMA,WAAU,kBAAIhB,QAAO,CAAGgB,YAAUhB,QAAQgB;IAE1DC,iBAAe,AAACx4B,0BAAY3Q,YAAY,CAAGwV,SAAO5O,KAAMqiC;IAExDG,eAAa,iCAAA,fAAMF,eAAU,iBAAA7R,kBAAA;IAAAC,kBAAO,CAAG4R,gBAAUrT;AAApB,AAAA,SAAAwB,kBAAAC,mBAAAD,kBAAAC;KAAhB;IAYb+R,uBAAe,iCAAA,fAAMlB,eAAU,AAAChnC,6CAAE,iBAAAmoC,WAAM,AAACtqC,gBAAMmpC;AAAb,AAAA,wGAAAmB,wCAAAA,xIAACloC,iDAAAA,2DAAAA;iEAApB,5DAAgB;IAC/BmoC,gBACE,kBAAI,iBAAA3lC,mBAAIkiC;AAAJ,AAAA,oBAAAliC;AAAAA;;AAAA,IAAAA,uBAAsB,mBAAA,lBAAOkkC;AAA7B,AAAA,GAAAlkC;AAAAA;;AAA4CylC;;;MAAhD,IAAA;IACFG,oBAAkB,iBAAA5lC,mBAAIwlC;AAAJ,AAAA,oBAAAxlC;AAAAA;;AAAA,IAAAA,uBAAiBskC;AAAjB,AAAA,oBAAAtkC;AAAAA;;AAAA;;;;IAClB6lC,iBAAe,iBAAApS,kBAAKmS;IAALlS,kBAAuBiS;AAAvB,AAAA,SAAAlS,kBAAAC,mBAAAD,kBAAAC;;IAIfoS,cACE,kBAAI5D,yBAAkB,CAAG2D,iBAAe5T,SAAS4T;IACnDE,WAAS,CAAGF,iBAAe5T;IAE3B+T,iBACE,iBAAAhmC,mBAAIslC;AAAJ,AAAA,oBAAAtlC;AAAAA;;AACI,QAAG,EAAI,mBAAA,lBAAOkkC,wBAAehI,aAAa,CAAGtqB,SAAO5O,QACjD,iBAAAhD,uBAAIskC;AAAJ,AAAA,oBAAAtkC;AAAAA;;AAAA;;;;;IACTimC,sBAAoBD;IA7D1BlB,aA+DQ,yTAAA,mFAAA,2BAAA,+ZAAA,mFAAA,KAAA,wGAAA,pgCAAM,EAAI,wDAAA,xDAACvnC,6CAAEwmC,kHACH,wDAAA,xDAACxmC,6CAAEwmC,iMACCQ,wBACR,qIAAA,nIAAI,wDAAA,xDAAChnC,6CAAEwmC,wFACH,wDAAA,xDAACxmC,6CAAEwmC,kGACH,wDAAA,xDAACxmC,6CAAEwmC,qQACEzmC;+BArEvB,AAAAb,4CAAAqoC,WAAA,IAAA,tFA8DOoB;yBA9DP,AAAAzpC,4CAAAqoC,WAAA,IAAA,hFA8D0BqB;IA9D1BpB,aAuEQ,+TAAA,mFAAA,2BAAA,yaAAA,mFAAA,KAAA,wGAAA,phCAAM,EAAI,wDAAA,xDAACxnC,6CAAEwmC,qHACH,wDAAA,xDAACxmC,6CAAEwmC,oMACCQ,wBACR,uIAAA,rIAAI,wDAAA,xDAAChnC,6CAAEwmC,0FACH,wDAAA,xDAACxmC,6CAAEwmC,qGACH,wDAAA,xDAACxmC,6CAAEwmC,0QACEzmC;uBA7EvB,AAAAb,4CAAAsoC,WAAA,IAAA,9EAsEOqB;iBAtEP,AAAA3pC,4CAAAsoC,WAAA,IAAA,xEAsEkBsB;IAtElBrB,aA+EQ,6SAAA,mFAAA,2BAAA,zZAAM,EAAI,wDAAA,xDAACznC,6CAAEwmC,6GACH,wDAAA,xDAACxmC,6CAAEwmC,0LACCQ;0BAjFtB,AAAA9nC,4CAAAuoC,WAAA,IAAA,jFA8EOsB;oBA9EP,AAAA7pC,4CAAAuoC,WAAA,IAAA,3EA8EqBuB;IAIfC,kBAAU,iBAAAhjC,oBAAK,iBAAAxD,mBAAI1C;AAAJ,AAAA,oBAAA0C;AAAAA;;AAAA,IAAAA,uBAASolC;AAAT,AAAA,GAAAplC;AAAAA;;AAAmBukC;;;;AAAxB,AAAA,oBAAA/gC;AAAA,IAAAA,wBACK,iBAAAxD,mBAAI,AAACyG,cAAIy7B;AAAT,AAAA,GAAAliC;AAAAA;;AAA4BsmC;;;AADjC,AAAA,oBAAA9iC;AAAA,IAAAA,wBAEK,kTAAA,hTAAI,EAAI,wDAAA,xDAACjG,6CAAEwmC,kGACH,wDAAA,xDAACxmC,6CAAEwmC,mGACTS;AAJP,AAAA,oBAAAhhC;AAAA,IAAAA,wBAMK,GAAK2hC;AANV,AAAA,GAAA3hC;AAOK,IAAAxD,mBAAIkmC;AAAJ,AAAA,oBAAAlmC;AAAAA;;AAAA,IAAAA,uBACIomC;AADJ,AAAA,oBAAApmC;AAAAA;;AAAA,IAAAA,uBAEIsmC;AAFJ,AAAA,oBAAAtmC;AAAAA;;AAGI,SAAK,CAAGiyB,UAAQjtB,YAAO,CAAG+gC,WAAS/gC;;;;;AAV5CxB;;;AAAAA;;;AAAAA;;;AAAAA;;;IAWVijC,cACE,mCAAA,jBAAMD,iBACJ,wIAAA,mLAAA,0GAAA,uJAAA,kOAAA,kdAAA,9uCACEpB,iBAAU,AAACjf,0DAAc,AAACvf,sBAAQxK,aAAS2pC,SAASxB,iCACpD2B,0BAAmB,iIAAA,jIAAC7Y,mEACCzuB,OACAxC,YAIA2pC,SACAC,eACAG,2CAGrBG,qBAAc,AAACze,+BAAiBzrB,YAAQ2pC,SAASQ,iCACjDH,kBAAW,AAACv5B,yBAAWzQ,YACA,CAAGwV,SAAO5O,KACV,AAAC0jB,6BAAetqB,YAEA2pC,SACAM,eAGvC,wDAAA,xDAAC9oC,6CAAEwmC,+FACD,AAAChuB,kCAAoB,AAACnP,sBAAQxK,aAAS2pC,SAASzoC,QAClD,EAAI,wDAAA,xDAACC,6CAAEwmC,uGACH,wDAAA,xDAACxmC,6CAAEwmC,8FACL,oHAAA,pHAAC5d,0DAAc,AAACvf,sBAAQxK,aAAS2pC,SAASxB,yEACtC,iBAAAmC,WAAU,AAAC9/B,sBAAQxK;IAAnBuqC,WAA4BZ;IAA5Ba,WAAqCtpC;AAArC,AAAA,8HAAAopC,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAACzyB,4DAAAA,wFAAAA;;OA5BX;IA+BFsyB,kBAAY,kBAAI,iBAAAjjC,oBAAK,iBAAAxD,mBAAIkmC;AAAJ,AAAA,oBAAAlmC;AAAAA;;AAAuBomC;;;AAA5B,AAAA,oBAAA5iC;AAAA,SACK,2HAAA,3HAACjG,6CAAE,yEAAA,zEAACd,4CAAI,AAACrB,gBAAMqrC,0FACf,2EAAA,3EAAClpC,6CAAE,AAAC4X,iBAAOsxB;;AAFhBjjC;;MAGF,AAACnI,eAAKorC,aACNA;IAEdI,aAAW,AAAC95B,0BAAY3Q,YAAQ2pC,SAASU;IAGzC5C,wBAAY,mSAAA,jSAAI,EAAI,wDAAA,xDAACtmC,6CAAEwmC,uGACH,wDAAA,xDAACxmC,6CAAEwmC,mGAETF;IAGdiD,oBAAY,mCAAA,yCAAA,1DAAML,iBAAY,oCAAA,nCAAG,AAAC7mC,gBAAM6mC;IAExCM,eAAa,8BAAA,4BAAA,xCAAMF,YAAW,AAACzrC,gBAAMyrC;IAGrCG,kBAAU,iBAAAxjC,oBAAK,iBAAAxD,mBAAI1C;AAAJ,AAAA,oBAAA0C;AAAAA;;AAAA,IAAAA,uBAASolC;AAAT,AAAA,GAAAplC;AAAAA;;AAAmBukC;;;;AAAxB,AAAA,oBAAA/gC;AACK,IAAAA,wBAAK,GAAK,AAAC1G,uBAAO2pC;AAAlB,AAAA,GAAAjjC;AACK,oBAAIsjC;AACF,IAAA9mC,mBAAI6jC;AAAJ,AAAA,oBAAA7jC;AAAAA;;AAAgB,wBAAA,hBAAI+mC;;;AADtB;;;AADLvjC;;;AADLA;;;IAOVy/B,aAAW,iBAAAjjC,mBAAIymC;AAAJ,AAAA,oBAAAzmC;AAAAA;;AAAgBqlC;;;IAE3B4B,wBAAgB,0HAAA,1HAAC1pC,6CAAE,wEAAA,xEAACd,4CAAI,AAACrB,gBAAM6nC;IAC/BiE,kBAAU,iBAAAlnC,mBAAImlC;AAAJ,AAAA,GAAAnlC;AAAAA;;AAAA,IAAAA,uBACIinC;AADJ,AAAA,GAAAjnC;AAAAA;;AAAA,IAAAA,uBAEI,0HAAA,1HAACzC,6CAAE,wEAAA,xEAACd,4CAAI,AAACrB,gBAAM6nC;AAFnB,AAAA,GAAAjjC;AAAAA;;AAAA,IAAAA,uBAGI,0HAAA,1HAACzC,6CAAE,wEAAA,xEAACd,4CAAI,AAACrB,gBAAM6nC;AAHnB,AAAA,GAAAjjC;AAAAA;;AAAA,IAAAA,uBAII,EAAK,GAAK,mBAAA,lBAAOkkC,8BACZ,0HAAA,1HAAC3mC,6CAAE,wEAAA,xEAACd,4CAAI,AAACrB,gBAAM6nC;AALxB,AAAA,GAAAjjC;AAAAA;;AAOI,IAAAwD,oBAAKgjC;AAAL,AAAA,oBAAAhjC;AAAe,OAACiD,cAAIugC;;AAApBxjC;;;;;;;;IAYd8gC,aAAO,0BAAA,RAAMA,QAAO,kBAAI,iBAAA9gC,oBAAKgjC;AAAL,AAAA,oBAAAhjC;AAAe,OAACiD,cAAIugC;;AAApBxjC;;mBAAjB,bAAa,KAAwC8gC;IAG5DgB,gBAAU,iCAAA,fAAMA,eACJ,kBAAI,iBAAA9hC,oBAAKgjC;AAAL,AAAA,oBAAAhjC;AAAe,OAACiD,cAAIugC;;AAApBxjC;;0BADN,pBACE,KAAwC8hC;IAIpD6B,WAAS,iBAAAnnC,mBAAIslC;AAAJ,AAAA,oBAAAtlC;AAAAA;;AACI,QAAG,EAAI,mBAAA,lBAAOkkC,wBAAehI,aAAa,CAAGtqB,SAAO5O,QACjD,iBAAAhD,uBAAIskC;AAAJ,AAAA,oBAAAtkC;AAAAA;;AAAA;;;;;IAMhBgmC,qBAAemB;IACfC,kBAAU,iBAAA5jC,oBAAK,AAACiD,cAAI+/B;AAAV,AAAA,GAAAhjC;AAAA,IAAAA,wBACK,iBAAAxD,mBAAIslC;AAAJ,AAAA,oBAAAtlC;AAAAA;;AAAcskC;;;AADnB,AAAA,oBAAA9gC;AAEK,OAACiD,cAAI,AAAA,4FAAWrK;;AAFrBoH;;;AAAAA;;;IAIV6jC,kBAAU,iBAAA7jC,oBAAK,iBAAAxD,mBAAI1C;AAAJ,AAAA,oBAAA0C;AAAAA;;AAAA,IAAAA,uBAASolC;AAAT,AAAA,GAAAplC;AAAAA;;AAAmBukC;;;;AAAxB,AAAA,oBAAA/gC;AAAA,SACK,AAACiD,cAAIugC,sBACL,GAAKC;;AAFVzjC;;;IAMV8jC,cAAY,kBAAM,iBAAA9jC,oBAAK4jC;AAAL,AAAA,oBAAA5jC;AAAe6jC;;AAAf7jC;;MAAN,AACE,EAAI4hC,iBACF,AAACjf,0DAAc,AAACvf,sBAAQxK,aAAS+qC,SAAS5C,eAC1C,iBAAAgD,WAAU,AAAC3gC,sBAAQxK;IAAnBorC,WAA4BL;IAA5BM,WAAqCnqC;AAArC,AAAA,8HAAAiqC,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAACtzB,4DAAAA,wFAAAA;MAHL;IAIZuzB,oBAAkBJ;IAGlBH,eAAS,kBAAI,iBAAA3jC,oBAAK6jC;AAAL,AAAA,oBAAA7jC;AAAA,IAAAA,wBAAe4jC;AAAf,AAAA,oBAAA5jC;AAAyB,OAAC1G,uBAAOwqC;;AAAjC9jC;;;AAAAA;;MACF,EAAI,mBAAA,lBAAO0gC,wBAAehI,aAAa,CAAGtqB,SAAO5O,MACjDmkC;IAKXG,kBAAY,kBAAI,iBAAA9jC,oBAAK6jC;AAAL,AAAA,oBAAA7jC;AAAe,OAAC1G,uBAAOwqC;;AAAvB9jC;;MACF,qHAAA,qLAAA,2KAAA,2JAAA,+MAAA,+bAAA,5vCACE4hC,iBAAU,AAACjf,0DAAc/pB,YAAQ+qC,aAAS5C,iCAI1C2B,0BAAmB,mIAAA,nIAAC7Y,mEACCzuB,OACAxC,YAIA+qC,aACAA,aACAhB,2CAGrBG,qBAAc,8HAAA,9HAACjZ,mEACCzuB,OACAxC,YAGA+qC,aACAA,aACAZ,sCAGhBH,kBAAW,AAACv5B,yBAAWzQ,YACA,CAAGwV,SAAO5O,KACV,AAAC0jB,6BAAetqB,YAGA+qC,aACAd,eACvC,wDAAA,xDAAC9oC,6CAAEwmC,+FACD,AAAChuB,kCAAoB3Z,YAAQ+qC,aAAS7pC,QACxC,EAAI,wDAAA,xDAACC,6CAAEwmC,uGACH,wDAAA,xDAACxmC,6CAAEwmC,8FACL,iGAAA,jGAAC5d,0DAAc/pB,YAAQ+qC,aAAS5C,yEAC5B,CAACpwB,4DAAAA,2FAAAA,jCAAS/X,wEAAAA,5DAAQ+qC,wEAAAA,3DAAS7pC,wEAAAA;OACnCgqC;IAKdA,kBAAY,kBAAI,iBAAA9jC,oBAAK,iBAAAxD,mBAAIkmC;AAAJ,AAAA,oBAAAlmC;AAAAA;;AAAA,IAAAA,uBACIomC;AADJ,AAAA,oBAAApmC;AAAAA;;AAAA,IAAAA,uBAEIsmC;AAFJ,AAAA,oBAAAtmC;AAAAA;;AAAA,SAGI,wDAAA,xDAACzC,6CAAEwmC,gGACH,wDAAA,xDAACxmC,6CAAEwmC;;;;;AAJZ,AAAA,oBAAAvgC;AAAA,SAKK,+HAAA,/HAACjG,6CAAE,6EAAA,7EAACd,4CAAI,AAACrB,gBAAMksC,qFACf,oEAAA,pEAAClgB,kCAA4B,AAACjS,iBAAOmyB;;AAN1C9jC;;MAQF,AAACnI,eAAKisC,iBACNA;IACd7e,aAAW,AAAC1b,0BAAY3Q,YAAQ+qC,aAASG;IAazCrE,iBAAW,iBAAAjjC,mBAAIsnC;AAAJ,AAAA,oBAAAtnC;AAAAA;;AAAgBijC;;;IAG3BiE,sBAAU,iBAAAlnC,mBAAIknC;AAAJ,AAAA,oBAAAlnC;AAAAA;;AAAcsnC;;;IACxB78B,iBAAS,8HAAA,9HAAClN,6CAAE,4EAAA,5EAACd,4CAAI,AAACrB,gBAAM6nC;IACxBP,wBAAgB,8HAAA,9HAACnlC,6CAAE,4EAAA,5EAACd,4CAAI,AAACrB,gBAAM6nC;IAC/BtP,iBAAS,EAAI,EAAK,8HAAA,9HAACp2B,6CAAE,4EAAA,5EAACd,4CAAI,AAACrB,gBAAM6nC,sFACf,6EAAA,7EAAC1lC,6CAAE,AAACqC,gBAAMqjC,4BACfkC;IAIbwC,gBAAQ,EAAI,8HAAA,9HAACpqC,6CAAE,4EAAA,5EAACd,4CAAI,AAACrB,gBAAM6nC,oFACf,8HAAA,9HAAC1lC,6CAAE,4EAAA,5EAACd,4CAAI,AAACrB,gBAAM6nC;IAI3B1P,eAAO,kCAAA,wCAAA,xDAAM0P,gBAAW,mCAAA,lCAAG,AAACrjC,gBAAMqjC;IA5SxCgC,aAsTgC,kCAAA,hBAAMhC,gBACJ,iBAAAjjC,mBAAIyoB;AAAJ,AAAA,oBAAAzoB;AAAAA;;AAAA,IAAAA,uBAAe6mC;AAAf,AAAA,oBAAA7mC;AAAAA;;AAA0BulC;;;KAD5B;cAtThC,AAAA9oC,4CAAAwoC,WAAA,IAAA,rEAsTOxS;gBAtTP,AAAAh2B,4CAAAwoC,WAAA,IAAA,vEAsTeh3B;YAtTf,AAAAxR,4CAAAwoC,WAAA,IAAA,nEAsTyB72B;IAEnBskB,aAAW,AAACnsB,eAAK6H;IAYjBkI,aAAK,AAAC7P,cAAIygC;IAGVjf,UACE,+DAAA,7DAGE,EAAIxd,oBAASi4B,yBAAiB,SAAA,RAAK19B,+BAGnC,iBAAAxB,oBAAK0hC;AAAL,AAAA,GAAA1hC;AAAa0+B;;AAAb1+B;;oBANF,dAMkC,SAAA,RAAKwB,+BAIrC,iBAAAxB,oBAAK+vB;AAAL,AAAA,oBAAA/vB;AAAA,SAAY,WAAA,VAAGivB,oBAAW,AAAChsB,cAAIusB;;AAA/BxvB;;oBAVF,dAUqD,SAAA,RAAKwB,+BAIxD,iBAAAxB,oBAAK+vB;AAAL,AAAA,oBAAA/vB;AAAY,kBAAA,VAAGivB;;AAAfjvB;;iBAdF,yBAAA,0EAAA,9GAc6BkvB,aAE3Bpc,YAAKoc,aAiBLiB,gBAAS,EAAI,mBAAA,lBAAOuQ,wBAAehI,aAAa,CAAGtqB,SAAO5O,MACpD0vB;;IACV+R,gBAAU,yDAAA,zDAAC1kC,+CAAO0kC;IAClBA,gBAAU,mEAAA,qHAAA,xLAACxlC,qDAAMwlC,yEACIxc,uHACC,iBAAAzkB,oBAAK8S;AAAL,AAAA,GAAA9S;AAAUghC;;AAAVhhC;;;AA9W5B,AAmXE,oBAAA,AAAAtE,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,bAAO/C,mDAGA,AAACwrC,2DAAU,iBAAAC,WAAA;IAAAC,WAEE,6CAAA,7CAAC7+B,8EACK,iBAAM++B,UAAQ,AAACpoC,gBAAMmB;IACfknC,WAAS,mBAAA,lBAAK,CAAA,MAAOD;IACrBC,eAAS,EAAI,wBAAA,vBAAG,CAAGD,UAAQC,mBAChB,WAAA,VAAGD,gBACHC;AAJjB,AAKE,oCAAA,7BAACvmC,iCAAiBX;;IAR5BgnC,eAAC,AAAA,yFAAU3rC;AAAX,AAAA,QAAA2rC,6CAAAA,2CAAAF,SAAAC,YAAAC,wBAAAF,SAAAC;uDAAX;;AAHP;;AAaA,oBAAA,AAAA5oC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAU9C;AAAV,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,rHAAUnD,yJAAmD2nC;;AAA7D;;AACA,oBAAA,AAAA7kC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,bAAO/C,iDAGA,AAACwrC,2DAAU,iBAAAM,WAAA;IAAAC,WAAuB,6BAAA,7BAACzmC,iCAAiBuhC;IAAzCmF,eAAC,AAAA,yFAAUhsC;AAAX,AAAA,QAAAgsC,6CAAAA,2CAAAF,SAAAC,YAAAC,wBAAAF,SAAAC;uDAAX;;AAHP;;AAKA,oBAAA,AAAAjpC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAU9C;AAAV,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,rHAAUnD,uJAAiDsoC;;AAA3D;;AAEA,oBAAA,AAAAxlC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFACE9C;AADF,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,iBAAA,mBAAA,iBAAA,4CAAA,kDAAA,wCAAA,yBAAA,iCAAA,0CAAA,8BAAA,8BAAA,0BAAA,4BAAA,0CAAA,0CAAA,6DAAA,8CAAA,sDAAA,8CAAA,yBAAA,6BAAA,+BAAA,uBAAA,UAAA,GAAA,4BAAA,wBAAA,8CAAA,8BAAA,mCAAA,gCAAA,+BAAA,+BAAA,mCAAA,iDAAA,iCAAA,uCAAA,kCAAA,0CAAA,oCAAA,UAAA,GAAA,4BAAA,+BAAA,+BAAA,wCAAA,4BAAA,oCAAA,wBAAA,sCAAA,iBAAA,qBAAA,yBAAA,2BAAA,aAAA,mBAAA,qBAAA,qBAAA,iBAAA,oBAAA,4BAAA,zzDACE/C,0CAEYwC,kBACD+J,gBACD,GAAK,AAAC7L,uBAAOQ,2BACJ,AAACsC,gBAAM2kC,kCACPkB,oCACJzB,6BACIE,kCACCJ,oCACNxyB,8BACA8zB,4BACFuC,2BACChU,mCACOwR,0CACA8B,uDACa9C,kDACXjC,kDACI0C,kDACJp5B,uCACP44B,yBACAkB,gCACGE,yBACNlB,yCAEKuC,0BACFd,mCACWE,sCACRH,6BACDgB,qCACEC,4BACJP,+BACAQ,+BACAE,4CACShB,yCACRE,oCACGE,wCACCX,sCACIC,uCACHC,6CAEJpd,0BACF2e,+BACAC,qCACMrB,kCACNmB,kCACM,CAAGv1B,SAAO5O,gBACpBuwB,6BACKsQ,iCACLz1B,mBACEqkB,uBACExkB,0BACCykB,oBACP1vB,gBACG4O,oBACCqgB,qBACAhK,mBACFjjB,eACFsR,wBACIkuB,6BACC0C;;AA7DhB;;AAxYF,wGAAA,dA2cGzC,iGAKC9Q,eAEAwR,sBAEA,kCAAA,hCAAK,GAAKA,+BACL,AAAC1+B,cAAI,iBAAAjD,wBAAKgI;AAAL,AAAA,oBAAAhI;AAAuBmwB;;AAAvBnwB;;WACL,EAAK,GAAK8S,kBAAUqd,qBAEzB,EAAIlpB,oBAASi4B,gCAId,iBAAM2F,oBACE,EAAI/xB,YAEF,EAAI,GAAK,WAAA,VAAO3N,kBACd,mHAAA,mFAAA,sHAAA,qDAAA,kEAAA,nbAACmE,yRAAgB,AAACvE,sBAAOu9B,yJACV7C,qBAEfA,gBACF,EAAItP,gBACF,AAAC7mB,mHAMC,kBAAI,iBAAAtJ,oBAAK2gC;AAAL,AAAA,oBAAA3gC;AACK,8CAAA,tCAAM,+BAAA,9BAAK2gC;;AADhB3gC;;+SANN,mFAAA,wFAAA,qDAAA,yDAAA,hVAME,lPAEE,mFAAA,mFAAA,KAAA,yDAAA,pOAAC9I,+CAAO,+BAAA,9BAAKypC,+ZAGb,8IAQJ,kBAAI,iBAAA3gC,oBAAK0+B;AAAL,AAAA,oBAAA1+B;AACK,OAACiD,cAAI,iBAAAjD,wBAAKiH;AAAL,AAAA,GAAAjH;AAAcmhC;;AAAdnhC;;;;AADVA;;MAGF;AAAI,oBAAA,AAAAtE,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,bAAO/C;;AAAP;;AAMA,0HAAA,mFAAA,uHAAA,qDAAA,kEAAA,pbAAC0Q,yRAAgB,AAACvE,sBAAO4+B,0JAEV,AAACnE,yCAAwBC;;CAG5C,EAAI,EAAI0E,mBAAQ,mBAAA,lBAAOzD,0BAErBjB,eACA;AAAI,oBAAA,AAAA/jC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,bAAO/C;;AAAP;;AACA,OAACyQ,yBACCzQ,YAUA+qC,aACAlE;;;AA1DtB,AA2DE,oBAAA,AAAA/jC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,+FAAO/C,aAEA,+SAAA,/SAACwrC,2DAAU,CAAA,yCACK,+BAAA,yGAAA,tIAAM,sBAAA,rBAAMS,4BACV,CAAA,+BACK,mCAAA,AAAA,sBAAA,vCAAM/2B,mMAE7B,iBAAAg3B,WAAA,2CAAA,0DAAA;IAAAC,WAAmCF;IAAnCG,eAAC,AAAA,yFAAUpsC;AAAX,AAAA,QAAAosC,6CAAAA,2CAAAF,SAAAC,YAAAC,wBAAAF,SAAAC;;;AAPP;;AAUA,oBAAMF;AAAN,AAAwB,OAACz/B,+CAAO7H,IAAIsnC;;AAApC;;;;;AAET;;;0CAAA,1CAAMI,4FAIHtnC;AAJH,AAKE,IAAMorB,eAAa,qEAAA,rEAAC9vB,4CAAI,AAACrB,gBAAM+F;AAA/B,AACE,mIAAA,1HAAI,0DAAA,1DAAC5D,6CAAEgvB,+EACH,0DAAA,1DAAChvB,6CAAEgvB,2FACH,0DAAA,1DAAChvB,6CAAEgvB;;AAEX;;;2BAAA,3BAAMmc,8DAEHjE,UAAUC;AAFb,AAGE,IAAAjR,kBAAK,iBAAAzzB,mBAAI,2HAAA,zGAAM,AAAA,6FAAYykC,YAChB,iBAAAhR,kBAAA;IAAAC,kBACK,CAAG,CAAG,AAAChxB,4CAAIgiC,SAAS,AAAA,6FAAYD,cAC1B,iBAAAzkC,mBAAI,AAAA,sFAASykC;AAAb,AAAA,oBAAAzkC;AAAAA;;AAAA;;QACH,AAAA,gFAAMykC;AAHd,AAAA,SAAAhR,kBAAAC,mBAAAD,kBAAAC;KADF;AAAJ,AAAA,oBAAA1zB;AAAAA;;AAAA;;;IAAL0zB,kBAMK,CAAG,CAAG,AAAA,yFAAU+Q,aAAW,iBAAAzkC,mBAAI,AAAA,sFAASykC;AAAb,AAAA,oBAAAzkC;AAAAA;;AAAA;;QACxB,AAAA,gFAAMykC;AAPd,AAAA,SAAAhR,kBAAAC,mBAAAD,kBAAAC;;AAUF;;;;8BAAA,6CAAAiV,3EAAMvM,oEAGHx9B,gBAGcoE,IAAIivB,QAAQkK,aAAab,MAAM1V;AANhD,AAAA,IAAAgjB,aAAAD;IAAAC,iBAAA,AAAAnmC,4BAAAmmC;cAAAA,VAMQxsC;IANRysC,aAAA,AAAAnmC,4CAAAkmC,eAKmDhqC;IALnDiqC,iBAAA,AAAApmC,4BAAAomC;8BAAA,AAAAnmC,4CAAAmmC,eAAA,rFAKY7V;wBALZ,AAAAtwB,4CAAAmmC,eAAA,/EAK8BljB;aAL9B,AAAAjjB,4CAAAmmC,eAAA,pEAK0Cj3B;YAL1C,AAAAlP,4CAAAkmC,eAAA,nEAIW5jC;eAJX,AAAAtC,4CAAAkmC,eAAA,tEAIiB3jC;sBAJjB,AAAAvC,4CAAAkmC,eAAA,7EAI0Bt3B;AAJ1B,AAOE,oBAAA,AAAApS,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,+FAAO/C,SACO,AAACwrC,2DAAU,CAAA,qEACK,iBAAAkB,WAAS,AAAC1tC,gBAAMwqB;AAAhB,AAAA,8GAAAkjB,2CAAAA,jJAAChrC,oDAAAA,8DAAAA;iIAF/B,iBAAA,WAAA,mBAAA,6BAAA,3IACc,yEAGGc,cACHoE,eACIivB,wBACKkK,sBACP,AAACyL,2DAAU,iBAAAmB,WAAA,2CAAA,uDAAA;IAAAC,WAAyC1N;IAAzC2N,eAAC,AAAA,yFAAU7sC;AAAX,AAAA,QAAA6sC,6CAAAA,2CAAAF,SAAAC,YAAAC,wBAAAF,SAAAC;uDAAX;;AARhB;;AAYA,oBAAI,iBAAAxlC,oBAAK8N;AAAL,AAAA,oBAAA9N;AAAe,sBAAA,iFAAA,hGAACtE,+KAAiBo8B;;AAAjC93B;;;AAEF,AAAI,oBAAA,AAAAtE,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,4DAAA,rEAAO/C;;AAAP;;AAAJ;;AAKA,IAAM6I,eAAS,AAACyB,2BAAazB;IACvBo/B,iBAAe,6BAAA,5BAAK,AAACzkC,gBAAMgmB;AADjC,AAEE,oBAAU0V;AAAV;AAAA,AACE,MAAO,KAAAn/B,MAEC,CAAA,kGACK,AAACoR,6CAAKzP,oBAAQ8nB;;;AAC7B,IAAOyjB,WAASzjB;gBAAhB,ZACOoe;IACAC,YAAU3I;oBAFjB,hBAGO4I;YAHP,RAIOv7B;gBAJP,2CAAA,mEAAA,sDAAA,8EAAA,sEAAA,yFAAA,yEAAA,oFAAA,6DAAA,vnBAKO87B,kHAAoBxS,0DACJjvB,0EACSivB,iEACNkK,uFACQkI,2EACNp/B,yFACO7I;eAXnC,XAaOsoC;IAbPwE,WAAA;IAAAC,aAAAD;8BAAA,AAAAzsC,4CAAA0sC,WAAA,IAAA,rFAcQjH;qCAdR,AAAAzlC,4CAAA0sC,WAAA,IAAA,5FAc0BxE;kCAd1B,AAAAloC,4CAAA0sC,WAAA,IAAA,zFAcmDvE;8BAdnD,AAAAnoC,4CAAA0sC,WAAA,IAAA,rFAeQ39B;oBAfR29B,hBAe8BtE;IAEvBzoC,cAAQA;UAjBf,NAkBO2E;AAlBP,AAAA,IAAOsoC,eAAAA;IACArF,gBAAAA;IACAC,gBAAAA;IACAC,oBAAAA;IACAv7B,YAAAA;IACA87B,gBAAAA;IAQAC,eAAAA;IAbPwE,eAAAA;IAiBO9sC,cAAAA;IACA2E,UAAAA;;AAlBP,AAAA,IAAOsoC,eAAAA;IACArF,gBAAAA;IACAC,gBAAAA;IACAC,oBAAAA;IACAv7B,YAAAA;IACA87B,gBAAAA;IAQAC,eAAAA;IAbP0E,aAAAF;kCAAA,AAAAzsC,4CAAA2sC,WAAA,IAAA,zFAcQlH;yCAdR,AAAAzlC,4CAAA2sC,WAAA,IAAA,hGAc0BzE;sCAd1B,AAAAloC,4CAAA2sC,WAAA,IAAA,7FAcmDxE;kCAdnD,AAAAnoC,4CAAA2sC,WAAA,IAAA,zFAeQ59B;wBAfR49B,pBAe8BvE;IAEvBzoC,cAAAA;IACA2E,UAAAA;AAlBP,AAuBE,GAAI,EAAI,AAAC0F,cAAI,iBAAAzG,mBAAIikC;AAAJ,AAAA,oBAAAjkC;AAAAA;;AAAA,IAAAA,uBAAcqpC;AAAd,AAAA,oBAAArpC;AAAAA;;AAAuB,OAAA,mHAAuBykC;;;WACnD,YAAA,XAAM1jC;AACZ,AAAI,oBAAA,AAAA7B,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,+FAAO/C,aAEA,2DAAA,wEAAA,nIAACwrC,2MACD,iBAAA0B,WAAA;IAAAC,WAAuB,6CAAA,7CAACtgC,8EAAQ,6BAAA,7BAACvH,iCAAiBX;IAAlDyoC,eAAC,AAAA,yFAAUptC;AAAX,AAAA,QAAAotC,6CAAAA,2CAAAF,SAAAC,YAAAC,wBAAAF,SAAAC;;;AAHP;;AAIAxoC;;AACJ,GAAI,aAAA,ZAAG4H;AACL,MAAO,KAAAxM,MAEC,CAAA,0BAAA,mCAAA,wDAEiB,AAACf,gBAAM6oC;;AAChC,IAAMwF,kBAAgB,AAACruC,gBAAM6oC;IACvBtnC,IAAE,kBAAA,AAAAuC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,+DAAA,nSACE/C,uNAAAA,4DAGEqtC,sDAEA,iBAAAC,WAAA;IAAAC,WAEE,qTAAA,rTAAC1qC,8CAAM,oEAAA,iHAAA,rLAACc,sDAAO0kC,wRACE,AAAC7kC,gBAAM,AAAA,6FAAY6kC;IAHtCmF,eAAC,AAAA,yFAAUxtC;AAAX,AAAA,QAAAwtC,6CAAAA,2CAAAF,SAAAC,YAAAC,wBAAAF,SAAAC;WANJ;IAkBFhtC,QAAE,yCAAA,vCAAM,AAACG,uBAAOmnC,gBACZ,kBAAA,AAAA/kC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,pOAAO/C,uNAAAA,oDAGE,AAACwrC,2DAAU,iBAAAiC,WAAA,2CAAA,yDAAA,2CAAA,wDAAA;IAAAC,WAEExO;IAFFyO,eAAC,AAAA,yFAAU3tC;AAAX,AAAA,QAAA2tC,6CAAAA,2CAAAF,SAAAC,YAAAC,wBAAAF,SAAAC;+HAHpB,xEAGS,wFAIc,iBAAAE,WAAA,2CAAA,yDAAA,2CAAA,wDAAA;IAAAC,WAEE,6CAAA,7CAAChhC,8EACK,AAACjH,4CAAIlE,oBAAQ8nB;IAHrBskB,eAAC,AAAA,yFAAU9tC;AAAX,AAAA,QAAA8tC,6CAAAA,2CAAAF,SAAAC,YAAAC,wBAAAF,SAAAC;iBARzB,NACE;IAcJhG,gBAAU,iBAAAjkC,mBAAIikC;AAAJ,AAAA,oBAAAjkC;AAAAA;;AAAA,0FAAA;;;IAGVyK,iBAAS,AAAClN,6CAAE,iBAAA4sC,WAAM,AAAC/uC,gBAAMiuC;AAAb,AAAA,wGAAAc,wCAAAA,xIAAC3sC,iDAAAA,2DAAAA;KAAJ;IAETklC,wBAAgBj4B;IAChB2/B,sBAAc,AAAC7sC,6CAAE,iBAAA8sC,WAAM,AAACjvC,gBAAMiuC;AAAb,AAAA,wGAAAgB,wCAAAA,xIAAC7sC,iDAAAA,2DAAAA;KAAJ;IACd0nC,gBAAQ,AAAC3nC,6CAAE,iBAAA+sC,WAAM,AAAClvC,gBAAMiuC;AAAb,AAAA,wGAAAiB,wCAAAA,xIAAC9sC,iDAAAA,2DAAAA;KAAJ;AAzCd,AA0CE,oBACE,iBAAAgG,oBAAK,AAAA,6FAAYihC;AAAjB,AAAA,oBAAAjhC;AAA4B,OAAA,6FAAYihC;;AAAxCjhC;;;AAOE,GACE,6DAAA,7DAACjG,6CAAEksC;AAMD,AAAI,oBAAA,AAAAvqC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,+FAAO/C,aAEA,2DAAA,gGAAA,3JAACwrC;;AAFR;;AAKA,eAAOyB;eACArF;eACA,AAAC3oC,eAAK4oC;eACNC;eACA,aAAA,ZAAKv7B;eACL,4DAAA,+DAAA,3HAAC1J,8CAAMwlC;eACPC;eACAG;eACAzoC;eACA2E;;;;;;;;;;;;;AArBf,GAsBE,6DAAA,7DAACxD,6CAAEksC;AACD,IAAAc,aACQ,AAACppB,qBAAW1C,kCAAc4qB;oCADlC,AAAA5sC,4CAAA8tC,WAAA,IAAA,3FAAOC;yBAAP,AAAA/tC,4CAAA8tC,WAAA,IAAA,hFAAqCE;IAE/BlG,YAAU,AAAA,6FAAYE;IAGtBF,gBAAU,6CAAA,7CAACt7B,8EACK,AAACL,+CACC27B,UACAiG;IAClBniB,YAAU,AAACjtB,gBAAMqvC;IAEjBlG,gBAAU,kBAAIlc,WACF,AAAC5mB,6CAAK8iC,cACA,AAACnpC,gBAAMqvC,qBACblG;AAdlB,AAeE,oBAAA,AAAArlC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,+FAAO/C,aAEA,2DAAA,4FAAA,vJAACwrC;;AAFR;;AAKA,eACE,AAACvsC,eAAKovC;eACN,CAAA,mEAAA,lEAAGzG,gBAAU,AAACpkC,gBAAM4qC;eACpB,AAACnvC,eAAK4oC;eACNC;eACA,aAAA,ZAAKv7B;eACL,4DAAA,5DAAC1J,8CAAMwlC,6EAAqBF;eAC5BG;eACAG;eACAzoC;eACA2E;;;;;;;;;;;;;AArDR,AAsDQ,MAAO,KAAA5E,MAEC,CAAA,6CAAA,mCAAA,mFAAA,jBAIEstC;;;;;AApEtB,oBA0EE,iBAAAjmC,oBAAK,6DAAA,7DAACjG,6CAAEksC;AAAR,AAAA,GAAAjmC;AAAkCohC;;AAAlCphC;;;AAGE,AAAI,oBAAA,AAAAtE,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,0UAAA,3OAAO/C,aAEA,2DAAA,2FAAA,tJAACwrC;;AAFR;;AAKA,eAAOyB;eACArF;eACA,AAAC3oC,eAAK4oC;eACNC;eACA,aAAA,ZAAKv7B;eAEL,oEAAA,0GAAA,9KAAC5I,sDAAO0kC;eACRC;eAPP,kJAAA,/DAQQxC,4BAAkByC,wCAEdn5B;eACLpP;eACA2E;;;;;;;;;;;;;AA9Ff,GA+FE,6DAAA,7DAACxD,6CAAEksC;AAGD,AAAI,oBAAA,AAAAvqC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFACE9C;AADF,AAAA,AAAA+C,yGAAA,AAAA,gXAAA,jRACE/C,aAEA,2DAAA,kFAAA,7IAACwrC,qNACD,AAACxsC,gBAAM,AAACC,eAAK4oC,yBAEb,CAAG,AAAA,yFAAUQ,iBAAW,iBAAAzkC,mBAAI,AAAA,sFAASykC;AAAb,AAAA,oBAAAzkC;AAAAA;;AAAA;;;;AAN1B;;AAOA,eAAOqpC;eACArF;eAEA,AAAC9sB,gBAAM+sB;eACPC;eACA,aAAA,ZAAKv7B;eACL87B;eACA,AAACxlC,8CAAMylC,aACL,AAACtpC,gBAAM,AAACC,eAAK4oC,gBACX,CAAG,AAAA,yFAAUQ,iBACV,iBAAAzkC,mBAAI,AAAA,sFAASykC;AAAb,AAAA,oBAAAzkC;AAAAA;;AAAA;;;eACP6kC;eACAzoC;eACA2E;;;;;;;;;;;;;AAtHf,GAuHE,6DAAA,7DAACxD,6CAAEksC;AAGD,AAAI,oBAAA,AAAAvqC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,mXAAA,pRAAO/C,aAEA,2DAAA,qFAAA,hJAACwrC,wNAED,AAACxsC,gBAAM,AAACC,eAAK4oC,yBAEb,CAAG,AAAA,oGAAeQ,iBACf,AAACrpC,gBAAM,AAAC8b,gBAAM+sB;;AAPxB;;AAQA,eAAOoF;eACArF;eAGA,gCAAA,hCAAC5gB,kBAAQ6gB;eACTC;eACA,aAAA,ZAAKv7B;eACL87B;eACA,AAACxlC,8CAAMylC,aACL,AAACtpC,gBAAM,AAACC,eAAK4oC,gBACX,CAAG,AAAA,oGAAeQ,iBACf,AAACrpC,gBAAM,AAAC8b,gBAAM+sB;eACrBY;eACAzoC;eACA2E;;;;;;;;;;;;;AAhJf,GAiJE,6DAAA,7DAACxD,6CAAEksC;AAGD,AAAI,oBAAA,AAAAvqC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,0XAAA,3RAAO/C,aAEA,2DAAA,4FAAA,vJAACwrC,+NAGD,AAACxsC,gBAAM,AAACC,eAAK4oC,yBAEb,CAAA,CAAG,AAAA,gFAAMQ,iBACN,AAAA,uFAASA,kBACT,AAACrpC,gBAAM,AAAC8b,gBAAM+sB;;AATxB;;AAUA,eAAOoF;eACArF;eAGA,gCAAA,hCAAC5gB,kBAAQ6gB;eACTC;eACA,aAAA,ZAAKv7B;eACL87B;eACA,AAACxlC,8CAAMylC,aACL,AAACtpC,gBAAM,AAACC,eAAK4oC,gBACX,CAAA,CAAG,AAAA,uFAASQ,iBACT,AAAA,gFAAMA,kBACN,AAACrpC,gBAAM,AAAC8b,gBAAM+sB;eACrBY;eACAzoC;eACA2E;;;;;;;;;;;;;AA7Kf,GA8KE,6DAAA,7DAACxD,6CAAEksC;AAKD,AAAI,oBAAA,AAAAvqC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,+FAAO/C,aAEA,2DAAA,8EAAA,zIAACwrC,iNACD,AAACxsC,gBAAM,AAACC,eAAK4oC;;AAHpB;;AAIA,eAAOoF;eACArF;eAGA,AAAC9sB,gBAAM+sB;eACPC;eACA,aAAA,ZAAKv7B;eACL,4DAAA,5DAAC1J,8CAAMwlC,sEACG,CAAG,AAACrpC,gBAAM,AAACC,eAAK4oC,kBACb,iBAAAjkC,mBAAI,AAAA,sFAASykC;AAAb,AAAA,oBAAAzkC;AAAAA;;AAAA;;;eACb0kC;eACAG;eACAzoC;eACA2E;;;;;;;;;;;;;AApMf,GAqME,6DAAA,7DAACxD,6CAAEksC;AAED,AAAI,oBAAA,AAAAvqC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,bAAO/C,0CAGA,AAAChB,gBAAM,AAACC,eAAK4oC;;AAHpB;;AAIA,eAAOoF;eACArF;eAGA,AAAC9sB,gBAAM+sB;eACPC;eACA,aAAA,ZAAKv7B;eACL,4DAAA,5DAAC1J,8CAAMwlC,uEAAkB,AAACrpC,gBAAM,AAACC,eAAK4oC;eACtCS;eACAG;eACAzoC;eACA2E;;;;;;;;;;;;;AAtNf,GAuNE,6DAAA,7DAACxD,6CAAEksC;AAED,AACE,oBAAA,AAAAvqC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,kCAAA,yHAAA,wTAAA,mHAAA,nlBAAO/C,4DAEa,AAAA,6FAAYqoC,4BACZ,+HAAA,sKAAA,nRAAM,AAAA,6FAAYA,gBAChB,AAAC/hC,4CAAIgiC,aAAS,AAAA,6FAAYD,iCAC9B,AAAA,yFAAUA,yBACX,AAAA,sFAASA;;AAN1B;;AAOA,eAAO4E;eACArF;eACA,AAAC3oC,eAAK4oC;eACNC;eACA,aAAA,ZAAKv7B;eAGL,4DAAA,5DAAC1J,8CAAMwlC,uEAUH,AAACiE,yBAAWjE,cAAUC;eAE1BA;eACAG;eACAzoC;eACA2E;;;;;;;;;;;;;AAvPb,GAwPE,6DAAA,7DAACxD,6CAAEksC;AAED,IAAMrF,YAAU,AAAChpC,gBAAM,AAACC,eAAK4oC;IACvBtnC,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,oUAAA,iBAAA,6EAAA,yHAAA,npBAAO/C,uNAAAA,aACO,2DAAA,qFAAA,hJAACwrC,+NAGDxD,mBACE,AAAC1hC,4CAAIgiC,aAASN,sBACZ,AAAA,yFAAUK;AAPpC,AAQE,eAAO4E;eACArF;eAEA,AAAC9sB,gBAAM+sB;eACPC;eACA,aAAA,ZAAKv7B;eACL,4DAAA,5DAAC1J,8CAAMwlC,uEAMH,iBAAAzkC,mBAAI,uFAAA,rEAAM,AAAC0C,4CAAIgiC,aAASN,YAClB,iBAAA3Q,kBAAA;IAAAC,kBACK,CAAG,AAAChxB,4CAAIgiC,aAASN,aACd,AAAA,gFAAMK;AAFd,AAAA,SAAAhR,kBAAAC,mBAAAD,kBAAAC;KADF;AAAJ,AAAA,oBAAA1zB;AAAAA;;AAMI,OAAA,uFAASykC;;;eACjBC;eACAG;eACAzoC;eACA2E;;;;;;;;;;;;;AAxRb,GAyRE,6DAAA,7DAACxD,6CAAEksC;AAED,AAAI,oBAAA,AAAAvqC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,+FAAO/C,aAEA,2DAAA,qFAAA,hJAACwrC;;AAFR;;AAIA,eAAOyB;eACArF;eACA,AAAC3oC,eAAK4oC;eACNC;eACA,aAAA,ZAAKv7B;eACL,4DAAA,5DAAC1J,8CAAMwlC,uEAAkBtI;eACzBuI;eACAG;eACAzoC;eACA2E;;;;;;;;;;;;;AAxSf,GAySE,6DAAA,7DAACxD,6CAAEksC;AAED,IAAAiB,aAA4B,oIAAA,0BAAA,9JAAC3tC,yEACCX,YACA,AAAChB,gBAAM,AAACC,eAAK4oC;wBAF3C,AAAAxnC,4CAAAiuC,WAAA,IAAA,/EAAOC;YAAP,AAAAluC,4CAAAiuC,WAAA,IAAA,nEAAyB/tC;IAUnBA,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,oXAAA,5eAAO/C,uNAAAA,aAEA,2DAAA,gFAAA,3IAACwrC,mNAED,AAACxsC,gBAAM,AAACC,eAAK4oC;AAd5B,AAeE,eAAOoF;eACArF;eAEA,AAAC9sB,gBAAM+sB;eACPC;eACA,aAAA,ZAAKv7B;eACL87B;eACAC;eACAG;eACA8F;eACA5pC;;;;;;;;;;;;;AApUb,GAqUE,6DAAA,7DAACxD,6CAAEksC;AAGD,AAAI,oBAAA,AAAAvqC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,+FAAO/C,aAEA,2DAAA,sFAAA,jJAACwrC;;AAFR;;AAIA,eAAOyB;eACArF;eACA,AAAC3oC,eAAK4oC;eACNC;eACA,aAAA,ZAAKv7B;eACL87B;eACAC;eACAG;eACA,AAAA,0GAAkBJ;eAClB1jC;;;;;;;;;;;;;AArVf,GAsVE,6DAAA,7DAACxD,6CAAEksC;AAGD,IAAMrF,YAAU,AAAChpC,gBAAM,AAACC,eAAK4oC;IACvBtnC,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,6TAAA,iBAAA,mFAAA,zhBAAO/C,uNAAAA,aACO,2DAAA,8EAAA,zIAACwrC,wNAEDxD,mBACE,AAAC1hC,4CAAIgiC,aAASN;AALtC,AAME,eAAOiF;eACArF;eAEA,AAAC9sB,gBAAM+sB;eACPC;eACA,aAAA,ZAAKv7B;eAGL,oKAAA,pKAAC1J,8CAAM,6DAAA,7DAACc,+CAAO0kC,sIACFL;eACbM;eACAG;eACAzoC;eACA2E;;;;;;;;;;;;;AA5Wb,oBA6WE,AAAA,mHAAuB0jC;AAGrB,GAAI,EAAI,6DAAA,7DAAClnC,6CAAEksC,iFACH,6DAAA,7DAAClsC,6CAAEksC;AAET,AAAI,oBAAA,AAAAvqC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,+FAAO/C,aAEA,2DAAA,iGAAA,5JAACwrC,oOAGD,qIAAA,pIAAK,AAAA,mHAAuBnD;;AALnC;;AAMA,eAAO4E;eACArF;eACA,AAAC3oC,eAAK4oC;eACNC;eACA,aAAA,ZAAKv7B;eACL,AAAC5I,sDAAO,mEAAA,nEAACd,qDAAMwlC,mGAKH,kBAAI,iBAAAzkC,mBAAIqpC;AAAJ,AAAA,oBAAArpC;AAAAA;;AACI,oEAAA,7DAACzC,6CAAEksC;;+kBANvB,0GAAA,pXAAQ,/TAQM,qIAAA,pIAAK,AAAA,mHACEhF,sBACP,AAAA,mHAAuBA,6HAClB,CAAG,AAAA,uFAASA,iBACT,AAAA,gFAAMA;eAG5BC;eACAG;eACAzoC;eACA2E;;;;;;;;;;;;;AAKX,IACGpE,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,iVAAA,iKAAA,1mBACE/C,uNAAAA,aAEE,2DAAA,kGAAA,7JAACwrC,8PAGsB,AAAA,mHACEnD;IAC/B5B,4BAA0B,AAACC,2CACCuG;IAC5BwB,uBAAqB,AAAA,mHAAuBpG;IAC5CN,8BACE,iBAAA1Q,kBAAA;IAAAC,kBACK,CAAGmX,uBACAhI;AAFR,AAAA,SAAApP,kBAAAC,mBAAAD,kBAAAC;;IAGF+Q,gBAAU,6DAAA,7DAAC1kC,+CAAO0kC;IAIlBA,gBAAU,4DAAA,5DAACxlC,8CAAMwlC,yEACI,CAAG,AAAA,uFAASA,iBACT,AAAA,gFAAMA;IAC9BA,gBAAU,EAAI,+BAAA,9BAAMN,oCACR,4DAAA,5DAACllC,8CAAMwlC,gHAEHN,6BACJM;IA3BfmG,aAgCK,EAAI,+BAAA,9BAAMzG,oCACR;AACE,oBAAA,AAAAjlC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFACE9C;AADF,AAAA,AAAA+C,yGAAA,AAAA,+FACE/C,aAEA,2DAAA,mGAAA,9JAACwrC,sOAGDzD;;AANF;;AAOA,sDAAA,KAAA,KAAA,zDAACP,4BACChlC,OACAxC,iFAIA4nC,cACAC,cACAC,kBACAv7B,UACA87B,cACAC,aACAG,kBACA9jC;;CAtBN,mFAuBG0jC,cAAUI,kBAAc9jC;oBAvDhC,AAAAtE,4CAAAmuC,WAAA,IAAA,3EA+BIE;wBA/BJ,AAAAruC,4CAAAmuC,WAAA,IAAA,/EA+BkBG;cA/BlB,AAAAtuC,4CAAAmuC,WAAA,IAAA,rEA+BoC/nB;AA/BpC,AAwDE,eAAOwmB;eACArF;eAGAC;eACAC;eACA,aAAA,ZAAKv7B;eACLmiC;eACApG;eACAqG;eACA3uC;eACAymB;;;;;;;;;;;;;;AAxdf,GAydE,EAAI,6DAAA,7DAACtlB,6CAAEksC,iFACH,6DAAA,7DAAClsC,6CAAEksC;AAEL,AAAI,oBAAA,AAAAvqC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFACE9C;AADF,AAAA,AAAA+C,yGAAA,AAAA,+FACE/C,aAEA,2DAAA,sGAAA,jKAACwrC;;AAHH;;AAMA,eAAOyB;eACArF;eACA,AAAC3oC,eAAK4oC;eACNC;eACA,aAAA,ZAAKv7B;eAGL,EAAI,EAAI,GAAK,AAAC7L,uBAAOusC,qBACb,6DAAA,7DAAC9rC,6CAAEksC,2FACT,8gBAAA,0GAAA,xnBAAC1pC,sDAAO,mEAAA,qFAAA,sDAAA,9MAACd,qDAAMwlC,oNAEI,CAAG,AAAA,gFAAMA,iBACN,AAAA,uFAASA,qMAG/BA;eACFC;eACAG;eACAzoC;eACA2E;;;;;;;;;;;;;AArff,GAwfE,6DAAA,7DAACxD,6CAAEksC;AAED,AAAI,oBAAA,AAAAvqC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,+FAAO/C,aAEA,2DAAA,kGAAA,7JAACwrC;;AAFR;;AAKA,eAAOyB;eACArF;eACA,AAAC3oC,eAAK4oC;eACNC;eACA,aAAA,ZAAKv7B;eACL,mEAAA,+DAAA,mFAAA,+DAAA,pRAAC1J,qDAAMwlC;eAGPC;eACAG;eACAzoC;eACA2E;;;;;;;;;;;;;AA1gBf,GA6gBE,+JAAA,kKAAA,wJAAA,vdAAI,6DAAA,7DAACxD,6CAAEksC,kHACH,6DAAA,7DAAClsC,6CAAEksC,qHACH,6DAAA,7DAAClsC,6CAAEksC,2GACH,6DAAA,7DAAClsC,6CAAEksC,qGACH,6DAAA,7DAAClsC,6CAAEksC;AAIL,IAAM9sC,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,+XAAA,yHAAA,hnBAAO/C,uNAAAA,aACO,2MAAA,3MAACwrC,2DAAU,CAAA,kEACK6B,iKAEX,AAAA,0FAAWrtC;IAEhCO,QAAE,yDAAA,KAAA,5DAAU,AAACG,uBAAO,AAACzB,eAAK4oC,sBACtB,kBAAO,KAAA9nC,MAEC,8DAAA,jBACEstC;IAGdhF,gBAAU,kBAAI,AAAA,6FAAYA,gBACdA,cACA,4DAAA,+DAAA,3HAACxlC,8CAAMwlC;IAEnBA,gBAAU,4DAAA,5DAACxlC,8CAAMwlC,6EACM,AAAC77B,+CAAO,AAAA,6FAAY67B,eACZ4E;IAC/B1sC,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,sCAAA,+SAAA,zjBAAO/C,uNAAAA,mCAEsBqtC,8BACR,AAAClqC,wGAAO,AAACyC,4CAAIlE,oBACH,AAAA,6FACE2mC;AAzBzC,AA0BE,GAAI,AAAC3nC,uBAAO,AAAA,6FAAY2nC;AAEtB,eAAO4E;eACArF;eACA,AAAC3oC,eAAK4oC;eACNC;eACA,aAAA,ZAAKv7B;eACL,oEAAA,iHAAA,rLAAC5I,sDAAO0kC;eACRC;eACAG;eACAzoC;eACA2E;;;;;;;;;;;;;AAEP,IAAAiqC,aACQ,+CAAA,KAAA,pDAACpH,4BAAchlC,OACAxC,sBAGAqtC,gBACAzF,cACAC,cACAC,kBACAv7B,UACA87B,cACAC,aACAG,kBACA9jC;oBAbvB,AAAAtE,4CAAAuuC,WAAA,IAAA,3EAAOF;wBAAP,AAAAruC,4CAAAuuC,WAAA,IAAA,/EAAqBD;cAArB,AAAAtuC,4CAAAuuC,WAAA,IAAA,rEAAuCnoB;AAAvC,AAcE,eAAA;eACO,CAAGmhB,gBAAU,AAACpkC,gBAAMypC;eACpB,AAAChuC,eAAK4oC;eACNC;eACA,aAAA,ZAAKv7B;eACL,oEAAA,iHAAA,rLAAC5I,sDAAO+qC;eACRpG;eACAqG;eACA3uC;eACAymB;;;;;;;;;;;;;;AAnlBjB,GA4lBE,EAAK,iBAAA,hBAAMwmB,2BAAU,AAACvsC,uBAAO,AAAA,6FAAY2nC;AAKvC,AAAI,oBAAA,AAAAvlC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,oFAAO9C;AAAP,AAAA,AAAA+C,yGAAA,AAAA,+FAAO/C,aAEA,2DAAA,2FAAA,tJAACwrC;;AAFR;;AAIA,eAAO,AAACvsC,eAAKguC;eACN,iBAAA,hBAAKrF;eACL,AAAC3oC,eAAK4oC;eACNC;eACA,aAAA,ZAAKv7B;eACL87B;eACAC;eACAG;eACAzoC;eACA2E;;;;;;;;;;;;;AA9mBf,GA+mBE,sBAAA,6BAAA,jDAAI0J,sBAASi4B,6BAAgBwC,mBAAQkF;AAGnC,IACGztC,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,yVAAA,0BAAA,wCAAA,wBAAA,0CAAA,rlBACE/C,uNAAAA,aAEE,2DAAA,0GAAA,rKAACwrC,wPAGQn9B,iCACOi4B,gCACRwC,8BACMkF;IAVvBa,aAYK,kIAAA,lIAACrH,4BAAchlC,OACAxC,YACA,AAAChB,gBAAMiuC,cACP,AAACvsC,uBAAO,AAACzB,eAAKguC,oBAEdrF,cACAC,cACAC,kBACAv7B,UACA87B,cACAC,aACAG,kBACA9jC;oBAxBpB,AAAAtE,4CAAAwuC,WAAA,IAAA,3EAWIH;wBAXJ,AAAAruC,4CAAAwuC,WAAA,IAAA,/EAWkBF;cAXlB,AAAAtuC,4CAAAwuC,WAAA,IAAA,rEAWoCpoB;AAXpC,AAyBE,eAAO,AAACxnB,eAAKguC;eACN,iBAAA,hBAAKrF;eAGLC;eACAC;eACA,aAAA,ZAAKv7B;eACLmiC;eACApG;eACAqG;eACA3uC;eACAymB;;;;;;;;;;;;;AAtpBb,GAupBE,gIAAA,2IAAA,0IAAA,4IAAA,sJAAA,yJAAA,8IAAA,mJAAA,/mCAAI,6DAAA,7DAACtlB,6CAAEksC,mFACH,6DAAA,7DAAClsC,6CAAEksC,8FACH,6DAAA,7DAAClsC,6CAAEksC,6FACH,6DAAA,7DAAClsC,6CAAEksC,+FACH,6DAAA,7DAAClsC,6CAAEksC,yGACH,6DAAA,7DAAClsC,6CAAEksC,4GACH,6DAAA,7DAAClsC,6CAAEksC,iGACH,6DAAA,7DAAClsC,6CAAEksC,sGACH,6DAAA,7DAAClsC,6CAAEksC,qFACH,6DAAA,7DAAClsC,6CAAEksC;AAGL,IAAM9sC,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,qYAAA,7fAAO/C,uNAAAA,aAEA,2MAAA,3MAACwrC,2DAAU,CAAA,kEACK6B;IAEzB9sC,QAAE,yeAAA,gJAAA,vnBAAM,EAAK,oIAAA,lIAAI,6DAAA,7DAACY,6CAAEksC,uFACH,6DAAA,7DAAClsC,6CAAEksC,+FACH,6DAAA,7DAAClsC,6CAAEksC,wGACP,GAAK,AAAC3sC,uBAAO,AAACzB,eAAK4oC,qBAC5B,kBAAO,KAAA9nC,MAEC,8DAAA,jBACEstC;IAZpByB,aAeQ,AAACtH,4BAAchlC,OACAxC,YACA,AAAChB,gBAAMiuC,cACP,AAACvsC,uBAAO,AAACzB,eAAKguC,eACdI,gBACAzF,cACAC,cACAC,kBACAv7B,UACA87B,cACAC,aACAG,kBACA9jC;oBA3BvB,AAAAtE,4CAAAyuC,WAAA,IAAA,3EAcOJ;wBAdP,AAAAruC,4CAAAyuC,WAAA,IAAA,/EAcqBH;cAdrB,AAAAtuC,4CAAAyuC,WAAA,IAAA,rEAcuCroB;AAdvC,AA4BE,eAAO,AAACxnB,eAAKguC;eACN,iBAAA,hBAAKrF;eACL,sKAAA,mbAAA,vlBAAM,6DAAA,7DAACzmC,6CAAEksC,wFAED,AAACvyB,gBAAM+sB,iBACT,oIAAA,lIAAI,6DAAA,7DAAC1mC,6CAAEksC,uFACH,6DAAA,7DAAClsC,6CAAEksC,+FACH,6DAAA,7DAAClsC,6CAAEksC,oGAILxF,cACI,AAAC5oC,eAAK4oC;;eAClB,qBAAA,pBAAKC;eACL,aAAA,ZAAKv7B;eAEL,oEAAA,0GAAA,9KAAC5I,sDAAO+qC;eACRpG;eACAqG;eACA3uC;eACAymB;;;;;;;;;;;;;AAntBb,GAotBE,sKAAA,yKAAA,iKAAA,9eAAI,6DAAA,7DAACtlB,6CAAEksC,yHACH,6DAAA,7DAAClsC,6CAAEksC,4HACH,6DAAA,7DAAClsC,6CAAEksC,oHACH,6DAAA,7DAAClsC,6CAAEksC,uGACH,6DAAA,7DAAClsC,6CAAEksC;AAEL,IAAM9sC,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,4DAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,qYAAA,7fAAO/C,uNAAAA,aAEA,2MAAA,3MAACwrC,2DAAU,CAAA,kEACK6B;IAH/B0B,aAMQ,+CAAA,/CAACvH,4BAAchlC,OACAxC,iBAGA,AAACU,uBAAOusC,cACRI,gBACAzF,cACAC,cACAC,kBACAv7B,UACA87B,cACAC,aACAG,kBACA9jC;oBAnBvB,AAAAtE,4CAAA0uC,WAAA,IAAA,3EAKOL;wBALP,AAAAruC,4CAAA0uC,WAAA,IAAA,/EAKqBJ;cALrB,AAAAtuC,4CAAA0uC,WAAA,IAAA,rEAKuCtoB;AALvC,AAoBE,eAAOwmB;eACArF;eACA,AAAC3oC,eAAK4oC;eACNC;eACA,aAAA,ZAAKv7B;eAGL,oEAAA,0GAAA,+DAAA,7OAAC5I,sDAAO+qC;eACRpG;eACAqG;eACA3uC;eACAymB;;;;;;;;;;;;;AAzvBb,AA8vBQ,MAAO,KAAA1mB,MAEC,CAAA,4FAAA,KAAA,tBACKstC,gFAGA,iBAAA2B,WAAS,AAAChwC,gBAAMiuC;AAAhB,AAAA,8GAAA+B,2CAAAA,jJAACttC,oDAAAA,8DAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEpC;;;0BAAA,1BAAMutC,4DAEH1pC;AAFH,AAGE,sDAAA,WAAA2pC,1DAACvzB;AAAD,AAAS,uIAAA,hIAACxa,6CAAE,8EAAA,9EAACd,4CAAI,gBAAA6uC,hBAAClwC;GAAsBuG;;AAE1C;;;;2CAAA,3CAAM4pC,8FAGH3lB;AAHH,AAIE,sDAAA,WAAA4lB,iBAAAC,3EAAChwC;AAAD,AAAS,GAAM,iNAAA,jNAAC8B,6CAAE,iGAAAkuC,gDAAAA,hJAACjuC,iDAAAA,mEAAAA;AAAV,AAA6B,yBAAA,lBAAC8J;;AAA9B;;GAAT,MAA4Dse;;AAE9D;;;;kCAAA,6DAAA8lB,/FAAMG,4EAGHjtC,OAAOC,MAAMC,eAKCkE,IAAI1F;AARrB,AAAA,IAAAquC,aAAAD;IAAAC,iBAAA,AAAAlpC,4BAAAkpC;cAAAA,VAQQvvC;IARRwvC,aAAA,AAAAlpC,4CAAAipC,eAOM/sC;IAPNgtC,iBAAA,AAAAnpC,4BAAAmpC;kBAAA,AAAAlpC,4CAAAkpC,eAAA,zEAKgE5tB;0BALhE,AAAAtb,4CAAAkpC,eAAA,jFAMY3tB;uBANZ,AAAAvb,4CAAAkpC,eAAA,9EAKYzL;aALZ,AAAAz9B,4CAAAkpC,eAAA,pEAMoCh6B;sBANpC,AAAAlP,4CAAAkpC,eAAA,7EAM2C3wB;gBAN3C,AAAAvY,4CAAAkpC,eAAA,vEAKsD3uC;kBALtD,AAAAyF,4CAAAkpC,eAAA,zEAKuBE;qBALvB,AAAAppC,4CAAAkpC,eAAA,5EAK6BG;sBAL7B,AAAArpC,4CAAAkpC,eAAA,7EAKsC1rC;gBALtC,AAAAwC,4CAAAkpC,eAAA,vEAM0BI;eAN1B,AAAAtpC,4CAAAipC,eAAA,tEAIW1mC;qBAJX,AAAAvC,4CAAAipC,eAAA,5EAIoBxtB;AAJpB,AASE,oBAAA,AAAA,mFAAK/hB;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,wBAAA,iBAAA,iBAAA,nEAAK/C,6BACoB4G,cACV4O,iBACAhT,eACF,CAACpB,iDAAAA,uDAAAA,RAAKF,oCAAAA;;AAJnB;;AAKA,GAAI,8IAAA,9IAACC,6CAAE,AAAA,wFAASnB;AACd,QAAC49B,+DAAAA,yFAAAA,5BAAiBn7B,sEAAAA,hEAAMC,sEAAAA,hEAAM1C,sEAAAA,9DAAQkB,sEAAAA;;AACtC,oBAAI,iBAAAkG,oBAAKuoC;AAAL,AAAA,oBAAAvoC;AAAc,kJAAA,3IAACjG,6CAAE,AAAA,qFAAQnB;;AAAzBoH;;;AACF,OAACuS,kCAAoB3Z,QAAQ4G,IAAI1F;;AACjC,IAAA2uC,aACQ,gDAAA,hDAAC/V,iCAAmB95B,QAAQwC;wBADpC,AAAAnC,4CAAAwvC,WAAA,IAAA,/EAAOtmB;wBAAP,AAAAlpB,4CAAAwvC,WAAA,IAAA,/EAAmB7V;yBAAnB,AAAA35B,4CAAAwvC,WAAA,IAAA,hFAA+B5V;IAOzBj6B,cAAQ,EAAI,EAAK,oDAAA,pDAACmB,6CAAEqB,gFAAqB,6CAAA,7CAACrB,oGAAS,CAACC,iDAAAA,uDAAAA,RAAKF,oCAAAA,WAC/C,sDAAA,0DAAA,hHAAC2B,8CAAM7C,wEACPA;IAThB8vC,aAWQ,+GAAA,+FAAA,5LAAIhsC,iBACF,AAACD,mCAAqBrB,OAAOxC,YAAQ8D,gBAAgB5C,yFACpDlB;kBAbX,AAAAK,4CAAAyvC,WAAA,IAAA,zEAUO9vC;kBAVP,AAAAK,4CAAAyvC,WAAA,IAAA,zEAUe7sC;IAIT1C,IAAE,mCAAA,yfAAA,1gBAAMuD,iBACJ,kBAAA,AAAA,iGAAA,AAAA,AAAAf,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,mEAAA,9YAAQnD,sNAAAA,gKAEAiD;IAjBlB8sC,aAoBQ,yGAAA,vFAAIlvC,WACF,AAAC0B,6BAAeC,OAAOxC,YAAQa,UAAUK,KAAKuB,MAAMC,0FACnD1C,YAAQkB,KAAKuB,MAAMC;kBAtB9B,AAAArC,4CAAA0vC,WAAA,IAAA,zEAmBO/vC;eAnBP,AAAAK,4CAAA0vC,WAAA,IAAA,tEAmBe7uC;gBAnBf,AAAAb,4CAAA0vC,WAAA,IAAA,vEAmBoBttC;gBAnBpB,AAAApC,4CAAA0vC,WAAA,IAAA,vEAmB0BrtC;IAKpB81B,YAAU,AAACh1B,gBAAMf;gBAxBvB,mFAAA,6IAAA,5OAyBMolB,kLAAYplB,UAAM,AAACiQ,yBAAW1S,YAAQyC;IACtCqlB,YACE,AAACP,qDAASvnB,YAAQ,CAAG4G,MAAI,iBAAAywB,kBAAA;IAAAC,kBAAO,aAAA,ZAAKkB;AAAZ,AAAA,SAAAnB,kBAAAC,mBAAAD,kBAAAC;MAAyBp2B,SAAKwB;IACzDqc,MAAI,CAAC/E,mDAAAA,6DAAAA,ZAAO9Y,0CAAAA;IA5BlB8uC,aAqCQhwC;IArCRgwC,iBAAA,AAAA3pC,4BAAA2pC;kBAAAA,dAoCWhwC;IApCXiwC,aAAA,AAAA3pC,4CAAA0pC,eAmCSxtC;IAnCTytC,iBAAA,AAAA5pC,4BAAA4pC;6BAAA,AAAA3pC,4CAAA2pC,eAAA,pFAkC8ChW;sBAlC9C,AAAA3zB,4CAAA2pC,eAAA,7EAiCiEruB;8BAjCjE,AAAAtb,4CAAA2pC,eAAA,rFAkCyBpuB;2BAlCzB,AAAAvb,4CAAA2pC,eAAA,lFAiCelM;iBAjCf,AAAAz9B,4CAAA2pC,eAAA,xEAkCuCz6B;4BAlCvC,AAAAlP,4CAAA2pC,eAAA,nFAiCqD1mB;4BAjCrD,AAAAjjB,4CAAA2pC,eAAA,nFAiCyCjW;sBAjCzC,AAAA1zB,4CAAA2pC,eAAA,7EAiC0BP;yBAjC1B,AAAAppC,4CAAA2pC,eAAA,hFAiCgCN;oBAjChC,AAAArpC,4CAAA2pC,eAAA,3EAkCeL;IAKT1Q,QAAM,yCAAA,vCAAM,AAAC70B,cAAI4vB,yBACT,iBAAAr2B,mBAAI,AAAA,qFAAQ5D;AAAZ,AAAA,oBAAA4D;AAAAA;;AAAqB,OAACM,0BAAY1B,OAAOxC;;KAD3C;IAENA,cAAQ,2DAAA,3DAAC2D,+CAAO3D;IAChBO,QAAE,yBAAA,8dAAA,reAAM2+B,OAAM,kBAAA,AAAA,iGAAA,AAAA,AAAAn8B,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,wCAAA,nXAAQnD,sNAAAA,2IAA8Bk/B;IACpD1V,WAAS,kBAAM,iBAAA5lB,mBAAI2lB;AAAJ,AAAA,oBAAA3lB;AAAAA;;AAAgBq2B;;+MAAtB,kPAAA,3bAAoC,CAAC/I,sDAAAA,mFAAAA,/BAAUC,gEAAAA,7CACAjwB,gEAAAA,6BACzC84B,uBAAY,CAAC5I,sDAAAA,mFAAAA,/BAAUD,gEAAAA,7CAASjwB,gEAAAA,WAC1B,CAACmwB,iDAAAA,8EAAAA,/BAAKF,2DAAAA,xCAASjwB,2DAAAA;;AA9C1C,AA+CE,oBACEg+B;AAAM,OAACxuB,mHAAcmX,UACA,4BAAA,5BAACmY,qFAGChgC,YAEA4G,IAEA,CAAG4xB,YAAU5xB,KACb4O,WACA0pB,MACA1V,UACF1B;;AAbvB,oBAcE8nB;AAME,wCAAA,jCAACnS,gGACch7B,UACAC,UAIA,0DAAA,1DAACG,8CAAM7C,yEAAkB4vC,eAEzBhpC,IACA1F;;AA7BnB,AA+BI,IAIMsU,aAAO,iBAAA5R,mBAAI4R;AAAJ,AAAA,oBAAA5R;AAAAA;;AAAW,OAACJ,gBAAMf;;;IACzBopB,UAAQ,kBAAIoO,wBAAarzB,IAAI,CAAG4O,aAAO5O;IACvCrG,QAAE,kBAAA,AAAA,iGAAA,AAAA,AAAAwC,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,6KAAA,+BAAA,vhBAAQnD,sNAAAA,qIACgB,CAAC0B,oDAAAA,8DAAAA,ZAAQR,2CAAAA,sBACd2qB;IACrBrC,eAAS,kBAAI,iBAAApiB,oBAAKwa;AAAL,AAAA,oBAAAxa;AAAA,IAAAA,wBACK,0DAAA,xCAAI2a,gBAASF;AADlB,AAAA,oBAAAza;AAAA,gFAAA,4CAAA,nHAEK,AAACiD,cAAI,AAAC8kC,yCAAqB3lB,kBAC3B,AAACnf,cAAIkf,8BACL,AAAClf,cAAI2vB,4BACL,AAAC3vB,cAAI4vB;;AALV7yB;;;AAAAA;;MAMF,AAACua,wBAAUnf,OAAOxC,YAAQmxB,mBAAS3H,UACnCA;IACX+D,aAAW,iBAAA,mFAAA,mFAAA,mFAAA,GAAA,qDAAA,kEAAA,lYAAI,SAAA,RAAOxO,8ZAET,AAACwN,0BAAYvsB,YAAQ6rB,QAAQrC;IAC1CjpB,QAAE,kBAAA,AAAA,iGAAA,AAAA,AAAAwC,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,mDAAA,9XAAQnD,sNAAAA,iJAAoCutB;IAI9CA,iBAAW,EAAA,AAAAljB,yEAAA,3DAAQ,AAACI,kCAAc8iB,cAAYA;IAC9CC,WAAS,kCAAA,hBAAMD,gBAGJ,AAACnvB,8CAAMkN,4BACL,kDAAA,mFAAA,mFAAA,IAAA,qDAAA,kEAAA,nVAACmiB,wWAKC,kBAAI,iBAAA7pB,mBAAI2lB;AAAJ,AAAA,oBAAA3lB;AAAAA;;AAAA,IAAAA,uBAAA;AAAA,AAAA,oBAAAA;AAAAA;;AAA6Bq2B;;;gEATvC,1DAUQ1M,eACA,AAAC0hB,wBAAU1hB;IAC5BhtB,QAAE,oCAAA,pCAACgG,wBAAUvG,4BAAwB6rB,QAAQ2B;IAC7CjtB,QAAE,kBAAA,AAAA,iGAAA,AAAA,AAAAwC,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,iCAAA,4BAAA,iCAAA,zaAAQnD,sNAAAA,8IACyB6rB,oBACbhN,4BACA2O;IACtBE,iBAAe,AAAC/c,0BAAY3Q,YAAQ6rB,QAAQ2B;AA1ClD,AA2CE,GAAI,SAAA,RAAOzO;AACT,OAACrO,mHAAcmX,UAAUC;;AACzB,oBAAM4F;AAAN,AACE,GAAI,EAAK,AAACrjB,cAAIwU,sBACL,AAAC9M,6BAAe/R,YAAQ0tB;AAC/B,OAAChd,mHAAcmX,UAAU2F,SAAS1F;;AAClC,oBAAImS;AAEF,OAACvpB,mHAAcmX,UACA,AAAC8P,wDAAYn1B,OACAxC,YACA4G,IAEA,CAAGA,MAAI4xB,WACPjL,eACA/X,YACbsS;;AAEf,oBAAI,iBAAAlkB,mBAAI,iBAAAwD,oBAAK,AAACiD,cAAI05B;AAAV,AAAA,GAAA38B;AACK,OAAC48B,+BAAWhkC,YAAQ6rB,QAAQ3qB;;AADjCkG;;;AAAJ,AAAA,oBAAAxD;AAAAA;;AAAA,IAAAA,uBAEI,AAACyG,cAAIqlC;AAFT,AAAA,GAAA9rC;AAAAA;;AAGIib;;;;AACN,OAACnO,mHAAcmX,UACA,AAACzpB,8CAAMkN,4BACL,iBAAA4kC,WAAclwC;IAAdmwC,WACctkB;IADdukB,WAEc7iB;IAFd8iB,WAAA;IAAAC,WAIc,AAAA,4FAAW,CAAC9tC,uCAAAA,oDAAAA,fACCxC,iCAAAA;AAL3B,AAAA,4HAAAkwC,SAAAC,SAAAC,SAAAC,SAAAC,kDAAAJ,SAAAC,SAAAC,SAAAC,SAAAC,9OAACtiB,2DAAAA,yGAAAA;MAMHlG;;AAOf,OAACpX,mHAAcmX,UACA;AAAI,oBAAA,AAAA,mFACE7nB;AADF,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,rHACEnD,sJAEAutB;;AAHF;;AAIA,OAACoX,wBAAUniC,OACAxC,YACA6rB,QACAA,QACA0B;;CACfzF;;;;;AA7CvB;;;;;;;;;AA+ChB,4BAAA,5BAAMyoB,gEACHvwC,QAAQ4G,IAAI1F;AADf,AAEE,uCAAA,yDAAA,IAAA,7FAACuuC,iGAA6B,AAACx9B,wBAAUjS,SAAS4G,IAAI1F;;AAExD,8BAAA,9BAAMsvC,oEACHxwC,QAAQ4G,IAAI1F;AADf,AAEE,uCAAA,wDAAA,IAAA,5FAACuuC,gGAA4B,AAACx9B,wBAAUjS,SAAS4G,IAAI1F;;AAEvD;;;4BAAA,5BAAMuvC,gEAEHzwC,QAAQ4G,IAAI1F;AAFf,AAGE,uCAAA,kDAAA,KAAA,vFAACuuC,2FAA2B,AAACx9B,wBAAUjS,SAAS4G,IAAI1F;;AAGtD;;;;;iCAAA,jCAAMwvC,0EAIHC,SAASC,QAAQC,YAAMtrC;AAJ1B,AAKE,IAAOA,WAAKA;IACLZ,MAAI,qBAAA,rBAACyG;uBADZ,nBAEO0lC;;AAFP,AAGE,GAAI,AAACpwC,uBAAO6E;AACV,OAAC8F,2BAAY1G;;AACb,eAAO,AAAC1F,eAAKsG;eACN,kBAAIurC,kBACF,AAACC,iEAASpsC,sDAAIgsC,SAAS,AAAC3xC,gBAAMuG,gBAC9B,EAAI,EAAI,0BAAA,zBAAO,AAAC/B,gBAAMmB,mBAAM,YAAA,XAAMisC,oBAChC,AAACzlC,mDAAMxG,IAAI,AAAC3F,gBAAMuG,WAClB,AAACwrC,iEAASpsC,sDAAIisC,QAAQ,AAAC5xC,gBAAMuG;eACjC,iBAAAyrC,WAAO,AAAChyC,gBAAMuG;AAAd,AAAA,8FAAAyrC,mCAAAA,zHAACH,4CAAAA,sDAAAA;;;;;;;;;;AAEd;;;;;;;;;;;;6BAAA,7BAAM7iB,kEAWHhuB,QAAQ4G,IAAIrB,KAAK0rC,iBAAW5jB;AAX/B,AAYE,oBAAA,AAAA,mFAAQrtB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,mDAAA,8BAAA,lMAAQnD,8IAC6B,AAACwD,gBAAM+B,mBACvB0rC,6BACD5jB;;AAHpB;;AAIA,IAAMA,eAAS,iBAAAzpB,mBAAIypB;AAAJ,AAAA,oBAAAzpB;AAAAA;;AAAA;;;IAETypB,eAAS,sDAAA,pDAAI,AAACzgB,wBAAQygB,eAAUA,gGAAUA;IAC1CA,eAAS,6CAAA,mFAAA,hIAACxgB,4IAASwgB;AAHzB,AAIE,IAAO9nB,WAAKA;IACL2rC,UAAQ,EAAI,AAACvmC,sBAAM/D,MAAKA,IAAI,KAAA8rB,2BAAA,KAAA,EAAA,IAAA,AAAAA,sCAAA,MAAA,LAAQ9rB;IACpCjC,MAAI,qBAAA,rBAACyG;IACL+lC,kBAAUF;IAEVG,SAAO,kBAAIH,kBAAW,AAACjyC,gBAAMquB,cAAU,iCAAA,hCAAK,AAACruB,gBAAMquB;IACnDgkB,eAAahkB;;AANpB,AAOE,GAAI,AAAC3sB,uBAAO6E;AACV,IAAMnC,SAAO,AAACiI,2BAAY1G;IACpBpE,IAAE,kBAAA,AAAA,6FAAA,AAAA,AAAAwC,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,yCAAA,5WAAQnD,kNAAAA,uIAA8BoD;IAIxCkuC,yBAAuB,2BAAA,1BAAG,AAAC9tC,gBAAMJ;IACjCmuC,gBAAc,uCAAA,6IAAA,lLAAM,GAAK,0BAAA,zBAAMD,iCACf,wIAAA,xIAACjxC,4CAAI,AAACrB,gBAAM,AAACqB,4CAAI+C,OAAOkuC;AAP9C,AASEluC;;AACF,IAAAouC,aAAmC,AAACxyC,gBAAMuG;IAA1CksC,aAAA,AAAApxC,4CAAAmxC,WAAA,IAAA;QAAA,AAAAnxC,4CAAAoxC,WAAA,IAAA,/DAAQjyC;YAAR,AAAAa,4CAAAoxC,WAAA,IAAA,nEAAU3lC;WAAV,AAAAzL,4CAAAoxC,WAAA,IAAA,lEAAgB3sC;cAAhB0sC,VAA0BzsC;IASpByQ,SAAO,AAACxW,gBAAMkyC;IACd3Z,iBAAS,kDAAA,lDAACp2B,6CAAE2D;IAEZuJ,iBAAS,kDAAA,lDAAClN,6CAAE2D;IACZwhC,wBAAgB,kDAAA,lDAACnlC,6CAAE2D;IAEnB4sC,YAAU,oEAAA,pEAACrxC,4CAAI,AAAC8J,eAAKpF;AAf3B,AAgBE,oBAAA,AAAA,mFAAQ/E;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,iCAAA,4BAAA,iBAAA,/LAAQnD,0IACyB+E,oBACbosC,0BACFC,kBACC/iC;;AAJnB;;AAKA,eACE,AAACpP,eAAKsG;eAGN,iBAAA9F,qBAAkB,AAACR,eAAKiyC;AAAxB,AAAA,GAAAzxC;AAAA,eAAAA,XAASsrC;AAAT,AACEA;;AACAmG;;;eACF,EAAI3Z,gBAOF,iBAAMoa,YAAU,AAAC1yC,eAAKsG;AAAtB,AACE,GAAI,AAAC7E,uBAAOixC;AACV,OAACxmC,mDAAMxG,IAAII;;AACX,IAAA6sC,aAAwB,AAAC5yC,gBAAM2yC;IAA/BE,aAAA,AAAAxxC,4CAAAuxC,WAAA,IAAA;QAAA,AAAAvxC,4CAAAwxC,WAAA,IAAA,/DAAQtxC;YAAR,AAAAF,4CAAAwxC,WAAA,IAAA,nEAAUtxC;gBAAV,AAAAF,4CAAAwxC,WAAA,IAAA,vEAAYC;IACNC,oBAAkBV;AADxB,AAEE,oBAAA,AAAA,mFAAQrxC;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,oCAAA,+BAAA,pLAAQnD,2IAC0B8xC,0BACV,UAAA,TAAKV,2CACQ,AAACpyC,gBACC+yC;;AAJvC;;AAKA,GAAI,EAAI,uDAAA,vDAAC5wC,6CAAE2wC,2EACH,CAAG,UAAA,TAAKV,gBAAQ,AAACpyC,gBAAM+yC;AAG7B,8DAAA,mFAAA,mFAAA,WAAA,2DAAA,nSAAC5mC,mDAAMxG,+KAAWmH;;AAClB,OAACX,mDAAMxG,IAAII;;;KAGnB,EAAI,CAAIqsC,UAAO,AAACpyC,gBAAMqyC,gBAEpB,AAAClmC,mDAAMxG,IAAII,SAEX,uHAAA,mFAAA,iXAAA,qDAAA,yDAAA,zqBAACgsC,iEAASpsC,4NACE,6CAAK,AAACvG,8CAAMC,cACL,wFAAA,xFAACC,+CAAO,CAAG,AAACU,gBAAMqyC,gBAAcD,4DAElC,AAACjlC,sBAAOqJ,sJACfzQ;eAGdwyB;eAEA,EAAIA,gBACF,UAAA,TAAK6Z,cACL,wDAAA,tDAAI/iC,gBAAS,iCAAA,hCAAK,AAACrP,gBAAMqyC;eAI3B,EAAI,sBAAA,pBAAI9Z,sBAASlpB,oBAASi4B,2BACxB+K,aACA,EAAI,AAACpyC,eAAKoyC,eAAc,AAACpyC,eAAKoyC,cAAcA;;;;;;;;;;;;AAE1D;;;;;oCAAA,pCAAMW,gFAIHC;AAJH,AAKE,IAAMC,iBAAe,AAAC1uC,gBAAM,AAACy0B,iDAAS,4CAAA,WAAAka,vDAACvsC;AAAD,AAAM,mDAAAusC,iBAAA,7DAAC9xC;GAAS4xC;AAAtD,AAGE,GAAM,EAAI,+DAAA,/DAACx+B,gDAAKy+B,yBACN,oIAAA,pIAACz+B,gDAAK,+EAAA,/EAACpT,4CAAI,AAACrB,gBAAMizC;AAD5B,AAEE,MACE,KAAAlyC,MAEC,CAAA,0DAAA,mCAAA,8HAAA,hBAGOmyC,2EACaD;;AATzB;;AAUA,OAACzuC,gBAAMyuC;;AAEX;;;mCAAA,nCAAMjmC,8EAEHxM;AAFH,AAGE,IAAO25B,IAAE,AAAC31B,gBAAMhE;;AAAhB,AACE,GAAI,KAAA,JAAM25B;AACR,OAAC31B,gBAAMhE;;AACP,GAAI,sFAAA,tFAAC4yC,gCAA0B,+CAAA,/CAACxyC,6CAAKJ,MAAI25B;AACvC,eAAO,KAAA,JAAKA;;;;AACZ,QAAG,AAAC31B,gBAAMhE,KAAG25B;;;;;;AAErB;;;6BAAA,7BAAMjtB,kEAEH1M;AAFH,AAGE,IAAO25B,IAAE,AAAC31B,gBAAMhE;;AAAhB,AACE,GAAI,KAAA,JAAM25B;AAAV;;AAEE,GAAI,sFAAA,tFAACiZ,gCAA0B,+CAAA,/CAACxyC,6CAAKJ,MAAI25B;AACvC,eAAO,KAAA,JAAKA;;;;AACZ,sDAAA,/CAACv5B,6CAAKJ,MAAI25B;;;;;;AAElB;;;;;oCAAA,pCAAMkZ,gFAIHl0C,EAAE0I;AAJL,AAKE,IAAMyrC,aAAW,iBAAAjb,kBAAK,KAAA,JAAKl5B;IAAVm5B,kBAAA;AAAA,AAAA,SAAAD,kBAAAC,mBAAAD,kBAAAC;;AAAjB,AACE,GAAI,gBAAA,fAAOgb;AACTzrC;;AACA,IAAA0rC,aAAqB,AAACpoC,eAAKtD;QAA3B,AAAAxG,4CAAAkyC,WAAA,IAAA,/DAAO/yC;YAAP,AAAAa,4CAAAkyC,WAAA,IAAA,nEAASzmC;WAAT,AAAAzL,4CAAAkyC,WAAA,IAAA,lEAAeztC;uBAAf,nBACM0tC,sGAAkB,AAACtmC,2BAAa1M,GAAGsM,MAAMhH;IACzC2tC,qBACE,6CAAA,7CAAC5lC,8EAAQ,AAACL,+CAAO,AAACqgB,kBAAQhmB,WAAW2rC;AAH7C,AAIE,oDAAA,7CAAC3lC,8EAAQ,AAACL,+CAAO,AAAClO,+CAAOg0C,WAAWG,oBAAoB5rC;;;AAEhE;;;qCAAA,6CAAA6rC,lFAAME;AAAN,AAAA,IAAAD,aAAAD;QAAA,AAAAryC,4CAAAsyC,WAAA,IAAA,/DAEInzC;YAFJ,AAAAa,4CAAAsyC,WAAA,IAAA,nEAEM7mC;WAFN,AAAAzL,4CAAAsyC,WAAA,IAAA,lEAEY7tC;AAFZ,AAAA,0FAGG,AAACoH,2BAAa1M,GAAGsM,MAAMhH;;AAE1B;;;uCAAA,vCAAM+tC,sFAEHhsC;AAFH,AAGE,OAACsK,6CAAKyhC,mCAAqB/rC;;AAE7B;;;;;;;kCAAA,lCAAMisC,4EAMH30C,EAAE4G;AANL,AAQE,IAAMutC,aAAW,iBAAAjb,kBAAK,KAAA,JAAKl5B;IAAVm5B,kBAAA;AAAA,AAAA,SAAAD,kBAAAC,mBAAAD,kBAAAC;;AAAjB,AACE,GAAI,gBAAA,fAAOgb;AAAX,0FACGvtC;;AACD,IAAAguC,aAAqBhuC;QAArB,AAAA1E,4CAAA0yC,WAAA,IAAA,/DAAOvzC;YAAP,AAAAa,4CAAA0yC,WAAA,IAAA,nEAASjnC;WAAT,AAAAzL,4CAAA0yC,WAAA,IAAA,lEAAejuC;uBAAf,nBACM0tC,sGAAkB,AAACtmC,2BAAa1M,GAAGsM,MAAMhH;IACzC1B,SACE,6CAAA,7CAACyJ,8EAAQ,2HAAA,3HAACL,+CAAO,AAAClO,+CAAOg0C,WAAWE,qGAAmBztC;AAH/D,AAKE3B;;;AAER;;;;;oCAAA,pCAAM4vC,gFAIHztC;AAJH,AAKE,IAAOA,WAAKA;;AAAZ,AACE,GAAI,AAAC7E,uBAAO6E;AAAZ;;AAEE,IAAA0tC,aAAoB,AAACj0C,gBAAMuG;QAA3B,AAAAlF,4CAAA4yC,WAAA,IAAA,/DAAO1yC;gBAAP,AAAAF,4CAAA4yC,WAAA,IAAA,vEAASpsC;IAATqsC,aACiB,AAACl0C,gBAAM6H;YADxB,AAAAxG,4CAAA6yC,WAAA,IAAA,nEACO3yC;YADP,AAAAF,4CAAA6yC,WAAA,IAAA,nEACS3yC;WADT,AAAAF,4CAAA6yC,WAAA,IAAA,lEACWpuC;AADX,AAEE,GAAI,oHAAA,kIAAA,pPAAI,kDAAA,lDAAC3D,6CAAE2D,uEACH,kDAAA,lDAAC3D,6CAAE2D,qFACH,kDAAA,lDAAC3D,6CAAE2D,oEACH,kDAAA,lDAAC3D,6CAAE2D;AACT,eAAO,AAAC7F,eAAKsG;;;;AACb,OAACvG,gBAAMuG;;;;;;AAIjB;;;;;;;;;uCAAA,iFAAA4tC,xHAAME,sFAOHC,UAAUC,aAAarnB,IAAIsnB,gBAE3Bhc,aAAOjyB;AATV,AAAA,IAAA6tC,aAAAD;IAAAC,iBAAA,AAAA/sC,4BAAA+sC;iBAAAA,bAQiDM;0BARjD,AAAAptC,4CAAA8sC,eAAA,jFAQWzrB;8BARX,AAAArhB,4CAAA8sC,eAAA,rFAQyBK;AARzB,AAWE,IAAOluC,WAAKA;IACLZ,MAAI,qBAAA,rBAACyG;kCADZ,9BAEOuoC;oBAFP,hBAGOC;mBAHP,fAIOC;oBAJP,hBAKOC;;AALP,AAME,GAAI,AAACpzC,uBAAO6E;AACV,OAACnH,8CAAMkN,4BACL,AAACD,2BAEC,EAAI,mBAAA,lBAAOyoC,wBACTnvC,IACA,AAACosC,iEAASpsC,sDAAI,AAACmuC,gCAAkBgB,cAAc,AAAC90C,gBAAMktB;;AAC5D,IAAA6nB,aAA2B,AAAC/0C,gBAAMuG;eAAlC,AAAAlF,4CAAA0zC,WAAA,IAAA,tEAAOE;gBAAP,AAAA5zC,4CAAA0zC,WAAA,IAAA,vEAAgBltC;IAAhBmtC,aACiB,AAACh1C,gBAAM6H;QADxB,AAAAxG,4CAAA2zC,WAAA,IAAA,/DACOzzC;YADP,AAAAF,4CAAA2zC,WAAA,IAAA,nEACSzzC;WADT,AAAAF,4CAAA2zC,WAAA,IAAA,lEACWlvC;AADX,AAGE,GACE,kDAAA,lDAAC3D,6CAAE2D;AASD,AACI,eAAO,AAAC7F,eAAKsG;eACNZ;eACAgvC;eACAC;eACAC;eACA,CAAGC,gBAAc,AAAC9B,kCAAoBnrC;;;;;;;;;AAhBrD,AAqBI,IAAAqtC,aACQ,kBAAIP,6BACF,iCAAA,gGAAA,YAAA,6FAAA,xNAAIC,kGAASL,4GAAiBD,uBAC9B,iCAAA,0FAAA,YAAA,uFAAA,5MAAIM,kGAASJ,sGAAWtnB;0BAHlC,AAAA7rB,4CAAA6zC,WAAA,IAAA,jFAAOC;sBAAP,AAAA9zC,4CAAA6zC,WAAA,IAAA,7EAA2BE;IAKrBA,sBAAgB,gCAAA,dAAIP,kBAASO;IAC7BC,kBAAgB,iBAAAhd,kBAAK,CAAGyc,gBAAcM;IAAtB9c,kBAAA;AAAA,AAAA,SAAAD,kBAAAC,mBAAAD,kBAAAC;;AANtB,AAWE,eACE,AAACr4B,eAAKsG;eACN,kBAAIsuC,cACF,EAAI,qBAAA,pBAAOQ,0BACT,AAAClpC,mDAAMxG,IAAIkC,WACX,AAACkqC,iEAASpsC,sDACA,AAACmuC,gCAAkBuB,gBAAgB,AAACr1C,gBAAMktB,MAC1CrlB,iBACZ,EAAI,qBAAA,pBAAOwtC,0BACT,AAACtD,iEAASpsC,sDAAIwvC,oBAAoBttC,gBAClC,AAACkqC,iEAASpsC,sDACA,AAACkuC,qCAAuBsB,qBACxB,AAACrB,gCAAkBuB,gBAAgB,AAACr1C,gBAAMktB,MAC1CrlB;eACd,iBAAAO,oBAAKowB;AAAL,AAAA,oBAAApwB;AAAA,IAAAA,wBAEK,qDAAA,rDAACqM,gDAAK3O;AAFX,AAAA,GAAAsC;AAAA,IAAAA,wBAGK,qDAAA,rDAACqM,gDAAK3O;AAHX,AAAA,GAAAsC;AASK,OAAC4rC,kCAAoB,AAAC/zC,eAAKsG;;AAThC6B;;;AAAAA;;;AAAAA;;;eAsBA,iBAAAxD,mBAAI,iBAAAwD,oBAAKugB;AAAL,AAAA,oBAAAvgB;AAAmB,6DAAA,tDAACjG,6CAAE8yC;;AAAtB7sC;;;AAAJ,AAAA,oBAAAxD;AAAAA;;AAA2C6vC;;;eApC7C;eAAA;;;;;;;;;;;;;;AAyCd;;;;;;gCAAA,hCAAMvrB,wEAKHwrB,WAAW9sC,IAAIrB;AALlB,AAME,4CAAA,KAAA,KAAA,mFAAA,2KAAA,qDAAA,yDAAA,qBAAA,mFAAA,wFAAA,qDAAA,yDAAA,aAAA,2KAAA,qDAAA,yDAAA,gCAAA,/gCAAC8tC,qNAEyB,CAAA,iDAAU,AAAClnC,sBAAOvF,yTAClB,mNACA,CAAA,iDAAU,AAACuF,sBAAOvF,mJACpB8sC,gBAEAnuC;;AAE1B,kCAAA,6DAAA+uC,/FAAMG,4EACHjyC,OAAOC,MAAMC,eAMCkE,IAAI1F,KAAK4zC;AAP1B,AAAA,IAAAP,aAAAD;IAAAC,iBAAA,AAAAluC,4BAAAkuC;cAAAA,VAOQv0C;IAPRw0C,aAAA,AAAAluC,4CAAAiuC,eAMM/xC;IANNgyC,iBAAA,AAAAnuC,4BAAAmuC;kBAAAA,dAKSK;mBALT,AAAAvuC,4CAAAkuC,eAAA,1EAGYhd;iBAHZ,AAAAlxB,4CAAAkuC,eAAA,xEAGmBzwB;wBAHnB,AAAAzd,4CAAAkuC,eAAA,/EAG8BxwB;0BAH9B,AAAA1d,4CAAAkuC,eAAA,jFAGgD7sB;sBAHhD,AAAArhB,4CAAAkuC,eAAA,7EAG8D31B;qBAH9D,AAAAvY,4CAAAkuC,eAAA,5EAGwEG;6BAHxE,AAAAruC,4CAAAkuC,eAAA,pFAIYI;aAJZ,AAAAtuC,4CAAAkuC,eAAA,pEAI6Bh/B;sBAJ7B,AAAAlP,4CAAAiuC,eAAA,7EAEWr/B;YAFX,AAAA5O,4CAAAiuC,eAAA,nEAEqBG;gBAFrB,AAAApuC,4CAAAiuC,eAAA,vEAE2Bn/B;qBAF3B,AAAA9O,4CAAAiuC,eAAA,5EAEqCxyB;AAFrC,AAQE,GAAI,8IAAA,9IAAC5gB,6CAAE,AAAA,wFAASnB;AACd,IAAA+0C,WAEE,kBAAID,IAAG,CAAA,gDAASA,gDAAGryC,iBAAOA;IAF5BuyC,WAGEtyC;IAHFuyC,WAIEj1C;IAJFk1C,WAKEh0C;AALF,AAAA,oIAAA6zC,SAAAC,SAAAC,SAAAC,sDAAAH,SAAAC,SAAAC,SAAAC,xOAACtX,+DAAAA,oGAAAA;;AAMD,IAAAuX,aACQ,gDAAA,hDAACrb,iCAAmB95B,QAAQwC;wBADpC,AAAAnC,4CAAA80C,WAAA,IAAA,/EAAO5rB;wBAAP,AAAAlpB,4CAAA80C,WAAA,IAAA,/EAAmBnb;yBAAnB,AAAA35B,4CAAA80C,WAAA,IAAA,hFAA+Blb;AAA/B,AAEE,oBAAA,AAAA,mFAAQj6B;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD,wIAA+BwC;;AAAvC;;AACA,oBAAIy3B;AACF,IAAMj6B,cAAQ,sDAAA,tDAAC6C,8CAAM7C,uEAAmB,aAAA,ZAAKoV;IAEvC3S,YAAM,kBAAIqyC,IAAG,CAAA,gDAASA,gDAAGryC,iBAAOA;gBAFtC,mFAAA,6IAAA,5OAGMolB,kLAAYplB,UAAM,AAACiQ,yBAAW1S,YAAQyC;IACtCqlB,YAAU,AAACP,qDAASvnB,YAAQ4G,IAAI1F,KAAKwB;AAJ3C,AAKE,GAAI,uJAAA,tJAAO,CAACsX,mDAAAA,yDAAAA,RAAO9Y,sCAAAA;AACjB,OAACwP,mHAAcmX,UAAUC;;AACzB,OAACpX,mHAAcmX,UACA,uGAAA,KAAA,5GAACmR,2DAAex2B,OACAC,UACAC,MACA1C,YACA4G,IACA1F,gBAIhB4mB;;;AACnB,IAAM9nB,cAAQ,sDAAA,tDAAC6C,8CAAM7C,uEAAmB,aAAA,ZAAKoV;IACvClU,WAAK,kBAAI,iBAAAkG,oBAAK,mDAAA,nDAACjG,6CAAEuzC;AAAR,AAAA,GAAAttC;AAAsB,IAAAxD,mBAAImgB;AAAJ,AAAA,oBAAAngB;AAAAA;;AAAeogB;;;AAArC5c;;MACF,AAAC0c,yBAAWthB,OAAOxC,YAAQkB,MAC3BA;IAHbk0C,aAU0B,AAACjxB,iCACC3hB,OACA,AAACkL,4BAAc1N,aACf,iNAAA,iNAAA,hZAAMupB,mBAAY,CAAC+rB,yDAAAA,mEAAAA,ZAAap0C,gDAAAA,6BAC1B84B,mBAAY,CAACub,yDAAAA,mEAAAA,ZAAar0C,gDAAAA,WACpB,CAACs0C,oDAAAA,8DAAAA,ZAAQt0C,2CAAAA;;qBAfjD,AAAAb,4CAAA+0C,WAAA,IAAA,5EAUOhxB;eAVP,AAAA/jB,4CAAA+0C,WAAA,IAAA,tEAUgBnlB;IAMV1vB,IAAE,kBAAA,AAAAuC,eAAA,iFAAA,gEAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,pOAAO/C,uNAAAA,sCAGA,6CAAA,WAAAy1C,xDAACtkC;AAAD,AAAO,YAAAuhB,2BAAA,KAAA,EAAA,IAAA,AAAAA,sCAAA,sLAAA,rLAAQ,gBAAA+iB,hBAACjyC,kCAAS,gIAAAiyC,hIAACtkC,6CAAK,AAACqN,6CAAKk3B,iBAAOh0C;mBAHnD,hBAISuuB;IAIX7L,qBAAS,iBAAAxgB,mBAAIwgB;AAAJ,AAAA,oBAAAxgB;AAAAA;;AAAA,IAAAA,uBAAa2lB;AAAb,AAAA,oBAAA3lB;AAAAA;;AAAyBo2B;;;;IAxBxCqb,aA0BQ,iBAAAO,WAAU,0DAAA,1DAAC/yC,8CAAMgyC,wEAAsB9yB;IAAvC8zB,WAAiD5lB;IAAjD6lB,WAA0DhB;AAA1D,AAAA,gHAAAc,SAAAC,SAAAC,4CAAAF,SAAAC,SAAAC,xLAACC,qDAAAA,iFAAAA;;aA1BT,AAAA11C,4CAAAg1C,WAAA,IAAA,pEAyBOP;oBAzBP,AAAAz0C,4CAAAg1C,WAAA,IAAA,3EAyBUM;IAEJp1C,QAAE,kBAAA,AAAA,iGAAA,AAAA,AAAAwC,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,mCAAA,0CAAA,xZAAQnD,sNAAAA,iJAC4B80C,kBACjB1wB;IACrB3hB,YAAM,kBAAIqyC,QAAG,CAAA,gDAASA,oDAAGryC,iBAAOA;IAChCwtB,eAAS,iBAAArsB,mBAAI+xC;AAAJ,AAAA,oBAAA/xC;AAAAA;;AAAkBqsB;;;IAC3BA,eACE,kBAAI7L,oBAAS6L,aAAS,AAACtO,wBAAUnf,OAAOxC,YAAQhB,gBAAMixB;IAExD1iB,aAAW,AAACD,6BAAetN;IAC3Bg2C,aAAW,AAACxyC,gBAAMysB;IAClBA,eAAS,EAAI,CAAG+lB,aAAWzoC,aAChB,AAACf,+CAAO,AAACC,6CAAKc,WAAW0iB,cACjB,KAAAlhB,eAAA,oMAAA,KAAA,IAAA,xMAAM,KAAAA,eAAA,2JAAA,KAAA,IAAA,/JAAM,CAACqT,uDAAAA,yDAAAA,sEACrB6N;IACXza,aAAO,AAAChS,gBAAMf;gBAzCpB,mFAAA,6IAAA,5OA0CMolB,kLAAYplB,UAAM,AAACiQ,yBAAW1S,YAAQyC;IACtCqlB,YAAU,AAACP,qDAASvnB,YAAQ4G,IAAI1F,SAAKwB;AA3C3C,AA4CE,GAAI,AAAChC,uBAAOuvB;AACV,OAACvf,mHAAcmX,UAAUC;;AACzB,IAAMvnB,QAAE,kBAAA,AAAA,iGAAA,AAAA,AAAAwC,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,6KAAA,WAAA,sBAAA,+HAAA,xpBAAQnD,sNAAAA,qIACgB,CAAC0B,oDAAAA,8DAAAA,ZAAQR,2CAAAA,kBAClB0F,aACE4wB,yBACG,AAAA,0FAAWx3B;IAGjCi2C,sBACE,AAACp2B,iCACCrd,OAGA,kBAAI0S,iBAAUlV,YAAQ,0DAAA,+DAAA,zHAAC6C,8CAAM7C,kFAC7B,CAAGwV,aAAO5O,KACV4wB,aACAvH;IACJgmB,0BAAoB,AAAC53B,8BAAgB43B;IACrC11C,QAAE,2CAAA,zBAAM01C,yBACJ,kBAAA,AAAAnzC,eAAA,iFAAA,uDAAA,yEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,pOAAO/C,uNAAAA,oCAGA,iBAAAk2C,WAAA;IAAAC,WAAuBF;IAAvBG,eAAC,AAAA,yFAAUp2C;AAAX,AAAA,QAAAo2C,6CAAAA,2CAAAF,SAAAC,YAAAC,wBAAAF,SAAAC;iBAJT,NACE;IAMJ3oB,WAAS,2CAAA,qhCAAA,9iCAAMyoB,yBACJ,AAAC73C,8CAAMkN,4BACL,+BAAA,mFAAA,mFAAA,iGAAA,kEAAA,aAAA,mFAAA,IAAA,qDAAA,kEAAA,qBAAA,mFAAA,mFAAA,IAAA,qDAAA,kEAAA,z3BAAColC,yMACO,qCAAA,rCAACh+B,yBAAW1S,4qBAGlB,AAACq2C,qBAAW7e,cACZye;IACfvoB,iBAAe,AAAC/c,0BAAY3Q,YAAQ,CAAGwV,aAAO5O,KAAK4mB;IACnDA,eAAS,4DAAA,SAAA,nEAAM,AAACzb,6BAAe/R,YAAQ0tB,iBAC5BF;AAlCjB,AAmCE,oBAAIA;AACF,OAAC9c,mHAAcmX,UAAU2F,aAAS1F;;AAElC,GAAM,AAACzd,cAAI6K;AAAX,AAEE,IAAMohC,aAAW,AAACz2B,iCAAmBrd,OACAxC,YACA,CAAGwV,aAAO5O,KACV4wB,aACAvH;AAJrC,AAKE,OAACvf,mHACCmX,UAGA,qCAAA,mFAAA,mFAAA,iGAAA,kEAAA,aAAA,0LAAA,qDAAA,yDAAA,qBAAA,mFAAA,mFAAA,iGAAA,kEAAA,aAAA,mFAAA,KAAA,qDAAA,yDAAA,aAAA,0LAAA,qDAAA,yDAAA,qBAAA,mFAAA,0LAAA,qDAAA,yDAAA,qBAAA,mFAAA,mFAAA,KAAA,qDAAA,yDAAA,aAAA,0LAAA,qDAAA,yDAAA,5/EAACwrB,+MAEO,qCAAA,rCAAC3gC,yBAAW1S,sOAChB,CAAA,iDAAU,AAACmM,sBAAO,CAAGqJ,aAAO5O,8TACxB,qCAAA,rCAAC8L,yBAAW1S,ybAIhB,CAAA,iDAAU,AAACmM,sBAAO,CAAGqJ,aAAO5O,0TAE5B,CAAA,iDAAU,AAACuF,sBAAO,CAAGqJ,aAAO5O,6gBAE5B,CAAA,iDAAU,AAACuF,sBAAO,CAAGqJ,aAAO5O,oJAC9B,AAAA,iFAAM5G,aACNw3B,aACA8e,YACFxuB;;AA3BN;;;;;;;AA6BhB;;;4BAAA,5BAAMyuB,gEAEHv2C,QAAQ4G,IAAI1F;AAFf,AAGE,IAAAs1C,aACQ,kNAAA,hMAAM,CAACE,kEAAAA,wEAAAA,RAAgBx1C,qDAAAA,QAErB,iBAAMsoB,WAAS,CAAC6H,iDAAAA,0EAAAA,3BAAKF,uDAAAA,pCAASjwB,uDAAAA;AAA9B,AACE,oBAAA,AAAA,mFAAQlB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD,yIAAgC,AAAC4F,4CAAIlE,oBAAQ8nB;;AAArD;;AADF,0FAEG,iBAAAmtB,WAAS,AAAC33C,gBAAMwqB;AAAhB,AAAA,8GAAAmtB,2CAAAA,jJAACj1C,oDAAAA,8DAAAA;KAA0B,AAAC0C,iBAAOolB;KAJxC;SADR,AAAAnpB,4CAAAm2C,WAAA,IAAA,hEAAO1B;iBAAP,AAAAz0C,4CAAAm2C,WAAA,IAAA,xEAAUC;AAAV,AAME,oBAAA,AAAA,mFAAQz2C;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,sBAAA,4LAAA,nUAAQnD,oIACmB80C,aACT,AAAA,uFAAS,AAAA,iFAAM90C,yBACV,yIAAA,zIAAC2D,+CAAO,AAAA,iFAAM3D;;AAHrC;;AAIA,oBAAI80C;AACF,uCAAA,mDAAA,IAAA,vFAACL,2FAA0B,AAACxiC,wBAAUjS,SAAS4G,IAAI6vC,WAAW3B;;AAC9D,uCAAA,mDAAA,IAAA,8CAAA,rIAACL,2FAA0B,AAACxiC,wBAAUjS,SAAS4G,IAAI1F;;;AAEzD;;;kCAAA,lCAAM01C,4EAEHp3C;AAFH,AAGE,yBAAA,lBAAC8H,+BAAsB9H;;AAEzB,AAAA;;;;+BAAA,uCAAAjB,tEAAMu4C;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,2DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,2DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA/2C,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,6DAAA,7DAAM+2C,wEAGF92C,QAAQ4G,IAAI1F,KAAK61C;AAHrB,AAIG,uCAAA,yDAAA,WAAA,pGAACtH,wGAGazvC,QACA4G,IACA,CAACowC,wDAAAA,yEAAAA,nBAAY91C,sDAAAA,jDAAK61C,sDAAAA;;;AATnC,CAAA,6DAAA,7DAAMD,wEAUF92C,QAAQ4G,IAAI1F;AAVhB,AAWG,uCAAA,yDAAA,WAAA,pGAACuuC,wGAAoCzvC,QAAQ4G,IAAI,CAACowC,wDAAAA,8DAAAA,RAAY91C,2CAAAA;;;AAXjE,CAAA,uDAAA,vDAAM41C;;AAAN,AAaA;;;kCAAA,lCAAMG,4EAEHC;AAFH,AAKW,mDAAK,AAACC,eAAKD;;AAKtB,6BAAA,qCAAAE,lEAAMG,2EACoC3wC,IAAI1F;AAD9C,AAAA,IAAAm2C,aAAAD;IAAAC,iBAAA,AAAAhxC,4BAAAgxC;cAAAA,VACiCr3C;IADjCs3C,aAAA,AAAAhxC,4CAAA+wC,eAAA;IAAAC,iBAAA,AAAAjxC,4BAAAixC;oBAAA,AAAAhxC,4CAAAgxC,eAAA,3EACYE;AADZ,AAEE,oBAAI,iBAAApwC,oBAAKowC;AAAL,AAAA,oBAAApwC;AAAa,OAACwvC,gCAAY,CAACl1C,oDAAAA,0DAAAA,RAAQR,uCAAAA;;AAAnCkG;;;AACF,OAACqwC,2DAAez3C,QAAQ4G,IAAI1F,KAAK,CAACw2C,mDAAAA,yDAAAA,RAAOx2C,sCAAAA;;AACzC,YAAA,RAAMuB;YAAN,RACMC;IACA8S,SAAO,EAAO/S;gBAFpB,mFAAA,iIAAA,hOAGMolB,kLAAYplB,MAAM,AAACiQ,yBAAW1S,QAAQyC;IACtCqlB,YAAU,AAACP,qDAASvnB,QAAQ4G,IAAI1F,KAAKwB;IACrCoV,QAAM,CAAA,QAAa,AAACm/B,gCAAkB/1C;IACtCq3B,eAAa,CAAA,CAAA,iBAAA,hBAAG3xB,MAAI4O,iBAAS,EAAOsC;AAN1C,AAOE,oBAAA,AAAA,mFAAQ9X;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,6BAAA,9IAAQnD,wIACuB8X,uBACN,CAACpW,oDAAAA,0DAAAA,RAAQR,uCAAAA;;AAFlC;;AAGA,oIAAA,mFAAA,gLAAA,hYAACwP,mHAAcmX,gLACE/P,MAAM,iCAAA,jCAACpF,yBAAW1S,yIACpB,+BAAA,/BAACquB,0FACiB,AAACpc,wBAAUjS,SACXu4B,aACA,CAAG/iB,SAAO5O,KACV,CAAC8wC,mDAAAA,yDAAAA,RAAOx2C,sCAAAA,QAC1B4mB;;;AAErB;;;;;;mDAAA,nDAAM6vB,8GAKH33C,QAAQ4G,IAAI1F;AALf,AAME,IAAM02C,YAAU,6LAAA,yDAAA,gMAAA,2DAAA,0LAAA,uDAAA,0LAAA,uDAAA,j8BAAM,CAACC,2DAAAA,iEAAAA,RAAS32C,8CAAAA,mFACV,CAAC42C,4DAAAA,kEAAAA,RAAU52C,+CAAAA,qFACX,CAAC62C,0DAAAA,gEAAAA,RAAQ72C,6CAAAA,iFACT,CAAC82C,0DAAAA,gEAAAA,RAAQ92C,6CAAAA,+DACH,kBAAO,KAAAnB,MAAA,mCAGC,CAAC2B,oDAAAA,0DAAAA,RAAQR,uCAAAA;;AAP7C,AAQE,oBAAI,iBAAAkG,oBAAK,AAAA,0FAAU,CAACpH,wCAAAA,mDAAAA,bAAQ43C,gCAAAA;AAAxB,AAAA,oBAAAxwC;AAAoC,OAACwvC,gCAAY,CAACl1C,oDAAAA,0DAAAA,RAAQR,uCAAAA;;AAA1DkG;;;AACF,GAAI,EAAI,uDAAA,vDAACjG,6CAAEy2C,uEAAkB,AAACK,0BAAU/2C;AACtC,OAACu2C,2DAAez3C,QAAQ4G,IAAI1F,KAAK,CAACw2C,mDAAAA,yDAAAA,RAAOx2C,sCAAAA;;AACzC,OAACu2C,2DAAez3C,QAAQ4G,IAAI1F;;;AAC9B,YAAA,RAAMuB;YAAN,RACMC;IACA8S,SAAO,EAAO/S;gBAFpB,mFAAA,iIAAA,hOAGMolB,kLAAYplB,MAAM,AAACiQ,yBAAW1S,QAAQyC;IACtCqlB,YAAU,AAACP,qDAASvnB,QAAQ4G,IAAI1F,KAAKwB;IACrCw1C,WAAS,iBAAAC,WAAMP;IAANO,eAAA,EAAA,CAAAA,oBAAArlC,oBAAA,AAAAqlC,aAAA;AAAA,AAAA,QAAAA;KAAA;AAAA;;;KAAA;AAAA;;;KAAA;AAAA;;;KAAA;AAAA;;;;AAAA,MAAA,KAAAp4C,MAAA,CAAA,mEAAAo4C;;;;IAKTrgC,QAAM,6CAAKogC,UAAS,AAACjB,gCAAkB/1C;IAMrCq3B,eACF,CAAA,CAAA,iBAAA,hBAAG3xB,MAAI4O,iBAAS,EAAOsC;IAAQsgC,uBAC/B,kHAAA,hHAAI,uDAAA,vDAACj3C,6CAAEy2C,wEAAuB,AAACK,0BAAU/2C;IAAO8E,QAChD,EAAIoyC,sBACF,CAACV,mDAAAA,yDAAAA,RAAOx2C,sCAAAA,OACR,iBAAAm3C,WAAMT;IAANS,eAAA,EAAA,CAAAA,oBAAAvlC,oBAAA,AAAAulC,aAAA;AAAA,AAAA,QAAAA;KAAA;AAAA;;;KAAA;AAAA;;;KAAA;AAAA;;;;AAAA,MAAA,KAAAt4C,MAAA,CAAA,mEAAAs4C;;;;IAIAr4C,cACF,EAAIo4C,sBAAep4C,QAAQ,sDAAA,mEAAA,zHAAC6C,8CAAM7C;AA1BxC,AA2BE,oBAAA,AAAA,mFAAQA;AAAR,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,6BAAA,lJAAQnD,4IACuB8X,uBACN,CAACpW,oDAAAA,0DAAAA,RAAQR,uCAAAA;;AAFlC;;AAGA,oIAAA,mFAAA,oLAAA,pYAACwP,mHAAcmX,gLACE/P,MAAM,qCAAA,rCAACpF,yBAAW1S,6IACpB,+BAAA,/BAACquB,0FACiB,AAACpc,wBAAUjS,aACXu4B,aACA,CAAG/iB,SAAO5O,KACVZ,OAClB8hB;;;AAEvB;;;;;+BAAA,uCAAAwwB,tEAAMG,+EAIsC7xC,IAAI1F;AAJhD,AAAA,IAAAq3C,aAAAD;IAAAC,iBAAA,AAAAlyC,4BAAAkyC;cAAAA,VAImCv4C;IAJnCw4C,aAAA,AAAAlyC,4CAAAiyC,eAAA;IAAAC,iBAAA,AAAAnyC,4BAAAmyC;oBAAA,AAAAlyC,4CAAAkyC,eAAA,3EAIYhB;AAJZ,AAKE,oBAAI,iBAAApwC,oBAAKowC;AAAL,AAAA,oBAAApwC;AAAa,OAACwvC,gCAAY,CAACl1C,oDAAAA,0DAAAA,RAAQR,uCAAAA;;AAAnCkG;;;AACF,OAACqwC,2DAAez3C,QAAQ4G,IAAI1F;;AAC5B,YAAA,RAAMuB;YAAN,RACMC;IACA8S,SAAO,EAAO/S;gBAFpB,mFAAA,6KAAA,5QAGMolB,kLAAYplB,MAAM,iCAAA,jCAACiQ,yBAAW1S;IAC9B8nB,YAAU,4EAAA,5EAACP,qDAASvnB,QAAQ4G,IAAI1F,KAAKwB;iBAJ3C,bAKMg2C;IACAC,cAAY,AAAC1B,gCAAkB/1C;IAC/Bq3B,eAAa,CAAA,CAAA,CAAA,iBAAA,hBAAG3xB,MAAI4O,iBAAS,EAAOkjC,uBAAY,EAAOC;IACvDC,YAAU,AAACz1C,wGACgB,AAAC01C,eAAK33C;IAMtB43C,UAAQ,4CAAK,AAAQ53C;IAAO4K,QAC5B,kBAAI,iBAAAlI,mBAAI,kBAAA,lBAAC0D,6BAAoBwxC;AAAzB,AAAA,oBAAAl1C;AAAAA;;AACI,yBAAA,lBAAC0D,0BAAiBwxC;;0FAD1B,pFAEE,iCAAA,jCAACpmC,yBAAW1S;IACL+4C,aAAW,2DAAA,3DAAC7rC,mDAAqB4rC;IAC1CE,QACA,gMAAA,nJAAK,AAAC56C,8CAAMC,cAAI,kDAAA,lDAACovB,sDAAc,AAACZ,kBAAQksB,+DAEnC,AAAC5uC,eAAK4uC;AAvB5B,AAwBE,oBAAA,AAAA,mFAAQ/4C;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,gDAAA,jKAAQnD,0IAEA04C,WACAC,6BAEA,CAACj3C,oDAAAA,0DAAAA,RAAQR,uCAAAA;;AALjB;;AAMA,oIAAA,mFAAA,kLAAA,2EAAA,mFAAA,sLAAA,ttBAACwP,mHAAcmX,gLACE6wB,WAAW,iCAAA,jCAAChmC,yBAAW1S,4SACvB24C,YAAY,iCAAA,jCAACjmC,yBAAW1S,yIAC1B,+BAAA,/BAACquB,0FACiB,AAACpc,wBAAU,6DAAA,mEAAA,uDAAA,vLAACpP,qDAAM7C,wMAES8L,aAC3BysB,aACA,CAAG/iB,SAAO5O,KACVoyC,OAClBlxB;;;AAErB,2BAAA,3BAAMmxB,8DACHj5C,QAAQ4G,IAAI1F;AADf,AAEE,YAAA,RAAMuB;YAAN,RACMC;IACA8S,SAAO,EAAO/S;gBAFpB,mFAAA,iIAAA,hOAGMolB,kLAAYplB,MAAM,AAACiQ,yBAAW1S,QAAQyC;IACtCqlB,YAAU,AAACP,qDAASvnB,QAAQ4G,IAAI1F,KAAKwB;YAJ3C,RAKMoV;IACAygB,eAAa,CAAA,CAAA,iBAAA,hBAAG3xB,MAAI4O,iBAAS,EAAOsC;AAN1C,AAOE,oBAAA,AAAA,mFAAQ9X;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,2BAAA,5IAAQnD,sIAA6B8X,uBAAuB,CAACpW,oDAAAA,0DAAAA,RAAQR,uCAAAA;;AAArE;;AACA,oIAAA,mFAAA,gLAAA,hYAACwP,mHAAcmX,gLACE/P,MAAM,iCAAA,jCAACpF,yBAAW1S,yIACpB,+BAAA,/BAACquB,0FACiB,AAACpc,wBAAUjS,SACXu4B,aACA,CAAG/iB,SAAO5O,KACV,AAACsyC,kBAAQh4C,OAC3B4mB;;AAEnB;;;0BAAA,1BAAMqxB,4DAEHn5C;AAFH,AAGE,oBAAMA;AAAN,AAAc,6DAAA,tDAAC6C,8CAAM7C,+DAAe,CAAK,iBAAA4D,mBAAI,AAAA,qFAAQ5D;AAAZ,AAAA,oBAAA4D;AAAAA;;AAAA;;OAAL;;AAApC;;;AAEF,+BAAA,uCAAAw1C,tEAAMG,+EACsD3yC,IAAI1F;AADhE,AAAA,IAAAm4C,aAAAD;IAAAC,iBAAA,AAAAhzC,4BAAAgzC;cAAAA,VACmDr5C;IADnDs5C,aAAA,AAAAhzC,4CAAA+yC,eAAA;IAAAC,iBAAA,AAAAjzC,4BAAAizC;yBAAA,AAAAhzC,4CAAAgzC,eAAA,hFACYE;uBADZ,AAAAlzC,4CAAAgzC,eAAA,9EACyBG;AADzB,AAEE,oBAAIA;AACF,IAAAC,WAAU15C;IAAV25C,WAAkB/yC;IAAlBgzC,WAAsB,AAAG14C;AAAzB,AAAA,8HAAAw4C,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAAC7hC,4DAAAA,wFAAAA;;AACD,GAAA,AAAA1N,cAAQmvC;AAEN,IAAAK,WAAU75C;IAAV85C,WAAkBlzC;IAAlBmzC,WAAsB,6CAAA,7CAACltC,gFAAQ3L;AAA/B,AAAA,8HAAA24C,SAAAC,SAAAC,mDAAAF,SAAAC,SAAAC,7MAAChiC,4DAAAA,wFAAAA;;AACD,YAAA,RAAMtV;YAAN,RACMC;IACA8S,SAAO,EAAO/S;gBAFpB,mFAAA,iIAAA,hOAGMolB,kLAAYplB,MAAM,AAACiQ,yBAAW1S,QAAQyC;IACtCqlB,YAAU,AAACP,qDAASvnB,QAAQ4G,IAAI1F,KAAKwB;IACrCoV,QAEW,0JAAA,IAAA,9JAAChW,uBAAuB,AAACqB,wGAAO,AAAC01C,eAAK33C;IACjD4W,YAAM,iBAAMkiC,SAAO,yDAAA,zDAAC9sC,mDAAqB4K;AAAnC,AACE,OAAC1Z,8CAAMC,cAAI,6CAAA,7CAACwO,8EAAQ,kDAAA,lDAAC4gB,sDAAcusB;;IAC3CzhB,eAAa,CAAA,CAAA,iBAAA,hBAAG3xB,MAAI4O,iBAAS,AAAChS,gBAAMsU;AAV1C,AAWE,oBAAA,AAAA,mFAAQ9X;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,mCAAA,pJAAQnD,0IACyB8X,0BACT,CAACpW,oDAAAA,0DAAAA,RAAQR,uCAAAA;;AAFjC;;AAGA,oIAAA,mFAAA,oLAAA,pYAACwP,mHAAcmX,gLACE/P,UAAM,iCAAA,jCAACpF,yBAAW1S,yIACpB,+BAAA,/BAACquB,wFACiB,AAAC8qB,wBAAUn5C,SAEXu4B,aACA,CAAG/iB,SAAO5O,KAIV,6CAAA,7CAACiG,gFAAQ3L,OAC3B4mB;;;;AAEvB;;;;+CAAA,/CAAM4J,sGAGHnsB;AAHH,AAIE,IAAM00C,gBAAc,AAACC,mDAAWC,+BAAa50C;AAA7C,AAAoD,oDAAA,7CAACmH,iDAAOutC;;AAE9D;;;;+CAAA,/CAAMG,sGAGH70C;AAHH,AAIE,IAAOA,WAAKA;UAAZ,NACOZ;;AADP,AAEE,oBAAIY;AACF,IAAMR,UAAQ,AAAC/F,gBAAMuG;AAArB,AACE,GAAI,AAAC8E,cAAI,CAAC8vC,+DAAAA,wEAAAA,XAAap1C,qDAAAA;AACrB,OAACM,6CAAKV,IAAII;;AACV,eAAO,AAAC9F,eAAKsG;eAAM,AAACF,6CAAKV,IAAII;;;;;;AACjCJ;;;;;AAEN;;;;;;6BAAA,7BAAM01C,kEAKHr6C,QAAQ4G,IAAI1F;AALf,AAME,YAAA,RAAMuB;YAAN,RACMC;gBADN,mFAAA,iIAAA,hOAEMmlB,kLAAYplB,MAAM,AAACiQ,yBAAW1S,QAAQyC;IACtCqlB,YAAU,AAACP,qDAASvnB,QAAQ4G,IAAI1F,KAAKwB;IAErC8mB,WAAS,mCAAA,nCAACrB,uFAA2BnoB,QAAQkB;IAC7CsoB,eAAS,kBAAI,AAAA,wFAAS,AAAA,mFAAOxpB,WAKlB,AAACo6C,6CAA+B5wB,UAChCA;AAZjB,AAaE,oBAAA,AAAA,mFAAQxpB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,2KAAA,5RAAQnD,uIACsB,CAAC0B,oDAAAA,0DAAAA,RAAQR,uCAAAA,kBACpB,AAAC0E,4CAAIlE,oBAAQ8nB;;AAFhC;;AAGA,OAAC9Y,mHAAcmX,UACA,kBAAI,AAAA,kGAAe,AAAA,kFAAO7nB,WAIxB,2DAAA,+DAAA,oBAAA,KAAA,KAAA,xJAACg5B,oHACev2B,SAEAzC,QACA4G,IACA1F,gGAIhB,6DAAA,7DAAC+sB,kHAKCjuB,QAOA,AAAC5B,8CAAMs1B,iBACL,CAAG,EAAOjxB,iBAAOmE,KACjB,AAACtI,+CAAO,iCAAA,hCAAK,AAACkF,gBAAMgmB,qBAAW5iB,MACjC4iB,eACJ1B;;AAEnB;;;;;;qCAAA,rCAAMwyB,kFAKHt6C,QAAQ4G,IAAI1F;AALf,AAME,IAAMs5C,OAAK,iBAAAC,WAAS,CAAClnC,mDAAAA,yDAAAA,RAAOrS,sCAAAA;AAAjB,AAAA,8GAAAu5C,2CAAAA,jJAAC/4C,oDAAAA,8DAAAA;;IAINg5C,gBAAQ,EAAK,mEAAA,nEAACv5C,6CAAE,AAACqC,gBAAMg3C,gBAAS,wGAAA,xGAACr5C,6CAAE,kDAAA,IAAA,tDAACvB,6CAAK46C;IACzCG,qBAAa,wGAAA,xGAACx5C,6CAAE,kDAAA,IAAA,tDAACvB,6CAAK46C;IAKtBI,oBAAY,wGAAA,xGAACz5C,6CAAE,kDAAA,IAAA,tDAACvB,6CAAK46C;IACrBK,YAAI,EAAI,AAAC15C,6CAAE,iBAAA25C,WAAM,CAACC,oDAAAA,0DAAAA,RAAQ75C,uCAAAA;AAAf,AAAA,wGAAA45C,wCAAAA,xIAAC15C,iDAAAA,2DAAAA;KAAJ,6DAAiCs5C;IAX/CH,aAcQ,yCAAA,oEAAA,7GAACzgB,iCAAmB95B;wBAd5B,AAAAK,4CAAAk6C,WAAA,IAAA,/EAaOhxB;wBAbP,AAAAlpB,4CAAAk6C,WAAA,IAAA,/EAamBvgB;yBAbnB,AAAA35B,4CAAAk6C,WAAA,IAAA,hFAa+BtgB;IAEzBx3B,QAAM,yCAAA,MAAA,7CAAM,EAAKk4C,wBAAaE,qCAClB,iBAAAzzC,oBAAKuzC;AAAL,AAAA,GAAAvzC;AAAkB,IAAA4zC,WAAQ,CAACD,oDAAAA,0DAAAA,RAAQ75C,uCAAAA;AAAjB,AAAA,wHAAA85C,gDAAAA,hKAACn1B,yDAAAA,mEAAAA;;AAAnBze;;MADN,KAAA,EAEMuzC,oBACE,kBAAO,KAAA56C,MAEC,CAAA,4NAAA,tJAA+B,CAAC2B,oDAAAA,0DAAAA,RAAQR,uCAAAA,sEACjB,iBAAA+5C,WAAS,CAAC1nC,mDAAAA,yDAAAA,RAAOrS,sCAAAA;AAAjB,AAAA,8GAAA+5C,2CAAAA,jJAACv5C,oDAAAA,8DAAAA;sBANxC,sFAAA,AAAA,pFAOMk5C,mBAAY,CAAA,gDAASJ;;YAtBvC,RAwBM93C;IAEAnC,IAAE,uHAAA,AAAA,KAAA,1GAAM,AAAA,2FAAWP;IAGnBwV,SAAO,EAAO/S;gBA7BpB,mFAAA,iIAAA,hOAgCMolB,kLAAYplB,MAAM,AAACiQ,yBAAW1S,QAAQyC;IACtCqlB,YAAU,AAACP,qDAASvnB,QAAQ4G,IAAI1F,KAAKwB;IACrCw4C,OACE,EAAI,EAAKL,eAAI,GAAKH,mBAAU,iBAAAS,WAAQ,CAACJ,oDAAAA,0DAAAA,RAAQ75C,uCAAAA;AAAjB,AAAA,4GAAAi6C,0CAAAA,9IAAC5nC,mDAAAA,6DAAAA;KAAuB,CAACwnC,oDAAAA,0DAAAA,RAAQ75C,uCAAAA;AAnCrE,AAoCE,oBAAA,AAAA,mFAAQlB;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,mLAAA,6JAAA,eAAA,hdAAQnD,+IAC8B,CAAC0B,oDAAAA,0DAAAA,RAAQR,uCAAAA,eAC/B,CAACQ,oDAAAA,0DAAAA,RAAQw5C,uCAAAA,gBACRz4C,qBACMk4C;;AAJvB;;AAaA,oBAAI1gB;AACF,IAAMmhB,WAAS,EAAIT,oBAAa,OAAA,NAAKl4C,oBAAWA;IAC1C44C,WAAS,sBAAA,IAAA,xBAAIV;mBADnB,mFAAA,uIAAA,zOAEMW,qLAAeF,SAAS,AAAC1oC,yBAAW1S,QAAQo7C;IAC5CG,eAAa,AAACh0B,qDAASvnB,QAAQ4G,IAAI1F,KAAKm6C;AAH9C,AAIE,OAAC3qC,mHAAc4qC,aACA,EAAIX,oBACF,2DAAA,+GAAA,KAAA,/KAAC3hB,8GACeoiB,SACAC,SACA,AAACppC,wBAAUjS,SACX4G,IACAs0C,gBAIhB,2DAAA,4SAAA,KAAA,5WAACliB,8GAECoiB,SACAC,SACA,AAACppC,wBAAUjS,SACX4G,IACA,EAAIg0C,mBAAY,CAACY,0DAAAA,gEAAAA,RAAct6C,6CAAAA,OAAMA,kBAIzCq6C;;AACjB,oIAAA,mFAAA,mFAAA,GAAA,qDAAA,3VAAC7qC,mHACCmX,mTAKA,EAAI8yB,oBAEF,gCAAA,oEAAA,IAAA,yDAAA,jKAAClG,4GAGa,AAACxiC,wBAAUjS,SASX,CAAGwV,SAAO5O,KACVs0C,WAGd,AAACnxB,0DAAc/pB,QACA,CAAGwV,SAAO5O,KACV,iBAAM4iB,WACE,sOAAA,sOAAA,1bAAMD,mBAAY,CAAC2H,sDAAAA,+EAAAA,3BAAUC,4DAAAA,zCAASjwB,4DAAAA,yBAChC84B,mBAAY,CAAC5I,sDAAAA,+EAAAA,3BAAUD,4DAAAA,zCAASjwB,4DAAAA,OAC1B,CAACmwB,iDAAAA,0EAAAA,3BAAKF,uDAAAA,pCAASjwB,uDAAAA;;AAHnC,AAIE,GAAI05C;AAAY,OAAC37C,eAAKuqB;;AAAUA;;KANjD,2EAQF1B;;;AAER;;;;gCAAA,hCAAM2zB,wEAGHz7C,QAAQ4G,IAAI1F;AAHf,AAIE,IAAMs5C,OAAK,CAAC94C,oDAAAA,0DAAAA,RAAQR,uCAAAA;IAApBw6C,aACwB,AAACC,0BAAYnB;oBADrC,AAAAn6C,4CAAAq7C,WAAA,IAAA,3EACO5H;QADP,AAAAzzC,4CAAAq7C,WAAA,IAAA,/DACqBn7C;AADrB,AAEE,oBAAA,AAAA,mFAAQP;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,8KAAA,+BAAA,9TAAQnD,0IACyB,CAAC0B,oDAAAA,0DAAAA,RAAQR,uCAAAA,wBACjB4yC,qBACVltC;;AAHf;;AAIA,oDAAA,7CAACiG,8EACK,6DAAA,2KAAA,qDAAA,2DAAA,xVAACvO,+CAAOw1C,iGAAe,CAAA,iDAAU,AAAC3nC,sBAAOvF;;AAEnD,4BAAA,2CAAA,uDAAA,IAAA,sEAAA,IAAA,2DAAA,IAAA,6EAAA,KAAA,uDAAA,IAAA,mDAAA,KAAA,yDAAA,zgBAAKg1C;AASL;;;+BAAA,/BAAMC,sEAEH77C,QAAQ87C;AAFX,AAGE,GAAM,wDAAA,xDAAC36C,6CAAE26C;AAAoB,6DAAA,tDAACj5C,8CAAM7C,uEACM,AAAA,6FAAY,AAAA,uFAASA;;AAD/D,GAEM,wDAAA,xDAACmB,6CAAE26C;6CACG97C,nBACA,2BAAA,mFAAA,+DAAA,7KAAC0jB,4OACS,AAAA,8GAAqB,AAAA,6FAAY1jB,jdAC3C,4dAAA,mFAAA,+DAAA,vmBAAC0jB,irBACS,AAAA,8GAAqB,AAAA,6FAAY1jB;;AAPvD,AAQYA;;;;;AAEd;;;;;;;;;4BAAA,5BAAM+7C,gEAQH/7C,QAAQg8C,WAAWC,gBAAgBC;AARtC,AASE,+NAAA,WAAAC,nOAAC3c,kDAAUx/B,QACA,+CAAA,/CAACwM,kIAAQwvC,mBAAYE;AADhC,AAEY,AAAAC;AAAM,OAAC34B,+CAAOxjB,QAAQ,+CAAA,/CAACwM,kIAAQyvC,wBAAiBC;;;AAO9D;;;;;qCAAA,rCAAME,kFAIHp8C;AAJH,AAKE,oBAAA,AAAA,mFAAQA;AAAR,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,jHAAQnD;;AAAR;;AACA,IAAMq8C,aAAW,AAAA,sGAAA,RAAar8C;AAA9B,AACE,GAAM,AAACs8C,qBAAKD;AAAY,OAACr9C,gBAAM,gEAAA,cAAA,wIAAA,tNAACyB,mFAGC,uDAAA,vDAACkD,+CAAO3D,yEACRq8C;;AAJjC,GAOM,AAACzvC,wBAAQyvC;AAAY,sDAAA,WAAAE,iBAAAC,3EAACn9C;AAAD,AAAS,OAACL,gBACC,gEAAA,oBAAA,KAAAu9C,iBAAAC,iBAAA,3HAAC/7C;GAMV,uDAAA,vDAACkD,+CAAO3D,yEACRq8C;;AAf7B,GAgBM,wDAAA,xDAACl7C,6CAAEk7C;AAAmBr8C;;AAhB5B,AAiBYA;;;;;;AAQhB;;;;qCAAA,rCAAMy8C,kFAGH/mB;AAHH,AAIE,IAAOgnB,OAAKhnB;UAAZ,NACO/wB;;AADP,AAEE,GAAI,AAACjE,uBAAOg8C;AACV/3C;;AACA,IAAAg4C,aAAmC,AAAC39C,gBAAM09C;QAA1C,AAAAr8C,4CAAAs8C,WAAA,IAAA,/DAAOp8C;YAAP,AAAAF,4CAAAs8C,WAAA,IAAA,nEAASp8C;gBAAT,AAAAF,4CAAAs8C,WAAA,IAAA,vEAAWE;eAAXF,XAAyBG;IAAzBF,aACmC,AAACx4C,iBAAOs4C;YAD3C,AAAAr8C,4CAAAu8C,WAAA,IAAA,nEACOr8C;YADP,AAAAF,4CAAAu8C,WAAA,IAAA,nEACSr8C;gBADT,AAAAF,4CAAAu8C,WAAA,IAAA,vEACW9K;eADX8K,XACyB3tC;AADzB,AAEE,eAAO,AAAChQ,eAAKy9C;eACN,EAAI,EAAK,uDAAA,vDAACv7C,6CAAE07C,kFACH,EAAI,uDAAA,vDAAC17C,6CAAE2wC,2EAAoB,uDAAA,vDAAC3wC,6CAAE2wC,yEACrCntC,IACA,AAACU,6CAAKV,IAAIm4C;;;;;;;;AAE3B;;;;;iCAAA,jCAAMlf,0EAIHn7B,MAAMC,MAAM1C,QAAQkB;AAJvB,AAKE,gBAAA,mFAAA,iIAAA,hOAAM2mB,kLAAYplB,MAAM,AAACiQ,yBAAW1S,QAAQyC;IACtCqlB,YAAU,6DAAA,7DAACP,qDAASvnB,YAAUkB,KAAKwB;IACnCqc,MAAI,CAAC/E,mDAAAA,yDAAAA,RAAO9Y,sCAAAA;IACZX,IAAE,kBAAA,AAAAuC,eAAA,iFAAA,uDAAA,iFAAA,AAAA,+FAAA,AAAA,AAAAC,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,6KAAA,uBAAA,xgBAAUnD,mNAAAA,yIAEwB,CAAC0B,oDAAAA,0DAAAA,RAAQR,uCAAAA,cAC1B6d;IACnBg+B,oBAAa,iBAAAC,WAAqB,oFAAA,pFAACx3C,gDAAQuS,4BAAS/X;IAAvCi9C,WAAkD/7C;AAAlD,AAAA,sIAAA87C,SAAAC,uDAAAD,SAAAC,vMAACC,gEAAAA,mFAAAA;;IACd38C,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,uDAAA,iFAAA,AAAA,+FAAA,AAAA,AAAAC,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,+DAAA,nYAAUnD,mNAAAA,kJAGA+8C;IACZI,aACE,EAAI,SAAA,RAAOp+B,cACT,AAACrO,mHAAcmX,UAAUC,gBACzB,AAACpX,mHAAcmX,UAAU,AAACzpB,8CAAMg/C,iBAAOL,mBAAcj1B;IACzDvnB,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,uDAAA,iFAAA,AAAA,+FAAA,AAAA,AAAAC,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,sDAAA,1XAAUnD,mNAAAA,gJAAiDm9C;IAC7DE,oBAAkB,AAACZ,mCAAqBU;IACxC58C,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,uDAAA,iFAAA,AAAA,+FAAA,AAAA,AAAAC,yGAAA,AAAA,wGAAA,AAAAI,wGAAA,oEAAA,xYAAUnD,mNAAAA,uJAGAq9C;AArBlB,AAsBEA;;AAsBJ;;;8BAAA,sCAAAC,pEAAMvlC,6EAKWvC,OAAOtU;AALxB,AAAA,IAAAq8C,aAAAD;IAAAC,iBAAA,AAAAl3C,4BAAAk3C;cAAAA,VAKQv9C;gBALR,AAAAsG,4CAAAi3C,eAAA,vEAGoDM;gBAHpD,AAAAv3C,4CAAAi3C,eAAA,vEAE+BE;qBAF/B,AAAAn3C,4CAAAi3C,eAAA,5EAIiDU;qBAJjD,AAAA33C,4CAAAi3C,eAAA,5EAIWx7B;qBAJX,AAAAzb,4CAAAi3C,eAAA,5EAIoBQ;iBAJpB,AAAAz3C,4CAAAi3C,eAAA,xEAIgElB;YAJhE,AAAA/1C,4CAAAi3C,eAAA,nEAEyDG;qBAFzD,AAAAp3C,4CAAAi3C,eAAA,5EAE+D72C;eAF/D,AAAAJ,4CAAAi3C,eAAA,tEAEiB10C;YAFjB,AAAAvC,4CAAAi3C,eAAA,nEAEW30C;iBAFX,AAAAtC,4CAAAi3C,eAAA,xEAE0BC;uBAF1B,AAAAl3C,4CAAAi3C,eAAA,9EAE8C/2C;iBAF9C,AAAAF,4CAAAi3C,eAAA,xEAEyCz0C;mBAFzC,AAAAxC,4CAAAi3C,eAAA,1EAGiCK;2BAHjC,AAAAt3C,4CAAAi3C,eAAA,lFAG8DO;oBAH9D,AAAAx3C,4CAAAi3C,eAAA,3EAImCS;sBAJnC,AAAA13C,4CAAAi3C,eAAA,7EAGWroC;YAHX,AAAA5O,4CAAAi3C,eAAA,nEAG8C74C;wBAH9C,AAAA4B,4CAAAi3C,eAAA,/EAGqBI;AAHrB,AAME,IAAMQ,QAAM,CAAGv1C,QAAM4M;IAEfxV,cAAQ,sDAAA,tDAAC6C,8CAAM7C,+DAAe,SAAA,RAAK0E;IAEnCnE,IAAE,kBAAA,AAAAuC,eAAA,iFAAA,qEAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,+QAAA,sIAAA,juBAAUnD,uNAAAA,iIAEY,AAACmD,wGAAO,CAACzB,oDAAAA,0DAAAA,RAAQR,uCAAAA,4BACd,AAAA,8FAAalB;IACxCA,cAAQ,kBAAIq8C,YAOF,AAACD,mCAAqBp8C,aACtBA;IACVA,cAAQ,kBAAI,iBAAA4D,mBAAIkF;AAAJ,AAAA,oBAAAlF;AAAAA;;AAAA,IAAAA,uBAAS4C;AAAT,AAAA,oBAAA5C;AAAAA;;AAAoB85C;;;MACtB,0DAAA,1DAAC76C,8CAAM7C,6EACO,6CAAK,wDAAA,iEAAA,zHAACsG,4CAAItG,kFACL,mCAAA,IAAA,kCAAA,IAAA,AAAA,3DAAMkV,uCACAxO;cAEzB1G;IACVO,QAAE,kBAAA,AAAAuC,eAAA,iFAAA,qEAAA,sEAAA,AAAA,mGAAA,AAAA,AAAAC,yGAAA,AAAA,4GAAA,AAAAI,wGAAA,mCAAA,eAAA,iBAAA,2BAAA,yYAAA,nzBAAUnD,uNAAAA,+IAGA6I,kBAEAnE,gBAEA8Q,mBAEA9O,8BAEA,AAAA,8FAAa1G,aACb,AAACmD,wGAAO,CAACzB,oDAAAA,0DAAAA,RAAQR,uCAAAA;eApCnC,AAAAg9C,XAqCME,2BAAUn4C;IACVo4C,mBAAW,iBAAAj3C,oBAAK0B;AAAL,AAAA,oBAAA1B;AAAU,OAACjG,6CAAEi9C,SAAS,AAACh6C,iBAAO,CAACk6C,uDAAAA,6DAAAA,RAAWp9C,0CAAAA;;AAA1CkG;;;IACXpH,cAAQ,kBAAIq+C,kBAAW,0DAAA,kDAAA,5GAACx7C,8CAAM7C,+GAAkBA;IAChDO,QAAE,gLAAA,9JAAI89C,kBAAW,yGAAA,zGAACt7C,6HAA4Bq7C;AAxCpD,AA6CE,oBACE,iBAAAh3C,oBAAK,CAACye,yDAAAA,+DAAAA,RAAO3kB,4CAAAA;AAAb,AAAA,oBAAAkG;AACK,SAAI,CAAI1C,SAAMm5C,gBAAW,+CAAA,9CAAO,AAACvwC,6BAAetN;;AADrDoH;;;AAEE,GAAI,AAACjG,6CAAED,KAAK,CAACkhB,uDAAAA,yDAAAA;AAAb,0FAAA,mFAAA,iGAAA,3FACU,qCAAA,rCAAC1P,yBAAW1S;;AADtB,0FAAA,2SAAA,xNAEI,AAAA,2GAAmBA,aAAS,qCAAA,rCAAC0S,yBAAW1S;;;AALhD,oBAUE,iBAAAoH,oBAAKV;AAAL,AAAA,oBAAAU;AAAA,6CAAA,pCACK,AAACiD,cAAI6K,wBACL,AAAC7K,cAAI0X,qBAEL,EAAI,CAAG,CAAGrd,QAAMgC,kBAAUs3C,oBACtB,sCAAA,pCAAK,AAAC3zC,cAAI6K,wBACL,CAAG,CAAC8E,mDAAAA,yDAAAA,RAAO9Y,sCAAAA,SAAM+8C,qBACjB,CAAGv5C,QAAMq5C;;AAPvB32C;;;AAVF;;AAAA,oBAmBE,CAACm3C,2DAAAA,iEAAAA,RAASr9C,8CAAAA;AAAM,OAACq4C,6BAAev5C,YAAQwV,OAAOtU;;AAnBjD,oBAoBE,CAAC49B,yDAAAA,+DAAAA,RAAO59B,4CAAAA;AAAM,OAACmkC,2BAAarlC,YAAQwV,OAAOtU;;AApB7C,oBAqBE,CAACuY,2DAAAA,iEAAAA,RAASvY,8CAAAA;AAAM,OAACqvC,0BAAYvwC,YAAQwV,OAAOtU;;AArB9C,oBAsBE,iBAAA0C,mBAAI,CAACm7B,wDAAAA,8DAAAA,RAAM79B,2CAAAA;AAAX,AAAA,oBAAA0C;AAAAA;;AAAiB,QAAC8yC,kEAAAA,wEAAAA,RAAgBx1C,qDAAAA;;;AAAO,OAACq1C,0BAAYv2C,YAAQwV,OAAOtU;;AAtBvE,oBAuBE,CAAC89B,wDAAAA,8DAAAA,RAAM99B,2CAAAA;AAAM,OAACuvC,0BAAYzwC,YAAQwV,OAAOtU;;AAvB3C,oBAwBE,CAACs9C,2DAAAA,iEAAAA,RAASt9C,8CAAAA;AAAM,OAACokC,8BAAgBtlC,YAAQwV,OAAOtU;;AAxBlD,oBAyBE,CAACu9C,2DAAAA,iEAAAA,RAASv9C,8CAAAA;AAAM,OAACu3C,6BAAez4C,YAAQwV,OAAOtU;;AAzBjD,oBA0BE,CAACw9C,0DAAAA,gEAAAA,RAAQx9C,6CAAAA;AAAM,oBAAI,AAAA,0FAAU,AAAA,sFAAQlB;AACpB,OAACy3C,2DAAez3C,YAAQwV,OAAOtU;;AAC/B,OAACsvC,4BAMuBxwC,YACTwV,OACA,CAACmpC,yDAAAA,+DAAAA,RAAaz9C,4CAAAA;;;AApChD,oBAqCE,CAAC09C,yDAAAA,+DAAAA,RAAO19C,4CAAAA;AAAM,OAACq2C,2BAAav3C,YAAQwV,OAAOtU;;AArC7C,oBAsCE,CAACswB,yDAAAA,+DAAAA,RAAOtwB,4CAAAA;AAAM,OAACm5C,2BAAar6C,YAAQwV,OAAOtU;;AAtC7C,oBAuCE,iBAAA29C,WAAa,CAACz9C,iDAAAA,uDAAAA,RAAKF,oCAAAA;AAAnB,AAAA,0HAAA29C,iDAAAA,nKAACjD,0DAAAA,oEAAAA;;AACC,uCAAA,hCAACnM,mGACa,iBAAAqP,WAAa,CAAC19C,iDAAAA,uDAAAA,RAAKF,oCAAAA;AAAnB,AAAA,0HAAA49C,iDAAAA,nKAAClD,0DAAAA,oEAAAA;KADf,iFAQkB,AAACC,6BAAe77C,YAAQ,CAACoB,iDAAAA,uDAAAA,RAAKF,oCAAAA,xMAC9B,gNAAA,mEAAA,oDAAA,mFAAA,1ZAAC66C,1BACD,igBAAA,mEAAA,oDAAA,mFAAA,3sBAACA,1BACD,gzBAAA,mEAAA,oDAAA,mFAAA,1/BAACA,qkCACLvmC,OACAtU;;AArDlB,oBAsDE,CAAC69C,uDAAAA,6DAAAA,RAAK79C,0CAAAA;AAAM,OAAC+3C,yBAAWj5C,YAAQwV,OAAOtU;;AAtDzC,oBAuDE,iBAAA0C,mBAAI,CAACk0C,4DAAAA,kEAAAA,RAAU52C,+CAAAA;AAAf,AAAA,oBAAA0C;AAAAA;;AAAA,IAAAA,uBAAqB,CAACi0C,2DAAAA,iEAAAA,RAAS32C,8CAAAA;AAA/B,AAAA,oBAAA0C;AAAAA;;AAAA,IAAAA,uBAAqC,CAACm0C,0DAAAA,gEAAAA,RAAQ72C,6CAAAA;AAA9C,AAAA,oBAAA0C;AAAAA;;AAAoD,QAACo0C,0DAAAA,gEAAAA,RAAQ92C,6CAAAA;;;;;AAC3D,OAACy2C,iDAAmC33C,YAAQwV,OAAOtU;;AAxDvD,oBAyDE,CAAC89C,iEAAAA,uEAAAA,RAAe99C,oDAAAA;AAAM,OAACo5C,mCAAqBt6C,YAAQwV,OAAOtU;;AAzD7D,GA6DE,EAAK,yLAAA,zLAACC,6CAAE,CAACC,iDAAAA,uDAAAA,RAAKF,oCAAAA,wEAAgB,SAAA,RAAGwD;AAC/B,OAAC+2C,8BAAgBz7C,YAAQwV,OAAOtU;;AA9DpC,AAgEI,IAAMs5C,OAAK,CAAC94C,oDAAAA,0DAAAA,RAAQR,uCAAAA;IACd+9C,0BAAkB,iBAAA73C,oBAAKV;AAAL,AAAA,oBAAAU;AACK,QAAG,CAAA,CAAG,AAAC5D,gBAAMg3C,QAAMhlC,UAAO,iBAAA5R,mBAAIiF;AAAJ,AAAA,oBAAAjF;AAAAA;;AAAA;;QACvBgF;;AAFRxB;;;AADxB,AAIE,oBACE,iBAAAA,oBAAK,CAACkT,4DAAAA,kEAAAA,RAAUpZ,+CAAAA;AAAhB,AAAA,oBAAAkG;AAAsB,OAACiD,cAAI,eAAA,iFAAA,hGAACvH,wHAAW03C;;AAAvCpzC;;;AAEE,OAACq0C,8BAAgBz7C,YAAQwV,OAAOtU;;AAHpC,oBAIE,CAACoZ,4DAAAA,kEAAAA,RAAUpZ,+CAAAA;AACT,IAAMg+C,WAEE,EAAI,EAAK,WAAA,VAAOx6C,oBAAO,AAAC2F,cAAIyzC,yBAC1BtD,KAEA,AAAC2E,qBAAqB3E;IAI1B4E,qBAAmB,mNAAA,0CAAA,3OAAM,AAAA,0FAAU,AAAA,wFAAUp/C,eACxB,AAACq/C,oCAAen+C;AAV3C,AAWE,oBAAA,AAAA,mFAAKlB;AAAL,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,gDAAA,7DAAK/C,wCAC2B89C,2CACLsB;;AAF3B;;AAGA,oBAAI,iBAAAh4C,oBAAK,AAAA,uFAAS,AAAA,wFAAUpH;AAAxB,AAAA,oBAAAoH;AAAkC63C;;AAAlC73C;;;AACF,AAAI,oBAAA,AAAA,mFAAKpH;AAAL,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,bAAK/C;;AAAL;;AAAJ;;AACA,oBAAIo/C;AAAJ,0FAAA,4LAAA,zGACIF,SAAS,qCAAA,rCAACxsC,yBAAW1S,+IACrB,AAAChB,gBAAMogD,oBAAoB,AAACh7C,iBAAOg7C;;AAFvC,0FAAA,4LAAA,zGAGIF,SAAS,qCAAA,rCAACxsC,yBAAW1S;;;;AAxBjC,GAyBE,yLAAA,zLAACmB,6CAAE,CAACC,iDAAAA,uDAAAA,RAAKF,oCAAAA;AAzBX,0FAAA,qLAAA,lGAyB2Bs5C,KAAK,qCAAA,rCAAC9nC,yBAAW1S;;AAzB5C,GA0Ba,EAAK,yLAAA,zLAACmB,6CAAE,CAACC,iDAAAA,uDAAAA,RAAKF,oCAAAA,+EACT,oCAAA,pCAACgP,+BAAyBsqC;AA3B5C,0FAAA,mFAAA,iGAAA,7FA4BqB,qCAAA,rCAAC9nC,yBAAW1S;;AA5BjC,oBA8BE,CAACs/C,wEAAAA,8EAAAA,RAAsBp+C,2DAAAA;AA9BzB,0FAAA,wFAAA,qDAAA,kEAAA,5HA8BiCs5C;;AA9BjC,oBAqCEyE;AAAkB,AAAI,oBAAA,AAAA,mFAAKj/C;AAAL,AAAA,AAAA+C,yGAAA,AAAA,4GAAA,bAAK/C;;AAAL;;AAAJ;;AArCpB,oBAuCE,CAAC4+B,4DAAAA,kEAAAA,RAAU19B,+CAAAA;AAvCb,0FAAA,wLAAA,rGAuCqBs5C,KAAK,qCAAA,rCAAC9nC,yBAAW1S;;AAvCtC,AAwCQ,IAAMu/C,aAAW,AAACh+C,wBAAUvB,YAAQkB;AAApC,AACE,GAAM,OAASq+C;AAAf,0FAAA,uaAAA,pVAA6B,kBAAI5B,mBACG4B,WAEL,CAAC79C,oDAAAA,0DAAAA,RAAQR,uCAAAA,QACX,kBAAI08C,cACFA,aACA,qCAAA,rCAAClrC,yBAAW1S;;AAN3C,oBAQM,AAACiH,4BAAQjH,YAAQu/C;AARvB,0FAAA,gLAAA,7FASU/E,KAAK,qCAAA,rCAAC9nC,yBAAW1S;;AAT3B,oBAUM,AAAC8H,kCAAc9H,YAAQu/C;AAV7B,0FAAA,wLAAA,rGAWU/E,KAAK,qCAAA,rCAAC9nC,yBAAW1S;;AAX3B,GAYM,OAASu/C;AAZf,0FAAA,qZAAA,lUAaU,kBAAI/B,YAAK,CAACgC,oDAAAA,+EAAAA,7BAAQt+C,4DAAAA,vDAAKs8C,4DAAAA,jDAAKC,4DAAAA,YAAWjD,MACvC,qCAAA,rCAAC9nC,yBAAW1S;;AAdtB,GAeM,uBAAAuH,tBAASg4C;AAff,0FAAA,wLAAA,rGAgBU/E,KAAK,qCAAA,rCAAC9nC,yBAAW1S;;AAhB3B,GAiBM,eAAA,dAAMu/C;AAjBZ,0FAAA,+KAAA,5FAiB0B/E,KAAK,qCAAA,rCAAC9nC,yBAAW1S;;AAjB3C,GAmBM,AAAOu/C;AAnBb,0FAAA,oLAAA,jGAmB2B/E,KAAK,qCAAA,rCAAC9nC,yBAAW1S;;AAnB5C,GAqBM,AAAQu/C;AArBd,0FAAA,qLAAA,lGAqB4B/E,KAAK,qCAAA,rCAAC9nC,yBAAW1S;;AArB7C,GAuBM,AAACy/C,sBAAMF;AAvBb,0FAAA,mLAAA,hGAuB2B/E,KAAK,qCAAA,rCAAC9nC,yBAAW1S;;AAvB5C,oBAyBM,iBAAA4D,mBAAI,iBAAA87C,kBACoB,eAAA,fAAC7G;IADrB8G,kBAEWJ;AAFX,AAAA,QAAAI,2BAAAD;;AAAJ,AAAA,oBAAA97C;AAAAA;;AAGI,yBAAA,lBAAC0D,8BAAqBkzC;;;AA5BhC,0FAAA,oLAAA,jGA6BUA,KAAK,qCAAA,rCAAC9nC,yBAAW1S;;AA7B3B,AAAA,0FAAA,mLAAA,hGA8Bcw6C,KAAK,qCAAA,rCAAC9nC,yBAAW1S;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOnD;;;wBAAA,xBAAM4/C,wDAEH5/C,QAAQwV,OAAOtU;AAFlB,AAIE,oBAAA,AAAA,mFAAKlB;AAAL,AAAA,AAAA+C,yGAAA,AAAA,wGAAA,0BAAA,nCAAK/C,4BAA2BwV,2BAA2B,AAAA,uFAASxV;;AAApE;;AAKA,IAAMkB,WAAK,EAAA,AAAAmJ,cAAQ,iBAAAjD,oBAAK,2IAAA,3IAACjG,6CAAE,AAAA,qFAAQnB;AAAhB,AAAA,GAAAoH;AAAkC,OAAA,oFAAQ,AAAA,kFAAOpH;;AAAjDoH;;OACNlG,KACA,AAAC2+C,mCAAsB3+C,KAAK,AAAA,oFAAQ,AAAA,kFAAOlB;IAClD6G,YAAU,AAACkR,4BAAS,6DAAA,uDAAA,sDAAA,+DAAA,IAAA,7OAAClV,qDAAM7C,mPAKI,AAAC8/C,4BACZtqC,OACAtU;AAV1B,AAYE2F;;AAYJ;;;2BAAA,3BAAMk5C,8DAAuCvgD;AAA7C,AAAgD,oDAAA,5CAAK,AAACgE,gBAAM,iBAAA,jBAACw8C,sBAAaxgD;;AAE1E;;;4BAAA,5BAAMygD,gEAEHzgD;AAFH,AAGE,OAACoG,4CAAIpC,gBAAM,qDAAA,rDAAC0J,mDAAqB1N;;AAEnC;;;0BAAA,1BAAM0gD,4DAEH1gD;AAFH,AAGE,OAACH,+CAAOyR,cAAI,AAACmvC,0BAAYzgD;;AAM3B,AAAA;;;;4BAAA,oCAAAjB,hEAAM6hD;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,wDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,wDAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAArgD,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,0DAAA,1DAAMqgD,qEAGFC,SAAS7gD;AAHb,AAKG,GAAI,iCAAA,jCAAC0Q,+BAAyB1Q;AAC5B,OAACpB,8CAAMC,cACL,iBAAOiiD,WAAS,AAACv1C,cAAIvL;IACduO,UAAQ,gBAAA,hBAAC+d;IACTnnB,MAAI,qBAAA,rBAACyG;;AAFZ,AAGE,GAAI,AAAC1K,uBAAO4/C;AACV,OAACj1C,2BAAY1G;;AACb,IAAM47C,YAAU,AAACvhD,gBAAMshD;IACjBE,gBAAc,6GAAA,3GAAI,uDAAA,vDAACr/C,6CAAEo/C,iBACL,CAAGF,WAAS,AAACI,cAAI1yC,QAAQsyC;AAF/C,AAIE,eAAO,AAACK,eAAKJ;eACN,gEAAA,9DAAI,uDAAA,vDAACn/C,6CAAEo/C,qBAEL,CAAGxyC,UAAQ,AAAC+d,gBAAK,iBAAAloB,mBAAI48C;AAAJ,AAAA,oBAAA58C;AAAAA;;AAAA;;;eACnB,kBAAI48C,eACF,AAACpiD,8CAAMS,4BAAS8F,IAAI,6DAAA,7DAACrG,+CAAOkiD,oBAC5B,AAACr1C,mDAAMxG,IAAI47C;;;;;;;;;;AAC5B/gD;;;;AAvBL,CAAA,0DAAA,1DAAM4gD,qEAwBF5gD;AAxBJ,AAwBO,+DAAA,xDAACmhD,4DAAcnhD;;;AAxBtB,CAAA,oDAAA,pDAAM4gD;;AAAN,AA8BA;;;;;6CAAA,7CAAMQ,kGAIHphD;AAJH,AAKE,GAAI,iCAAA,jCAAC0Q,+BAAyB1Q;AAE5B,IAAMwS,QAAM,qDAAA,aAAA,lEAAC9E,mDAAqB1N;IAC5BqhD,cAAY,AAAC3zC,mDAAqB,+CAAA,/CAACtN,6CAAKJ,MAAI,iBAAAgO,kBAAK,AAAChK,gBAAMhE;IAAZiO,kBAAA;AAAA,AAAA,SAAAD,kBAAAC,mBAAAD,kBAAAC;MAAhC;IAGZ4f,WACE,+CAAA,WAAAyzB,iBAAAC,3EAAC1hD;AAAD,AAAS,GAAI,kCAAA0hD,iBAAA,nDAAC/1B;AAAqC,QAAA81B,mBAAA;;AAA1CA;;GAAT,IAEED;IAEJG,cAAY,sDAAA,OAAA,3DAAI,CAAI3zB,YAAS,gCAAA,/BAAG,AAAC7pB,gBAAMq9C;AAT7C,AAAA,0FAUGG,YAAYhvC;;AAZjB,0FAAA,KAcQ,qDAAA,KAAA,1DAAC9E,mDAAqB1N;;;AAQhC,AAAA,AAAA,AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,AAAA,CAAA,AAAA,8DAAA,WAAAyhD,mBAAAC,5FAAWsD;;AAAX,AAAA,IAAAvD,yBAAA;AAAA,AAAA,OAAAA,+DAAAC,gBAAA;;;AAAA,CAAA,AAAA,8DAAA,WAAAC,mBAAAC,OAAAC,nGAAWmD;;AAAX,AAAA,IAAArD,yBAAA;AAAA,AAAA,IAAAG,WAAAF;IAAAE,eAAA,EAAA,CAAAA,oBAAAxuC,oBAAA,AAAAwuC,aAAA;AAAA,AAAA,QAAAA;KAAA;AAAAt0C;;;KAAA;AAAAC;;;;AAAA,OAAA3G,4CAAAi7C,gBAAAH,OAAAC;;;;;AAAA,CAAA,AAAA,mEAAA,WAAAG,mBAAAC,gBAAAC,jHAAW8C;;AAAX,AAAA,IAAAhD,yBAAA;AAAA,AAAA,OAAAniD,+CAAA,WAAAsiD,kBAAAC;AAAA,AAAA,IAAAC,aAAAD;IAAAE,kBAAA,AAAAzhD,4CAAAwhD,WAAA,IAAA;IAAAE,kBAAA,AAAA1hD,4CAAAwhD,WAAA,IAAA;AAAA,AAAA,QAAAJ,gDAAAA,8CAAAE,kBAAAG,gBAAAC,mBAAAN,2BAAAE,kBAAAG,gBAAAC;GAAAL,mBAAAF;;;AAAA,CAAA,AAAA,0EAAA,WAAAQ,mBAAAC,qBAAAC,7HAAWsC;;AAAX,AAAA,IAAAxC,yBAAA;AAAA,AAAA,IAAAG,wBAAA,WAAAC;AAAA,AAAA,OAAAC,+BAAAJ,qBAAA,oBAAA,GAAA,IAAA,GAAAC,mBAAAE;;AAAA,AAAA,OAAAC,+BAAAJ,qBAAAE,sBAAA,oBAAA,KAAA,IAAAD,mBAAA,AAAA11C,+CAAA,mFAAA,KAAAkmB,2BAAA,KAAA,EAAA,IAAA,AAAAA,sCAAA,CAAA,qDAAA1lB,aAAA,OAAA,KAAA0lB,2BAAA,KAAA,EAAA,IAAA,AAAAA,sCAAA,CAAA,uDAAAzlB,cAAA,eAAAs0C;;;AAAA,CAAA,AAAA,kEAAA,WAAAe,7EAAWkC;;AAAX,AAAA,IAAAlC,eAAA;AAAA,AAAA,YAAAC,qBAAA,IAAAD,aAAA,EAAA,mFAAA,qDAAA,+DAAA,kBAAAf,iBAAA,AAAAiB,oBAAAjB,iBAAA,AAAAkB;;;AAAA,CAAA,AAAA,0DAAA,WAAAC,rEAAW8B;;AAAX,AAAA,IAAA9B,yBAAA;AAAA,AAAAC;;;AAAA,CAAA,AAAA,gEAAA,WAAAC,3EAAW4B;;AAAX,AAAA,IAAA5B,yBAAA;AAAA,AAAA,4BAAA51C,YAAAC,aAAA01C,cAAApB,gBAAAsB,vEAAW2B;;;AAAX,CAAA,AAAA,8DAAA,WAAA1B,zEAAW0B;;AAAX,AAAA,IAAA1B,yBAAA;AAAA,AAAA,QAAA,IAAA,AAAAt/C,gBAAA+9C;;;AAAA,CAAA,AAAA,0DAAA,WAAAwB,rEAAWyB;;AAAX,AAAA,IAAAzB,yBAAA;AAAA,AAAA,IAAAC,kBAAAH;AAAA,AAAA,GAAA,GAAA,CAAAG,mBAAA;AAAAA;;AAAA,IAAAA,sBAAA,AAAA,WAAAC;AAAA,AAAA,QAAA,cAAA,AAAAC,8BAAAD;GAAAF;AAAA,AAAA,CAAAF,gBAAAG;;AAAAA;;;;AAAA,CAAA,AAAA,4DAAA,WAAAG,UAAAC,jFAAWoB;;AAAX,AAAA,IAAArB,gBAAA;AAAA,AAAA,SAAA,GAAA,CAAAC,cAAA,aAAA,EAAA,CAAA,AAAAD,8BAAA,AAAAC,6BAAA,EAAA,AAAAjiD,6CAAA,AAAAgiD,mBAAA,AAAAC,sBAAA,EAAA,AAAAjiD,6CAAA,AAAAgiD,oBAAA,AAAAC,uBAAA,AAAAjiD,6CAAA,AAAAgiD,uBAAA,AAAAC;;;AAAA,CAAA,AAAA,2DAAA,WAAAC,mBAAAC,zFAAWkB;;AAAX,AAAA,IAAAnB,yBAAA;AAAA,AAAA,GAAA,AAAAE,0BAAA,iFAAA,4DAAA,yEAAAD;AAAA,OAAA3/C,+CAAA,AAAA6/C,qBAAA,AAAA32C,6CAAA,mCAAAw2C,wBAAAV,eAAAW;;AAAA,4BAAAt2C,YAAAC,aAAA01C,cAAA,AAAAc,oBAAA,AAAA9/C,+CAAA49C,gBAAA+B,kBAAA,5JAAWkB;;;;AAAX,CAAA,AAAA,gFAAA,WAAAd,mBAAAtC,9GAAWoD;;AAAX,AAAA,IAAAd,yBAAA;AAAA,AAAA,IAAAC,WAAAvC;IAAAuC,eAAA,EAAA,CAAAA,oBAAA7wC,oBAAA,AAAA6wC,aAAA;AAAA,AAAA,QAAAA;KAAA;KAAA;AAAA;;;;AAAA,OAAAJ,0BAAAhC,gBAAAH;;;;;AAAA,CAAA,AAAA,kEAAA,WAAAwC,mBAAAC,gBAAAvB,hHAAWkC;;AAAX,AAAA,IAAAZ,yBAAA;AAAA,AAAA,IAAAE,cAAAC;IAAAC,cAAAH;AAAA,AAAA,oBAAA,CAAAC,4CAAAA,0CAAA,qDAAAE,eAAAF,uBAAA,qDAAAE;AAAA,4BAAA1B,SAAAr1C,aAAA01C,cAAApB,gBAAA,pEAAWiD;;AAAX,oBAAA,CAAAV,4CAAAA,0CAAA,uDAAAE,eAAAF,uBAAA,uDAAAE;AAAA,4BAAAh3C,YAAAs1C,SAAAK,cAAApB,gBAAA,nEAAWiD;;AAAX,4BAAAx3C,YAAAC,aAAA01C,cAAA,AAAA9/C,8CAAA0+C,gBAAAsC,gBAAAvB,UAAA,/IAAWkC;;;;;AAAX,CAAA,AAAA,4DAAA,WAAAP,vEAAWO;;AAAX,AAAA,IAAAP,yBAAA;AAAA,AAAA,OAAAl5C,cAAA,AAAAyB,+CAAA,mFAAA,KAAA03C,mBAAA,qDAAAl3C,YAAA,OAAA,KAAAk3C,mBAAA,uDAAAj3C,aAAA,eAAAs0C;;;AAAA,CAAA,AAAA,mEAAA,WAAA4C,mBAAA7B,jGAAWkC;;AAAX,AAAA,IAAAL,yBAAA;AAAA,AAAA,4BAAAn3C,YAAAC,aAAAq1C,SAAAf,gBAAAsB,lEAAW2B;;;AAAX,CAAA,AAAA,gEAAA,WAAAJ,mBAAAC,9FAAWG;;AAAX,AAAA,IAAAJ,yBAAA;AAAA,AAAA,GAAA,AAAAx3C,wBAAAy3C;AAAA,OAAAD,mEAAA,AAAAE,eAAAD,oBAAA,KAAA,AAAAC,eAAAD,oBAAA;;AAAA,OAAAhlD,+CAAAklD,gBAAAH,uBAAAC;;;;AAAA,CAAA,AAAAG,2BAAA;AAAA,AAAA,AAAA;;;AAAA,CAAA,AAAAA,iCAAA;;AAAA,CAAA,AAAAA,sCAAA,WAAAC;AAAA,AAAA,YAAA11C,eAAA,KAAA,kBAAA,KAAA,IAAA;;;AAAA,CAAA,AAAAy1C,yCAAA,WAAAC,mBAAAC;AAAA,AAAA,OAAAC,iBAAAD,qBAAA;;;AAAA;;;uBAAA,vBAAWM,sDAAGh4C,KAAKC;AAAnB,AAAA,YAAAu3C,2BAAA,KAAA,KAAA,rBAAcx3C,KAAKC;;;AAAnB;;;0BAAA,kCAAA23C,5DAAWK;AAAX,AAAA,IAAAJ,uBAAA,iBAAAC,WAAA,AAAAnhD,sDAAAihD,SAAA,uGAAA;AAAA,AAAA,GAAA,AAAAG,wBAAAH;AAAA,OAAA/3C,6CAAA,mCAAAi4C;;AAAAA;;;AAAA,AAAA,YAAAN,gBAAA,AAAA,mFAAAI,UAAA,AAAA,qFAAAA,UAAA,KAAA,AAAAnB,oBAAAoB,sBAAA;;;AAAAL,AACA,4BAAA,5BAAMU,gEAAal4C,KAAKC;AAAxB,AAA+B,uCAAA,KAAA,KAAA,rCAAKu3C,gBAAEx3C,KAAKC","names":["zprint.zprint/dots","n","cljs.core.apply","cljs.core/str","cljs.core.repeat","var_args","args__5732__auto__","len__5726__auto__","i__5727__auto__","argseq__5733__auto__","cljs.core/IndexedSeq","zprint.zprint/conj-it!","seq79986","G__79987","cljs.core/first","cljs.core/next","self__5711__auto__","to","rest","cljs.core.reduce","cljs.core/conj!","zprint.zprint/split-lf-2","s","temp__5821__auto__","next-lf","clojure.string.index_of","cljs.core.subs","G__79992","zprint.zprint/internal-config-and-validate","js/Error","options","new-map","error-str","validate?","vec__79994","cljs.core.nth","updated-map","_","errors","zprint.config.config_and_validate","cljs.core/empty?","zprint.zprint.internal_config_and_validate","zprint.zprint/option-fn-name","option-fn","e80000","option-fn-name","e","zprint.zprint/zsexpr-token?","zloc","cljs.core._EQ_","zprint.zfns/ztag","zprint.zfns/zsexpr?","zprint.zprint/empty-coll","zprint.zprint/get-sexpr","e80005","zprint.zfns/zsexpr","zprint.zfns/zstring","new-s","p1__80003#","p2__80004#","clojure.string/replace","sexpr","e80006","rewrite-clj.parser/parse-string","clojure.string/trim","new-zloc","rewrite_clj.zip.of_node_STAR_","zprint.zprint/get-sexpr-or-nil","e80008","zprint.zprint/call-option-fn","caller","l-str","r-str","vec__80013","sexpr-seq","cljs.core.assoc","cljs.core/some","cljs.core.println","merged-options","new-options","e80019","cljs.core.pr_str","result","G__80021","G__80022","G__80023","cljs.core/count","new-l-str","new-r-str","cljs.core.dissoc","or__5002__auto__","zprint.zprint/call-option-fn-first","option-fn-first","first-sexpr","zprint.zfns/zfirst-sexpr","e80025","zprint.zprint/guide-debug","debug-vector","cljs.core/second","p__80027","p__80028","vec__80029","vec__80032","zprint.zprint/condense","depth","out","accumulated-string","current-depth","what","element","new-depth","accumulating?","start-accumulating?","new-accumulated-string","next-accumulated-string","cljs.core.conj","zprint.zprint/condense-depth","coll","cljs.core.partial","G__80036","zprint.zprint/zpmap","f","cljs.core.map","coll1","coll2","zprint.zprint/zat","value","zprint.zprint/fzprint-dbg","cljs.core.atom","p__80037","map__80038","cljs.core/--destructure-map","cljs.core.get","zprint.zprint/log-lines","dbg-print?","dbg-indent","in-hang?","dbg-output","ind","style-vec","cljs.core.prn","p__80040","map__80041","zprint.zprint/showfn?","fn-map","color?","and__5000__auto__","f-str","cljs.core/re-find","cljs.core/Symbol","e80042","cljs.core/meta","G__80043","cljs.core/name","p__80044","map__80045","zprint.zprint/show-user-fn?","user-fn-map","e80046","zprint.zprint/right-separator-map","p__80047","p__80048","p__80049","map__80050","map__80051","map__80052","map__80053","vec__80054","vec__80057","zprint.zprint/good-enough?","width","rightcnt","dbg?","general-hang-adjust","hang-expand","hang-diff","hang-size","hang-adjust","hang-flow","hang-type-flow","hang-flow-limit","hang-if-equal-flow?","fn-style","p-count","indent-diff","p-lines","p-maxwidth","p-length-seq","p-what","b-lines","b-maxwidth","b-what","p-last-maxwidth","cljs.core/last","tuning","cljs.core/not","zprint.zprint/fix-rightcnt","factor","zprint.zprint/in-hang","zprint.zprint/contains-nil?","p1__80060#","cljs.core/coll?","zprint.zprint/concat-no-nil-pre-noseq","seq80061","self__5712__auto__","cljs.core/seq","v","o","cljs.core/reduced","cljs.core.conj_BANG_","cljs.core/transient","cljs.core/persistent!","zprint.zprint/concat-no-nil","seq80062","vec__80063","right-ind","last-element","cljs.core/peek","vec__80066","previous-index","color","previous-what","zprint.zprint/count-right-blanks","new-previous","zprint.zprint/trimr-blanks","zprint.comment/blanks","zprint.zprint/concat-no-nil-pre-right","seq80069","zprint.zprint/remove-one","index","cljs.core.concat","cljs.core.take","cljs.core.drop","zprint.zprint/force-vector","cljs.core/vector?","cljs.core.into","zprint.zprint/keyword-fn?","vec__80070","left","right","clojure.string.split","fexpr__80073","p__80074","map__80075","zprint.zprint/get-max-length","max-length","x__5090__auto__","y__5091__auto__","zprint.zprint/no-max-length","p__80076","vec__80077","zprint.zprint/accumulate-ll","count-comment?","cur-len","just-eol?","just-comment?","in","tag","eol?","comment?","count-s","p__80080","p__80081","vec__80082","vec__80085","zprint.zprint/generate-ll","vec__80088","l","r","cljs.core/List","zprint.zprint/line-lengths-iter","next-vec","current-string","line-length","previous-comment?","vec__80097","vec__80100","advance?","next-string","force-newline?","new-line-length","zprint.zprint/line-lengths","length-vec","vec__80106","zprint.zprint/single-line?","p1__80109#","p2__80110#","p1__80111#","clojure.string/includes?","zprint.zprint/find-what","s-vec","vec__80112","this","zprint.zprint/first-nl?","vec__80116","zprint.zprint/prepend-nl","zprint.zprint.concat_no_nil","zprint.zprint/style-lines","lengths","count-lengths","cljs.core/max","dbg-ge","zprint.zprint/style-lines-hangflow","hangflow-style-vec","style-vecs","cljs.core.mapv","style-lines-map","cljs.core/flatten","p1__80119#","p__80120","p__80121","map__80122","vec__80123","zprint.zprint/fzfit","line-count","max-width","style-lines-return","zprint.zprint/fzfit-one-line","lines","zprint.zprint/rightmost","zprint.zprint/not-rightmost","zprint.zprint/c-r-pair","commas?","rightmost-pair?","rightmost?","zprint.zprint/str->key","p__80126","map__80127","zprint.zprint/zcolor-map","color-map","key-or-str","G__80128","cljs.core/Keyword","zprint.zprint/hangflow","hangflow?","hang-or-flow","zprint.zprint/fzprint-hang-unless-fail","hindent","findent","fzfn","G__80129","zprint.zfns/zfirst","hanging","cljs.core.not_EQ_","G__80130","G__80131","G__80132","value__66548__auto__","zprint.zprint/replace-color","local-color","vec__80133","vec__80136","string","p__80139","map__80140","map__80141","zprint.zprint/use-hang?","hang-accept","ha-depth-factor","ha-width-factor","hang-count","hanging-line-count","p__80142","p__80143","map__80144","map__80145","vec__80146","zprint.zprint/fzprint-two-up","one-line?","do-in-hang?","map-depth","hang?","dbg-local?","dbg-cnt?","indent","indent-arg","flow?","key-color","key-depth-color","key-value-color","key-value-options","justify","multi-lhs-hang?","justify-width","justify-options","narrow-width","force-flow?","lloc","rloc","xloc","pair","vec__80157","vec__80160","vec__80163","local-hang?","non-justify-options","local-options","loptions","loptions-non-narrow","roptions","non-justify-roptions","local-roptions","value-color-map","G__80167","zprint.config.merge_deep","value-options-map","G__80168","modifier-set","modifier?","G__80169","zprint.zprint/middle-element?","G__80170","arg-1","zprint.zprint/fzprint*","no-justify","arg-1-newline?","zprint.zfns/znewline?","arg-1-line-count","arg-1-max-width","arg-1-lines","combined-arg-1","G__80177","G__80178","G__80179","arg-1-fit-oneline?","arg-1-fit?","arg-1-width","justifying?","G__80181","cljs.core/ffirst","G__80189","G__80190","G__80191","hanging-width","justify-width-n","arg-1-width-n","hanging-spaces","hanging-indent","flow-indent","zprint.zfns/zvector?","vec__80196","zprint.zprint/fzprint-binding-vec","vec__80199","G__80208","G__80209","G__80210","zprint.zfns/zcount","hanging-lines","fit?","flow-it?","flow","flow-lines","zprint.zfns/zcomment?","G__80225","G__80226","G__80227","G__80228","G__80229","G__80230","zprint.zprint/fzprint-flow-seq","cljs.core/nnext","G__80237","G__80238","G__80239","G__80240","G__80241","G__80242","p__80268","map__80273","map__80274","zprint.zprint/fzprint-justify-width","justify?","coll-2-or-more","cljs.core.remove","cljs.core/nil?","p1__80249#","p1__80250#","ignore-for-variance","firsts","p1__80253#","narrow-result","G__80282","G__80283","G__80284","G__80285","G__80286","G__80287","p1__80255#","G__80288","cljs.core/true?","p1__80256#","p1__80257#","G__80289","style-seq","each-one-line?","p1__80258#","p2__80259#","max-gap-configured","max-gap-allowed","max-gap","widths","min-width","cljs.core/min","max-gap-ok?","max-variance","alignment","zprint.util/column-width-variance","cljs.core/vec","p1__80262#","p1__80263#","G__80295","zprint.zprint/fit-within?","size","zprint.zprint.fit_within_QMARK_","remaining","zprint.zprint/remove-hangflow","hf-style-vec","zprint.zprint/pair-lengths","cljs.core.comp","p__80299","map__80300","map__80301","zprint.zprint/fzprint-two-up-pass","force-nl?","parallel?","len","beginning-coll","cljs.core/pop","beginning-remaining","beginning","zprint.zprint.zpmap","end-coll","end-remaining","end","temp__5823__auto__","end-result","p__80326","map__80327","map__80328","zprint.zprint/fzprint-map-two-up","vec__80329","vec__80332","caller-options","lhs-narrow","use-narrow?","justify-narrow-width","G__80335","flow-all-if-any?","result-narrow","result-lines","result-narrow-lines","G__80336","flow-all-if-any-fail?","hang-flow-set","cljs.core/set","G__80338","G__80339","fexpr__80337","zprint.zprint/compare-keys","x","y","cljs.core/compare","zprint.zprint/compare-ordered-keys","key-value","divider-value","zdotdotdot","p__80344","map__80345","map__80346","zprint.zprint/order-out","sort?","sort-in-code?","key-order","in-code?","access","p1__80342#","p2__80343#","cljs.core.sort","zprint.zfns/zdotdotdot","zprint.zprint/pair-element?","zprint.zfns/zuneval?","zprint.zprint/nosort?","no-sort-set","regex-seq","cljs.core.filter","cljs.core/string?","p1__80380#","p__80382","map__80383","zprint.zprint/remove-key-seq","m","ks","this-key","next-key","removed-map","G__80384","G__80385","zprint.zprint/ignore-key-seq-silent","cljs.core.get_in","zprint.zprint/ignore-key-seq","cljs.core/assoc-in","p__80387","map__80388","map__80389","zprint.zprint/map-ignore","key-ignore","key-ignore-silent","ignored-silent","ignored","zprint.zprint/partition-all-2-nc","no-sort?","G__80402","G__80403","vec__80404","new-remaining","pair-vec","new-no-sort?","vec__80407","comment-seq","rest-seq","p1__80390#","cljs.core/split-with","G__80410","G__80411","G__80412","zprint.zprint/cleave-end","G__80414","zprint.zfns/zsymbol?","G__80415","zprint.zfns/zreader-cond-w-symbol?","vec__80416","rev-seq","cljs.core/reverse","split-non-coll","p1__80413#","zprint.zfns/zcoll?","zprint.zfns/zreader-cond-w-coll?","cljs.core/list","remainder","zprint.zprint/partition-all-sym","part-sym","p1__80419#","cljs.core.partition_by","zprint.zfns/znil?","cljs.core.mapcat","vec__80433","next-remaining","new-out","G__80436","G__80437","G__80438","G__80439","G__80440","G__80441","cljs.core/nthnext","G__80442","G__80443","cljs.core/cons","G__80448","zprint.zprint/rstr-vec","r-type","zprint.zprint.rstr_vec","p__80451","map__80452","map__80453","nl-separator?","G__80456","l-str-vec","r-str-vec","G__80457","G__80458","G__80459","zprint.zprint/interpose-nl-hf","zprint.zprint/fzprint-get-zloc-seq","p__80462","map__80463","zprint.zprint/fzprint-hang","force-eol-blanks?","zloc-count","fexpr__80464","G__80465","G__80466","G__80467","G__80468","fexpr__80470","hr-lines","fd-lines","hr-good?","G__80474","zprint.zprint/fzprint-pairs","p__80476","map__80477","map__80478","respect-nl?","zloc-seq","G__80479","G__80480","G__80481","G__80482","vec__80483","part","zprint.zprint.fzprint_pairs","zprint.zprint/check-for-coll?","zprint.zprint/check-for-first-coll?","seq-series","p__80492","map__80493","map__80494","zprint.zprint/fzprint-extend","G__80495","p1__80491#","G__80497","G__80498","G__80499","G__80500","G__80501","G__80502","zprint.zprint/fzprint-hang-remaining","clojure.string/starts-with?","G__80504","G__80505","G__80506","zprint.zprint/concatv!","seq80509","G__80510","cols","col","zprint.zprint/fzprint-one-line","seq-right","last-index","gt-1?","new-ind","cljs.core/long","vec__80552","vec__80555","next-zloc","sep","next-options","next-out","next-lines","zprint.zprint.concatv_BANG_","zprint.zprint/fzprint-seq","p1__80564#","p2__80565#","G__80569","G__80570","G__80571","cljs.core/butlast","G__80573","G__80574","G__80575","G__80577","p__80578","map__80579","map__80580","nl-count","nl-first?","coll-print","one-line","cljs.core.interpose","one-line-lines","G__80581","G__80582","G__80583","G__80584","G__80585","zprint.zprint/precede-w-nl","zprint.zprint.fzprint_flow_seq","p__80592","map__80593","map__80594","zprint.zprint/fzprint-hang-one","hang-avoid","G__80597","G__80598","G__80599","G__80600","zprint.zprint/count-constant-pairs","constant-pair-fn","zloc-seq-rev","element-count","paired-element-count","constant-required?","pair-size","actual-pair-size","comment-or-newline?","zprint.zprint/zcomment-or-newline?","G__80623","zprint.zfns/zconstant?","p__80630","map__80631","map__80632","zprint.zprint/constant-pair","constant-pair?","constant-pair-min","vec__80633","paired-item-count","actual-paired-items","non-paired-item-count","pair-seq","zprint.zprint/ensure-start-w-nl","element-type","zprint.zprint/ensure-end-w-nl","G__80649","p__80650","map__80651","map__80652","G__80653","G__80654","vec__80655","vec__80658","vec__80661","vec__80664","hang-result","flow-result","zprint.zprint.fzprint_hang_remaining","zprint.zfns/zmap-w-nl","cljs.core/identity","zprint.zfns/zmap-w-bl","zprint.zfns/zmap","zprint.zprint/extract-meta","out-vec","zprint.zfns/zmeta?","G__80676","zprint.zprint/drop-thru-first-non-whitespace","G__80677","G__80678","G__80679","G__80680","G__80681","cljs.core/conj","zprint.zprint/fzprint-split-meta-in-seq","zprint.zprint/newline-or-comment?","zloc-tag","zprint.zprint/remove-last-newline","ssv","last-style-vec","last-len","total-len","remove-one","cljs.core/PersistentVector","zprint.zprint/remove-one-newline","zprint.zprint/add-newline-to-comment","fzprint*-return","the-type","zprint.zprint/gather-up-to-next-zloc","nloc-seq","next-count","p__80692","vec__80697","zprint.zprint/fzprint-up-to-next-zloc","current-count","next-data","starting-count","vec__80703","pre-next-zloc-seq","cljs.core/vector","coll-out","first-type","zprint.zprint/fzprint-up-to-first-zloc","p__80719","vec__80720","zprint.zprint/get-zloc-seq-right","input-data","zprint.zprint/at-newline?","this-tag","zprint.zprint/next-newline","nloc","next-right","rewrite-clj.zip/right*","zprint.zutil/whitespace?","zprint.zprint/next-actual","next-nloc","zprint.zutil/zrightnws","next-tag","rewrite-clj.zip/tag","zprint.zprint/first-actual","zprint.zprint/hang-zloc?","vec__80725","count-prior-to-newline","newline","second-element","second-indent","zprint.comment/length-before","third-element","third-indent","zprint.zprint/indent-shift","actual-ind","svec","shift-ind","cur-seq","cur-ind","vec__80744","this-seq","new-seq","vec__80747","type","next-seq","this-shift","linecnt","last-width","G__80755","zprint.zprint/indent-zmap","p__80756","map__80757","map__80758","wrap-after-multi?","first-indent-only?","zprint.zprint/merge-fzprint-seq","actual-indent","beginning?","l-str-indent?","vec__80770","multi?","thetype","x__5087__auto__","y__5088__auto__","newline?","comma?","isempty?","newline-next?","zprint.zprint.indent_zmap","zprint.zprint/newline-seq?","newline-vec","starts-with-nl-vec","p1__80778#","true-seq","cljs.core.distinct","fzprint-seq-vec","p1__80780#","p2__80779#","G__80783","zprint.zprint/fzprint-indent","arg-1-indent","l-str-len","zprint.zfns/zmap-w-nl-comma","indent-only-style","already-hung?","rewrite-clj.zip/down*","raw-indent","coll-print-contains-nil?","output","zprint.zprint.fzprint_indent","zprint.zprint/zfind-seq","zthing?","i","G__80788","zprint.zprint/body-set","zprint.zprint/body-map","zprint.zprint/noarg1-set","zprint.zprint/noarg1-map","zprint.zprint/noarg1","fn-type","zprint.zprint/fn-style->caller","zprint.zprint/find-nl-count","zprint.zprint/create-nl-count-vec","zprint.zprint/get-respect-indent","backup","respect-bl?","indent-only?","p__80796","map__80797","zprint.zprint/allow-one-line?","fn-force-nl","fn-gt2-force-nl","fn-gt3-force-nl","future-caller","caller-map","zprint.zprint/modify-zloc-legacy","vec__80799","trigger-symbol","modify-fn","return-altered-zipper-value","call-fn?","G__80802","G__80803","return","G__80805","zprint.zprint/lookup-fn-str","fn-str","fn-str-set","zprint.zprint.lookup_fn_str","zprint.zprint/get-correct-options-map","G__80817","zprint.zprint/lookup-fn-type-map","fn-type-set","fexpr__80822","G__80823","G__80824","G__80825","zprint.zprint/handle-fn-style","zprint.zprint.lookup_fn_type_map","G__80827","vec__80828","vec__80831","new-fn-type","options-map","latest-fn-type","zprint.zprint.handle_fn_style","zprint.zprint/handle-new-fn-style","new-fn-style","found-fn-style","G__80852","zprint.zprint/fn-style+option-fn","option-fn-set","vec__80856","vec__80859","vec__80862","vec__80865","changed?","new-changed?","new-option-fn","zprint.zprint.fn_style_PLUS_option_fn","p__80908","map__80909","zprint.zprint/fzprint-list*","no-arg1?","quote?","zprint.zprint/fzprint-noformat","vec__80921","vec__80925","vec__80928","vec__80931","vec__80934","vec__80937","G__80945","G__80946","G__80947","zprint.zfns/ztake-append","pre-arg-1-style-vec","arg-1-zloc","arg-1-count","first-data","arg-1-coll?","zprint.zfns/zkeyword?","arg-1-indent-alt?","zprint.zfns/zlist?","zprint.zfns/zmap?","zprint.zfns/zset?","vector-fn-style?","guide","pre-arg-2-style-vec","arg-2-zloc","arg-2-count","second-data","zprint.zfns/zcount-zloc-seq-nc-nws","cljs.core.update_in","cljs.core/dissoc","one-line-ok?","fexpr__80994","indent-adj","default-indent","one-line-ind","local-indent","zprint.zprint/fzprint-guide","vec__80997","binding-style-vec","G__81000","G__81001","G__81002","zloc-seq-right-first","G__81004","G__81005","G__81006","G__81008","G__81009","G__81010","vec__81014","vec__81017","pre-arg-3-style-vec","arg-3-zloc","arg-3-count","third-data","zloc-seq-right-third","first-three","first-two-wo-pre-arg-1","G__81021","G__81022","G__81023","first-two-one-line?","first-two","G__81039","G__81040","G__81041","vec__81054","vec__81060","pre-arg-4-style-vec","arg-4-zloc","arg-4-count","fourth-data","arg-vec-index","p1__80899#","G__81075","doc-string?","mixin-start","mixin-length","mixins?","doc-string","mixins","vec__81077","mixin-sentinal","G__81080","G__81081","G__81082","G__81084","G__81085","G__81086","zloc-seq-right-second","G__81087","G__81088","G__81089","G__81090","G__81091","G__81092","G__81093","G__81094","G__81095","wrap-coll?","zprint.zprint/any-zcoll?","G__81137","G__81138","G__81139","G__81140","G__81141","G__81158","G__81159","G__81160","G__81161","G__81162","zprint.zprint/wrap-zmap","nl-count-vector","G__81187","G__81188","G__81189","G__81190","G__81191","G__81200","G__81201","G__81202","zprint.zprint/fzprint-list","zprint.zprint/fzprint-anon-fn","coll?-seq","p1__81225#","p2__81226#","p__81264","map__81265","map__81266","no-wrap-after","previous-newline?","vec__81296","vec__81299","no-wrap-element?","G__81303","next-len","vec__81304","original-len","comment-inline?","this-seq-next","zprint.zprint/count-comments-and-newlines","comment-and-newline-count","zprint.zprint/zcount-comments-and-newlines","G__81349","zprint.zprint/inline-comment->comment","output-seq","vec__81396","c","new-first","p__81441","p__81442","p__81443","map__81449","map__81450","map__81451","vec__81452","zprint.zprint/guided-output","wrap-multi?","rightmost-zloc?","next-guide","cur-index","guide-seq","element-index","excess-guided-newline-count","align-key","last-cur-index","spaces","group-seq","all-fit?","param-map","mark-map","previous-guided-newline?","unguided-newline-out?","previous-data","vec__81473","vec__81476","vec__81479","vec__81482","uneval?","guided-newline?","do-pairs?","incoming-seq","align-ind","incoming-lines","align-spaces","group-newline?","G__81485","regular-space","additional-spaces","beyond-cur-ind","this-spaces","this-ind","early-next-ind","this-early-next-ind","do-hang-remaining?","hang-remaining-seq","do-extend?","extend-seq","do-wrap-flow?","wrap-flow-seq","try-this?","this-result","G__81486","G__81487","G__81488","this-lines","this-multi?","this-linecnt","this-fit?","output-newline?","fail-fit?","next-ind","test-fit?","try-next?","next-result","G__81489","G__81490","G__81491","first-next-result","indent?","zprint.ansi.color_str","G__81493","G__81494","fexpr__81492","out-len","out-drop","G__81496","G__81497","fexpr__81495","guided-output-out","G__81499","G__81500","fexpr__81498","zprint.zprint/comment-or-newline?","zprint.zprint/guide-here","p__81505","map__81506","map__81507","G__81510","G__81512","G__81513","fexpr__81511","G__81517","vec__81519","vec__81585","cur-zloc","G__81589","G__81590","fexpr__81588","first-guide-seq","G__81592","G__81593","fexpr__81591","G__81595","G__81596","fexpr__81594","G__81598","G__81599","fexpr__81597","G__81600","next-newline?","G__81601","G__81602","vec__81603","comments-or-newlines-cur-zloc","remaining-cur-zloc","vec__81622","merged-option-map","vec__81627","guided-newline-count","new-param-map","new-previous-data","vec__81632","vec__81635","vec__81641","vec__81649","G__81653","zprint.zprint/remove-nl","p1__81654#","zprint.zprint/comment-in-zloc-seq?","p1__81658#","p2__81657#","p__81663","map__81664","map__81665","zprint.zprint/fzprint-vec*","wrap?","binding?","fn-format","vec__81668","vec__81671","vec__81674","map__81677","map__81678","G__81679","G__81680","G__81681","G__81682","G__81683","zprint.zprint/fzprint-vec","zprint.zprint/fzprint-array","zprint.zprint/fzprint-set","zprint.zprint/interpose-either","sep-true","sep-nil","pred?","interpose?","zprint.zprint.conj_it_BANG_","G__81688","not-first?","ind-seq","added-nl?","num-nl","nl-count-vec","previous-element-index","previous-type","vec__81723","vec__81726","last-what","next-coll","vec__81731","vec__81734","next-what","next-nl-count-vec","zprint.zprint/count-newline-types","newline-style-vec","count-of-types","p1__81741#","clojure.string/ends-with?","zprint.zprint/repeat-style-vec-nl","no-space-n","vec__81755","no-space-element","no-space-style-vec","p__81759","vec__81760","zprint.zprint/trimr-blanks-element","zprint.zprint/trimr-blanks-style-vec","zprint.zprint/repeat-element-nl","vec__81767","zprint.zprint/next-non-comment-nl","vec__81777","vec__81780","p__81792","map__81793","zprint.zprint/interpose-either-nl-hf","sep-comma","sep-comma-nl","sep-nl","nl-separator-all?","suboptions","previous-needs-comma?","add-nl?","first?","newline-count","vec__81824","vec__81827","hangflow","vec__81833","interpose-style-vec","interpose-count","addtl-nl-needed","p__81862","map__81864","map__81865","zprint.zprint/fzprint-map*","ztype","lift-ns?","lift-ns-in-code?","map-options","ns","G__81867","G__81868","G__81869","G__81870","vec__81875","vec__81897","vec__81900","zprint.zfns/zseqnws-w-nl","zprint.zfns/zseqnws-w-bl","zprint.zfns/zseqnws","p1__81855#","cljs.core/pr-str","lift-pair-seq","G__81908","G__81909","G__81910","zprint.zfns/zlift-ns","pair-count","pair-print-one-line","G__81921","G__81922","fexpr__81920","cljs.core/constantly","pair-print","zprint.zprint/fzprint-map","vec__81963","lifted-map","zprint.zfns/znamespacedmap?","G__81967","zprint.zprint/object-str?","G__81976","zprint.zprint/fzprint-object","zloc-value","zprint.zfns/zobj-to-vec","zprint.zprint/hash-identity-str","obj","cljs.core/hash","p__81986","map__81987","map__81988","zprint.zprint/fzprint-atom","object?","zprint.zprint.fzprint_object","zprint.zfns/zderef","zprint.zprint/fzprint-future-promise-delay-agent","zloc-type","zprint.zfns/zfuture?","zprint.zfns/zpromise?","zprint.zfns/zdelay?","zprint.zfns/zagent?","cljs.core/realized?","type-str","G__82001","zloc-realized?","G__82004","p__82007","map__82008","map__82009","zprint.zprint/fzprint-fn-obj","arg-1-left","arg-1-right","class-str","cljs.core/type","name-js","name-split","arg-2","zprint.zprint/fzprint-ns","cljs.core/ns-name","zprint.zprint/dec-depth","p__82040","map__82041","map__82042","zprint.zprint/fzprint-record","record-type?","to-string?","G__82044","G__82045","G__82046","G__82050","G__82051","G__82052","tokens","no-whitespace","cljs.core.drop_while","zprint.zfns/zwhitespace?","zprint.zprint/take-thru-first-non-whitespace","zprint.zprint/fzprint-meta","zprint.zprint/fzprint-reader-macro","vec__82080","zstr","G__82083","alt-at?","reader-cond?","namespaced?","at?","G__82096","zprint.zfns/zsecond","G__82097","G__82099","floc","G__82101","l-str-io","r-str-io","l-str-vec-io","r-str-vec-io","zprint.zfns/znextnws-w-nl","zprint.zprint/fzprint-newline","vec__82108","zprint.finish/newline-vec","zprint.zprint/prefix-tags","zprint.zprint/prefix-options","prefix-tag","zprint.zprint/make-caller","new-caller","existing-caller","key-seq","p1__82115#","zprint.zprint/integrate-next-inner","next-inner","cljs.core/map?","p1__82118#","p2__82119#","zprint.zprint/remove-spaces-pre-nl","nvec","vec__82132","vec__82135","this-what","this-vec","fzprint*-seq","G__82147","G__82148","zprint.zfns/zmap-all-nl-comment","concat-vec","cljs.core/concat","remove-spaces-vec","p__82180","map__82181","hex?","shift-seq","dbg-s","string-str?","string-color","max-depth","trim-comments?","max-hang-depth","max-hang-span","max-hang-count","cljs.core/deref","avail","dbg-data","dbg-focus?","zprint.zfns/zfind-path","zprint.zfns/zrecord?","zprint.zfns/zanonfn?","zprint.zfns/zfn-obj?","zprint.zfns/zarray?","zprint.zfns/zexpandarray","zprint.zfns/zatom?","G__82199","G__82200","zprint.zfns/zns?","zprint.zfns/zreader-macro?","overflow-in-hang?","zcomment","clojure.string/trimr","inline-comment-vec","zprint.comment/inlinecomment?","zprint.zfns/zwhitespaceorcomment?","zloc-sexpr","zprint.zfns/znumstr","cljs.core/char?","c__5035__auto__","x__5036__auto__","zprint.zprint/fzprint","zprint.zutil/add-spec-to-docstring","zprint.zfns/zfn-map","zprint.zprint/line-count","cljs.core/re-seq","zprint.zprint/line-widths","zprint.zprint/max-width","G__82208","zprint.zprint/expand-tabs","tab-size","char-seq","this-char","tab-expansion","cljs.core/mod","cljs.core/rest","zprint.zprint.expand_tabs","zprint.zprint/determine-ending-split-lines","first-lines","p1__82213#","p2__82212#","line-ending","this__5300__auto__","k__5301__auto__","this__5302__auto__","k82215","else__5303__auto__","G__82219","__extmap","this__5320__auto__","f__5321__auto__","init__5322__auto__","ret__5323__auto__","p__82239","vec__82243","k__5324__auto__","v__5325__auto__","this__5315__auto__","writer__5316__auto__","opts__5317__auto__","pr-pair__5318__auto__","keyval__5319__auto__","cljs.core/pr-sequential-writer","G__82214","cljs.core/RecordIter","cljs.core/-iterator","cljs.core/nil-iter","this__5298__auto__","__meta","this__5295__auto__","__hash","this__5304__auto__","this__5296__auto__","h__5111__auto__","coll__5297__auto__","cljs.core/hash-unordered-coll","this82216","other82217","this__5310__auto__","k__5311__auto__","cljs.core/contains?","cljs.core/-with-meta","cljs.core/not-empty","this__5307__auto__","G__82356","this__5308__auto__","k__5309__auto__","pred__82357","cljs.core/keyword-identical?","expr__82358","this__5313__auto__","cljs.core/MapEntry","this__5299__auto__","this__5305__auto__","entry__5306__auto__","cljs.core/-nth","cljs.core/-conj","zprint.zprint/r","this__5346__auto__","writer__5347__auto__","cljs.core/-write","G__82218","extmap__5342__auto__","G__82368","cljs.core/record?","zprint.zprint/->r","zprint.zprint/map->r","zprint.zprint/make-record"],"sourcesContent":[";!zprint {:style :require-justify}\n(ns ^:no-doc zprint.zprint\n  #?@(:cljs [[:require-macros\n              [zprint.macros :refer\n               [dbg dbg-s dbg-pr dbg-s-pr dbg-form dbg-print zfuture]]]])\n  (:require\n    #?@(:clj [[zprint.macros :refer\n               [dbg-pr dbg-s-pr dbg dbg-s dbg-form dbg-print zfuture]]])\n    [clojure.string     :as s]\n    [zprint.finish      :refer [newline-vec]]\n    [zprint.zfns        :refer\n                          [zstring znumstr zbyte-array? zcomment? zsexpr zseqnws\n                           zseqnws-w-nl zfocus-style zstart zfirst zfirst-sexpr\n                           zsecond znthnext zcount zmap zanonfn? zfn-obj? zfocus\n                           zfind-path zwhitespace? zlist? zcount-zloc-seq-nc-nws\n                           zvector? zmap? zset? zcoll? zuneval? zmeta? ztag\n                           zlast zarray? zatom? zderef zrecord? zns? zobj-to-vec\n                           zexpandarray znewline? zwhitespaceorcomment? zmap-all\n                           zmap-all-nl-comment zpromise? zfuture? zdelay?\n                           zkeyword? zconstant? zagent? zreader-macro?\n                           zarray-to-shift-seq zdotdotdot zsymbol? znil?\n                           zreader-cond-w-symbol? zreader-cond-w-coll? zlift-ns\n                           zfind zmap-w-nl zmap-w-nl-comma ztake-append\n                           znextnws-w-nl znextnws znamespacedmap? zmap-w-bl\n                           zseqnws-w-bl zsexpr? zmap-no-comment zfn-map]]\n    [zprint.comment     :refer [blanks inlinecomment? length-before]]\n    [zprint.ansi        :refer [color-str]]\n    [zprint.config      :refer [validate-options merge-deep]]\n    [zprint.zutil       :refer [add-spec-to-docstring]]\n    [zprint.util        :refer [column-width-variance median mean percent-gt-n]]\n    [zprint.optionfn    :refer [rodfn]]\n    [rewrite-clj.parser :as p]\n    [rewrite-clj.zip    :as    z\n                        :refer [of-node* tag right* down*]]\n    #_[taoensso.tufte :as tufte :refer (p defnp profiled profile)]))\n\n#_(tufte/add-basic-println-handler! {})\n\n;;\n;; # Utility Functions\n;;\n\n(defn dots\n  \"Produce a dot string of desired size.\"\n  [n]\n  (apply str (repeat n \".\")))\n\n; This is about 10% faster than:\n;\n;(defn conj-it!-orig\n;  \"Make a version of conj! that take multiple arguments.\"\n;  [& rest]\n;  (loop [out (first rest)\n;         more (next rest)]\n;    (if more (recur (conj! out (first more)) (next more)) out)))\n\n(defn conj-it!\n  \"Make a version of conj! that takes multiple arguments.\"\n  [to & rest]\n  (reduce conj! to rest))\n\n(defn split-lf-2\n  \"Do split for newlines, instead of using regular expressions.\n  Maximum split is 2.\"\n  [s]\n  (if-let [next-lf (clojure.string/index-of s \"\\n\")]\n    [(subs s 0 next-lf) (subs s (inc next-lf))]\n    [s]))\n\n(defn internal-config-and-validate\n  \"Possibly validate an options map and merge it correctly with the existing\n  options map.  Validation only happens when the caller says to validate\n  and the new-map doesn't have :no-validate? true (unless the existing\n  options map has :force-validate? true).\n  This is necessary instead of just doing a merge-deep, since\n  that doesn't get styles and removal done correctly.  Returns\n  [merged-options-map new-options] or throws an error.\"\n  ([options new-map error-str validate?]\n   (let [validate? (when validate?\n                     (if (:no-validate? new-map)\n                       (when (:force-validate? options) :validate)\n                       :validate))\n         [updated-map _ errors] (zprint.config/config-and-validate nil\n                                                                   #_error-str\n                                                                   nil\n                                                                   options\n                                                                   new-map\n                                                                   validate?)\n         errors (when errors\n                  (str \"Options resulting from \" error-str\n                       \" had these errors: \" errors))]\n     (if (not (empty? errors))\n       (throw (#?(:clj Exception.\n                  :cljs js/Error.)\n               errors))\n       [updated-map new-map])))\n  ([options new-map error-str]\n   (internal-config-and-validate options new-map error-str :validate)))\n\n(defn option-fn-name\n  \"Given an option-fn, call it with no arguments to see if it returns its\n  name.  To be used only in exceptions or other times when performance is\n  not important, because historically many option-fn's didn't know to do this.\"\n  [option-fn]\n  (try (let [option-fn-name (option-fn)]\n         (when (string? option-fn-name) (str \" named '\" option-fn-name \"'\")))\n       (catch #?(:clj Exception\n                 :cljs :default)\n         e\n         nil)))\n\n\n(defn zsexpr-token?\n  \"Call zsexpr?, but only if zloc is a :token\"\n  [zloc]\n  (when (= (ztag zloc) :token) (zsexpr? zloc)))\n\n(defn empty-coll\n  \"For the major collections, returns a empty one. Essentially an\n  implementation of empty for zlocs.\"\n  [zloc]\n  (cond (= (ztag zloc) :list) '()\n        (= (ztag zloc) :vector) []\n        (= (ztag zloc) :set) #{}\n        (= (ztag zloc) :map) {}))\n\n(defn get-sexpr\n  \"Given a zloc, do the best we can to get an sexpr out of it.\"\n  [options zloc]\n  (try\n    (zsexpr zloc)\n    (catch #?(:clj Exception\n              :cljs :default)\n      e\n      (let [#_(prn \"tag:\" (ztag zloc) \"zloc:\" zloc \"zstring:\" (zstring zloc))\n            s (zstring zloc)\n            new-s (reduce #(clojure.string/replace %1 %2 \"\")\n                    s\n                    (:ignore-if-parse-fails (:parse options)))\n            #_(clojure.string/replace s \"...\" \"\")\n            #_(prn \"new-s:\" new-s)\n            ; So, let's try parsing it again and see if this works.  If the\n            ; zsexpr failed, we know it is a string because the structure\n            ; version of zsexpr is identity, which is unlikely to fail.\n            sexpr\n              (try\n                (let [n (p/parse-string (clojure.string/trim new-s))\n                      new-zloc (of-node* n)\n                      sexpr (zsexpr new-zloc)]\n                  sexpr)\n                (catch #?(:clj Exception\n                          :cljs :default)\n                  e\n                  (throw\n                    (#?(:clj Exception.\n                        :cljs js/Error.)\n                     (str\n                       \"Unable to parse the string '\" s\n                       \"' because of '\" e\n                       \"'.  Consider adding any unallowed elements to\"\n                         \" {:parse {:ignore-if-parse-fails #{ <string> }}}\")))))\n            #_(prn \"sexpr:\" sexpr)]\n        sexpr))))\n\n(defn get-sexpr-or-nil\n  \"Try to get an sexpr of something, and return nil if we can't.\"\n  [options zloc]\n  (try (get-sexpr options zloc)\n       (catch #?(:clj Exception\n                 :cljs :default)\n         e\n         nil)))\n\n;!zprint {:format :next :vector {:wrap? false}}\n(defn call-option-fn\n  \"Call an option-fn and return a validated map of the merged options. \n  Returns [merged-options-map new-options zloc l-str r-str changed?] where\n  changed? refers only to changes in any of zloc, l-str, or r-str.\"\n  [caller options option-fn zloc l-str r-str]\n  #_(prn \"call-option-fn caller:\" caller)\n  (let [sexpr-seq (get-sexpr options zloc)\n        ; Add the current zloc and l-str, r-str to the options\n        ; for the option-fn\n        options (assoc options\n                  :zloc zloc\n                  :l-str l-str\n                  :r-str r-str\n                  :caller caller)\n        _ (dbg-s options\n                 #{:call-option-fn}\n                 \"call-option-fn: caller:\" caller\n                 \"option-fn:\" option-fn\n                 \"sexpr-seq:\" sexpr-seq)\n        [merged-options new-options]\n          (internal-config-and-validate\n            options\n            (try (dbg-pr options \"call-option-fn sexpr-seq:\" sexpr-seq)\n                 (let [result (option-fn options (count sexpr-seq) sexpr-seq)]\n                   (dbg-s options\n                          #{:call-option-fn}\n                          \"call-option-fn result:\"\n                          result)\n                   result)\n                 (catch #?(:clj Exception\n                           :cljs :default)\n                   e\n                   (do (dbg-s options\n                              :guide-exception\n                              \"Failure in option-fn:\"\n                              (throw e))\n                       (throw (#?(:clj Exception.\n                                  :cljs js/Error.)\n                               (str \" When \" caller\n                                    \" called an option-fn\" (option-fn-name\n                                                             option-fn)\n                                    \" it failed because: \" e))))))\n            (str caller\n                 \" :option-fn\" (option-fn-name option-fn)\n                 \" called with an sexpr of length \" (count sexpr-seq))\n            :validate)\n        new-zloc (:new-zloc merged-options)\n        new-l-str (:new-l-str merged-options)\n        new-r-str (:new-r-str merged-options)]\n    (dbg-pr options\n            \"call-option-fn: caller:\"\n            caller\n            \"\n            option-fn '\"\n            (option-fn-name option-fn)\n            \"' returned new options:\"\n            new-options)\n    [(dissoc merged-options\n       :caller\n       :zloc\n       :new-zloc\n       :l-str\n       :new-l-str\n       :r-str\n       :new-r-str)\n     (or new-zloc zloc)\n     (or new-l-str l-str)\n     (or new-r-str r-str)\n     ; Don't return more than we need to here, we might log it!\n     (when (or new-zloc new-l-str new-r-str) true)]))\n\n(defn call-option-fn-first\n  \"Call an option-fn-first with just the first thing in the zloc, and\n  then return a validated map of just the new options.\n  Returns [merge-options-map new-options]\"\n  [caller options option-fn-first zloc]\n  (let [first-sexpr (get-sexpr options (zfirst-sexpr zloc))]\n    (internal-config-and-validate\n      options\n      (try (option-fn-first options first-sexpr)\n           (catch #?(:clj Exception\n                     :cljs :default)\n             e\n             (throw (#?(:clj Exception.\n                        :cljs js/Error.)\n                     (str \"When \" caller\n                          \" called an option-fn-first\" (option-fn-name\n                                                         option-fn-first)\n                          \" with '\" first-sexpr\n                          \"' failed because: \" e)))))\n      (str caller\n           \" :option-fn-first\" (option-fn-name option-fn-first)\n           \" called with \" first-sexpr)\n      :validate)))\n\n(defn guide-debug\n  \"Given the options map and a caller, look for :guide-debug in the options\n  map.  It looks like [:caller :depth [:element ...]]  If the caller and \n  depth match, return the guide, else nil.\"\n  [caller options]\n  (let [debug-vector (:guide-debug options)]\n    (when debug-vector\n      (dbg-s options\n             :guide\n             \"guide-debug: caller:\" caller\n             \"depth:\" (:depth options)\n             \"guide:\" debug-vector)\n      (if (and (= caller (first debug-vector))\n               (= (:depth options) (second debug-vector)))\n        (nth debug-vector 2)))))\n\n(defn condense\n  [depth [out accumulated-string current-depth] [s _ what :as element]]\n  (let [new-depth (cond (= what :left) (inc current-depth)\n                        (= what :right) (dec current-depth)\n                        :else current-depth)\n        accumulating? (> current-depth depth)\n        start-accumulating? (> new-depth depth)\n        new-accumulated-string (if (or accumulating? start-accumulating?)\n                                 (str accumulated-string s)\n                                 accumulated-string)\n        next-accumulated-string\n          (if start-accumulating? new-accumulated-string \"\")]\n    [(cond (and accumulating? (not start-accumulating?))\n             (conj out new-accumulated-string)\n           (and accumulating? start-accumulating?) out\n           (and (not accumulating?) (not start-accumulating?)) (conj out\n                                                                     element)\n           (and (not accumulating?) start-accumulating?) out\n           :else (println \"shouldn't be an else\")) next-accumulated-string\n     new-depth]))\n\n(defn condense-depth\n  \"Take a style vec, and condense everything above the given depth.\"\n  [depth coll]\n  (first (reduce (partial condense depth) [[] \"\" 1] coll)))\n\n;;\n;; # Use pmap when we have it\n;;\n\n#?(:bb (defn zpmap\n         ([options f coll] (map f coll))\n         ([options f coll1 coll2] (map f coll1 coll2)))\n   :clj (defn zpmap\n          ([options f coll]\n           (if (:parallel? options) (pmap f coll) (map f coll)))\n          ([options f coll1 coll2]\n           (if (:parallel? options) (pmap f coll1 coll2) (map f coll1 coll2))))\n   :cljs (defn zpmap\n           ([options f coll] (map f coll))\n           ([options f coll1 coll2] (map f coll1 coll2))))\n\n;;\n;; # More parallelism issues -- zderef to go with zfuture macro\n;;\n\n(defn zat\n  \"Takes an option map and the return from zfuture.  If the\n  options map has (:parallel? options) as true, then deref\n  the value, otherwise just pass it through.\"\n  [options value]\n  #?(:bb value\n     :clj (if (:parallel? options) (deref value) value)\n     :cljs value))\n\n;;\n;; # Debugging Assistance\n;;\n\n(def fzprint-dbg (atom nil))\n\n(defn log-lines\n  \"Accept a style-vec that we are about to hand to style-lines, and\n  output it if called for, to aid in debugging.\"\n  [{:keys [dbg-print? dbg-indent in-hang?], :as options} dbg-output ind\n   style-vec]\n  (when dbg-print?\n    (if style-vec\n      (do (println dbg-indent dbg-output \"--------------\" \"in-hang?\" in-hang?)\n          (prn style-vec)\n          #_(println (apply str (blanks ind) (map first style-vec))))\n      (println dbg-indent dbg-output \"--------------- no style-vec\"))))\n\n;;\n;; # What is a function?\n;;\n\n(defn showfn?\n  \"Show this thing as a function?\"\n  [{:keys [fn-map color?], :as options} f]\n  (when (and color? (not (string? f)))\n    (let [f-str (str f)\n          fn-map (:fn-map options)]\n      (or (fn-map f-str)\n          (re-find #\"clojure\" f-str)\n          (if (symbol? f)\n            ; This is necessary because f can be a symbol that\n            ; resolve will have a problem with.  The obvious ones\n            ; were (ns-name <some-namespace>), but there are almost\n            ; certainly others.\n            (try (or (re-find #\"clojure\"\n                              (str (:ns (meta #?(:clj (resolve f)\n                                                 :cljs f)))))\n                     (fn-map (name f)))\n                 (catch #?(:clj Exception\n                           :cljs :default)\n                   e\n                   nil)))))))\n\n(defn show-user-fn?\n  \"Show this thing as a user defined function?  Assumes that we\n  have already handled any clojure defined functions!\"\n  [{:keys [user-fn-map color?], :as options} f]\n  (when (and color? (not (string? f)))\n    (let [f-str (str f)]\n      (or (get user-fn-map f-str)\n          (if (symbol? f)\n            ; This is necessary because f can be a symbol that\n            ; resolve will have a problem with.  The obvious ones\n            ; were (ns-name <some-namespace>), but there are almost\n            ; certainly others.\n            (try (or (not (empty? (str (:ns (meta #?(:clj (resolve f)\n                                                     :cljs f))))))\n                     (get user-fn-map (name f)))\n                 (catch #?(:clj Exception\n                           :cljs :default)\n                   e\n                   nil)))))))\n\n(def right-separator-map {\")\" 1, \"]\" 1, \"}\" 1})\n\n;;\n;; # Functions to compare alternative printing approaches\n;;\n\n(declare fix-rightcnt)\n(declare contains-nil?)\n\n(defn good-enough?\n  \"Given the fn-style, is the first output good enough to be worth\n  doing. p is pretty, which is typically hanging, and b is basic, which\n  is typically flow. p-count is the number of elements in the hang.\"\n  [caller\n   {:keys [width rightcnt dbg?],\n    {:keys [general-hang-adjust]} :tuning,\n    {:keys [hang-expand hang-diff hang-size hang-adjust],\n     {:keys [hang-flow hang-type-flow hang-flow-limit hang-if-equal-flow?]}\n       :tuning}\n      caller,\n    :as options} fn-style p-count indent-diff\n   [p-lines p-maxwidth p-length-seq p-what] [b-lines b-maxwidth _ b-what]]\n  (let [p-last-maxwidth (last p-length-seq)\n        hang-diff (or hang-diff 0)\n        hang-expand (or hang-expand 1000.)\n        hang-adjust (or hang-adjust general-hang-adjust)\n        ; Get solid versions of key local tuning parameters\n        tuning (:tuning options)\n        hang-flow (or hang-flow (:hang-flow tuning))\n        hang-type-flow (or hang-type-flow (:hang-type-flow tuning))\n        hang-flow-limit (or hang-flow-limit (:hang-flow-limit tuning))\n        hang-if-equal-flow? (or hang-if-equal-flow?\n                                (:hang-if-equal-flow? tuning))\n        #_(options (if (and p-lines\n                            p-count\n                            (pos? p-count)\n                            (not (<= indent-diff hang-diff))\n                            (not (<= (/ (dec p-lines) p-count) hang-expand)))\n                     (assoc options :dbg? true)\n                     options))\n        options (if (or p-what b-what) (assoc options :dbg? true) options)\n        result (if (not b-lines)\n                 true\n                 (and p-lines\n                      ; Does the last line fit, including the collection\n                      ; ending stuff? Do we really need this anymore?\n                      (<= p-last-maxwidth (- width (fix-rightcnt rightcnt)))\n                      ; Does it widest line fit? Do we have a problem if\n                      ; the widest line has a rightcnt?\n                      (<= p-maxwidth width)\n                      ;      (<= p-maxwidth (- width (fix-rightcnt\n                      ;      rightcnt)))\n                      (or\n                        (zero? p-lines)\n                        (and ; do we have lines to operate on?\n                          (> b-lines 0)\n                          (> p-count 0)\n                          ; if the hang and the flow are the same size, why\n                          ; not hang?\n                          (if (and (= p-lines b-lines) hang-if-equal-flow?)\n                            true\n                            ; is the difference between the indents so\n                            ; small that we don't care?\n                            (and (if (<= indent-diff hang-diff)\n                                   true\n                                   ; Do the number of lines in the hang\n                                   ; exceed the number of elements in the\n                                   ; hang?\n                                   (<= (/ (dec p-lines) p-count) hang-expand))\n                                 (if hang-size (< p-lines hang-size) true)\n                                 (let [factor (if (= fn-style :hang)\n                                                hang-type-flow\n                                                hang-flow)]\n                                   ; if we have more than n lines, take the\n                                   ; shortest\n                                   (if (> p-lines hang-flow-limit)\n                                     (<= (dec p-lines) b-lines)\n                                     ; if we have less then n lines, we\n                                     ; don't necessarily take the shortest\n                                     ; once we did (dec p-lines) here, fwiw\n                                     ; then we tried it w/out the dec, now\n                                     ; we let you set it in :tuning. The\n                                     ; whole point of having a hang-adjust\n                                     ; of -1 is to allow hangs when the\n                                     ; number of lines in a hang is the\n                                     ; same as the number of lines in a\n                                     ; flow.\n                                     ;(< (/ p-lines b-lines) factor)))))))]\n                                     (< (/ (+ p-lines hang-adjust) b-lines)\n                                        factor)))))))))]\n    (dbg\n      options\n      (if result \"++++++\" \"XXXXXX\")\n      \"p-what\" p-what\n      \"good-enough? caller:\" caller\n      \"fn-style:\" fn-style\n      \"width:\" width\n      \"rightcnt:\" rightcnt\n      \"hang-expand:\" hang-expand\n      \"hang-flow-limit:\" hang-flow-limit\n      \"hang-adjust:\" hang-adjust\n      \"(/ (+ p-lines hang-adjust) b-lines)\"\n        (when (and p-lines b-lines hang-adjust)\n          (/ (+ p-lines hang-adjust) b-lines))\n      \"factor:\" (if (= fn-style :hang) hang-type-flow hang-flow)\n      \"p-count:\" p-count\n      \"p-lines:\" p-lines\n      \"p-maxwidth:\" p-maxwidth\n      \"indent-diff:\" indent-diff\n      \"hang-diff:\" hang-diff\n      \"p-last-maxwidth:\" p-last-maxwidth\n      \"b-lines:\" b-lines\n      \"b-maxwidth:\" b-maxwidth)\n    result))\n\n;;\n;; # Utility Functions\n;;\n\n(defn in-hang\n  \"Add :in-hang? true to the options map.\"\n  [options]\n  (if (:in-hang? options)\n    options\n    (if (:do-in-hang? options)\n      (assoc options :in-hang? (or (:depth options) true))\n      options)))\n\n(defn contains-nil?\n  \"Scan a collection, and return true if it contains any nils or empty\n  collections.\"\n  [coll]\n  (some #(if (coll? %) (empty? %) (nil? %)) coll))\n\n#_(defn concat-no-nil-alt\n    \"Concatentate multiple sequences, but if any of them are nil, return nil.\n  This version is 15-20% slower than the version below. Keeping it around\n  just for illustrative purposes.\"\n    [& rest]\n    (loop [coll rest\n           out (transient [])]\n      (let [c (first coll)]\n        (if-not c\n          (persistent! out)\n          (when (or (and (coll? c) (not (empty? c))) (not (nil? c)))\n            (recur (next coll) (conj! out c)))))))\n\n(defn concat-no-nil-pre-noseq\n  \"Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil.\"\n  [& rest]\n  (let [result (reduce (fn [v o]\n                         (if (coll? o)\n                           (if (empty? o) (reduced nil) (reduce conj! v o))\n                           (if (nil? o) (reduced nil) (conj! v o))))\n                 (transient [])\n                 rest)]\n    (when result (persistent! result))))\n\n(declare count-right-blanks)\n(declare trimr-blanks)\n\n(defn concat-no-nil\n  \"Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil. If any of them are :noseq, just skip them.\n  When complete, check the last element-- if it is a :right, and if it\n  the previous element is a :newline or :indent, then ensure that the\n  number of spaces in that previous element matches the number to the\n  right of the :right.\"\n  [& rest]\n  (let [result (reduce (fn [v o]\n                         (if (coll? o)\n                           (if (empty? o) (reduced nil) (reduce conj! v o))\n                           (if (= :noseq o)\n                             ; if the supposed sequence is :noseq, skip it\n                             v\n                             (if (nil? o) (reduced nil) (conj! v o)))))\n                 (transient [])\n                 rest)]\n    (when result\n      (let [result (persistent! result)]\n        (if (< (count result) 2)\n          result\n          (let [[_ _ what right-ind :as last-element] (peek result)]\n            (if (= what :right)\n              ; we have a right paren, bracket, brace as the last thing\n              (let [previous-index (- (count result) 2)\n                    [s color previous-what] (nth result previous-index)]\n                (if (or (= previous-what :newline) (= previous-what :indent))\n                  ; we have a newline or equivalent before the last thing\n                  (if (= (count-right-blanks s) right-ind)\n                    ; we already have the right number of blanks!\n                    result\n                    (let [new-previous [(str (trimr-blanks s)\n                                             (blanks right-ind)) color\n                                        previous-what]]\n                      (assoc result previous-index new-previous)))\n                  result))\n              result)))))))\n\n\n(defn concat-no-nil-pre-right\n  \"Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil. If any of them are :noseq, just skip them.\"\n  [& rest]\n  (let [result (reduce (fn [v o]\n                         (if (coll? o)\n                           (if (empty? o) (reduced nil) (reduce conj! v o))\n                           (if (= :noseq o)\n                             ; if the supposed sequence is :noseq, skip it\n                             v\n                             (if (nil? o) (reduced nil) (conj! v o)))))\n                 (transient [])\n                 rest)]\n    (when result (persistent! result))))\n\n(defn remove-one\n  \"Remove a single thing from a sequence.\"\n  [s index]\n  (concat (take index s) (drop (inc index) s)))\n\n(defn force-vector\n  \"Ensure that whatever we have is a vector.\"\n  [coll]\n  (if (vector? coll) coll (into [] coll)))\n\n(defn keyword-fn?\n  \"Takes a string, and returns the fn-style if it is a keyword and\n  without the : it can be found in the fn-map.\"\n  [options s]\n  (let [[left right] (clojure.string/split s #\"^:\")]\n    (when right ((:fn-map options) right))))\n\n(defn get-max-length\n  \"Given the options map, return the max length.  This might be\n  a constant number, but it might be based on the depth as well.\n  Returns nil of there is no max-length set.\"\n  [{:as options, :keys [max-length depth]}]\n  (when max-length\n    (if (vector? max-length)\n      (nth max-length (min (dec depth) (dec (count max-length))))\n      max-length)))\n\n(defn no-max-length\n  \"Given an options map, return another options map with no\n  :max-length key.  This is to that you can call a routine that\n  normally deals with :max-length and get it to do the normal\n  thing.\"\n  [options]\n  (assoc options :max-length 10000))\n\n;;\n;; # Work with style-vecs and analyze results\n;;\n\n;; Transients don't help here, though they don't hurt much either.\n\n(defn accumulate-ll\n  \"Take the vector carrying the intermediate results, and\n  do the right thing with a new string. Vector is\n  [ 0 out - vector accumulating line lengths \n    1 cur-len - length of current line\n    just-eol? - did we just do an eol?\n    ]\n  s - string to add to current line\n  tag - element type of string (comment's don't count in length)\n  eol? - should we terminate line after adding count of s\"\n  [count-comment? [out cur-len just-eol? just-comment? :as in] s tag eol?]\n  (let [comment? (or (= tag :comment) (= tag :comment-inline))\n        count-s (if (and comment? (not count-comment?)) 0 (count s))]\n    (cond\n      ; if we are told to terminate the line or it\n      ; is a comment, we terminate the line with the\n      ; size of the string added to it\n      (or (and eol? (not (and just-eol? (zero? count-s)))) comment?)\n        [(conj out (+ cur-len count-s)) 0 true comment?]\n      ;(assoc in 0 (conj out (+ cur-len count-s)) 1 0 2 true 3 comment?)\n      ; no reason to terminate the line, just accumulate the size in\n      ; cur-len\n      :else [out (+ cur-len count-s) nil comment?])))\n\n(defn generate-ll\n  [count-comment? [out cur-len just-eol? just-comment? :as in]\n   [s _ tag :as element]]\n  (let [[l r] (if (or (= tag :whitespace) (= tag :indent) (= tag :newline))\n                (split-lf-2 s)\n                (list s))\n        ; if tag = :comment, shouldn't have \\n and therefore shouldn't have\n        ; r if r is non-nil, then we had a newline, so we want to terminate\n        ; the current line if we are already in a comment and we have\n        ; something that is not whitespace, then we want to terminate the\n        ; current line\n        in (accumulate-ll count-comment? in l tag (not (nil? r)))\n        in (if (empty? r) in (accumulate-ll count-comment? in r tag nil))]\n    in))\n\n\n(defn line-lengths-iter\n  \"Take a style-vec, and output a sequence of numbers, one for each\n  line, which contains the actual length. Must take the current\n  indent to have a prayer of getting this right, but it is used\n  only for the first line.  The ind can be an integer or a seq of\n  integers, in which case only the first integer is used. Newlines\n  can come anywhere in an element in a style-vec, it will account\n  for both sides.  Will break lines on comments even if no newlines\n  in them.  This doesn't count the length of comment lines unless\n  [:comment :count?] is true, so that we don't format based on\n  comment size -- that is handled with the wrap-comments elsewhere.\n  Note that only vectors with :whitespace, :indent, or :newline are scanned\n  for newlines, and if consecutive newlines appear, only the first\n  is counted as a newline -- the second is counted as a regular \n  character. A single comment is counted as two lines. Lots of edge\n  conditions that are really quite important.\"\n  [options ind style-vec]\n  (let [count-comment? (:count? (:comment options))\n        ind (if (coll? ind) (first ind) ind)]\n    (dbg-pr options \"line-lengths-iter: style-vec:\" style-vec)\n    (loop [next-vec style-vec\n           current-string nil\n           line-length ind\n           previous-comment? nil\n           out []]\n      (if (or (and (empty? next-vec) (empty? current-string)))\n        ; A trailing newline isn't counted.\n        (cond (and (zero? line-length) (not previous-comment?)) out\n              previous-comment? (conj out line-length 0)\n              :else (conj out line-length))\n        (let [advance? (empty? current-string)\n              [next-string _ tag] (when advance? (first next-vec))\n              comment? (or (= tag :comment) (= tag :comment-inline))\n              s (if advance? next-string current-string)\n              [l r] (when s\n                      ; if we have a current-string, then we are looking\n                      ; for newlines\n                      (cond (and comment? (not count-comment?)) [\"\"]\n                            (or (and advance?\n                                     (or (= tag :whitespace)\n                                         (= tag :newline)\n                                         (= tag :indent)))\n                                current-string)\n                              (split-lf-2 s)\n                            :else [s]))\n              ; If r non-nil, we had a newline at end of l. If we had a\n              ; previous-comment, then we want to imply a newline unless we\n              ; have a newline at the start of s. If r is non-nil, and l is\n              ; empty, then the newline was at the front of r, in which\n              ; case we don't need to do an implied newline for the comment\n              ; (if any).\n              ; Choices:\n              ;  leave l and r alone\n              ;  l becomes nil and r is (str l r)\n              force-newline? (and previous-comment? (not (empty? l)))\n              #_(prn \"l:\" l\n                     \"r:\" r\n                     \"force-newline?\" force-newline?\n                     \"comment?\" comment?)\n              r (if force-newline? (str l r) r)\n              l (if force-newline? nil l)\n              new-line-length (+ line-length (count l))]\n          #_(prn \"current-string:\" current-string\n                 \"line-length:\" line-length\n                 \"advance?\" advance?\n                 \"s:\" s\n                 \"l:\" l\n                 \"r:\" r\n                 \"new-line-length:\" new-line-length)\n          (recur (if advance? (next next-vec) next-vec)\n                 r\n                 (if r 0 new-line-length)\n                 comment?\n                 (if r (conj out new-line-length) out)))))))\n\n(defn line-lengths\n  \"Take a style-vec, and output a sequence of numbers, one for each\n  line, which contains the actual length. Must take the current\n  indent to have a prayer of getting this right, but it is used\n  only for the first line.  The ind can be an integer or a seq of\n  integers, in which case only the first integer is used. Newlines\n  can come anywhere in an element in a style-vec, it will account\n  for both sides.  Will break lines on comments even if no newlines\n  in them.  This doesn't count the length of comment lines unless\n  [:comment :count?] is true, so that we don't format based on\n  comment size -- that is handled with the wrap-comments at the\n  end. Note that only vectors with :whitespace or :indent are scanned\n  for newlines, and if consecutive newlines appear, only the first\n  is counted as a newline -- the second is counted as a regular \n  character.\"\n  [options ind style-vec]\n  (let [length-vec (first ; this final accumulate-ll is to terminate the\n                          ; last line, the one in progress\n                     (let [count-comment? (:count? (:comment options))\n                           [_ _ just-eol? just-comment? :as result]\n                             (reduce (partial generate-ll count-comment?)\n                               [[] (if (coll? ind) (first ind) ind) nil nil]\n                               style-vec)]\n                       (if (and just-eol? (not just-comment?))\n                         result\n                         (accumulate-ll count-comment?\n                                        (assoc result 2 nil)\n                                        \"\"\n                                        nil\n                                        true))))]\n    (dbg-pr options\n            \"line-lengths: style-vec:\" style-vec\n            \"ind:\" ind\n            \"length-vec:\" length-vec)\n    length-vec))\n\n(defn single-line?\n  \"This looks at a style vec and doesn't do all that style-lines does.\n  It just looks for a new-line in the strings, and returns true if it\n  doesn't find one.\"\n  [style-vec]\n  #_(prn \"style-vec:\" style-vec)\n  (not (reduce #(or %1 %2)\n         false\n         (map #(clojure.string/includes? (first %) \"\\n\") style-vec))))\n\n(defn find-what\n  \"Given a style-vec, come up with a string that gives some hint of \n  where this style-vec came from.\"\n  [style-vec]\n  (loop [s-vec style-vec]\n    (when s-vec\n      (let [[what _ this] (first s-vec)]\n        (if (= this :element) what (recur (next s-vec)))))))\n\n(defn first-nl?\n  \"Look at a style vec ready to be given to concat-no-nil, and see if\n  the first thing in there is a newline of some sort.\"\n  [style-vec]\n  (let [[s color what] (first style-vec)]\n    (or (= what :newline) (= what :indent))))\n\n(defn prepend-nl\n  \"Given an indent ind and a style-vec coll, place a newline (actually an\n  indent) at the front of coll.  If the first thing in coll is a newline,\n  then don't add any spaces after the newline that we prepend.\"\n  [options ind coll]\n  (concat-no-nil [[(str \"\\n\" (blanks (if (first-nl? coll) 0 ind))) :none :indent\n                   1]]\n                 coll))\n\n; Debugging help to find differences between line-lengths and\n; line-lengths-iter.  Surprisingly helpful!\n#_(defonce lldiff (atom []))\n\n(defn style-lines\n  \"Take a style output, and tell us how many lines it takes to print it\n  and the maximum width that it reaches. Returns \n  [<line-count> <max-width> [line-lengths]].\n  Doesn't require any max-width inside the style-vec. Also returns the\n  line lengths in case that is helpful (since we have them anyway).\n  If (:dbg-ge options) has value, then uses find-what to see if what it\n  finds matches the value, and if it does, place the value in the\n  resulting vector.\"\n  [options ind style-vec]\n  (when (and style-vec (not (empty? style-vec)) (not (contains-nil? style-vec)))\n    (let [;lengths (line-lengths options ind style-vec)\n          lengths (line-lengths-iter options ind style-vec)\n          count-lengths (count lengths)\n          result [count-lengths (if (zero? count-lengths) 0 (apply max lengths))\n                  lengths]\n          dbg-ge (:dbg-ge options)\n          what (when (and dbg-ge (= (find-what style-vec) dbg-ge)) dbg-ge)]\n      #_(when (not= lengths lengths-iter) (swap! lldiff conj style-vec))\n      (if what (conj result what) result))))\n\n(defn style-lines-hangflow\n  \"Does style-lines on something formatted like [[:hang ...] [:flow ...]],\n  which is the output from fzprint-map-two-up. Assumes each :hang or :flow\n  thing is on a separate line, which may not be true when the \n  hangflow-style-vec is ultimately given to interpose-....\"\n  [options ind hangflow-style-vec]\n  (when (and hangflow-style-vec\n             (not (empty? hangflow-style-vec))\n             (not (contains-nil? hangflow-style-vec)))\n    (let [style-vecs (mapv second hangflow-style-vec)\n          style-lines-map (mapv (partial style-lines options ind) style-vecs)\n          lengths (into [] (flatten (mapv #(nth % 2) style-lines-map)))\n          max-length (apply max lengths)]\n      [(count lengths) max-length lengths])))\n\n(defn fzfit\n  \"Given output from style-lines and options, see if it fits the width.  \n  Return the number of lines it takes if it fits, nil otherwise.\"\n  [{:keys [width rightcnt dbg?], :as options}\n   [line-count max-width :as style-lines-return]]\n  (dbg options\n       \"fzfit: fixed-rightcnt:\" (fix-rightcnt rightcnt)\n       \"line-count:\" line-count\n       \"max-width:\" max-width\n       \"width:\" width)\n  (when style-lines-return\n    (if (<= max-width (- width (fix-rightcnt rightcnt))) line-count nil)))\n\n(defn fzfit-one-line\n  \"Given the return from style-lines  and options, \n  return true if it fits on a single line.\"\n  [options style-lines-return]\n  (let [lines (fzfit options style-lines-return)]\n    (and (number? lines) (= lines 1))))\n\n;;\n;; # Handle Rightmost Size\n;;\n\n(defn rightmost\n  \"Increase the rightmost count, if any, and return one if not.\"\n  [options]\n  (assoc options :rightcnt (inc (:rightcnt options 0))))\n\n(defn not-rightmost\n  \"Remove the rightmost count.\"\n  [options]\n  (dissoc options :rightcnt))\n\n(defn c-r-pair\n  \"Handle the complexity of commas and rightmost-pair with options.\n  If it isn't a rightmost, it loses rightmost status.\n  If it is a rightmost, and in the rightmost pair, it gain one rightmost\n  since it has the right end thing (and we don't care about the comma).\n  If it is the rightmost of the non-rightmost-pair, then the comma\n  matters, and we handle that appropriately.  Whew!\"\n  [commas? rightmost-pair? rightmost? options]\n  (if-not rightmost?\n    (not-rightmost options)\n    (if rightmost-pair?\n      options\n      (if commas?\n        (rightmost (not-rightmost options))\n        (not-rightmost options)))))\n\n(defn fix-rightcnt\n  \"Handle issue with rightcnt.\"\n  [rightcnt]\n  (if (number? rightcnt) rightcnt 0))\n\n;;\n;; # First pass at color -- turn string or type into keyword color\n;;\n\n;;\n;; ## Translate from a string to a keyword as needed.\n;;\n\n(def str->key\n  {\"(\" :paren,\n   \")\" :paren,\n   \"[\" :bracket,\n   \"]\" :bracket,\n   \"{\" :brace,\n   \"}\" :brace,\n   \"#{\" :hash-brace,\n   \"#(\" :hash-paren,\n   \"#_\" :uneval,\n   \"'\" :quote,\n   \"`\" :syntax-quote,\n   \"~\" :unquote,\n   \"~@\" :unquote-splicing,\n   \"@\" :deref})\n\n\n(defn zcolor-map\n  \"Look up the thing in the zprint-color-map.  Accepts keywords or\n  strings.\"\n  [{:keys [color-map color?], :as options} key-or-str]\n  ; If we aren't doing color, don't even bother to do the lookup\n  (if color?\n    (color-map (if (keyword? key-or-str) key-or-str (str->key key-or-str)))\n    :none))\n\n\n;;\n;; ## Pretty Printer Code\n;;\n\n(declare fzprint*)\n(declare fzprint-flow-seq)\n\n(defn hangflow\n  \"Take a style-vec, and if hangflow? is true, return a\n  vector [hang-or-flow style-vec], else return style-vec.\n  But a nil style-vec returns nil.\"\n  [hangflow? hang-or-flow style-vec]\n  (when style-vec (if hangflow? [hang-or-flow style-vec] style-vec)))\n\n(defn fzprint-hang-unless-fail\n  \"Try to hang something and if it doesn't hang at all, then flow it,\n  but strongly prefer hang.  Has hang and flow indents, and fzfn is the\n  fzprint-? function to use with zloc.  Callers need to know whether this\n  was hang or flow, so it returns [{:hang | :flow} style-vec] all the time.\"\n  [options hindent findent fzfn zloc]\n  (dbg options\n       \"fzprint-hang-unless-fail: hindent:\" hindent\n       \"findent:\" findent\n       \"zloc:\" (zstring (zfirst zloc)))\n  ; If the hindent is different than the findent, we'll try hang, otherwise\n  ; we will just do the flow\n  (let [hanging (when (not= hindent findent)\n                  (fzfn (in-hang options) hindent zloc))]\n    (dbg-form\n      options\n      \"fzprint-hang-unless-fail: exit:\"\n      (if (and hanging (fzfit options (style-lines options hindent hanging)))\n        [:hang hanging]\n        ; hang didn't work, do flow\n        (do (dbg options \"fzprint-hang-unless-fail: hang failed, doing flow\")\n            [:flow\n             (prepend-nl options findent (fzfn options findent zloc))])))))\n\n(defn replace-color\n  \"Given a style-vec with exactly one thing in it, replace the color\n  with whatever local color we have determined is correct.\"\n  [local-color style-vec]\n  (if (= (count style-vec) 1)\n    (let [[[string color element]] style-vec] [[string local-color element]])\n    style-vec))\n\n(declare fzprint-binding-vec)\n(declare middle-element?)\n\n(defn use-hang?\n  \"This routine tries to figure out if existing hang should be used without\n  even bothering to do a flow and compare them with good-enough?.\"\n  [caller\n   {:keys [depth width],\n    {:keys [hang-accept ha-depth-factor ha-width-factor]} caller,\n    :as options} ind hang-count hanging-line-count]\n  (when (and hanging-line-count hang-accept (pos? hang-count))\n    #_(prn \"use-hang? caller:\" caller \"(/ ind width):\" (double (/ ind width)))\n    (let [hang-accept (+ hang-accept\n                         (* depth ha-depth-factor)\n                         (* (/ ind width) ha-width-factor))\n          result (<= (/ (dec hanging-line-count) hang-count) hang-accept)]\n      #_(prn \"use-hang? result:\" result)\n      #_(prn \"use-hang? caller:\" caller\n             \"(/ ind width):\" (double (/ ind width))\n             \"hang-count:\" hang-count\n             \"hanging-line-count:\" hanging-line-count\n             \"depth:\" depth\n             \"hang-accept:\" hang-accept\n             \"result:\" result)\n      result)))\n\n;;\n;; Performance Debugging\n;;\n\n#_(def pass-count (atom 0))\n#_(defn reset-pass-count! [] (reset! pass-count 0))\n#_(defn inc-pass-count [] (swap! pass-count inc))\n#_(defn print-pass-count [] (println \"pass-count:\" @pass-count))\n\n(defn fzprint-two-up\n  \"Print a single pair of things (though it might not be exactly a\n  pair, given comments and :extend and the like), like bindings in\n  a let, clauses in a cond, keys and values in a map.  Controlled\n  by various maps, the key of which is caller.  Returns \n  [:hang <style-vec>] or [:flow <style-vec>] so that the upstream folks\n  know whether this was a hang or flow and can do the right thing\n  based on that. If narrow-width is non-nil, that is the width to\n  harrow to, else don't narrow. Note that justify-width tells us we\n  are justifying.\"\n  [caller\n   {:keys [one-line? dbg? dbg-indent in-hang? do-in-hang? map-depth],\n    {:keys [hang? dbg-local? dbg-cnt? indent indent-arg flow? key-color\n            key-depth-color key-value-color key-value-options justify\n            multi-lhs-hang?]}\n      caller,\n    :as options} ind commas? justify-width justify-options narrow-width\n   rightmost-pair? force-flow? [lloc rloc xloc :as pair]]\n  (if dbg-cnt? (println \"two-up: caller:\" caller \"hang?\" hang? \"dbg?\" dbg?))\n  (dbg-s options\n         #{:narrow :justify :justify-result}\n         \"fzprint-two-up:\" (pr-str (zstring lloc))\n         \"justify-width:\" justify-width\n         \"width:\" (:width options)\n         \"justify-options-width:\" (:width justify-options)\n         \"(count pair):\" (count pair))\n  (if (or dbg? dbg-local?)\n    (println (or dbg-indent \"\")\n             \"==========================\"\n             (str \"\\n\" (or dbg-indent \"\"))\n             (pr-str\n               \"fzprint-two-up:\" (zstring lloc)\n               \"tag:\" (ztag lloc)\n               \"caller:\" caller\n               \"count:\" (count pair)\n               \"ind:\" ind\n               \"indent:\" indent\n               \"indent-arg:\" indent-arg\n               \"justify-width:\" justify-width\n               \"one-line?:\" one-line?\n               \"hang?:\" hang?\n               \"in-hang?\" in-hang?\n               \"do-in-hang?\" do-in-hang?\n               \"flow?\" flow?\n               \"force-flow?\" force-flow?\n               \"commas?\" commas?\n               \"rightmost-pair?\" rightmost-pair?)))\n  (let [flow? (or flow? force-flow?)\n        local-hang? (or one-line? hang?)\n        indent (or indent indent-arg)\n        ; We get options and justify-options.  Generally we want to use\n        ; the justify-options, unless we are not justifying, in which\n        ; case we want to use the regular options.  We can't tell if\n        ; we are justifying until after we figure the arg-1-width,\n        ; so we will use the justify-options for everything and\n        ; calculate one set of r-non-justify-options for use with\n        ; good-enough if we didn't justify.  This allows us to put\n        ; weird stuff in :justify-hang to change things other then\n        ; :hang-expand when we are justifying.\n        non-justify-options options\n        options justify-options\n        local-options\n          (if (not local-hang?) (assoc options :one-line? true) options)\n        _ (dbg-s options\n                 :rightmost-pair\n                 \"fzprint-two-up rightmost-pair:\" rightmost-pair?\n                 \"lloc:\" (pr-str (zstring lloc))\n                 \"width:\" (:width options)\n                 \"original-width:\" (:original-width options))\n        loptions (c-r-pair commas?\n                           rightmost-pair?\n                           nil\n                           (if narrow-width\n                             (assoc options :width narrow-width)\n                             options))\n        loptions-non-narrow (c-r-pair commas? rightmost-pair? nil options)\n        width (:width options)\n        roptions (c-r-pair commas? rightmost-pair? :rightmost options)\n        ; These are only really important for good-enough\n        non-justify-roptions\n          (c-r-pair commas? rightmost-pair? :rightmost non-justify-options)\n        local-roptions\n          (c-r-pair commas? rightmost-pair? :rightmost local-options)\n        ; If we have a key-value-color map, and the key we have matches any\n        ; of the keys in the map, then merge the resulting color-map\n        ; elements into the current color-map.  Could be problematic if\n        ; lloc is a modifier, but at present modifiers are only for extend\n        ; and key-value-color is only for maps, so they can't both show up\n        ; at once.\n        value-color-map (and key-value-color\n                             (> (count pair) 1)\n                             (zsexpr? lloc)\n                             (key-value-color (get-sexpr options lloc)))\n        local-roptions (if value-color-map\n                         (merge-deep local-roptions\n                                     {:color-map value-color-map})\n                         local-roptions)\n        roptions (if value-color-map\n                   (merge-deep roptions {:color-map value-color-map})\n                   roptions)\n        ; If we have a key-value-options map, and the key we have matches\n        ; any of the keys in the map, then merge the resulting options map\n        ; into the current options for the value.\n        value-options-map (and key-value-options\n                               (> (count pair) 1)\n                               (zsexpr? lloc)\n                               (key-value-options (get-sexpr options lloc)))\n        local-roptions (if value-options-map\n                         (merge-deep local-roptions value-options-map)\n                         local-roptions)\n        roptions (if value-options-map\n                   (merge-deep roptions value-options-map)\n                   roptions)\n        ; It is possible that lloc is a modifier, and if we have exactly\n        ; three things, we will pull rloc in with it, and move xloc to\n        ; rloc. If it is just two, we'll leave it to be handled normally.\n        ; Which might need to be re-thought due to justification, but since\n        ; we are really only talking :extend here, maybe not.\n        modifier-set (:modifiers (options caller))\n        modifier? (or (and modifier-set\n                           (modifier-set (zstring lloc))\n                           (> (count pair) 2))\n                      (middle-element? options rloc))\n        ; Figure out if we want to color keys based on their depth, and if\n        ; so, figure out the color for this one.\n        local-color (get key-depth-color (dec map-depth))\n        ; Doesn't work if we have a modifier, but at this point, key-color\n        ; is only for maps and modifiers are only for extend.\n        local-color (if (and key-color (> (count pair) 1) (zsexpr? lloc))\n                      (key-color (get-sexpr options lloc))\n                      local-color)\n        #_local-color\n        #_(cond (and map-depth (= caller :map) (= map-depth 2)) :green\n                (and map-depth (= caller :map) (= map-depth 1)) :blue\n                (and map-depth (= caller :map) (= map-depth 3)) :yellow\n                (and map-depth (= caller :map) (= map-depth 4)) :red\n                :else nil)\n        #_(println \"fzprint-two-up: :fn\" (:fn-type-map options))\n        #_(println \"fzprint-two-up: :next-inner\" (:next-inner options))\n        _ (dbg-s options\n                 :justify-result-deep\n                 \"fzprint-two-up:\" (pr-str (zstring lloc))\n                 \"one-line?\" one-line?\n                 \"loptions width:\" (:width loptions))\n        arg-1 (fzprint* loptions ind lloc)\n        ; If we were narrowing and justifying, and if this doesn't fit\n        ; the narrowing at all (i.e., returns nil), let's re-do it with\n        ; the regular width since this must be one that shouln't be\n        ; justified.\n        _ (dbg-s options\n                 #{:justify-width}\n                 \"fzprint-two-up: pre-a:\" (pr-str (zstring lloc))\n                 \"one-line?\" one-line?\n                 \"ind:\" ind\n                 \"loptions width:\" (:width loptions)\n                 \"lines:\" (style-lines options ind arg-1))\n        arg-1 (if (and (nil? arg-1) justify-width narrow-width)\n                (do (dbg-s options\n                           #{:justify-width}\n                           \"fzprint-two-up: DID NOT FIT:\" (pr-str (zstring\n                                                                    lloc))\n                           \"one-line?\" one-line?\n                           \"loptions width:\" (:width loptions))\n                    ; These need to be the regular loptions (which include\n                    ; justify-options) but just not be narrow, to match\n                    ; what fzprint-justify-width does when it redoes the\n                    ; fzprint* when it fails for narrowing.\n                    (fzprint* loptions-non-narrow ind lloc))\n                arg-1)\n        no-justify (:no-justify justify)\n        ; If we have a newline, make it one shorter since we did a newline\n        ; after the previous pair.  Unless this is the first pair, but we\n        ; should have done one before that pair too, maybe?\n        arg-1-newline? (and (= (count pair) 1) (znewline? lloc))\n        arg-1 (if local-color (replace-color local-color arg-1) arg-1)\n        ; If we are going to print the second thing on the line, we need\n        ; to know how big the first thing is, so we can see if the second\n        ; thing fits on the line.\n        [arg-1-line-count arg-1-max-width :as arg-1-lines]\n          (style-lines options ind arg-1)\n        ; Get the correct arg-1-max-width in the multi-line case.\n        ; Note that this get the width of the last line of a multi-line\n        ; arg-1!\n        arg-1-max-width (peek (nth arg-1-lines 2))\n        ; If arg-1 already takes multiple lines, we aren't going to do\n        ; anything interesting with a modifier.\n        _ (dbg options\n               \"fzprint-two-up before modifier: arg-1-line-count:\"\n                 arg-1-line-count\n               \"arg-1-max-width:\" arg-1-max-width)\n        modifier? (if (or (and arg-1-line-count (> arg-1-line-count 1))\n                          arg-1-newline?)\n                    nil\n                    modifier?)\n        ; See if we can merge the first and second things and have them\n        ; stay on the same line?\n        combined-arg-1 (if modifier?\n                         (concat-no-nil arg-1\n                                        [[(str \" \") :none :whitespace 1]]\n                                        (fzprint* (in-hang loptions)\n                                                  (+ ind arg-1-max-width)\n                                                  rloc))\n                         arg-1)\n        ; If they fit, then they are the new arg-1\n        arg-1 (if combined-arg-1 combined-arg-1 arg-1)\n        ; If they fit, then we are still doing modifier if we are already\n        modifier? (if combined-arg-1 modifier? nil)\n        ; If they fit, we need to recalculate the size of arg-1\n        [arg-1-line-count arg-1-max-width :as arg-1-lines]\n          (if combined-arg-1 (style-lines options ind arg-1) arg-1-lines)\n        ; Use the last line, not the widest\n        arg-1-max-width (peek (nth arg-1-lines 2))\n        _ (dbg options\n               \"fzprint-two-up after modifier: arg-1-line-count:\"\n                 arg-1-line-count\n               \"arg-1-max-width:\" arg-1-max-width)\n        lloc (if modifier? rloc lloc)\n        rloc (if modifier? xloc rloc)\n        ;     arg-1-fit-oneline? (and (not force-nl?)\n        ;                             (fzfit-one-line loptions\n        ;                             arg-1-lines))\n        arg-1-fit-oneline? (and (not flow?)\n                                (if multi-lhs-hang?\n                                  ; We don't care if it fits in a\n                                  ; single line so we fake it here.\n                                  true\n                                  (fzfit-one-line loptions arg-1-lines)))\n        arg-1-fit? (fzfit loptions arg-1-lines)\n        ; sometimes arg-1-max-width is nil because fzprint* returned nil,\n        ; but we need to have something for later code to use as a number\n        arg-1-width (- (or arg-1-max-width 0) ind)\n        ; Remember if we were supposed to be justifying.\n        justifying? justify-width\n        ; Should we justify the lhs of this particular pair? We use\n        ; justify-width as a signal of whether or not to justify\n        ; later in this routine.\n        justify-width (when justify-width\n                        (if (or (> arg-1-width justify-width)\n                                (when no-justify (no-justify (ffirst arg-1))))\n                          nil\n                          justify-width))\n        ; If we were doing narrow, and we were trying to justify, but this\n        ; lhs didn't meet the qualifcations for justifying, then let's not\n        ; narrow this lhs if it is a collection over one line\n        [narrow-width arg-1 arg-1-lines arg-1-width]\n          (if (and justifying?\n                   (not justify-width)\n                   narrow-width\n                   (not (fzfit-one-line loptions arg-1-lines))\n                   (= (nth (first arg-1) 2) :left))\n            ; Note that we need to use the loptions as they also have\n            ; the justify-options in them -- which needs to match what\n            ; we did in fzprint-justify-width.\n            (let [arg-1 (fzprint* (assoc loptions :width width) ind lloc)\n                  arg-1-lines (style-lines options ind arg-1)\n                  arg-1-max-width (peek (nth arg-1-lines 2))\n                  arg-1-width (- (or arg-1-max-width 0) ind)]\n              (dbg-s options\n                     #{:justify-opt :justify-width}\n                     \"fzprint-two-up: redoing lhs arg-1\" (pr-str (zstring lloc))\n                     \"arg-1-lines:\" arg-1-lines)\n              [nil arg-1 arg-1-lines arg-1-width])\n            [narrow-width arg-1 arg-1-lines arg-1-width])]\n    (dbg-s options\n           #{:justify-result :justify-width}\n           \"fzprint-two-up a:\" (zstring lloc)\n           \"justify-width:\" justify-width\n           \"narrow-width:\" narrow-width\n           \"arg-1-width\" arg-1-width\n           \"arg-1-max-width\" arg-1-max-width\n           \"ind\" ind\n           \"arg-1-lines\" arg-1-lines\n           \"arg-1-fit?\" arg-1-fit?\n           \"(not in-hang?)\" (not in-hang?)\n           \"(:width options)\" (:width options))\n    ; If we don't *have* an arg-1, no point in continuing...\n    ;  If arg-1 doesn't fit, maybe that's just how it is! If we are\n    ;  in-hang, then we can bail, but otherwise, not.\n    (dbg-pr options \"fzprint-two-up: arg-1:\" arg-1)\n    (when arg-1\n      #_(and arg-1 (or arg-1-fit? (not in-hang?)))\n      (cond\n        ; This used to always :flow\n        arg-1-newline? [(if force-flow? :flow :hang) arg-1]\n        ; This is what does comments, and will cause an infinite loop\n        ; in fzprint-map-two-up with flow-all-if-any? true,\n        ; since it used to always hang even if force-flow? was true.\n        (= (count pair) 1) [(if force-flow? :flow :hang)\n                            (fzprint* roptions ind lloc)]\n        (or (= (count pair) 2) (and modifier? (= (count pair) 3)))\n          ;concat-no-nil\n          ;  arg-1\n          ; We used to think: We will always do hanging, either fully or\n          ; with one-line? true, we will then do flow if hanging didn't do\n          ; anything or if it did, we will try to see if flow is better.\n          ;\n          ; But now, we don't do hang if arg-1-fit-oneline? is false, since\n          ; we won't use it.\n          (let [hanging-width (if justify-width justify-width arg-1-width)\n                ; These next two -n things are to keep the cljs compiler\n                ; happy, since it complains that - need numbers and these\n                ; might not be numbers if they are used below, despite the\n                ; if justify-width.  Sigh.\n                justify-width-n (or justify-width 0)\n                arg-1-width-n (or arg-1-width 0)\n                hanging-spaces\n                  (if justify-width (inc (- justify-width-n arg-1-width-n)) 1)\n                hanging-indent (+ 1 hanging-width ind)\n                flow-indent (+ indent ind)]\n            (if (and (zstring lloc)\n                     (keyword-fn? options (zstring lloc))\n                     (not (= caller :map)))\n              ; We could also check for (= caller :pair-fn) here,\n              ; or at least check to see that it isn't a map.\n              (if (zvector? rloc)\n                ; This is an embedded :let or :when-let or something. We\n                ; check to see if a keyword is found in the :fn-map\n                ; (without the :, of course) and if it is and there is a\n                ; vector after it, we assume that it must be one of these.\n                (let [[hang-or-flow style-vec] (fzprint-hang-unless-fail\n                                                 loptions\n                                                 hanging-indent\n                                                 flow-indent\n                                                 fzprint-binding-vec\n                                                 rloc)\n                      arg-1 (if (= hang-or-flow :hang)\n                              (concat-no-nil arg-1\n                                             [[(blanks hanging-spaces) :none\n                                               :whitespace 2]])\n                              arg-1)]\n                  [hang-or-flow (concat-no-nil arg-1 style-vec)])\n                (let [[hang-or-flow style-vec] (fzprint-hang-unless-fail\n                                                 loptions\n                                                 hanging-indent\n                                                 flow-indent\n                                                 fzprint*\n                                                 rloc)\n                      arg-1 (if (= hang-or-flow :hang)\n                              (concat-no-nil arg-1\n                                             [[(blanks hanging-spaces) :none\n                                               :whitespace 2]])\n                              arg-1)]\n                  [hang-or-flow (concat-no-nil arg-1 style-vec)]))\n              ; Make the above if a cond, and call fzprint-hang-one?  Or\n              ; maybe fzprint* if we are calling fzprint-hang-unless-fail,\n              ; which I think we are.\n              ;\n              ; This is a normal two element pair thing\n              (let [; Perhaps someday we could figure out if we are already\n                    ; completely in flow to this point, and be smarter\n                    ; about possibly dealing with the hang or flow now.\n                    ; But for now, we will simply do hang even if arg-1\n                    ; didn't fit on one line if the flow indent isn't\n                    ; better than the hang indent.\n                    _ (dbg options\n                           \"fzprint-two-up: before hang.  hanging tried?\"\n                           (or arg-1-fit-oneline?\n                               (and (not flow?)\n                                    (>= flow-indent hanging-indent))))\n                    ; We used to adjust the hang-flow in-line here to make\n                    ; things come out better.  Now we have instead made all\n                    ; fo the :justify-tuning to be relative to just the\n                    ; justification data or code type, and the hang-flow\n                    ; for the data in the justified rhs is independent of\n                    ; the hang-flow for the justification itself.\n                    ; local-roptions\n                    ;    (assoc-in local-roptions [:tuning :hang-flow] 1.1)\n                    hanging (when (or arg-1-fit-oneline?\n                                      (and (not flow?)\n                                           (>= flow-indent hanging-indent)))\n                              (fzprint* (if (< flow-indent hanging-indent)\n                                          (in-hang local-roptions)\n                                          local-roptions)\n                                        hanging-indent\n                                        rloc))\n                    hang-count (zcount rloc)\n                    _ (log-lines options\n                                 \"fzprint-two-up: hanging:\"\n                                 hanging-indent\n                                 hanging)\n                    hanging-lines (style-lines options hanging-indent hanging)\n                    _ (dbg-s options\n                             #{:justify :justify-result}\n                             \"fzprint-two-up:\" (zstring lloc)\n                             \"justify-width:\" justify-width\n                             \"justifying?\" justifying?\n                             \"arg-1-fit-oneline?\" arg-1-fit-oneline?\n                             \"one-line?\" one-line?\n                             \"hang?\" hang?\n                             \"hanging-indent:\" hanging-indent\n                             \"(:width local-roptions)\" (:width local-roptions)\n                             \"hanging\" (pr-str hanging))\n                    fit? (fzfit-one-line local-roptions hanging-lines)\n                    hanging-lines (if fit?\n                                    hanging-lines\n                                    (when (and (not one-line?) hang?)\n                                      hanging-lines))\n                    hanging-line-count (first hanging-lines)\n                    ; Don't flow if it fit, or it didn't fit and we were\n                    ; doing one line on input.  Do flow if we don't have\n                    ; hanging-lines and we were not one-line on input.\n                    _ (dbg options\n                           \"fzprint-two-up: fit?\" fit?\n                           \"hanging-lines:\" hanging-lines)\n                    _ (log-lines options\n                                 \"fzprint-two-up: hanging-2:\"\n                                 hanging-indent\n                                 hanging)\n                    flow-it? (or (not hanging-lines)\n                                 ; TODO: figure out what this was supposed\n                                 ; to be and fix it, w/out (not\n                                 ; hanging-lines)\n                                 (and (or (and (not hanging-lines)\n                                               (not one-line?))\n                                          (not (or fit? one-line?)))\n                                      ; this is for situations where the\n                                      ; first element is short and so the\n                                      ; hanging indent is the same as the\n                                      ; flow indent, so there is no point\n                                      ; in flow -- unless we don't have any\n                                      ; hanging-lines, in which case we\n                                      ; better do flow\n                                      (or (< flow-indent hanging-indent)\n                                          (not hanging-lines))))\n                    #_(prn \"depth:\" (:depth options)\n                           \"justify-width:\" justify-width\n                           \"flow-it?\" flow-it?\n                           \"arg-1\" arg-1)\n                    flow-it? (if (use-hang? caller\n                                            options\n                                            ind\n                                            hang-count\n                                            hanging-line-count)\n                               false\n                               flow-it?)\n                    #_(inc-pass-count)\n                    _ (dbg-s options\n                             #{:justify-opt}\n                             \"fzprint-two-up: before flow. flow-it?\"\n                             flow-it?)\n                    flow (when flow-it? (fzprint* roptions flow-indent rloc))\n                    _ (log-lines options\n                                 \"fzprint-two-up: flow:\"\n                                 (+ indent ind)\n                                 flow)\n                    flow-lines (style-lines options (+ indent ind) flow)]\n                (when dbg-local?\n                  (prn \"fzprint-two-up: local-hang:\" local-hang?)\n                  (prn \"fzprint-two-up: one-line?:\" one-line?)\n                  (prn \"fzprint-two-up: hanging-indent:\" hanging-indent)\n                  (prn \"fzprint-two-up: hanging-lines:\" hanging-lines)\n                  (prn \"fzprint-two-up: flow?:\" flow?)\n                  (prn \"fzprint-two-up: force-flow?:\" force-flow?)\n                  (prn \"fzprint-two-up: flow-it?:\" flow-it?)\n                  (prn \"fzprint-two-up: fit?:\" fit?)\n                  (prn \"fzprint-two-up: flow-indent:\" flow-indent)\n                  (prn \"fzprint-two-up: hanging:\" (zstring lloc) hanging)\n                  (prn \"fzprint-two-up: (+ indent ind):\" (+ indent ind))\n                  (prn \"fzprint-two-up: flow:\" (zstring lloc) flow))\n                (dbg options \"fzprint-two-up: before good-enough\")\n                (dbg-s options\n                       #{:justify :justify-opt}\n                       \"fzprint-two-up: b\" (zstring lloc)\n                       \"hanging-lines:\" hanging-lines\n                       \"flow-lines:\" flow-lines\n                       \"justify-width:\" justify-width\n                       \"justifying?\" justifying?\n                       \"fit?\" fit?)\n                (if fit?\n                  (do (dbg-s options\n                             :justify-result\n                             \"fzprint-two-up:\"\n                             (zstring lloc)\n                             \"justify-width:\"\n                             justify-width\n                             \"justifying?\"\n                             justifying?\n                             \"narrow-width\"\n                             narrow-width\n                             \"fit -- did hang\")\n                      [:hang\n                       (concat-no-nil arg-1\n                                      [[(blanks hanging-spaces) :none\n                                        :whitespace 3]]\n                                      hanging)])\n                  (when (or hanging-lines flow-lines)\n                    (dbg-s options\n                           #{:justify-opt}\n                           \"fzprint-two-up: before good-enough: narrow-width:\"\n                             narrow-width\n                           \"justify-width\" justify-width\n                           \"(fzfit-one-line ...)\" (fzfit-one-line loptions\n                                                                  arg-1-lines)\n                           \"coll?\" (nth (first arg-1) 2))\n                    (if (good-enough? caller\n                                      (if #_justifying?\n                                        justify-width\n                                        roptions\n                                        non-justify-roptions)\n                                      :none-two-up\n                                      hang-count\n                                      (- hanging-indent flow-indent)\n                                      hanging-lines\n                                      flow-lines)\n                      (do (dbg-s options\n                                 :justify-result\n                                 \"fzprint-two-up:\"\n                                 (zstring lloc)\n                                 \"justify-width:\"\n                                 justify-width\n                                 \"justifying?\"\n                                 justifying?\n                                 \"good enough succeeded\")\n                          [:hang\n                           (concat-no-nil arg-1\n                                          [[(blanks hanging-spaces) :none\n                                            :whitespace 4]]\n                                          hanging)])\n                      (do\n                        ; If we are justifying and this one was supposed to\n                        ; justify and good enough liked the flow better\n                        ; than the hang, then let's cancel justifying for\n                        ; everyone.\n                        (if (and justifying? justify-width)\n                          (do (dbg-s\n                                options\n                                #{:justify :justify-cancelled :justify-result}\n                                \"fzprint-two-up:\"\n                                (zstring lloc)\n                                \"justify-width:\"\n                                justify-width\n                                \"justifying?\"\n                                justifying?\n                                \"arg-1-fit-oneline?\"\n                                arg-1-fit-oneline?\n                                \"one-line?\"\n                                one-line?\n                                \"arg-1-lines:\"\n                                arg-1-lines\n                                \"hanging-lines:\"\n                                hanging-lines\n                                \"flow-lines:\"\n                                flow-lines\n                                \"hang?\"\n                                hang?\n                                \"cancelled justification, returning nil!\"\n                                \"\\n\"\n                                \"good enough follows:\")\n                              (dbg-s options\n                                     #{:justify :justify-cancelled}\n                                     \"fzprint-two-up:\" (zstring lloc)\n                                     \"\\n\" (good-enough?\n                                            caller\n                                            (assoc (if justify-width\n                                                     roptions\n                                                     non-justify-roptions)\n                                              :dbg? true)\n                                            :none-two-up\n                                            hang-count\n                                            (- hanging-indent flow-indent)\n                                            hanging-lines\n                                            flow-lines))\n                              nil)\n                          ; We either weren't justifying or this one wasn't\n                          ; supposed to justify anyway, so we'll flow.\n                          ;\n                          ; But if we did use narrow, and the lhs is\n                          ; > 1 lines, and it is a collection,\n                          ; then let's try the lhs w/out any narrow\n                          ; since the narrow can't help us now.\n                          ;\n                          ; But, we shouldn't be narrowing if we aren't\n                          ; justifying, whether or not we wanted to\n                          ; justify.\n                          (let [_ (dbg-s options\n                                         #{:justify-opt}\n                                         \"fzprint-two-up: c narrow-width:\"\n                                           narrow-width\n                                         \"(fzfit-one-line ...)\"\n                                           (fzfit-one-line loptions arg-1-lines)\n                                         \"coll?\" (nth (first arg-1) 2))\n                                arg-1\n                                  (if (and narrow-width\n                                           (not (fzfit-one-line loptions\n                                                                arg-1-lines))\n                                           (= (nth (first arg-1) 2) :left))\n                                    (do (dbg-s\n                                          options\n                                          #{:justify-opt}\n                                          \"fzprint-two-up: redoing lhs arg-1\")\n                                        (fzprint* loptions-non-narrow ind lloc))\n                                    arg-1)\n                                _ (dbg-s options\n                                         #{:justify-opt}\n                                         \"fzprint-two-up: style-lines:\"\n                                         (style-lines options ind arg-1))]\n                            [:flow\n                             (concat-no-nil arg-1\n                                            (prepend-nl options\n                                                        (+ indent ind)\n                                                        flow))])))))))))\n        :else (if (and justify-width (> (count pair) 2))\n                ; Fail justification if we are justifying and there are\n                ; more then two things in the pair. Issue #271. This is an\n                ; issue when we have :respect-nl, and so we put a newline\n                ; in the first time we format, and then the second time we\n                ; format we might well have 3 things, and so we don't even\n                ; think about justifying it, and the other things justify,\n                ; so then the output changes to be justified for some\n                ; pairs and not others.\n                ;\n                ; On the other hand, if the third thing is a comment,\n                ; this is a bit restrictive.  Let's try just failing\n                ; if one of the things is actually a newline.\n                (do\n                  (dbg-s options\n                         #{:justify :justify-result}\n                         \"fzprint-two-up:\"\n                         (zstring lloc)\n                         \"justify-width:\"\n                         justify-width\n                         \"justifying?\"\n                         justifying?\n                         \"(count pair)\"\n                         (count pair)\n                         \"(some zcomment?)\"\n                         (some zcomment? pair)\n                         \"zstring pair\"\n                         (pr-str (map zstring pair))\n                         \"Justifiction more than 2 things\")\n                  (if (some zcomment? pair)\n                    [:flow\n                     ; The following always flows things of 3 or more if\n                     ; they have a comment in them.  It doesn't cancel\n                     ; justification since this (probably?) can't be added\n                     ; by running zprint multiple times.\n                     (concat-no-nil arg-1\n                                    (fzprint-flow-seq\n                                      caller\n                                      ; Issue #271 -- respect-nl\n                                      ; causing files to change\n                                      ; after one format.  Kicks\n                                      ; them into\n                                      ; (= (count pair) 3), and\n                                      ; then rightcnt was +1.\n                                      ; Was options, not roptions.\n                                      roptions\n                                      (+ indent ind)\n                                      (if modifier? (nnext pair) (next pair))\n                                      :force-nl\n                                      :newline-first))]\n                    (do (dbg-s\n                          options\n                          #{:justify :justify-result :justify-cancelled}\n                          \"fzprint-two-up:\"\n                          (zstring lloc)\n                          \"justify-width:\"\n                          justify-width\n                          \"justifying?\"\n                          justifying?\n                          \"(count pair)\"\n                          (count pair)\n                          \"(some zcomment?)\"\n                          (some zcomment? pair)\n                          \"zstring pair\"\n                          (pr-str (map zstring pair))\n                          \"Failed justifiction more than 2 things, no comment\")\n                        nil))\n                  #_nil)\n                (do\n                  (dbg-s options\n                         #{:justify :justify-result}\n                         \"fzprint-two-up:\"\n                         (zstring lloc)\n                         \"justify-width:\"\n                         justify-width\n                         \"justifying?\"\n                         justifying?\n                         \"(count pair)\"\n                         (count pair)\n                         \"More than two things, not justifying, flowing rhs\")\n                  [:flow\n                   ; The following always flows things of 3 or more\n                   ; (absent modifers).  If the lloc is a single char,\n                   ; then that can look kind of poor.  But that case\n                   ; is rare enough that it probably isn't worth dealing\n                   ; with.  Possibly a hang-remaining call might fix it.\n                   (concat-no-nil arg-1\n                                  (fzprint-flow-seq\n                                    caller\n                                    ; Issue #271 -- respect-nl\n                                    ; causing files to change\n                                    ; after one format.  Kicks\n                                    ; them into\n                                    ; (= (count pair) 3), and\n                                    ; then rightcnt was +1.\n                                    ; Was options, not roptions.\n                                    roptions\n                                    (+ indent ind)\n                                    (if modifier? (nnext pair) (next pair))\n                                    :force-nl\n                                    :newline-first))]))))))\n\n;;\n;; # Two-up printing\n;;\n\n(defn fzprint-justify-width\n  \"Figure the width for a justification of a set of pairs in coll.  \n  Also, decide if it makes any sense to justify the pairs at all.\n  narrow? says that this call has a narrower width than necessary,\n  and triggers a check to see if any of the firsts are collections. \n  If they are not collections, and narrow-width is non-nil, then return \n  nil.\"\n  [caller {{:keys [justify? justify multi-lhs-hang?]} caller, :as options} ind\n   narrow-width coll]\n  (let [coll-2-or-more (remove nil? (map #(when (> (count %) 1) %) coll))]\n    (dbg-s options\n           #{:justify-width :justify-empty}\n           \"fzprint-justify-width: count coll-2-or-more\"\n           (map count coll-2-or-more)\n           (map #(map zstring %) coll-2-or-more))\n    ; If we don't have more than 1 element in set of pairs, we have can't\n    ; justify them\n    (if (or (<= (count coll-2-or-more) 1)\n            ; If we are below a certain depth, don't even try.\n            (> (:depth options) (or (:max-depth justify) 1000)))\n      nil\n      (let [ignore-for-variance (:ignore-for-variance justify)\n            no-justify (:no-justify justify)\n            ; Get rid of all of the things with only one element in them\n            #_#_coll-2-or-more\n              (remove nil? (map #(when (> (count %) 1) %) coll))\n            firsts\n              (map #(let [narrow-result (when narrow-width\n                                          (fzprint* (not-rightmost\n                                                      (assoc options\n                                                        :width narrow-width))\n                                                    ind\n                                                    (first %)))\n                          ; If the narrow-result didn't work at all, try it\n                          ; w/out narrowing, so we at least have\n                          ; something. This needs to use justify-options as\n                          ; much as the one above does, just not being\n                          ; narrow.  The code here has to match the code in\n                          ; fzprint-two-up where it does the lhs again if\n                          ; it fails on narrowing.\n                          result\n                            (if narrow-result\n                              narrow-result\n                              ; Try again w/out narrowing\n                              (fzprint* (not-rightmost options) ind (first %)))]\n                      result)\n                coll-2-or-more)\n            #_(println \"count coll-2-or-more\" (count coll-2-or-more)\n                       \"firsts\\n\" ((:dzprint options) {} firsts))\n            #_(def justall\n                (mapv #(fzprint* (not-rightmost options) ind (first %)) coll))\n            #_(def just firsts)\n            ; If we aren't supposed to justify something at all, remove it\n            ; from the variance calculation here.\n            firsts\n              (if no-justify (remove #(no-justify (ffirst %)) firsts) firsts)]\n        ; If we are narrowing, are any of the first we have encountered\n        ; collections?  If not, then we have no reason to narrow, so return\n        ; nil.  Also, if we had any lhs that didn't actually fit at all,\n        ; return nil as well.\n        (when (and (not (contains-nil? firsts))\n                   (or (not narrow-width)\n                       (some true? (mapv #(= (nth (first %) 2) :left) firsts))))\n          ; Is there anything that we should ignore for the variance\n          ; calculation but still justify?  This is largely for :else,\n          ; which, when it appears, it typically the last thing in a cond.\n          ; It seems fruitless to not justify a cond because a short :else\n          ; drives the variance too high, since it is rarely hard to line\n          ; up the :else with its value, no matter how far apart they are.\n          (let [firsts (if ignore-for-variance\n                         (remove #(ignore-for-variance (ffirst %)) firsts)\n                         firsts)\n                style-seq (mapv (partial style-lines options ind) firsts)\n                #_(println \"style-seq:\" ((:dzprint options) {} style-seq))\n                #_(def styleseq style-seq)\n                ; If we allow multi-lhs-hang?, then act like each was on\n                ; one line\n                each-one-line?\n                  (if multi-lhs-hang?\n                    true\n                    (reduce #(when %1 (= (first %2) 1)) true style-seq))\n                #_(def eol each-one-line?)\n                ; max-gap is nilable, so make sure it is a number\n                max-gap-configured (:max-gap justify)\n                max-gap-allowed (or max-gap-configured 1000)\n                max-gap (if max-gap-configured\n                          (let [widths (mapv second style-seq)]\n                            (if (not (empty? widths))\n                              (let [max-width (apply max widths)\n                                    min-width (apply min widths)]\n                                ; Add one for the space\n                                (inc (- max-width min-width)))\n                              0))\n                          0)\n                #_(def mg [max-gap max-gap-allowed])\n                max-gap-ok? (<= max-gap max-gap-allowed)\n                max-variance (:max-variance justify)\n                ; i273 take width of last line\n                #_(println [(vec (map #(- (peek (nth % 2)) ind) style-seq))])\n                ; take max-width of all of the lines\n                #_(println [(vec (map #(- (second %) ind) style-seq))])\n                #_(println \"style-seq:\" style-seq)\n                alignment (when (and each-one-line? max-gap-ok?)\n                            (column-width-variance\n                              max-variance\n                              ; i273\n                              (if (:multi-lhs-overlap? justify)\n                                [(vec (map #(- (peek (nth % 2)) ind)\n                                        style-seq))]\n                                [(vec (map #(- (second %) ind) style-seq))])\n                              0))\n                _ (dbg-s options\n                         #{:justify :justify-cancelled :justify-width}\n                         \"fzprint-justify-width\" (pr-str (take 6 (first firsts))\n                                                         #_firsts)\n                         \"max-variance:\" max-variance\n                         \"ind:\" ind\n                         \"ignore-for-variance:\" ignore-for-variance\n                         \"no-justify\" no-justify\n                         \"narrow-width\" narrow-width\n                         \"multi-lhs-overlap?\" (:multi-lhs-overlap? justify)\n                         \"each-one-line?\" each-one-line?\n                         \"alignment:\" alignment)\n                #_(prn \"what:\"\n                       (ffirst firsts)\n                       (first (last firsts))\n                       \"alignment:\" alignment\n                       \"ind:\" ind)\n                justify-width (when each-one-line? (first alignment))]\n            justify-width))))))\n\n(defn fit-within?\n  \"Take a size and a collection of vectors with two or more elements\n  per vector.  The elements are zlocs, the vectors are not.  Return\n  the remaining character count or nil if it for sure doesn't fit.\n  In order to be sure it doesn't fit, this version doesn't assume\n  *any* separators, so it really underestimates the size.\"\n  ([size coll depth]\n   (reduce (fn [size element]\n             (or (if (= depth 0)\n                   (fit-within? size element (inc depth))\n                   (let [remaining (- size (count (zstring element)))]\n                     (when (pos? remaining) remaining)))\n                 (reduced nil)))\n     size\n     coll))\n  ([size coll] (fit-within? size coll 0)))\n\n(defn remove-hangflow\n  \"Convert a hangflow style-vec to a sequence of regular style-vecs.\"\n  [hf-style-vec]\n  (when hf-style-vec (map second hf-style-vec)))\n\n(defn pair-lengths\n  \"When given the output from fzprint-map-two-up, calculate return the\n  output from style-lines for each thing.\"\n  [options ind result]\n  (mapv (comp (partial style-lines options ind) second) result))\n\n(defn fzprint-two-up-pass\n  \"Do one pass mapping fzprint-two-up across a sequence of pairs. The\n  options and width are whatever is appropriate for this pass.\"\n  [caller\n   {{:keys [justify? force-nl? multi-lhs-hang?]} caller,\n    :keys [width rightcnt one-line? parallel?],\n    :as options} ind justify-width justify-options narrow-width commas?\n   force-flow? coll]\n  (let [len (count coll)\n        #_#_coll (into [] coll)\n        beginning-coll (pop coll)\n        #_(butlast coll)\n        ; If beginning-coll is () because there is only a single pair\n        ; in coll, then this all works -- but only because\n        ; () is truthy, and zpmap returns () which is also truthy.\n        ; I hate relying on the truthy-ness of (), but in this case\n        ; it works out and it would be even more complicated to do\n        ; it another way.\n        beginning-remaining\n          (if one-line? (fit-within? (- width ind) beginning-coll) true)\n        _ (dbg options\n               \"fzprint-two-up-pass: remaining:\" (- width ind)\n               \"beginning-remaining:\" beginning-remaining)\n        beginning (when beginning-remaining\n                    (zpmap options\n                           (partial fzprint-two-up\n                                    caller\n                                    options\n                                    ind\n                                    commas?\n                                    justify-width\n                                    justify-options\n                                    narrow-width\n                                    nil ; rightmost-pair?\n                                    force-flow?)\n                           beginning-coll))\n        beginning (if (contains-nil? beginning) nil beginning)\n        end-coll [(peek coll) #_(last coll)]\n        ; If this is one-line? is there any point to even looking at the\n        ; end?\n        end-remaining\n          (if one-line?\n            (and beginning\n                 (fit-within? (- beginning-remaining (or rightcnt 0)) end-coll))\n            true)\n        _ (dbg options\n               \"fzprint-two-up-pass: beginning-remaining:\" beginning-remaining\n               \"rightcnt:\" rightcnt\n               \"end-remaining:\" end-remaining)\n        end (when end-remaining\n              (when-let [end-result (fzprint-two-up caller\n                                                    options\n                                                    ind\n                                                    commas?\n                                                    justify-width\n                                                    justify-options\n                                                    narrow-width\n                                                    :rightmost-pair\n                                                    force-flow? ; force-flow?\n                                                    (first end-coll))]\n                [end-result]))\n        result (cond (= len 1) end\n                     :else (concat-no-nil beginning end))]\n    (dbg-s options\n           #{:justify-result}\n           \"fzprint-two-up-pass: (count coll):\" (count coll)\n           \"(nil? end):\" (nil? end)\n           \"end:\\n\" (pr-str end)\n           \"\\n(nil? beginning):\" (nil? beginning)\n           \"beginning:\\n\" (pr-str beginning)\n           \"\\n(count end):\" (count end)\n           \"(count beginnging):\" (count beginning)\n           \"justify-width:\" justify-width)\n    result))\n\n(defn fzprint-map-two-up\n  \"Accept a sequence of pairs, and map fzprint-two-up across those pairs.\n  If you have :one-line? set, this will return nil if it is way over,\n  but it can't accurately tell exactly what will fit on one line, since\n  it doesn't know the separators and such.  So, :one-line? true is a\n  performance optimization, so it doesn't do a whole huge map just to\n  find out that it could not possibly have fit on one line.  This\n  returns a sequence of style-vecs, where the indentation for the\n  stuff inside of the pairs is already there, but the separators of\n  the style-vecs (including indentation and commas) is done by the\n  caller of fzprint-map-two-up. Always returns a sequence of vector pairs:\n  [[:hang <style-vec-for-one-pair>] [:flow <style-vec-for-one-pair>] ...].\n  If you want a style vec instead, call remove-hangflow on the return \n  from fzprint-map-two-up.  This will use one-line?, but not check to see\n  that it actually fits.  If you care about that, then you should check the\n  return yourself.  It will, however, make an estimate of whether or not\n  it will fit and if it clearly doesn't, it will return a nil.\"\n  [caller\n   {{:keys [justify? force-nl? multi-lhs-hang? justify]} caller,\n    :keys [width rightcnt one-line? parallel?],\n    :as options} ind commas? coll]\n  ; Make coll a vector, since fzprint-two-up-pass requires that\n  (let [coll (into [] coll)\n        len (count coll)]\n    ; If it is one-line? and force-nl? and there is more than one thing,\n    ; this can't work.\n    (when (not (and one-line? force-nl? (> len 1)))\n      (let [caller-options (options caller)\n            ; If the caller has flow? true, then justification is\n            ; meaningless\n            justify? (if (:flow? (caller options)) nil justify?)\n            ; If we are justifying merge in a full options map,\n            ; which can contain anything!  Don't validate it since\n            ; it was already in the options map to start with.\n            [justify-options _]\n              (when justify?\n                ; This might help performance, since at present there\n                ; isn't anything commplex oin the :justify-tuning.  And\n                ; we don't expect there to be anytime soon.  It didn't\n                ; really make much difference, interestingly enough.\n                #_[(merge-deep (merge-deep options\n                                           {caller (caller-options\n                                                     :justify-hang)})\n                               (caller-options :justify-tuning)) nil]\n                (internal-config-and-validate\n                  (merge-deep options {caller (caller-options :justify-hang)})\n                  (caller-options :justify-tuning)\n                  (str \"options in :justify-tuning for \" caller)\n                  nil ; validate?\n                ))\n            ; Some callers do not have lhs-narrow defined\n            lhs-narrow (or (:lhs-narrow justify) 1)\n            ;\n            ; There are two possibilties for justification:\n            ;  o Regular justification, with the lhs as big as it is\n            ;  o Narrowed justification, where the lhs is squeezed by a\n            ;    narrower width.  Only helps if the lhs contains some\n            ;    collections. Also this is only done if the lhs-narrow\n            ;    factor is more than 1.01.\n            ;\n            ; Each type of justification requires a different narrow-width.\n            ;\n            ; We will do both and compare them if they work.  They can fail\n            ; to work in two ways:\n            ;\n            ;  1. They can fail in fzprint-justify-width, because a good\n            ;     justify-width can't be found.\n            ;  2. They can fail in fzprint-two-up-pass, because the rhs had\n            ;     to flow, which will fail the justification.\n            ;\n            ; If only one of them works, we will use that.\n            ;\n            ; Do the fzprint-justify-width for any lhs-narrow\n            use-narrow? (and (> (- lhs-narrow 1) 0.01) justify? multi-lhs-hang?)\n            narrow-width (when use-narrow?\n                           (int (+ (/ (- (:width options) ind) lhs-narrow)\n                                   ind)))\n            justify-narrow-width\n              (when (and justify? narrow-width (not one-line?))\n                (fzprint-justify-width caller\n                                       justify-options\n                                       ind\n                                       narrow-width\n                                       coll))\n            ; Do the fzprint-justify-width without lhs-narrow\n            justify-width\n              (when (and justify? (not one-line?))\n                (fzprint-justify-width caller justify-options ind nil coll))\n            _ (dbg-s options\n                     #{:narrow :justify-width}\n                     \"fzprint-map-two-up:\"\n                     \"caller:\"\n                     caller\n                     (zstring (first (first coll)))\n                     \"lhs-narrow:\" lhs-narrow\n                     \"justify-narrow-width:\" justify-narrow-width\n                     \"justify-width:\" justify-width)\n            _ (dbg-print options\n                         \"fzprint-map-two-up: one-line?\" (:one-line? options)\n                         \"justify?:\" justify?)\n            force-flow? nil\n            flow-all-if-any? (:flow-all-if-any? caller-options)\n            ; If we are justifying, give that a try\n            result-narrow (when justify-narrow-width\n                            ;\n                            ; Pass 1: Justification, using a narrowed lhs\n                            ;         width, if any.\n                            ;\n                            (fzprint-two-up-pass caller\n                                                 options\n                                                 ind\n                                                 justify-narrow-width\n                                                 justify-options\n                                                 narrow-width\n                                                 commas?\n                                                 force-flow?\n                                                 coll))\n            result (when justify-width\n                     ;\n                     ; Pass 1A: Justification without narrowing\n                     ;\n                     (fzprint-two-up-pass caller\n                                          options\n                                          ind\n                                          justify-width\n                                          justify-options\n                                          width\n                                          commas?\n                                          force-flow?\n                                          coll))\n            ; Compare the two justifications, if any, and pick the best.\n            result (if (and result result-narrow)\n                     ; We have both justifications, compare them\n                     (let [result-lines\n                             (style-lines-hangflow options ind result)\n                           result-narrow-lines\n                             (style-lines-hangflow options ind result-narrow)]\n                       ;  [<line-count> <max-width> [line-lengths]].\n                       ;\n                       ; Use the one with the fewer lines\n                       ;\n                       (dbg-s options\n                              #{:narrow :justify-compare}\n                              \"fzprint-map-two-up: COMPARE \"\n                              \"caller:\"\n                              caller\n                              (zstring (first (first coll)))\n                              \"lhs-narrow:\" lhs-narrow\n                              \"result-lines:\" result-lines\n                              \"result-narrow-lines:\" result-narrow-lines\n                              ; \"\\nresult:\"\n                              ; ((:dzprint options) {} result)\n                              ; \"\\nresult-narrow:\"\n                              ; ((:dzprint options) {} result-narrow)\n                       )\n                       (if (> (first result-narrow-lines) (first result-lines))\n                         result\n                         result-narrow))\n                     ; We don't have both - use what we have, if any\n                     (or result result-narrow))\n            result (if result\n                     result\n                     ; The justifications didn't work or wasn't requested,\n                     ; let's try the regular approach.\n                     ;\n                     ; Pass 2: Regular, non-justified\n                     ;\n                     (fzprint-two-up-pass caller\n                                          options\n                                          ind\n                                          nil     ;justify-width\n                                          options ;justify-options\n                                          width\n                                          commas?\n                                          force-flow?\n                                          coll))\n            ; Check to see if anything flowed, and if care about\n            ; how many did because of flow-all-if-any?\n            [flow-all-if-any-fail? result hang-flow-set]\n              (if flow-all-if-any?\n                (let [hang-flow-set (set (mapv first result))]\n                  (if (<= (count hang-flow-set) 1)\n                    [false result hang-flow-set]\n                    [true nil hang-flow-set]))\n                [false result nil])\n            result (if flow-all-if-any-fail?\n                     ; We had a flow but not all flowed, and we had\n                     ; flow-all-if-any? true, so try again and force flow\n                     ; for all pairs.\n                     ;\n                     ; Pass 3: Force flow for every pair\n                     ;\n                     (fzprint-two-up-pass caller\n                                          options\n                                          ind\n                                          nil     ;justify-width\n                                          options ;justify-options\n                                          width\n                                          commas?\n                                          true    ;force-flow?\n                                          coll)\n                     result)\n            _ (when flow-all-if-any-fail?\n                (let [hang-flow-set (set (mapv first result))]\n                  (when (> (count hang-flow-set) 1)\n                    (dbg-pr options\n                            \"fzprint-map-two-up: ****************#############\"\n                              \" force-flow? didn't yield a single value in\"\n                            \" hang-flow-set:\" hang-flow-set))))]\n        (dbg-pr options\n                \"fzprint-map-two-up: len:\" len\n                \"justify-width:\" justify-width\n                \"flow-all-if-any?\" flow-all-if-any?\n                \"flow-all-if-any-fail?\" flow-all-if-any-fail?\n                \"hang-flow-set:\" hang-flow-set)\n        (dbg options\n             \"fzprint-map-two-up: result:\"\n             ((:dzprint options) {} result))\n        (do #_(let [pair-lens (pair-lengths options ind result)]\n                (println \"result:\"\n                         ((:dzprint options) {} result)\n                         ((:dzprint options) {} pair-lens)\n                         \"median:\" (median (mapv first pair-lens))\n                         \"mean:\" (int (mean (mapv first pair-lens)))\n                         \"percent-gt-n:\" (percent-gt-n 3\n                                                       (mapv first pair-lens))))\n            result)))))\n\n;;\n;; ## Support sorting of map keys\n;;\n\n(defn compare-keys\n  \"Do a key comparison that works well for numbers as well as\n  strings.\"\n  [x y]\n  (cond (and (number? x) (number? y)) (compare x y)\n        :else (compare (str x) (str y))))\n\n(defn compare-ordered-keys\n  \"Do a key comparison that places ordered keys first or last, based on\n  where they fall with respect to the value of a divider -- :|.\"\n  [key-value divider-value zdotdotdot x y]\n  (cond (and (key-value x) (key-value y)) (compare (key-value x) (key-value y))\n        (key-value x) (if (< (key-value x) divider-value) -1 +1)\n        (key-value y) (if (< (key-value y) divider-value) +1 -1)\n        (= zdotdotdot x) +1\n        (= zdotdotdot y) -1\n        :else (compare-keys x y)))\n\n(defn order-out\n  \"A variety of sorting and ordering options for the output of\n  partition-all-2-nc.  It can sort, which is the default, but if\n  the caller has a key-order vector, it will extract any keys in\n  that vector and place them first (in order) before sorting the\n  other keys.  If sorting is not called for, does nothing.\n  Note that key-value is a map of the keys in key-order associated\n  with ranges values based on their indicies in key-order.  The\n  key-value map is created in add-calculated-options in config.cljc.\"\n  [caller\n   {{:keys [sort? sort-in-code? key-order key-value]} caller,\n    :keys [in-code?],\n    :as options} access out]\n  (dbg-pr options\n          \"order-out caller:\" caller\n          \"key-order:\" key-order\n          \"sort?\" sort?\n          \"sort-in-code?\" sort-in-code?\n          \"in-code?\" in-code?\n          \"key-value:\" key-value)\n  (let [key-value (or key-value {})\n        divider-value (or (key-value :|) (inc (count out)))]\n    (if (and sort? (if in-code? sort-in-code? true))\n      (sort\n        #((partial compare-ordered-keys key-value divider-value (zdotdotdot))\n            (get-sexpr options (access %1))\n            (get-sexpr options (access %2)))\n        out)\n      out)))\n\n(defn pair-element?\n  \"This checks to see if an element should be considered part of a\n  pair if it comes between other elements, and a single element on\n  its own if it would otherwise be the first part of a pair.  Mostly\n  this will trigger on comments, but a #_(...) element will also\n  trigger this, as will a newline if one appears.\"\n  [zloc]\n  (or (zcomment? zloc) (zuneval? zloc) (znewline? zloc)))\n\n(defn nosort?\n  \"Check a zloc to see if this should trigger no-sort? for this set\n   of pairs.\"\n  [no-sort-set zloc]\n  (when no-sort-set\n    (and (= (ztag zloc) :token)\n         (let [s (zstring zloc)]\n           (or (no-sort-set s)\n               (let [regex-seq (filter (comp not string?) no-sort-set)]\n                 (when (not (empty? regex-seq))\n                   (some #(re-find % s) regex-seq))))))))\n\n\n(defn middle-element?\n  \"This checks to see if an element should be considered the middle element\n  of a pair.  At some point, we can expand this, but for now there is only\n  one middle element.\"\n  [{:keys [in-code?], :as options} zloc]\n  ;  nil)\n  (when (= in-code? \"condp\") (= (zstring zloc) \":>>\")))\n\n;;\n;; # Ignore keys in maps\n;;\n\n(defn remove-key-seq\n  \"If given a non-collection, simply does a dissoc of the key, but\n  if given a sequence of keys, will remove the final one.\"\n  [m ks]\n  (if (coll? ks)\n    (let [this-key (first ks)\n          next-key (next ks)]\n      (if next-key\n        (let [removed-map (remove-key-seq (get m this-key) (next ks))]\n          (if (empty? removed-map)\n            (dissoc m this-key)\n            (assoc m this-key removed-map)))\n        (dissoc m this-key)))\n    (dissoc m ks)))\n\n(defn ignore-key-seq-silent\n  \"Given a map and a key sequence, remove that key sequence if\n  it appears in the map, and terminate the reduce if it changes\n  the map.\"\n  [m ks]\n  (if (coll? ks)\n    (if (= (get-in m ks :zprint-not-found) :zprint-not-found)\n      m\n      (remove-key-seq m ks))\n    (if (= (get m ks :zprint-not-found) :zprint-not-found) m (dissoc m ks))))\n\n(defn ignore-key-seq\n  \"Given a map and a key sequence, remove that key sequence if\n  it appears in the map leaving behind a key :zprint-ignored, \n  and terminate the reduce if it changes the map.\"\n  [m ks]\n  (if (coll? ks)\n    (if (= (get-in m ks :zprint-not-found) :zprint-not-found)\n      m\n      (assoc-in m ks :zprint-ignored))\n    (if (= (get m ks :zprint-not-found) :zprint-not-found)\n      m\n      (assoc m ks :zprint-ignored))))\n\n(defn map-ignore\n  \"Take a map and remove any of the key sequences specified from it.\n  Note that this only works for sexpressions, not for actual zippers.\"\n  [caller {{:keys [key-ignore key-ignore-silent]} caller, :as options} zloc]\n  (let [ignored-silent (if key-ignore-silent\n                         (reduce ignore-key-seq-silent zloc key-ignore-silent)\n                         zloc)\n        ignored (if key-ignore\n                  (reduce ignore-key-seq ignored-silent key-ignore)\n                  ignored-silent)]\n    ignored))\n\n;;\n;; # Pre-processing for two-up printing\n;;\n\n(defn partition-all-2-nc\n  \"Input is (zseqnws zloc) or (zseqnws-w-nl) where one assumes that\n  these are pairs.  Thus, a seq of zlocs.  Output is a sequence of\n  seqs, where the seqs are usually pairs, but might be single things.\n  Doesn't pair up comments or #_(...) unevaled sexpressions.  The\n  ones before the first part of a pair come as a single element in\n  what would usually be a pair, and the ones between the first and\n  second parts of a pair come inside the pair.  There may be an\n  arbitrary number of elements between the first and second elements\n  of the pair (one per line).  If there are any comments or unevaled\n  sexpressions, don't sort the keys, as we might lose track of where\n  the comments or unevaled s-expressions go.\"\n  [caller options coll]\n  (when-not (empty? coll)\n    (let [max-length (get-max-length options)\n          no-sort-set (:key-no-sort (caller options))]\n      (loop [remaining coll\n             no-sort? nil\n             index 0\n             out (transient [])]\n        (dbg-pr options\n                \"partition-all-2-nc: index:\" index\n                \"no-sort?:\" no-sort?\n                ;  \"out:\" (map (comp zstring first)(persistent! out))\n                \"first remaining:\" (zstring (first remaining))\n                \"second remaining:\" (zstring (second remaining)))\n        (if-not remaining\n          [no-sort? (persistent! out)]\n          (let [[new-remaining pair-vec new-no-sort?]\n                  (cond (pair-element? (first remaining))\n                          [(next remaining) [(first remaining)] true]\n                        (or (pair-element? (second remaining))\n                            (middle-element? options (second remaining)))\n                          (let [[comment-seq rest-seq]\n                                  ;(split-with pair-element? (next\n                                  ;remaining))\n                                  (split-with #(or (pair-element? %)\n                                                   (middle-element? options %))\n                                              (next remaining))]\n                            (if (first rest-seq)\n                              ; We have more to than just a comment, so we\n                              ; can pair it up between two things.\n                              [(next rest-seq)\n                               (into []\n                                     (concat [(first remaining)]\n                                             comment-seq\n                                             [(first rest-seq)])) true]\n                              ; This is the end, don't pair a comment up\n                              ; with something on the left if there isn't\n                              ; something on the right of it.\n                              [(next remaining) [(first remaining)] true]))\n                        (= (count remaining) 1) [(next remaining)\n                                                 [(first remaining)] nil]\n                        :else [(next (next remaining))\n                               [(first remaining) (second remaining)] nil])\n                new-no-sort? (or new-no-sort?\n                                 (nosort? no-sort-set (first remaining)))]\n            #_(println \"partition-all-2-nc: count new-remaining:\"\n                       (count new-remaining))\n            (dbg-pr options\n                    \"partition-all-2-nc: pair-vec: first:\" (zstring (first\n                                                                      pair-vec))\n                    \"first tag:\" (ztag (first pair-vec))\n                    \"count:\" (count pair-vec)\n                    \"last:\" (zstring (last pair-vec)))\n            (recur (cond (< (inc index) max-length) new-remaining\n                         (and (= (inc index) max-length) new-remaining)\n                           (list (zdotdotdot))\n                         :else nil)\n                   (or no-sort? new-no-sort?)\n                   (inc index)\n                   (conj! out pair-vec))))))))\n\n;;\n;; ## Multi-up printing pre-processing\n;;\n\n(defn cleave-end\n  \"Take a seq, and if it is contains a single symbol, simply return\n  it in another seq.  If it contains something else, remove any non\n  collections off of the end and return them in their own double seqs,\n  as well as return the remainder (the beginning) as a double seq.\"\n  [coll]\n  (if (or (zsymbol? (first coll)) (zreader-cond-w-symbol? (first coll)))\n    ;(symbol? (first coll))\n    (list coll)\n    (let [rev-seq (reverse coll)\n          [split-non-coll _]\n            ;(split-with (comp not zcoll?) rev-seq)\n            (split-with #(not (or (zcoll? %) (zreader-cond-w-coll? %))) rev-seq)\n          #_(def sncce split-non-coll)\n          split-non-coll (map list (reverse split-non-coll))\n          remainder (take (- (count coll) (count split-non-coll)) coll)]\n      (if (empty? remainder)\n        split-non-coll\n        (concat (list remainder) split-non-coll)))))\n\n(defn partition-all-sym\n  \"Similar to partition-all-2-nc, but instead of trying to pair things\n  up (modulo comments and unevaled expressions), this begins things\n  with a symbol, and then accumulates collections until the next symbol.\n  Returns a seq of seqs, where the first thing in each internal seq is\n  a protocol and the remaining thing(s) in that seq are the expressions that\n  follow.  If there is a single thing, it is returned in its own internal\n  seq. ((P (foo [this a) (bar-me [this] b) (barx [this y] (+ c y))) ...)\n  Made harder by the fact that the symbol might be inside of a #?() reader\n  conditional.  It handles comments before symbols on the symbol indent, \n  and the comments before the collections on the collection indent.  \n  Since it doesn't know how many collections there are, this is not trivial.  \n  Must be called with a sequence of z-things (these days called a zseq)\"\n  [options modifier-set coll]\n  #_(prn \"partition-all-sym:\")\n  (dbg-pr options \"partition-all-sym:\" modifier-set)\n  #_(def scoll coll)\n  (dbg options \"partition-all-sym: coll:\" (map zstring coll))\n  (let [part-sym (partition-by\n                   #(or (zsymbol? %) (znil? %) (zreader-cond-w-symbol? %))\n                   coll)\n        split-non-coll (mapcat cleave-end part-sym)]\n    #_(def ps part-sym)\n    #_(def snc split-non-coll)\n    (loop [remaining split-non-coll\n           out (transient [])]\n      #_(prn \"remaining:\" (zprint.repl/pseqzseq remaining))\n      #_(prn \"out:\" (zprint.repl/pseqzseq out))\n      (if (empty? remaining)\n        (let [result (persistent! out)]\n          #_(def pasn result)\n          result)\n        (let [[next-remaining new-out]\n                (cond (and (or (zsymbol? (ffirst remaining))\n                               (znil? (ffirst remaining))\n                               (zreader-cond-w-symbol? (ffirst remaining)))\n                           (not (empty? (second remaining)))\n                           ; This keeps a comment after a symbol with no\n                           ; collections from being associated with the\n                           ; previous symbol instead of standing on its own\n                           ; (as it should)\n                           (or (not (or (= (ztag (first (second remaining)))\n                                           :comment)\n                                        (= (ztag (first (second remaining)))\n                                           :newline)))\n                               (zcoll? (last (second remaining)))))\n                        ; We have a non-collection in (first remaining) and\n                        ; we might have more than one, either because we\n                        ; just have a bunch of non-colls with no colls or\n                        ; because we have a modifier and then one or more\n                        ; non-colls (possibly with their own modifiers).\n                        (if (= (count (first remaining)) 1)\n                          ; original\n                          (do #_(prn \"a:\")\n                              ; We have a single non-coll, pull the next\n                              ; seq of one or more seqs into a seq with it.\n                              ; This is where we marry up the non-coll with\n                              ; all of its associated colls.\n                              [(nthnext remaining 2)\n                               (conj! out\n                                      (concat (first remaining)\n                                              (second remaining)))])\n                          (do\n                            #_(prn \"b:\")\n                            (if (and modifier-set\n                                     (modifier-set (zstring (ffirst\n                                                              remaining))))\n                              (if (= (count (first remaining)) 2)\n                                ; We have exactly two things in (first\n                                ; remaining), and the first one is both a\n                                ; non-coll and a modifier, so we know that\n                                ; the second one is a non-coll, and we know\n                                ; that we have a (second remaining) from\n                                ; above, so we bring the second remaining\n                                ; into the first remaining like we did\n                                ; above\n                                (do #_(prn \"d:\")\n                                    [(nthnext remaining 2)\n                                     (conj! out\n                                            (concat (first remaining)\n                                                    (second remaining)))])\n                                ; We have a modifier as the first thing in\n                                ; a seq of non-colls and then some more\n                                ; non-colls after that (since we don't have\n                                ; exactly two, as that case was caught\n                                ; above). Pull the next one into a seq with\n                                ; it. Do we need to check that the next one\n                                ; is also a non-coll?  That shouldn't be\n                                ; necessary,as you won't get colls in\n                                ;with non-colls.\n                                (do #_(prn \"c:\")\n                                    [(if (next (next (first remaining)))\n                                       (cons (next (next (first remaining)))\n                                             (next remaining))\n                                       (next remaining))\n                                     (conj! out\n                                            (list (ffirst remaining)\n                                                  (second (first\n                                                            remaining))))]))\n                              ; we have more than one non-coll in first\n                              ; remaining, so pull one out, and leave the\n                              ; next ones for the next loop\n                              [(cons (next (first remaining)) (next remaining))\n                               (conj! out (list (ffirst remaining)))])))\n                      :else [(next remaining) (conj! out (first remaining))])]\n          (recur next-remaining new-out))))))\n\n(defn rstr-vec\n  \"Create an r-str-vec with the indent appropriate for the r-str if\n  it is preceded by a newline.\"\n  ([options ind zloc r-str r-type]\n   [[r-str (zcolor-map options (or r-type r-str)) (or r-type :right) ind]])\n  ([options ind zloc r-str] (rstr-vec options ind zloc r-str nil)))\n\n(declare interpose-nl-hf)\n(declare fzprint-get-zloc-seq)\n\n(defn fzprint-binding-vec\n  [{{:keys [nl-separator?]} :binding, :as options} ind zloc]\n  (dbg options \"fzprint-binding-vec: ind:\" ind \"zloc:\" (zstring (zfirst zloc)))\n  (let [options (rightmost options)\n        l-str \"[\"\n        r-str \"]\"\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options ind zloc r-str)]\n    (dbg-form options\n              \"fzprint-binding-vec exit:\"\n              (if (= (zcount zloc) 0)\n                (concat-no-nil l-str-vec r-str-vec)\n                (concat-no-nil\n                  l-str-vec\n                  (interpose-nl-hf\n                    (:binding options)\n                    (inc ind)\n                    (fzprint-map-two-up\n                      :binding\n                      options\n                      (inc ind)\n                      false\n                      (second\n                        (partition-all-2-nc\n                          :binding\n                          options\n                          ; This is controlled by the :vector config\n                          ; options, because if we added it to the\n                          ; :binding option, it would not work because\n                          ; the fzprint-list* one line testing doesn't\n                          ; know it is a binding vector, it thinks\n                          ; that it is just a vector.  Alternatively\n                          ; we could probably notice that we were in\n                          ; a :binding fn-type, and force :vector\n                          ; :respect-nl? to be the same as :binding\n                          ; :respect-nl? for the one-line test.  Which\n                          ; would fail if there were some other vector\n                          ; with newlines in it that wasn't the\n                          ; binding vector.  Ultimately this is because\n                          ; :respect-nl? (and :respect-bl?) are only\n                          ; defined for vectors, maps, lists and sets,\n                          ; and that is implemented by changing what\n                          ; gets returned as a zloc-seq.\n                          (fzprint-get-zloc-seq :vector options zloc)))))\n                  r-str-vec)))))\n\n(defn fzprint-hang\n  \"Try to hang something and try to flow it, and then see which is\n  better.  Has hang and flow indents. fzfn is the function to use \n  to do zloc.  Note what fzfn does with the input. Presumably the\n  caller knows what the fzfn does, so it has to count the items\n  itself and pass it in here as zloc-count if it isn't just (zcount zloc).\"\n  [{:keys [one-line? force-eol-blanks?], :as options} caller hindent findent\n   fzfn zloc-count zloc]\n  (dbg options \"fzprint-hang: caller:\" caller)\n  (let [hanging (when (and (not= hindent findent)\n                           ((options caller) :hang?)\n                           ; If it starts with a newline, we aren't hanging\n                           ; it.  Comment, sure, but not newline.\n                           (not (znewline? (first zloc))))\n                  (concat-no-nil [[(str \" \") :none :whitespace 5]]\n                                 (fzfn (in-hang options) hindent zloc)))\n        #_(prn \"fzprint-hang: first hanging:\" (first hanging) (second hanging))\n        _ (dbg options\n               \"fzprint-hang: caller:\" caller\n               \"hang?\" ((options caller) :hang?))\n        hanging (when (not= (nth (second hanging) 2) :comment-inline) hanging)\n        hang-count (or zloc-count (zcount zloc))\n        hr-lines (style-lines options (dec hindent) hanging)\n        ;flow (fzfn options findent zloc)\n       ]\n    (if (or (fzfit-one-line options hr-lines) one-line?)\n      hanging\n      (let [flow (let [result (fzfn options findent zloc)]\n                   (concat-no-nil\n                     ; This will create an end-of-line blanks situation so\n                     ; we can test our ability to see it.  If we weren't\n                     ; intentionally creating end-of-line blanks, we would\n                     ; use prepend-nl here.\n                     (if (if force-eol-blanks? nil (first-nl? result))\n                       [[(str \"\\n\") :none :indent 42]]\n                       [[(str \"\\n\" (blanks findent)) :none :indent 4]])\n                     result))\n            _ (log-lines options \"fzprint-hang: flow:\" findent flow)\n            fd-lines (style-lines options findent flow)\n            _ (dbg-pr options\n                      \"fzprint-hang: ending: hang-count:\" hang-count\n                      \"hanging:\" hanging\n                      \"flow:\" flow)\n            hr-good? (when hanging\n                       (good-enough? caller\n                                     options\n                                     :none-hang\n                                     hang-count\n                                     (- hindent findent)\n                                     hr-lines\n                                     fd-lines))]\n        (if hr-good? hanging flow)))))\n\n(defn fzprint-pairs\n  \"Always prints pairs on a different line from other pairs. Takes a zloc-seq.\n  Defaults to caller as :pair, but will accept :binding as an alternative.\"\n  ([{{:keys [nl-separator? respect-nl?]} :pair, :as options} ind zloc-seq\n    caller]\n   (dbg-pr options\n           \"fzprint-pairs:\" (zstring (first zloc-seq))\n           \"rightcnt:\" (:rightcnt options))\n   (dbg-form options\n             \"fzprint-pairs: exit:\"\n             (interpose-nl-hf\n               (caller options)\n               ind\n               (fzprint-map-two-up\n                 caller\n                 options\n                 ind\n                 false\n                 (let [[_ part] (partition-all-2-nc caller options zloc-seq)]\n                   #_(def fp part)\n                   (dbg-pr options\n                           \"fzprint-pairs: partition:\" (map (comp zstring first)\n                                                         part)\n                           \"respect-nl?\" respect-nl?)\n                   part)))))\n  ([options ind zloc-seq] (fzprint-pairs options ind zloc-seq :pair)))\n\n(defn check-for-coll?\n  \"Return true if the first non-newline element in the seq is a coll?\"\n  [zloc-seq]\n  #_(prn \"check-for-coll? begin sequence\")\n  (loop [coll zloc-seq]\n    (if-not coll\n      nil\n      (let [zloc (first coll)]\n        #_(prn \"check-for-coll? zloc:\" (ztag zloc))\n        (cond (znewline? zloc) (recur (next coll))\n              (zcoll? zloc) true\n              (zsymbol? zloc) nil\n              (znil? zloc) nil\n              ; if we don't know what it is, should we skip it?\n              :else (recur (next coll)))))))\n\n(defn check-for-first-coll?\n  \"Check a series of sequences to see if the first non-newine thing in any \n  of them\n  is a zcoll?.  If it is, return true, else nil.\"\n  [seq-series]\n  (some check-for-coll? seq-series))\n\n(declare fzprint-hang-remaining)\n\n(defn fzprint-extend\n  \"Print things with a symbol and collections following.  Kind of like with\n  pairs, but not quite. Takes a zloc-seq.\"\n  [{{:keys [nl-separator?]} :extend, :as options} ind zloc-seq]\n  #_(def fezloc zloc-seq)\n  (dbg options \"fzprint-extend:\" (zstring (first zloc-seq)))\n  (let [part\n          (partition-all-sym options (:modifiers (:extend options)) zloc-seq)]\n    #_(def fe part)\n    (dbg options \"fzprint-extend: partition:\" (map #(map zstring %) part))\n    ; Look for any sequences in part which have zcoll? as their first\n    ; element.  If we find any, we don't do the map-two-up, but rather\n    ; fzprint-hang-remaining.\n    (if (check-for-first-coll? part)\n      ; The input does *not* look like an extend, so we won't try to\n      ; format it like one.\n      (dbg-form options\n                \"fzprint-extend: fzprint-hang-remaining exit:\"\n                (let [result (fzprint-hang-remaining :extend\n                                                     (assoc options\n                                                       :fn-style :fn)\n                                                     ind\n                                                     ind\n                                                     zloc-seq\n                                                     nil)]\n                  ; If it starts with a newline, remove it, since we will\n                  ; be doing a prepend-nl for the results of fzprint-extend\n                  ; whenever we use it.\n                  (if (and (or (= (nth (first result) 2) :indent)\n                               (= (nth (first result) 2) :newline))\n                           (clojure.string/starts-with? (ffirst result) \"\\n\"))\n                    (next result)\n                    result)))\n      (dbg-form options\n                \"fzprint-extend: exit:\"\n                (interpose-nl-hf (:extend options)\n                                 ind\n                                 (fzprint-map-two-up :extend\n                                                     (assoc options\n                                                       :fn-style :fn)\n                                                     ind\n                                                     false\n                                                     part))))))\n\n(defn concatv!\n  \"Given a transient vector v, concatenate all of the other\n  elements in all of the remaining collections onto v.\"\n  [v & rest]\n  (loop [cols rest\n         out v]\n    (if cols\n      (recur (next cols)\n             (loop [col (first cols)\n                    out out]\n               (if col (recur (next col) (conj! out (first col))) out)))\n      out)))\n\n(defn fzprint-one-line\n  \"Do a fzprint-seq like thing, but do it incrementally and\n  if it gets too big, return nil.\"\n  [options ind zloc-seq]\n  (dbg-print options \"fzprint-one-line:\")\n  (let [seq-right zloc-seq\n        len (count seq-right)\n        last-index (dec len)\n        gt-1? (> (count seq-right) 1)\n        options (assoc options :one-line? true)]\n    (loop [zloc-seq seq-right\n           new-ind (long ind)\n           index 0\n           out (transient [])]\n      (if (empty? zloc-seq)\n        (do (dbg options \"fzprint-one-line: exiting count:\" (count out))\n            (persistent! out))\n        (let [next-zloc (first zloc-seq)\n              [sep next-options]\n                (cond ; this needs to come first in case there is only one\n                      ; element in the list -- it needs to have\n                      ; the rightcnt passed through\n                  (= index last-index) [(if-not (zero? index)\n                                          [[\" \" :none :whitespace 6]]) options]\n                  (= index 0) [nil (not-rightmost options)]\n                  :else [[[\" \" :none :whitespace 7]] (not-rightmost options)])\n              next-out (fzprint* next-options new-ind next-zloc)\n              _ (log-lines options \"fzprint-one-line:\" new-ind next-out)\n              [line-count max-width :as next-lines]\n                (style-lines options new-ind next-out)]\n          (if-not (fzfit-one-line next-options next-lines)\n            (do (dbg options\n                     \"fzprint-one-line: failed, too wide or too many lines!\")\n                nil)\n            (recur (next zloc-seq)\n                   (inc (long max-width))\n                   (inc index)\n                   (concatv! out sep next-out))))))))\n\n(defn fzprint-seq\n  \"Take a seq of a zloc, created by (zmap identity zloc).  Return\n  a seq of the fzprint* of each element.  No spacing between any\n  of these elements. Note that this is not a style-vec, but a seq\n  of style-vecs of each of the elements.  These would need to be\n  concatenated together to become a style-vec.  ind is either a\n  constant or a seq of indents, one for each element in zloc-seq.\n  Note that right gets evaluated immediately, while left yields a\n  lazy sequence which get evaluated later.\"\n  [options ind zloc-seq]\n  (let [max-length (get-max-length options)\n        len (count zloc-seq)\n        zloc-seq (if (> len max-length)\n                   (concat (take max-length zloc-seq) (list (zdotdotdot)))\n                   zloc-seq)\n        len (count zloc-seq)]\n    (dbg options\n         \"fzprint-seq: (count zloc-seq):\" len\n         \"max-length:\" max-length\n         \"ind:\" ind)\n    (cond (empty? zloc-seq) nil\n          (zero? max-length) [[[\"#?#\" (zcolor-map options :keyword) :element]]]\n          :else (let [left (zpmap options\n                                  #(fzprint* (not-rightmost options) %1 %2)\n                                  (if (coll? ind) ind (repeat ind))\n                                  (butlast zloc-seq))\n                      right [(fzprint* options\n                                       (if (coll? ind) (last ind) ind)\n                                       (last zloc-seq))]]\n                  (cond (= len 1) right\n                        :else (concat-no-nil left right))))))\n\n(declare precede-w-nl)\n\n(defn fzprint-flow-seq\n  \"Takes zloc-seq, a seq of a zloc, created by (zmap identity zloc),\n  and returns a style-vec of the result.  Either it fits on one\n  line, or it is rendered on multiple lines.  You can force multiple\n  lines with force-nl?. If the seq is empty, returns :noseq, which\n  is what you give concat-no-nil if you want this to just disappear.\n  If you want it to do less than everything in the original zloc,\n  modify the result of (zmap identity zloc) to just contain what\n  you want to print. ind is either a single indent, or a seq of\n  indents, one for each element in zloc-seq.  Don't concatenate an\n  indent/newline on to the beginning of the output from this routine.\n  Let this routine do it for you, as it needs to know one is there\n  in order to properly deal with any newlines in the actual stream.\n  Else you will get two where you only should have one.\"\n  ([caller {{:keys [nl-count]} caller, :as options} ind zloc-seq force-nl?\n    nl-first?]\n   (dbg-pr options\n           \"fzprint-flow-seq: count zloc-seq:\" (count zloc-seq)\n           \"nl-first?\" nl-first?\n           \"force-nl?\" force-nl?\n           \"zloc-seq:\" (map zstring zloc-seq))\n   (let [coll-print (fzprint-seq options ind zloc-seq)\n         ; If we are force-nl?, then don't bother trying one-line\n         one-line (apply concat-no-nil\n                    (interpose [[\" \" :none :whitespace 8]] coll-print))\n         _ (log-lines options \"fzprint-flow-seq:\" ind one-line)\n         one-line-lines (style-lines options ind one-line)]\n     (dbg-pr options \"fzprint-flow-seq: coll-print:\" coll-print)\n     (dbg-form\n       options\n       \"fzprint-flow-seq: exit:\"\n       (if (and (not force-nl?) (fzfit-one-line options one-line-lines))\n         one-line\n         (if (not (empty? coll-print))\n           (apply concat-no-nil\n             (precede-w-nl options ind coll-print (not nl-first?) nl-count))\n           :noseq)))))\n  ([caller options ind zloc-seq]\n   (fzprint-flow-seq caller options ind zloc-seq nil nil))\n  ([caller options ind zloc-seq force-nl?]\n   (fzprint-flow-seq caller options ind zloc-seq force-nl? nil)))\n\n(defn fzprint-hang-one\n  \"Try out the given zloc, and if it fits on the current line, just\n  do that. It might fit on the same line, as this may not be the rest\n  of the list that we are printing. If not, check it out with good-enough?\n  and do the best you can.  Three choices, really: fits on same line, \n  does ok as hanging, or better with flow. hindent is hang-indent, and \n  findent is flow-indent, and each contains the initial separator.  \n  Might be nice if the fn-style actually got sent to this fn.\"\n  [caller {:keys [one-line? width], {:keys [hang-avoid]} caller, :as options}\n   hindent findent zloc]\n  (dbg-pr options\n          \"fzprint-hang-one:\" (zstring zloc)\n          \" hindent:\" hindent\n          \"findent:\" findent)\n  (when (:dbg-hang options)\n    (println (dots (:pdepth options))\n             \"h1 caller:\"\n             caller\n             (zstring (if (zcoll? zloc) (zfirst zloc) zloc))))\n  (let [local-options (if (and (not one-line?) (not (:hang? (caller options))))\n                        (assoc options :one-line? true)\n                        options)\n        ; If we don't have an hindent, we better not be trying to hang\n        ; things -- in this case, we'll just flow.\n        hindent (or hindent findent)\n        hang-count (zcount zloc)\n        ; This implements :hang-avoid for fzprint-hang-one, instead of just\n        ; for fzprint-hang-remaining.  It didn't change the tests, but\n        ; removed some silly formatting when using :arg2 and small widths.\n        hanging (when (and (not= hindent findent)\n                           (or (not hang-avoid)\n                               (< hang-count (* (- width hindent) hang-avoid))))\n                  (fzprint* (in-hang local-options) hindent zloc))\n        hanging (concat-no-nil [[\" \" :none :whitespace 9]] hanging)\n        _ (log-lines options \"fzprint-hang-one: hanging:\" (dec hindent) hanging)\n        hr-lines (style-lines options (dec hindent) hanging)]\n    _\n    (dbg options\n         \"fzprint-hang-one: hr-lines:\" hr-lines\n         \"hang-count:\" hang-count)\n    ; if hanging is nil and one-line? is true, then we didn't fit\n    ; and should exit\n    ;\n    ; if hanging is nil and one-line? is nil, and hang? nil,\n    ; then we we don't hang and this didn't fit on the same\n    ; line and we should contine\n    ;\n    ; if hanging is true, then if one-line? is true and fzfit-one-line\n    ; is true, then we just go with hanging\n    ;\n    ; if hanging is true and if fzfit-one-line is true, then we go\n    ; with hanging.  Which is probably the same as just above.\n    ;\n    ; if hanging is true and if one-line? is nil, and if hang? is\n    ; nil, and fzfit-one-line is true then it fit on one line and we\n    ; should go with hanging.\n    ;\n    ;\n    ; Summary:\n    ;\n    ; go with hanging if:\n    ;\n    ;  o fzfit-one-line true\n    ;  o one-line? true\n    ;\n    ; Otherwise, see about flow too\n    ;\n    (if (or (fzfit-one-line options hr-lines) one-line?)\n      hanging\n      (let [flow (prepend-nl options findent (fzprint* options findent zloc))\n            _ (log-lines options \"fzprint-hang-one: flow:\" findent flow)\n            fd-lines (style-lines options findent flow)\n            _ (dbg options \"fzprint-hang-one: fd-lines:\" fd-lines)\n            #_(println \"fzprint-hang-one: fd-lines:\" fd-lines)\n            _ (dbg options\n                   \"fzprint-hang-one: ending: hang-count:\" hang-count\n                   \"hanging:\" (pr-str hanging)\n                   \"flow:\" (pr-str flow))\n            hr-good? (and (:hang? (caller options))\n                          ; no point in calling good-enough if no hr-lines\n                          hr-lines\n                          (good-enough? caller\n                                        options\n                                        :none-hang-one\n                                        hang-count\n                                        (- hindent findent)\n                                        hr-lines\n                                        fd-lines))]\n        #_(println \"fzprint-hang-one: hr-good?\" hr-good?)\n        (if hr-good? hanging flow)))))\n\n;;\n;; # Constant pair support\n;;\n\n(declare zcomment-or-newline?)\n\n; This, you might think, would be faster.  But in reality it is almost\n; exactly the same as the version that reverses the list.\n; And even a bit more complex to understand, so we'll leave it\n; here for additional possible optimizations and simplifications later.\n\n#_(defn count-constant-pairs-new\n    \"Given a seq of zlocs, work backwards from the end, and see how\n  many elements are pairs of constants (using zconstant?).  So that\n  (... :a (stuff) :b (bother)) returns 4, since both :a and :b are\n  zconstant? true. This is made more difficult by having to skip\n  comments along the way as part of the pair check, but keep track\n  of the ones we skip so the count is right in the end.  We don't\n  expect any spaces in this but newlines must be handled, because \n  this seq should have been produced by zmap or its equivalent.\n  Returns two things: [paired-item-count actual-paired-items],\n  where paired-item-count is the number of things from the end of\n  the seq you have to trim off to get the constant pairs included,\n  and the actual-paired-items is the count of the items to be checked\n  against the constant-pair-min (which is exclusive of comments and\n  newlines).  \"\n    [zloc-seq]\n    (let [zloc-seq (if (vector? zloc-seq) zloc-seq (into [] zloc-seq))\n          len (count zloc-seq)\n          last-element-idx (dec len)]\n      ; If we don't have at least two elements, we aren't doing anything\n      ; useful\n      (if (not (pos? last-element-idx))\n        [0 0]\n        (loop [idx last-element-idx\n               element-count 0\n               paired-element-count 0\n               ; since it is reversed, we need a constant every second\n               ; element\n               constant-required? nil\n               pair-size 0\n               actual-pair-size 0]\n          (let [element (nth zloc-seq idx)]\n            #_(prn \"count-constant-pairs: element-count:\" element-count\n                   \"paired-element-count:\" paired-element-count\n                   \"constant-required:\" constant-required?\n                   \"pair-size:\" pair-size\n                   \"actual-pair-size:\" actual-pair-size\n                   \"element:\" (zstring element))\n            (let [comment-or-newline? (zcomment-or-newline? element)]\n              (if (and (not comment-or-newline?)\n                       constant-required?\n                       (not (zconstant? element)))\n                ; we counted the right-hand and any comments of this pair,\n                ; but it isn't a pair so exit now with whatever we have so\n                ; far\n                [(- element-count pair-size)\n                 (- paired-element-count actual-pair-size)]\n                (let [element-count (inc element-count)\n                      paired-element-count (if comment-or-newline?\n                                             paired-element-count\n                                             (inc paired-element-count))\n                      pair-size (if (and constant-required?\n                                         (not comment-or-newline?))\n                                  ; must be a constant, so start count over\n                                  0\n                                  (inc pair-size))\n                      actual-pair-size (if (and constant-required?\n                                                (not comment-or-newline?))\n                                         ; start count of actual pairs over\n                                         ; as well\n                                         0\n                                         (if comment-or-newline?\n                                           ; we are only counting actual\n                                           ; pairs here\n                                           actual-pair-size\n                                           (inc actual-pair-size)))]\n                  ; Are we finished?\n                  (if (zero? idx)\n                    ; Yes, remove potential elements of this pair, since we\n                    ; haven't seen the end of it, and return\n                    [(- element-count pair-size)\n                     (- paired-element-count actual-pair-size)]\n                    ; Not yet finished\n                    (recur (dec idx)\n                           element-count\n                           paired-element-count\n                           (if comment-or-newline?\n                             constant-required?\n                             (not constant-required?))\n                           pair-size\n                           actual-pair-size))))))))))\n\n(defn count-constant-pairs\n  \"Given a seq of zlocs, work backwards from the end, and see how\n  many elements are pairs of constants (using zconstant? or the\n  supplied constant-pair-fn).  So that (... :a (stuff) :b (bother))\n  returns 4, since both :a and :b are zconstant? true. This is made\n  more difficult by having to skip comments along the way as part\n  of the pair check, but keep track of the ones we skip so the count\n  is right in the end.  We don't expect any spaces in this but\n  newlines must be handled, because this seq should have been\n  produced by zmap or its equivalent.  Returns two things:\n  [paired-item-count actual-paired-items], where paired-item-count\n  is the number of things from the end of the seq you have to trim\n  off to get the constant pairs included, and the actual-paired-items\n  is the count of the items to be checked against the constant-pair-min\n  (which is exclusive of comments and newlines).\"\n  [options constant-pair-fn zloc-seq]\n  (loop [zloc-seq-rev (reverse zloc-seq)\n         element-count 0\n         paired-element-count 0\n         ; since it is reversed, we need a constant every second element\n         constant-required? nil\n         pair-size 0\n         actual-pair-size 0]\n    (let [element (first zloc-seq-rev)]\n      #_(prn \"count-constant-pairs: element-count:\" element-count\n             \"paired-element-count:\" paired-element-count\n             \"constant-required:\" constant-required?\n             \"pair-size:\" pair-size\n             \"actual-pair-size:\" actual-pair-size\n             \"element:\" (zstring element))\n      (if (empty? zloc-seq-rev)\n        ; remove potential elements of this pair, since we haven't\n        ; seen the end of it, and return\n        [(- element-count pair-size) (- paired-element-count actual-pair-size)]\n        (let [comment-or-newline? (zcomment-or-newline? element)]\n          #_(prn \"count-constant-pair:\" (get-sexpr options element)\n                 \"constant-pair-fn:\" constant-pair-fn)\n          (if (and (not comment-or-newline?)\n                   constant-required?\n                   (if constant-pair-fn\n                     ; If we can't call sexpr on it, it isn't a constant\n                     (not (when (zsexpr? element)\n                            (constant-pair-fn (get-sexpr options element))))\n                     (not (zconstant? element))))\n            ; we counted the right-hand and any comments of this pair, but\n            ; it isn't a pair so exit now with whatever we have so far\n            [(- element-count pair-size)\n             (- paired-element-count actual-pair-size)]\n            (recur (next zloc-seq-rev)\n                   (inc element-count)\n                   (if comment-or-newline?\n                     paired-element-count\n                     (inc paired-element-count))\n                   (if comment-or-newline?\n                     constant-required?\n                     (not constant-required?))\n                   (if (and constant-required? (not comment-or-newline?))\n                     ; must be a constant, so start count over\n                     0\n                     (inc pair-size))\n                   (if (and constant-required? (not comment-or-newline?))\n                     ; start count of actual pairs over as well\n                     0\n                     (if comment-or-newline?\n                       ; we are only counting actual pairs here\n                       actual-pair-size\n                       (inc actual-pair-size))))))))))\n\n(defn constant-pair\n  \"Argument is a zloc-seq.  Output is a [pair-seq non-paired-item-count],\n  if any.  If there are no pair-seqs, pair-seq must be nil, not an\n  empty seq.  This will largely ignore newlines and comments.\"\n  [caller\n   {{:keys [constant-pair? constant-pair-fn constant-pair-min]} caller,\n    :as options} zloc-seq]\n  #_(prn \"constant-pair:\" caller constant-pair-fn)\n  (if constant-pair?\n    (let [[paired-item-count actual-paired-items]\n            (count-constant-pairs options constant-pair-fn zloc-seq)\n          non-paired-item-count (- (count zloc-seq) paired-item-count)\n          _ (dbg options\n                 \"constant-pair: non-paired-items:\" non-paired-item-count\n                 \"paired-item-count:\" paired-item-count\n                 \"actual-paired-items:\" actual-paired-items)\n          pair-seq (when (>= actual-paired-items constant-pair-min)\n                     (drop non-paired-item-count zloc-seq))]\n      [pair-seq non-paired-item-count])\n    [nil (count zloc-seq)]))\n\n;;\n;; # Take into account constant pairs\n;;\n\n(declare interpose-either-nl-hf)\n\n(defn zcomment-or-newline?\n  \"If this zloc is a comment or a newline, return true.\"\n  [zloc]\n  (or (zcomment? zloc) (znewline? zloc)))\n\n(defn ensure-start-w-nl\n  \"Given a style-vec, ensure it starts with a newline.  If it doesn't,\n  then put one in.  We could take the whole newline, but the indent is\n  really the only unique thing.\"\n  [ind style-vec]\n  #_(def eswn style-vec)\n  #_(prn \"ensure-start-w-nl:\" style-vec)\n  (let [element-type (nth (first style-vec) 2)]\n    #_(prn \"ensure-start-w-nl:\" element-type)\n    (if (or (= element-type :newline) (= element-type :indent))\n      style-vec\n      ; Don't need prepend-nl, since we wouldn't be doing this if there\n      ; was a newline on the front of style-ec\n      (concat-no-nil [[(str \"\\n\" (blanks ind)) :none :indent 6]] style-vec))))\n\n(defn ensure-end-w-nl\n  \"Given a style-vec, ensure it ends with a newline.  If it doesn't,\n  then put one in.\"\n  [ind style-vec]\n  #_(def eewn style-vec)\n  #_(prn \"ensure-end-w-nl:\" style-vec)\n  (let [element-type (nth (last style-vec) 2)]\n    #_(prn \"ensure-end-w-nl:\" element-type)\n    (if (or (= element-type :newline) (= element-type :indent))\n      style-vec\n      (concat-no-nil style-vec [[(str \"\\n\" (blanks ind)) :none :indent 7]]))))\n\n\n; This version does hang first, and if it passes use-hang?, it\n; doesn't bother to do flow.\n\n(defn fzprint-hang-remaining\n  \"zloc-seq is a seq of zlocs of a collection.  We already know\n  that the given zloc won't fit on the current line. [Besides, we\n  ensure that if there are two things remaining anyway. ???] So\n  now, try hanging and see if that is better than flow.  Unless\n  :hang? is nil, in which case we will just flow.  hindent is\n  hang-indent, and findent is flow-indent. This should never be\n  called with :one-line because this is only called from fzprint-list*\n  after the one-line processing is done. If the hindent equals the\n  flow indent, then just do flow.  Do only zloc-count non-whitespace\n  elements of zloc-seq if it exists.\"\n  ([caller\n    {:keys [dbg? width],\n     {:keys [hang? constant-pair? constant-pair-min hang-avoid hang-expand\n             hang-diff nl-separator? respect-nl?]}\n       caller,\n     :as options} hindent findent zloc-seq fn-style zloc-count]\n   (when (:dbg-hang options)\n     (println (dots (:pdepth options)) \"hr:\" (zstring (first zloc-seq))))\n   (dbg-pr options\n           \"fzprint-hang-remaining first:\" (zstring (first zloc-seq))\n           \"hindent:\" hindent\n           \"findent:\" findent\n           \"caller:\" caller\n           \"nl-separator?:\" nl-separator?\n           \"(count zloc-seq):\" (count zloc-seq))\n   ; (in-hang options) slows things down here, for some reason\n   (let [seq-right zloc-seq\n         seq-right (if zloc-count (take zloc-count seq-right) seq-right)]\n     (if (empty? seq-right)\n       :noseq\n       (let [[pair-seq non-paired-item-count]\n               (constant-pair caller options seq-right)\n             _ (dbg options\n                    \"fzprint-hang-remaining count pair-seq:\"\n                    (count pair-seq))\n             #_(dbg options\n                    \"fzprint-hang-remaining: *=*=*=*=*=*\" (zstring (first\n                                                                     zloc-seq))\n                    \"hindent:\" hindent\n                    \"findent:\" findent\n                    \"caller:\" caller\n                    \"hang?\" hang?\n                    \"hang-diff\" hang-diff)\n             ; Now determine if there is any point in doing a hang, because\n             ; if the flow is beyond the expand limit, there is really no\n             ; chance that the hang is not beyond the expand limit.\n             ; This is what good-enough? does:\n             ;  (<= (/ (dec p-lines) p-count) hang-expand)\n             ;  Also need to account for the indent diffs.\n             ; Would be nice to move this into a common routine, since this\n             ; duplicates logic in good-enough?\n             ;\n             ; Yes, and this caused a problem when I put in the\n             ; hang-if-equal-flow? option in good-enough, so that now we\n             ; can't cancel the hang even though we are beyond the\n             ; hang-expand because the hang might be the same as the flow,\n             ; and in that case we don't really care how long the\n             ; hang-expand is. We could make this a feature, by having a\n             ; large-ish hang-expand and having it override\n             ; hang-if-equal-flow.  If we do that, we have to reorder the\n             ; checks in good-enough to put the hang-expand check first. I\n             ; can't see any great reason for doing a flow if the hang and\n             ; flow are equal, though, so we won't do that now.  And this\n             ; code comes out.\n             ;\n             #_#_[flow flow-lines] (zat options flow) ; PT\n             _ (dbg options\n                    \"fzprint-hang-remaining: first hang?\" hang?\n                    \"hang-avoid\" hang-avoid\n                    \"findent:\" findent\n                    \"hindent:\" hindent\n                    \"(count seq-right):\" (count seq-right)\n                    \"thing:\" (when hang-avoid (* (- width hindent) hang-avoid)))\n             hang? (and\n                     hang?\n                     ; This is a key for \"don't hang no matter what\", it\n                     ; isn't about making it prettier. People call this\n                     ; routine with these values equal to ensure that it\n                     ; always flows.\n                     (not= hindent findent)\n                     ; This is not the original, below. If we are doing\n                     ; respect-nl?, then the count of seq-right is going to\n                     ; be a lot more, even if it doesn't end up looking\n                     ; different than before.  So, perhaps we should adjust\n                     ; hang-avoid here?  Perhaps double it or something?\n                     (or (not hang-avoid)\n                         (< (count seq-right) (* (- width hindent) hang-avoid)))\n                     ; If the first thing in the flow is a comment, maybe\n                     ; we shouldn't be hanging anything?\n                     #_(not= (nth (first flow) 2) :comment-inline) ; PT\n                     ;flow-lines\n                     ;;TODO make this uneval!!!\n                     #_(or (<= (- hindent findent) hang-diff)\n                           (<= (/ (dec (first flow-lines)) (count seq-right))\n                               hang-expand)))\n             _ (dbg options \"fzprint-hang-remaining: second hang?\" hang?)\n             hanging\n               (#?@(:bb [do]\n                    :clj [zfuture options]\n                    :cljs [do])\n                (let [hang-result\n                        (when hang?\n                          (if-not pair-seq\n                            ; There are no paired elements\n                            (fzprint-flow-seq caller\n                                              (in-hang options)\n                                              hindent\n                                              seq-right\n                                              :force-nl\n                                              nil ;nl-first?\n                            )\n                            (if (not (zero? non-paired-item-count))\n                              (concat-no-nil\n                                ; The elements that are not paired\n                                (dbg-form options\n                                          \"fzprint-hang-remaining: mapv:\"\n                                          (ensure-end-w-nl\n                                            hindent\n                                            (fzprint-flow-seq\n                                              caller\n                                              (not-rightmost (in-hang options))\n                                              hindent\n                                              (take non-paired-item-count\n                                                    seq-right)\n                                              :force-nl\n                                              nil ;nl-first?\n                                            )))\n                                ; The elements that are paired\n                                (dbg-form\n                                  options\n                                  \"fzprint-hang-remaining: fzprint-hang:\"\n                                  (fzprint-pairs (in-hang options)\n                                                 hindent\n                                                 pair-seq)))\n                              ; All elements are paired\n                              (fzprint-pairs (in-hang options)\n                                             hindent\n                                             pair-seq))))]\n                  [hang-result (style-lines options hindent hang-result)]))\n             ; We used to calculate hang-count by doing the hang an\n             ; then  counting the output.  But ultimately this is\n             ; simple a series of map calls to the elements of\n             ; seq-right, so we go right to the source for this\n             ; number now.  That let's us move the interpose calls\n             ; above this point.\n             [hanging [hanging-line-count :as hanging-lines]] (zat options\n                                                                   hanging)\n             hang-count (count seq-right)\n             flow? (not (use-hang? caller\n                                   options\n                                   hindent\n                                   hang-count\n                                   hanging-line-count))\n             #_(inc-pass-count)\n             flow\n               (when flow?\n                 (#?@(:bb [do]\n                      :clj [zfuture options]\n                      :cljs [do])\n                  (let [flow-result\n                          (if-not pair-seq\n                            ; We don't have any constant pairs\n                            (fzprint-flow-seq caller\n                                              options\n                                              findent\n                                              seq-right\n                                              :force-nl\n                                              :nl-first)\n                            (if (not (zero? non-paired-item-count))\n                              ; We have constant pairs, ; but they follow\n                              ; some stuff that isn't paired. Do the\n                              ; elements that are not pairs\n                              (concat-no-nil\n                                (ensure-end-w-nl findent\n                                                 (fzprint-flow-seq\n                                                   caller\n                                                   (not-rightmost options)\n                                                   findent\n                                                   (take non-paired-item-count\n                                                         seq-right)\n                                                   :force-nl\n                                                   :nl-first))\n                                ; The elements that are constant pairs\n                                (fzprint-pairs options findent pair-seq))\n                              ; This code path is where we have all\n                              ; constant pairs.\n                              (fzprint-pairs options findent pair-seq)))]\n                    ; Skip the first line when doing the calcuation so that\n                    ; good-enough doesn't change the layout from the\n                    ; original\n                    [flow-result\n                     (style-lines\n                       options\n                       findent\n                       ; Issue #173 -- the following code caused code to\n                       ; disappear, because if there was just one thing\n                       ; in flow-result, then it would be empty and\n                       ; style-lines would return nil, causing neither\n                       ; hang nor flow to be used.\n                       ;\n                       ; (if (not pair-seq)\n                       ;   (next flow-result)\n                       ;   flow-result)\n                       ;\n                       ; Now we do a similar thing -- as long as\n                       ; flow-result has more than one thing, below when we\n                       ; call good-enough.\n                       flow-result)])))\n             [flow flow-lines] (when flow (zat options flow)) ; PT\n             _ (log-lines options\n                          \"fzprint-hang-remaining: hanging:\"\n                          hindent\n                          hanging)\n             _ (dbg options\n                    \"fzprint-hang-remaining: hanging-lines:\" hanging-lines\n                    \"hang-count:\" hang-count)]\n         (dbg options \"fzprint-hang-remaining: flow-lines:\" flow-lines)\n         (when dbg?\n           (if (zero? hang-count)\n             (println \"hang-count = 0:\" (str (map zstring zloc-seq)))))\n         (log-lines options \"fzprint-hang-remaining: flow\" findent flow)\n         ; If we did hang and not flow, then we better use it.\n         (if (and hanging-lines (not flow-lines))\n           (if (first-nl? hanging)\n             hanging\n             (concat-no-nil [[\" \" :none :whitespace 10]] hanging))\n           (when flow-lines\n             (if\n               ; Only call good-enough if we have both hanging-lines and\n               ; flow-lines!\n               (and hanging-lines\n                    (good-enough?\n                      caller\n                      options\n                      fn-style\n                      hang-count\n                      (- hindent findent)\n                      hanging-lines\n                      ; If we have more than one line in the flow\n                      ; and we didn't have any constant pairs,\n                      ; then decrease the line count for the flow.\n                      ; This seems to be necessary based on the results,\n                      ; but it can't be done in good-enough in all cases,\n                      ; because it breaks lots of stuff.  This was\n                      ; previously done above, in the call to style-lines,\n                      ; where we just skipped the first line.  That\n                      ; seems like a bad idea, so we now just create\n                      ; a new flow-lines to cover this situation.\n                      ; This was provoked by Issue #173 where we lost\n                      ; code when there was only one thing in flow-result,\n                      ; and we skipped that thing, causing style-lines\n                      ; to return nil and the whole thing disappeared.\n                      (if (and (not pair-seq) (> (first flow-lines) 1))\n                        [(dec (first flow-lines)) (second flow-lines)\n                         (nth flow-lines 2)]\n                        flow-lines)))\n               ; If hanging starts with a newline, don't put a blank at the\n               ; end of the previous line.\n               (if (first-nl? hanging)\n                 hanging\n                 (concat-no-nil [[\" \" :none :whitespace 10]] hanging))\n               (ensure-start-w-nl findent flow))))))))\n  ([caller options hindent findent zloc fn-style]\n   (fzprint-hang-remaining caller options hindent findent zloc fn-style nil)))\n\n\n; This version overlaps hang and flow, which can run into trouble when\n; you get very deep -- it runs out of threads.  But we'll keep it here\n; just for illustrative purposes, since when it works, it is pretty fast.\n#_(defn fzprint-hang-remaining-overlap\n    \"zloc-seq is a seq of zlocs of a collection.  We already know\n  that the given zloc won't fit on the current line. [Besides, we\n  ensure that if there are two things remaining anyway. ???] So\n  now, try hanging and see if that is better than flow.  Unless\n  :hang? is nil, in which case we will just flow.  hindent is\n  hang-indent, and findent is flow-indent. This should never be\n  called with :one-line because this is only called from fzprint-list*\n  after the one-line processing is done. If the hindent equals the\n  flow indent, then just do flow.  Do only zloc-count non-whitespace\n  elements of zloc-seq if it exists.\"\n    ([caller\n      {:keys [dbg? width],\n       {:keys [hang? constant-pair? constant-pair-min hang-avoid hang-expand\n               hang-diff nl-separator? respect-nl?]}\n         caller,\n       :as options} hindent findent zloc-seq fn-style zloc-count]\n     (when (:dbg-hang options)\n       (println (dots (:pdepth options)) \"hr:\" (zstring (first zloc-seq))))\n     (dbg-pr options\n             \"fzprint-hang-remaining first:\" (zstring (first zloc-seq))\n             \"hindent:\" hindent\n             \"findent:\" findent\n             \"caller:\" caller\n             \"nl-separator?:\" nl-separator?\n             \"(count zloc-seq):\" (count zloc-seq))\n     ; (in-hang options) slows things down here, for some reason\n     (let [seq-right zloc-seq\n           seq-right (if zloc-count (take zloc-count seq-right) seq-right)\n           [pair-seq non-paired-item-count]\n             (constant-pair caller options seq-right)\n           _ (dbg options\n                  \"fzprint-hang-remaining count pair-seq:\"\n                  (count pair-seq))\n           flow\n             (#?@(:bb [do]\n                  :clj [zfuture options]\n                  :cljs [do])\n              (let [flow-result (if-not pair-seq\n                                  ; We don't have any constant pairs\n                                  (fzprint-flow-seq options\n                                                    findent\n                                                    seq-right\n                                                    :force-nl\n                                                    :nl-first)\n                                  (if (not (zero? non-paired-item-count))\n                                    ; We have constant pairs, ; but they\n                                    ; follow some stuff that isn't paired.\n                                    ; Do the elements that are not pairs\n                                    (concat-no-nil\n                                      (ensure-end-w-nl\n                                        findent\n                                        (fzprint-flow-seq\n                                          (not-rightmost options)\n                                          findent\n                                          (take non-paired-item-count seq-right)\n                                          :force-nl\n                                          :nl-first))\n                                      ; The elements that are constant\n                                      ; pairs\n                                      (fzprint-pairs options findent pair-seq))\n                                    ; This code path is where we have all\n                                    ; constant pairs.\n                                    (fzprint-pairs options findent pair-seq)))]\n                ; Skip the first line when doing the calcuation so that\n                ; good-enough doesn't change the layout from the original\n                [flow-result\n                 (style-lines\n                   options\n                   findent\n                   (if (not pair-seq) (next flow-result) flow-result))]))\n           #_(dbg options\n                  \"fzprint-hang-remaining: *=*=*=*=*=*\" (zstring (first\n                                                                   zloc-seq))\n                  \"hindent:\" hindent\n                  \"findent:\" findent\n                  \"caller:\" caller\n                  \"hang?\" hang?\n                  \"hang-diff\" hang-diff)\n           ; Now determine if there is any point in doing a hang, because\n           ; if the flow is beyond the expand limit, there is really no\n           ; chance that the hang is not beyond the expand limit.\n           ; This is what good-enough? does:\n           ;  (<= (/ (dec p-lines) p-count) hang-expand)\n           ;  Also need to account for the indent diffs.\n           ; Would be nice to move this into a common routine, since this\n           ; duplicates logic in good-enough?\n           ;\n           ; Yes, and this caused a problem when I put in the\n           ; hang-if-equal-flow? option in good-enough, so that now we\n           ; can't cancel the hang even though we are beyond the\n           ; hang-expand because the hang might be the same as the flow,\n           ; and in that case we don't really care how long the hang-expand\n           ; is. We could make this a feature, by having a large-ish\n           ; hang-expand and having it override hang-if-equal-flow.  If we\n           ; do that, we have to reorder the checks in good-enough to put\n           ; the hang-expand check first. I can't see any great reason for\n           ; doing a flow if the hang and flow are equal, though, so we\n           ; won't do that now.  And this code comes out.\n           ;\n           #_#_[flow flow-lines] (zat options flow) ; PT\n           _ (dbg options\n                  \"fzprint-hang-remaining: first hang?\" hang?\n                  \"hang-avoid\" hang-avoid\n                  \"findent:\" findent\n                  \"hindent:\" hindent\n                  \"(count seq-right):\" (count seq-right)\n                  \"thing:\" (when hang-avoid (* (- width hindent) hang-avoid)))\n           hang? (and\n                   hang?\n                   ; This is a key for \"don't hang no matter what\", it\n                   ; isn't about making it prettier. People call this\n                   ; routine with these values equal to ensure that it\n                   ; always flows.\n                   (not= hindent findent)\n                   ; This is not the original, below. If we are doing\n                   ; respect-nl?, then the count of seq-right is going to\n                   ; be a lot more, even if it doesn't end up looking\n                   ; different than before.  So, perhaps we should adjust\n                   ; hang-avoid here?  Perhaps double it or something?\n                   (or (not hang-avoid)\n                       (< (count seq-right) (* (- width hindent) hang-avoid)))\n                   ; If the first thing in the flow is a comment, maybe we\n                   ; shouldn't be hanging anything?\n                   #_(not= (nth (first flow) 2) :comment-inline) ; PT\n                   ;flow-lines\n                   ;;TODO make this uneval!!!\n                   #_(or (<= (- hindent findent) hang-diff)\n                         (<= (/ (dec (first flow-lines)) (count seq-right))\n                             hang-expand)))\n           _ (dbg options \"fzprint-hang-remaining: second hang?\" hang?)\n           hanging\n             (#?@(:bb [do]\n                  :clj [zfuture options]\n                  :cljs [do])\n              (let [hang-result\n                      (when hang?\n                        (if-not pair-seq\n                          ; There are no paired elements\n                          (fzprint-flow-seq (in-hang options)\n                                            hindent\n                                            seq-right\n                                            :force-nl\n                                            nil ;nl-first?\n                          )\n                          (if (not (zero? non-paired-item-count))\n                            (concat-no-nil\n                              ; The elements that are not paired\n                              (dbg-form options\n                                        \"fzprint-hang-remaining: mapv:\"\n                                        (ensure-end-w-nl\n                                          hindent\n                                          (fzprint-flow-seq\n                                            (not-rightmost (in-hang options))\n                                            hindent\n                                            (take non-paired-item-count\n                                                  seq-right)\n                                            :force-nl\n                                            nil ;nl-first?\n                                          )))\n                              ; The elements that are paired\n                              (dbg-form options\n                                        \"fzprint-hang-remaining: fzprint-hang:\"\n                                        (fzprint-pairs (in-hang options)\n                                                       hindent\n                                                       pair-seq)))\n                            ; All elements are paired\n                            (fzprint-pairs (in-hang options)\n                                           hindent\n                                           pair-seq))))]\n                [hang-result (style-lines options hindent hang-result)]))\n           ; We used to calculate hang-count by doing the hang an then\n           ; counting the output.  But ultimately this is simple a series\n           ; of map calls to the elements of seq-right, so we go right to\n           ; the source for this number now.  That let's us move the\n           ; interpose calls above this point.\n           [hanging hanging-lines] (zat options hanging)\n           [flow flow-lines] (zat options flow) ; PT\n           hang-count (count seq-right)\n           _ (log-lines options\n                        \"fzprint-hang-remaining: hanging:\"\n                        hindent\n                        hanging)\n           _ (dbg options\n                  \"fzprint-hang-remaining: hanging-lines:\" hanging-lines\n                  \"hang-count:\" hang-count)]\n       (dbg options \"fzprint-hang-remaining: flow-lines:\" flow-lines)\n       (when dbg?\n         (if (zero? hang-count)\n           (println \"hang-count = 0:\" (str (map zstring zloc-seq)))))\n       (log-lines options \"fzprint-hang-remaining: flow\" findent flow)\n       (when flow-lines\n         (if (good-enough? caller\n                           options\n                           fn-style\n                           hang-count\n                           (- hindent findent)\n                           hanging-lines\n                           flow-lines)\n           ; If hanging starts with a newline, don't put a blank at the\n           ; end of the previous line.\n           (if (first-nl? hanging)\n             hanging\n             (concat-no-nil [[\" \" :none :whitespace 10]] hanging))\n           (ensure-start-w-nl findent flow)))))\n    ([caller options hindent findent zloc fn-style]\n     (fzprint-hang-remaining caller options hindent findent zloc fn-style nil)))\n\n;;\n;; # Find out and print what comes before the next element\n;;\n\n(defn fzprint-get-zloc-seq\n  \"Get the zloc seq, with or without newlines, as indicated by the options.\"\n  [caller options zloc]\n  (let [caller-options (caller options)\n        zloc-seq (cond (:respect-nl? caller-options) (zmap-w-nl identity zloc)\n                       (:respect-bl? caller-options) (zmap-w-bl identity zloc)\n                       :else (zmap identity zloc))]\n    (dbg-pr options \"fzprint-get-zloc-seq:\" (map zstring zloc-seq))\n    zloc-seq))\n\n(declare drop-thru-first-non-whitespace)\n\n(defn extract-meta\n  \"Given a zloc, if it is a zmeta?, then add all of the things at\n  the beginning (which are :meta) to the ouput and then the last\n  thing (which should be :token) to the output.\"\n  [caller options out-vec element]\n  (if (zmeta? element)\n    (let [remaining (drop-thru-first-non-whitespace\n                      (fzprint-get-zloc-seq caller options element))]\n      #_(dbg-pr options \"extract-meta remaining:\" remaining)\n      (if (= (ztag (first remaining)) :meta)\n        ; do it again\n        (extract-meta caller options (conj out-vec element) (first remaining))\n        (apply conj (conj out-vec element) remaining)))\n    (conj out-vec element)))\n\n(defn fzprint-split-meta-in-seq\n  \"Given the results from fzprint-get-zloc-seq, if any of the elements are\n  zmeta?, then if :meta :split? true, make the second and succeeding\n  elements of the meta an independent element in the outer seq.  \n  Returns a zloc-seq.\"\n  [caller options zloc-seq]\n  (let [result (if (:split? (:meta options))\n                 (reduce (partial extract-meta caller options) [] zloc-seq)\n                 zloc-seq)]\n    (dbg-pr options\n            \"fzprint-split-meta-in-seq: split?\" (:split? (:meta options))\n            \"result:\" (map zstring result)\n            \"tags:\" (map ztag result))\n    result))\n\n(defn newline-or-comment?\n  \"Given an zloc, is it a newline or a comment?\"\n  [zloc]\n  (when zloc\n    (let [zloc-tag (ztag zloc)]\n      (or (= zloc-tag :newline) (= zloc-tag :comment)))))\n\n(defn remove-last-newline\n  \"Given a seq of style-vecs, look at the last one, and if it is a\n  :newline, then remove it.  But the last one might be a single\n  one, in which case we will remove the whole thing, and it might be\n  the last one in a sequence, in which case we will remove just that\n  one.  If there is nothing left, return [[[\\\"\\\" :none :none]]].\"\n  [ssv]\n  #_(prn \"remove-last-newline:\" ssv)\n  (let [last-style-vec (last ssv)]\n    (if-not (= (nth (last last-style-vec) 2) :newline)\n      ssv\n      (let [last-len (count last-style-vec)\n            total-len (count ssv)\n            remove-one\n              (concat (butlast ssv)\n                      (if (= last-len 1) [] (vector (butlast last-style-vec))))]\n        (if (empty? remove-one) [[[\"\" :none :none]]] remove-one)))))\n\n(defn remove-one-newline\n  \"Given a single style-vec, look at the last element, and if it is a\n  :newline, remove it.  If there is nothing left, return :noseq\"\n  [style-vec]\n  #_(prn \"remove-one-newline:\" style-vec)\n  (let [last-style-vec (last style-vec)]\n    (if-not (= (nth last-style-vec 2) :newline)\n      style-vec\n      (let [remaining (butlast style-vec)]\n        (if (empty? remaining) :noseq remaining)))))\n\n(defn add-newline-to-comment\n  \"Given [[[\\\";stuff\\\" :none :comment]]] or \n  [[[\\\";bother\\\" :none :comment-inline 1]]] add [\\\"\\n\\\" :none :newline]\n  to the inside of it.\"\n  [indent fzprint*-return]\n  (let [the-type (nth (first fzprint*-return) 2)]\n    (if (or (= the-type :comment) (= the-type :comment-inline))\n      (concat fzprint*-return [[(str \"\\n\" (blanks indent)) :none :newline 1]])\n      fzprint*-return)))\n\n(defn gather-up-to-next-zloc\n  \"Given a zloc-seq, gather newlines and comments up to the next\n  zloc into a seq.  Returns [seq next-zloc next-count].\"\n  [zloc-seq]\n  (loop [nloc-seq zloc-seq\n         out []\n         next-count 0]\n    (if (not (newline-or-comment? (first nloc-seq)))\n      [out (first nloc-seq) next-count]\n      (recur (next nloc-seq) (conj out (first nloc-seq)) (inc next-count)))))\n\n(defn fzprint-up-to-next-zloc\n  \"Using the information returned from fzprint-up-to-first-zloc or\n  fzprint-up-to-next-zloc, find the next zloc and return \n  [pre-next-style-vec next-zloc next-count zloc-seq]\"\n  [caller options ind [_ _ current-count zloc-seq :as next-data]]\n  (let [starting-count (inc current-count)\n        nloc-seq (nthnext zloc-seq starting-count)]\n    (dbg-pr options\n            \"fzprint-up-to-next-zloc: starting-count:\" starting-count\n            \"zloc-seq:\" (map zstring zloc-seq))\n    (if-not (= (:ztype options) :zipper)\n      [:noseq (first nloc-seq) starting-count zloc-seq]\n      (let [[pre-next-zloc-seq next-zloc next-count] (gather-up-to-next-zloc\n                                                       nloc-seq)\n            next-count (+ starting-count next-count)]\n        (dbg-pr options\n                \"fzprint-up-to-next-zloc: next-count:\" next-count\n                \"pre-next-zloc-seq:\" (map zstring pre-next-zloc-seq))\n        (if (empty? pre-next-zloc-seq)\n          ; The normal case -- nothing before the first interesting zloc\n          [:noseq next-zloc next-count zloc-seq]\n          ; There were newlines or comments (or both) before the first\n          ; interesting zloc\n          (let [coll-print\n                  (fzprint-flow-seq caller options ind pre-next-zloc-seq)\n                ; we are set up for fzprint-seq, but fzprint-flow-seq does\n                ; a full-on style-vec, so turn it back into fzprint-seq\n                ; style output\n                coll-print (mapv vector coll-print)\n                ; We aren't trying to interpose anything here, we are just\n                ; trying to print the stuff we have in a way that will\n                ; work. Remove the last newline if we are not the first\n                ; thing\n                coll-print (if (not= starting-count 0)\n                             (remove-last-newline coll-print)\n                             coll-print)\n                coll-out (apply concat-no-nil coll-print)\n                ; If we are down inside a list and  the first thing is a\n                ; comment, ensure we start with a newline.  If it is an\n                ; inline comment, then it will get fixed later.\n                coll-out (if (and (not= starting-count 0)\n                                  (let [first-type (nth (first coll-out) 2)]\n                                    (or (= first-type :comment)\n                                        (= first-type :comment-inline))))\n                           (ensure-start-w-nl ind coll-out)\n                           coll-out)\n                ; Ensure that we end with a newline if we are the first\n                ; thing\n                coll-out (if (not= starting-count 0)\n                           coll-out\n                           (ensure-end-w-nl ind coll-out))\n                ; Make sure it ends with a newline, since all comments and\n                ; newlines better end with a newline.  But how could it not\n                ; end with a newline?  We only put comments and newlines in\n                ; here, and added newlines to comments.  So we will assume\n                ; that it ends with a newline.\n               ]\n            [coll-out next-zloc next-count zloc-seq]))))))\n\n(defn fzprint-up-to-first-zloc\n  \"Returns [pre-first-style-vec first-zloc first-count zloc-seq], where\n  pre-first-style-vec will be :noseq if there isn't anything, and first-count\n  is what you give to nthnext to get to the first-zloc in zloc-seq.\"\n  [caller options ind zloc]\n  (dbg-pr options \"fzprint-up-to-first-zloc\")\n  (if-not (= (:ztype options) :zipper)\n    [:noseq (first zloc) 0 zloc]\n    (let [zloc-seq (fzprint-get-zloc-seq caller options zloc)\n          zloc-seq (fzprint-split-meta-in-seq caller options zloc-seq)]\n      ; Start at -1 so that when fzprint-up-to-next-zloc skips, it goes\n      ; to zero.\n      (fzprint-up-to-next-zloc caller options ind [nil nil -1 zloc-seq]))))\n\n(defn get-zloc-seq-right\n  \"Using return from fzprint-up-to-first-zloc or fzprint-up-to-next-zloc,\n  [pre-next-style-vec next-zloc next-count zloc-seq], return a zloc-seq\n  pointer to just beyond the specific zloc which was found by the\n  fzprint-up-to-first or fzprint-up-to-next call.  You don't give this\n  a number, you give it the data structure from the thing that you found.\"\n  [[_ _ next-count zloc-seq :as input-data]]\n  (if (>= next-count (count zloc-seq))\n    (throw (#?(:clj Exception.\n               :cljs js/Error.)\n            (str \"get-zloc-seq-right input data inconsistent:\" input-data)))\n    (let [zloc-seq (nthnext zloc-seq (inc next-count))]\n      #_(prn \"get-zloc-seq-right: next-count:\" next-count\n             \"zloc-seq:\" (map zstring zloc-seq))\n      zloc-seq)))\n\n\n;;\n;; # Indent-only support\n;;\n\n(defn at-newline?\n  \"Is this a newline or equivalent?  Comments and newlines are both\n  newlines for the purposed of this routine.\"\n  [zloc]\n  (let [this-tag (ztag zloc)] (or (= this-tag :comment) (= this-tag :newline))))\n\n(defn next-newline\n  \"Given a zloc that is down inside of a collection, presumably\n  a list, return a vector containing the number of printing elements\n  we had to traverse to get to it as well as the newline.\"\n  [zloc]\n  (loop [nloc zloc\n         index 0]\n    #_(prn \"next-newline:\" (zstring nloc) \"tag:\" (tag nloc))\n    (let [next-right (right* nloc)]\n      (if next-right\n        (if (at-newline? nloc)\n          [index nloc]\n          (recur (right* nloc)\n                 (if-not (zprint.zutil/whitespace? nloc) (inc index) index)))\n        [index nloc]))))\n\n\n(defn next-actual\n  \"Return the next actual element, ignoring comments and whitespace\n  and everything else but real elements.\"\n  [zloc]\n  #_(prn \"next-actual: zloc\" (zstring zloc))\n  (loop [nloc zloc]\n    (if-not nloc\n      nloc\n      (let [next-nloc (zprint.zutil/zrightnws nloc)\n            next-tag (tag next-nloc)]\n        #_(prn \"nloc:\" nloc\n               \"next-actual: next-nloc:\" (zstring next-nloc)\n               \"next-tag:\" next-tag)\n        (if-not (or (= next-tag :newline) (= next-tag :comment))\n          next-nloc\n          (recur next-nloc))))))\n\n(defn first-actual\n  \"Return the first actual element, ignoring comments and whitespace\n  and everything else but real elements.\"\n  [zloc]\n  (if (at-newline? zloc) (next-actual zloc) zloc))\n\n(defn hang-zloc?\n  \"Should we hang this zloc, or flow it.  We assume that we are at\n  the start of the collection (though this could be generalized to\n  deal with other starting locations easily enough).  Return true\n  if we should hang it based just on the information in the zloc\n  itself.  The criteria are: If there is a newline after the second\n  thing in the zloc, and the amount of space prior to the third thing\n  is the same as the amount of space prior to the second thing, then\n  the incoming zloc was hung and we should do the same. Of course, it\n  would also only be hung if the second thing was on the same line as\n  the first thing.\"\n  [zloc]\n  #_(prn \"hang-zloc: zloc:\" zloc \"at-newline?:\" (at-newline? zloc))\n  (let [zloc (first-actual zloc) ; skip comments/newlines at start\n        [count-prior-to-newline newline] (next-newline zloc)]\n    #_(prn \"at-newline?:\" (at-newline? zloc)\n           \"hang-zloc?: count-prior...:\" count-prior-to-newline\n           \"zloc:\" (zstring zloc))\n    ; Are the first two real things on the same line?\n    (if (< count-prior-to-newline 2)\n      ; no -- then it can't be a hang\n      false\n      (let [second-element (zprint.zutil/zrightnws\n                             (if (zprint.zutil/whitespace? zloc)\n                               (zprint.zutil/zrightnws zloc)\n                               zloc))\n            second-indent (length-before second-element)\n            third-element (next-actual second-element)\n            third-indent (length-before third-element)]\n        #_(prn \"hang-zloc?: second-element:\" (zstring second-element)\n               \"second-indent:\" second-indent\n               \"third-element:\" (zstring third-element)\n               \"third-tag:\" (tag third-element)\n               \"third-indent:\" third-indent)\n        (and second-element third-element (= second-indent third-indent))))))\n\n(defn indent-shift\n  \"Take a style-vec that was once output from indent-zmap, and fix\n  up all of the :indent elements in it by adding (- actual-ind ind)\n  to them.  If we find a multiple thing in here, call indent-shift\n  recursively with the ind and cur-ind that is approprite.  All of\n  the actual indents are correct already -- all we are doing is\n  setting up their base.  There is no attempt to determine if we\n  are exceeding any configured width.\"\n  [caller options ind actual-ind svec]\n  (let [shift-ind actual-ind]\n    (dbg-pr options\n            \"indent-shift: ind:\" ind\n            \"actual-ind:\" actual-ind\n            \"shift-ind:\" shift-ind\n            \"svec:\" svec)\n    (loop [cur-seq svec\n           cur-ind actual-ind\n           out []]\n      (if-not cur-seq\n        out\n        (let [this-seq (first cur-seq)\n              new-seq (if (vector? (first this-seq))\n                        ; is this ind correct?\n                        (indent-shift caller options ind cur-ind this-seq)\n                        (let [[s color type] this-seq\n                              next-seq (first (next cur-seq))\n                              this-shift (if (and next-seq\n                                                  (not (vector? (first\n                                                                  next-seq)))\n                                                  (= (nth next-seq 2) :indent))\n                                           0\n                                           shift-ind)]\n                          (cond (= type :indent) [(str s (blanks this-shift))\n                                                  color type 42]\n                                (= type :right) [s color type shift-ind]\n                                :else this-seq)))\n              _ (dbg-pr options\n                        \"indent-shift: cur-ind:\" cur-ind\n                        \"this-seq:\" this-seq\n                        \"new-seq:\" new-seq)\n              ; Shouldn't this be (inc cur-ind)?\n              [linecnt max-width lines] (style-lines options cur-ind [new-seq])\n              ; Figure out where we are\n              last-width (last lines)]\n          (dbg-pr options\n                  \"indent-shift: last-width:\" last-width\n                  \"new-seq:\" new-seq)\n          ; Should this be (inc last-width)?\n          (recur (next cur-seq) last-width (conj out new-seq)))))))\n\n(declare merge-fzprint-seq)\n\n(defn indent-zmap\n  \"Implement :indent-only?.  This routine is the central one through\n  which all :indent-only? processing flows, and replaces all of the\n  detailed logic in fzprint-list*, fzprint-vec*, and fzprint-map*.\n  This is called directly by fzprint-vec*, which handles both vectors\n  and sets, and through fzprint-indent by fzprint-list* and\n  fzprint-map*.  Thus, all of the data structures get their\n  :indent-only? processing handled by ident-zmap.  coll-print is\n  the output from fzprint-seq, which is a style-vec in the making\n  without spacing, but with extra [] around the elements.  Everything\n  is based off of ind, and we know nothing to the left of that.\n  ind must be the left end of everything, not the right of l-str!\n  The actual-ind is to the right of l-str.  When we get a newline,\n  replace any spaces after it with our own, and that would be to\n  bring it to ind + indent.  \"\n  ([caller\n    {:keys [width rightcnt], {:keys [wrap-after-multi?]} caller, :as options}\n    ind actual-ind coll-print indent first-indent-only?]\n   (let [coll-print (merge-fzprint-seq coll-print)\n         last-index (dec (count coll-print))\n         rightcnt (fix-rightcnt rightcnt)\n         actual-indent (+ ind indent)]\n     (dbg-pr options\n             \"indent-zmap: ind:\" ind\n             \"actual-ind:\" actual-ind\n             \"first-indent-only?\" first-indent-only?\n             \"indent:\" indent\n             \"actual-indent:\" actual-indent\n             \"coll-print:\" coll-print)\n     (loop [cur-seq coll-print\n            cur-ind actual-ind\n            index 0\n            beginning? true ; beginning of line\n            ; transient here slowed things down, in a similar routine\n            l-str-indent? true\n            out []]\n       (if-not cur-seq\n         out\n         (let [this-seq (first cur-seq)]\n           (when this-seq\n             (let [multi? (> (count this-seq) 1)\n                   _ (log-lines options \"indent-zmap:\" ind this-seq)\n                   _ (dbg-pr options\n                             \"indent-zmap loop: cur-ind:\" cur-ind\n                             \"multi?\" multi?\n                             \"(count this-seq):\" (count this-seq)\n                             \"this-seq:\" this-seq\n                             \"out:\" out)\n                   this-seq\n                     (if multi?\n                       (indent-shift caller options actual-ind cur-ind this-seq)\n                       this-seq)\n                   [linecnt max-width lines]\n                     (style-lines options cur-ind this-seq)\n                   ; Figure out where we are\n                   last-width (last lines)\n                   ; How can this be right if there are multiple lines?\n                   ; Because we called indent-zmap to get the indents\n                   ; right, and they will be but for the first line, which\n                   ; style-lines fixed because it got the cur-ind..\n                   thetype (nth (last this-seq) 2)\n                   ; This is the total width of the current line\n                   ; relative to ind\n                   len (- last-width cur-ind)\n                   _ (dbg options\n                          \"linecnt:\" linecnt\n                          \"last-width:\" last-width\n                          \"len:\" len\n                          \"type:\" thetype)\n                   len (max 0 len)\n                   ; This isn't the only newline, actually.  Sometimes they\n                   ; are comment or comment-inline.  Later, for\n                   ; indent-shift, they are :indents.  Figure this out!\n                   newline? (= thetype :newline)\n                   comma? (= thetype :comma)\n                   isempty? (empty? (first (first this-seq)))\n                   comment? (or (= thetype :comment)\n                                (= thetype :comment-inline))\n                   ; Adjust for the rightcnt on the last element\n                   ;first-comment? (and comment? (= index 0))\n                   ;first-newline? (and newline? (= index 0)) l-str-indent?\n                   ;(or first-comment? first-newline?)\n                   l-str-indent? (and l-str-indent? (or comment? newline?))\n                   actual-indent (if (and (> index 0) first-indent-only?)\n                                   ind\n                                   (+ ind indent))\n                   width (if (= index last-index) (- width rightcnt) width)\n                   ; need to check size, and if one line and fits, should\n                   ; fit ??? why does it fit if this is the first thing?\n                   ; Because if it isn't, things won't get better?  Seems\n                   ; to me like if the first thing doesn't fit, we should\n                   ; return nil.\n                   ;\n                   ; But this is all about indent-only, not fitting.  But\n                   ; we will probably care about fitting someday.\n                   fit? (<= (+ cur-ind len) width)\n                   ; If we don't care about fit, then don't do this!!\n                   new-ind (cond newline? actual-indent\n                                 :else (+ cur-ind 1 len))]\n               (dbg-pr\n                 options\n                 \"------ this-seq:\" this-seq\n                 \"lines:\" lines\n                 \"linecnt:\" linecnt\n                 \"multi?\" multi?\n                 \"thetype:\" thetype\n                 \"newline?:\" newline?\n                 \"comment?:\" comment?\n                 \"comma?:\" comma?\n                 \"l-str-indent?:\" l-str-indent?\n                 \"first-indent-only?\" first-indent-only?\n                 \"actual-indent:\" actual-indent\n                 \"index:\" index\n                 \"beginning?:\" beginning?\n                 \"max-width:\" max-width\n                 \"last-width:\" last-width\n                 \"len:\" len\n                 \"cur-ind:\" cur-ind\n                 \"isempty?:\" isempty?\n                 \"new-ind:\" new-ind\n                 \"width:\" width\n                 \"fit?\" fit?)\n               (recur ; [cur-seq, cur-ind, index, beginning?, out]\n                 (next cur-seq)\n                 new-ind\n                 (inc index)\n                 ; beginning can happen because we created an indent\n                 ; or because a multi already had one.\n                 (or (and isempty? beginning?) newline? (= thetype :indent))\n                 ; l-str-indent\n                 l-str-indent?\n                 ; out\n                 (if isempty?\n                   out\n                   ; TODO: concat-no-nil fails here, why?\n                   (concat out\n                           (cond\n                             ; we don't want blanks if the next thing is a\n                             ; newline\n                             newline? [[(str\n                                          \"\\n\"\n                                          (let [next-seq (first (next cur-seq))\n                                                #_(prn \"next-seq:\" next-seq)\n                                                newline-next?\n                                                  (when next-seq\n                                                    (= (nth (first next-seq) 2)\n                                                       :newline))]\n                                            (if newline-next?\n                                              \"\"\n                                              (blanks (if l-str-indent?\n                                                        actual-ind\n                                                        actual-indent))))) :none\n                                        :indent 12]]\n                             ; Remove next line, unnecessary\n                             (zero? index) this-seq\n                             :else (if (or beginning? comma?)\n                                     this-seq\n                                     (concat-no-nil [[\" \" :none :whitespace 12]]\n                                                    this-seq)))))))))))))\n  ([caller options ind actual-ind coll-print indent]\n   (indent-zmap caller options ind actual-ind coll-print indent nil)))\n\n(defn newline-seq?\n  \"Given a vector of vectors, decide if we should merge these individually\n  into the top level vector.\"\n  [newline-vec]\n  (let [starts-with-nl-vec (mapv #(clojure.string/starts-with? (first %) \"\\n\")\n                             newline-vec)\n        #_(println \"newline-seq? starts-with-nl-vec\" starts-with-nl-vec)\n        true-seq (distinct starts-with-nl-vec)]\n    (and (= (count true-seq) 1) (= (first true-seq) true))))\n\n(defn merge-fzprint-seq\n  \"Given the output from fzprint-seq, which is a seq of the\n  output of fzprint*, apply a function to each of them that has\n  more than one element (since less has no meaning) and when the\n  function returns true, merge the vector in as individual elements.\"\n  [fzprint-seq-vec]\n  (into []\n        (reduce #(if (newline-seq? %2)\n                   (into [] (concat %1 (mapv vector %2)))\n                   (conj %1 %2))\n          []\n          fzprint-seq-vec)))\n\n(defn fzprint-indent\n  \"This function assumes that :indent-only? was set for the caller\n  in the options (since anything else doesn't make sense).  It takes\n  a zloc and the ind, which is where we are on the line this point,\n  and will process the zloc to include any newlines.  Of course we\n  have to have all of the white space in the zloc too, since we\n  need to ask some questions about what we are starting with at\n  some point.  We don't add newlines and we let the newlines that\n  are in there do their thing.  We might add newlines if we move\n  beyond the right margin, but for now, we don't (and it isn't\n  entirely clear how or if that would work).  This routine has to\n  make decisions about the indent, that is whether to hang or flow\n  the expression. It does that based on what was done in the input\n  if the configuration allows.\"\n  ([caller l-str r-str options ind zloc fn-style arg-1-indent\n    first-indent-only?]\n   (let [flow-indent (:indent (caller options))\n         l-str-len (count l-str)\n         ; Make sure that the flow-indent deals with the size of the\n         ; l-str -- important for anonymous functions\n         flow-indent (+ flow-indent (- l-str-len 1))\n         ; If it is a map, then an indent of (count l-str) (which is 1)\n         ; is all that makes sense.\n         flow-indent (if (= caller :map) (count l-str) flow-indent)\n         flow-indent (if (and (> flow-indent l-str-len) (= caller :list))\n                       ; If we don't think this could be a fn, indent\n                       ; minimally\n                       (if arg-1-indent flow-indent l-str-len)\n                       flow-indent)\n         actual-ind (+ ind l-str-len)\n         ; We could enable :comma? for lists, sets, vectors someday\n         zloc-seq (if (:comma? (caller options))\n                    (zmap-w-nl-comma identity zloc)\n                    (zmap-w-nl identity zloc))\n         _ (dbg-pr options\n                   \"fzprint-indent: caller:\" caller\n                   \"l-str-len:\" l-str-len\n                   \"ind:\" ind\n                   \"fn-style:\" fn-style\n                   \"arg-1-indent:\" arg-1-indent\n                   \"flow-indent:\" flow-indent\n                   \"actual-ind:\" actual-ind\n                   \"comma?\" (:comma? (caller options))\n                   \"zloc\" (zstring zloc)\n                   \"zloc-seq\" (map zstring zloc-seq))\n         coll-print (fzprint-seq options ind zloc-seq)\n         _ (dbg-pr options \"fzprint-indent: coll-print:\" coll-print)\n         indent-only-style (:indent-only-style (caller options))\n         ; If we have the possibility of :input-hang, then try if it is\n         ; configured.\n         already-hung? (when (and indent-only-style\n                                  (= indent-only-style :input-hang))\n                         (hang-zloc? (down* zloc)))\n         raw-indent (if (and arg-1-indent already-hung?)\n                      (- arg-1-indent ind)\n                      flow-indent)\n         indent raw-indent\n         coll-print-contains-nil? (contains-nil? coll-print)\n         _ (dbg-pr options\n                   \"fzprint-indent:\" (zstring zloc)\n                   \"ind:\" ind\n                   \"fn-style:\" fn-style\n                   \"indent-only-style:\" indent-only-style\n                   \"already-hung?:\" already-hung?\n                   \"arg-1-indent:\" arg-1-indent\n                   \"l-str-len:\" (count l-str)\n                   \"actual-ind:\" actual-ind\n                   \"raw-indent:\" raw-indent\n                   \"coll-print-contains-nil?:\" coll-print-contains-nil?\n                   \"indent:\" indent)\n         coll-print (when-not coll-print-contains-nil? coll-print)]\n     ; indent needs to adjust for the size of l-str-vec, since actual-ind\n     ; has l-str-vec in it so that indent-zmap knows where we are on the\n     ; line.  Just like fzprint-one-line needs one-line-ind, not ind.\n     (let [output (indent-zmap caller\n                               options\n                               ind\n                               actual-ind\n                               coll-print\n                               indent\n                               first-indent-only?)]\n       (dbg-pr options \"fzprint-indent: output:\" output)\n       output)))\n  ([caller l-str r-str options ind zloc fn-style arg-1-indent]\n   (fzprint-indent caller\n                   l-str\n                   r-str\n                   options\n                   ind\n                   zloc\n                   fn-style\n                   arg-1-indent\n                   nil)))\n\n(defn zfind-seq\n  \"Find the location, counting from zero, and counting every element \n  in the seq, of the first zthing?.  Return its index if it is found, \n  nil if not.\"\n  [zthing? zloc-seq]\n  (loop [nloc zloc-seq\n         i 0]\n    (when (not (nil? nloc))\n      (if (zthing? (first nloc)) i (recur (next nloc) (inc i))))))\n\n;;\n;; # Utilities to modify list printing in various ways\n;;\n\n;;\n;; Which fn-styles use :list {:indent n} instead of\n;; :list {:indent-arg n}\n;;\n\n(def body-set\n  #{:binding :arg1-> :arg2 :arg2-fn :arg2-pair :pair-fn :fn :arg1-body\n    :arg1-pair-body :none-body :noarg1-body :flow-body :arg2-extend-body\n    :arg1-force-nl-body :arg2-force-nl-body :guided-body :arg1-extend-body\n    :force-nl-body})\n\n;;\n;; Note Well -- every key in body-map should also appear in body-set!\n;;\n\n(def body-map\n  {:arg1-body :arg1,\n   :arg1-pair-body :arg1-pair,\n   :arg1-force-nl-body :arg1-force-nl,\n   :arg2-extend-body :arg2-extend,\n   :arg1-extend-body :arg1-extend,\n   :none-body :none,\n   :flow-body :flow,\n   :noarg1-body :noarg1,\n   :force-nl-body :force-nl,\n   :guided-body :guided,\n   :arg2-force-nl-body :arg2-force-nl})\n\n;;\n;; If the noarg1? value is set, this is the mapping for functions\n;; immediately below\n;; \n\n(def noarg1-set #{:noarg1 :arg1->})\n\n(def noarg1-map\n  {:arg1 :none,\n   :arg1-pair :pair-fn,\n   :arg1-extend :extend,\n   :arg2 :arg1,\n   :arg2-pair :arg1-pair})\n\n(defn noarg1\n  \"Set noarg1 in the options if it is the right fn-type.\"\n  [options fn-type]\n  (if (noarg1-set fn-type) (assoc options :no-arg1? true) options))\n\n; This is accessed prior to the -body being removed, so both types need to\n; be in here\n\n(def fn-style->caller\n  {:arg1-pair-body :pair,\n   :arg1-pair :pair,\n   :arg2-pair :pair,\n   :extend :extend,\n   :binding :binding,\n   :arg1-extend :extend,\n   :arg1-extend-body :extend,\n   :arg2-extend :extend,\n   :arg2-extend-body :extend,\n   :pair-fn :pair})\n\n(defn find-nl-count\n  \"Look at a style-vec, and if it is more than one line, return n, otherwise\n  return 1.\"\n  [options ind n out style-vec]\n  (let [lines (style-lines options ind style-vec)\n        fit? (fzfit-one-line options lines)]\n    (conj out (if fit? 1 n))))\n\n(defn create-nl-count-vec\n  \"Given a zloc-seq, create an nl-count vector which has the right\n  number (i.e., nl-count) of newlines between everything that is already\n  multi-line, and 1 otherwise.  Return the vector.\"\n  [options ind nl-count coll-print]\n  (reduce (partial find-nl-count options ind nl-count) [] coll-print))\n\n(defn get-respect-indent\n  \"Given an options map, get the respect-nl?, respect-bl? and indent-only?\n  options from the caller's options, and if the caller doesn't define these,\n  use the values from the backup section of the options map. Return\n  [respect-nl? respect-bl? indent-only?]\"\n  ; Note that the routine make-caller exists, and see its use in fzprint*\n  ; That is a different way to solve this problem\n  ;\n  ; We just evaluate the things that need to be evaluated, since this is\n  ; called a *lot*!.\n  [options caller backup]\n  (let [caller-options (caller options)\n        respect-nl? (get caller-options :respect-nl? :undef)\n        respect-bl? (get caller-options :respect-bl? :undef)\n        indent-only? (get caller-options :indent-only? :undef)]\n    [(if (not= respect-nl? :undef) respect-nl? (:respect-nl? (backup options)))\n     (if (not= respect-bl? :undef) respect-bl? (:respect-bl? (backup options)))\n     (if (not= indent-only? :undef)\n       indent-only?\n       (:indent-only? (backup options)))]))\n\n(defn allow-one-line?\n  \"Should we allow this function to print on a single line?\"\n  [{:keys [fn-force-nl fn-gt2-force-nl fn-gt3-force-nl], :as options} len\n   fn-style]\n  (not (or (fn-force-nl fn-style)\n           (and (> len 3) (fn-gt2-force-nl fn-style))\n           (and (> len 4) (fn-gt3-force-nl fn-style))\n           (if-let [future-caller (fn-style->caller fn-style)]\n             (let [caller-map (future-caller options)]\n               (or (:flow? caller-map) (:force-nl? caller-map)))))))\n\n(defn modify-zloc-legacy\n  \"If the (caller options) has a value for :return-altered-zipper, then\n  examine the value.  It should be [<depth> <symbol> <fn>]. \n  If the <depth> is nil, any depth will do. If the\n  <symbol> is nil, any symbol will do.  If the <depth> and <symbol>\n  match, then the <fn> is called as (fn caller options zloc), and must\n  return a new zloc.\"\n  [caller options zloc]\n  (let [[depth trigger-symbol modify-fn :as return-altered-zipper-value]\n          (:return-altered-zipper (caller options))]\n    (dbg options\n         \"modify-zloc-legacy caller:\" caller\n         \"ztype\" (:ztype options)\n         \"return-altered-zipper-value:\" return-altered-zipper-value)\n    (if (or (not= (:ztype options) :zipper) (nil? return-altered-zipper-value))\n      zloc\n      (let [call-fn? (and (or (nil? depth) (= (:depth options) depth))\n                          (or (not trigger-symbol)\n                              (and (zsymbol? (zfirst zloc))\n                                   (= trigger-symbol (zsexpr (zfirst zloc)))))\n                          modify-fn)]\n        (dbg options\n             \"modify-zloc:-legacy zloc\" (zstring zloc)\n             \"call-fn?\" call-fn?)\n        (if call-fn?\n          (let [return (modify-fn caller options zloc)]\n            (dbg options \"modify-zloc-legacy return:\" (zstring return))\n            return)\n          zloc)))))\n\n(declare fzprint-guide)\n(declare any-zcoll?)\n(declare wrap-zmap)\n\n(defn lookup-fn-str\n  \"Look up the fn-str in the :fn-map.  If the result is another string,\n  look that up.  Prevent infinite loops.\"\n  ([fn-map fn-str fn-str-set]\n   (if (fn-str-set fn-str)\n     (throw (#?(:clj Exception.\n                :cljs js/Error.)\n             (str \"Circular :fn-map lookup! fn-str: '\"\n                  fn-str\n                  \"' has already been used in this lookup.\"\n                  \" fn-strs in this lookup: \"\n                  fn-str-set)))\n     (let [result (fn-map fn-str)]\n       (when result\n         (if (string? result)\n           (lookup-fn-str fn-map result (conj fn-str-set fn-str))\n           result)))))\n  ([fn-map fn-str] (lookup-fn-str fn-map fn-str #{})))\n\n(defn get-correct-options-map\n  \"Given a fn-style, which might be a keyword or might be avector with \n  one or two options maps, get the correct one based on the :ztype \n  in the options. Returns [fn-style options-map]\"\n  [options fn-style]\n  (if (vector? fn-style)\n    (if (= (count fn-style) 2)\n      ; only one option map\n      [(first fn-style) (second fn-style)]\n      ; Two options maps, pick the right one\n      [(first fn-style)\n       (if (= :zipper (:ztype options)) (second fn-style) (nth fn-style 2))])\n    ; Just a fn-style, no options map\n    [fn-style nil]))\n\n(declare handle-fn-style)\n\n(defn lookup-fn-type-map\n  \"Given a keyword fn-type, look it up in the fn-type-map and handle\n  any aliasing and options maps that come up. This includes adding \n  options maps to the options. Returns [options fn-style]\"\n  ; In this routine, fn-type is a keyword, and fn-style might be a bare\n  ; fn-type, or it might be a vector with options maps.\n  ([options fn-type fn-type-set]\n   (if (fn-type-set fn-type)\n     (throw (#?(:clj Exception.\n                :cljs js/Error.)\n             (str \"Circular :fn-type-map lookup! fn-type: '\"\n                  fn-type\n                  \"' has already been used in this lookup.\"\n                  \" fn-types in this lookup: \"\n                  fn-type-set)))\n     (let [fn-style ((:fn-type-map options) fn-type)]\n       (if fn-style\n         ; We got something, let's see what we got\n         (handle-fn-style options fn-style (conj fn-type-set fn-type))\n         [options fn-type]))))\n  ([options fn-type] (lookup-fn-type-map fn-type #{})))\n\n(defn handle-fn-style\n  \"Takes current options map and a fn-style, which might be a single\n  fn-type, and might be a vector with one or two options maps, and\n  handles the lookups. Returns [new-options fn-type] Note: We allow\n  strings in the :fn-map only as bare strings, not in the fn-style\n  position within the vector.  You can say 'do it like this', but\n  not 'do it like this, with a few little changes'\"\n  ([options fn-style fn-type-set]\n   (if fn-style\n     ; We got something, let's see what we got\n     (let [[new-fn-type options-map] (get-correct-options-map options fn-style)\n           [new-options latest-fn-type]\n             (if new-fn-type\n               (lookup-fn-type-map options new-fn-type fn-type-set)\n               [options new-fn-type])]\n       (dbg-s options\n              #{:handle-fn-style}\n              \"handle-fn-style: :fn-style:\" fn-style\n              \"new-fn-type\" new-fn-type\n              \"latest-fn-type\" latest-fn-type\n              \"count new-options:\" (count new-options)\n              \"count options-map\" (count options-map)\n              \":fn\" (:fn (:fn-type-map options)))\n       (if options-map\n         [(first (zprint.config/config-and-validate \"fn-style:\"\n                                                    nil\n                                                    new-options\n                                                    options-map\n                                                    ; validate?\n                                                    nil)) latest-fn-type]\n         [new-options latest-fn-type]))\n     ; No fn-style, return what we were called with.\n     [options fn-style]))\n  ([options fn-style] (handle-fn-style options fn-style #{})))\n\n(defn handle-new-fn-style\n  \"If the :fn-style that is in the options differs from the fn-style\n  we were called with (which is the one we already had), then we\n  will deal with it.  It might be a traditional keyword, in which\n  case we just return it as the new fn-style.  But it might be a\n  string, in which case we need to look it up in the :fn-map, and\n  deal with handling the results (or failure) of that lookup.  In\n  any case, return [options fn-style]\"\n  [caller options fn-style fn-map user-fn-map option-fn]\n  (let [new-fn-style (let [new-fn-style (:fn-style options)]\n                       (when (not= new-fn-style fn-style) new-fn-style))\n        ; We have looked at this, now forget about it.\n        options (dissoc options :fn-style)]\n    (if new-fn-style\n      (if (string? new-fn-style)\n        (let [found-fn-style (or (lookup-fn-str fn-map new-fn-style)\n                                 (lookup-fn-str user-fn-map new-fn-style))]\n          (dbg-s options\n                 #{:handle-new-fn-style}\n                 \"handle-new-fn-style: string new-fn-style:\" new-fn-style\n                 \"found-fn-style:\" found-fn-style)\n          (if found-fn-style\n            ; Found something, use that.\n            (handle-fn-style options found-fn-style)\n            ; Didn't find it.\n            (throw (#?(:clj Exception.\n                       :cljs js/Error.)\n                    (str \" When \"\n                         caller\n                         \" called an option-fn \"\n                         (option-fn-name option-fn)\n                         \" it returned a fn-style which\"\n                         \" was a string '\"\n                         new-fn-style\n                         \"' which was not found in the :fn-map!\")))))\n        ; It wasn't a string, but it might be a full-on complex vector\n        ; style\n        (handle-fn-style options new-fn-style))\n      ; Didn't get a new fn-style in new-options,\n      ; use the ones we already have\n      [options fn-style])))\n\n(defn fn-style+option-fn\n  \"Take the current fn-style and lots of other important things,\n  and handle lookups in the fn-type-map, as well as calling\n  option-fn(s) as necessary.  \n  Returns [options fn-style zloc l-str r-str changed?], where changed?\n  refers only to the zloc, l-str, or r-str.\"\n  ([caller options fn-style zloc l-str r-str option-fn-set]\n   (dbg-s options\n          #{:call-option-fn}\n          \"fn-style+option-fn caller:\" caller\n          \"fn-style:\" fn-style\n          \"option-fn-set:\" option-fn-set)\n   (let [fn-map (:fn-map options)\n         user-fn-map (:user-fn-map options)\n         ; no validation because we assume these were validated in :fn-map\n         [options fn-style] (handle-fn-style options fn-style)\n         ; Now fn-style isn't a vector even if it was before\n         option-fn (:option-fn (options caller))\n         ; check the option-fn for having been called before\n         _ (when (option-fn-set option-fn)\n             (throw (#?(:clj Exception.\n                        :cljs js/Error.)\n                     (str \"Circular :option-fn lookup! option-fn: '\"\n                          option-fn\n                          \"' has already been called and is being called again!\"\n                          \" option-fns in this call chain: \"\n                          option-fn-set))))\n         ; If we have an option-fn, call it. New-options are the pre\n         ; config-and-validated options and are not worth much, since they\n         ; have raw styles in them\n         [options zloc l-str r-str changed?]\n           (if option-fn\n             (call-option-fn caller options option-fn zloc l-str r-str)\n             [options zloc l-str r-str nil])\n         ; If we got a new fn-style in new-options, handle it\n         [options fn-style] (handle-new-fn-style caller\n                                                 options\n                                                 fn-style\n                                                 fn-map\n                                                 user-fn-map\n                                                 option-fn)\n         ; Did we get a new option-fn? that is not nil?  If yes, do this\n         ; again\n         [options fn-style zloc l-str r-str new-changed?]\n           (let [new-option-fn (:option-fn (caller options))]\n             (if (and new-option-fn (not= option-fn new-option-fn))\n               (fn-style+option-fn caller\n                                   options\n                                   fn-style\n                                   zloc\n                                   l-str\n                                   r-str\n                                   (conj option-fn-set option-fn))\n               ; Didn't get a new option-fn, just return what we have\n               [options fn-style zloc l-str r-str nil]))\n         changed? (or changed? new-changed?)]\n     [options fn-style zloc l-str r-str changed?]))\n  ([caller options fn-style zloc l-str r-str]\n   (fn-style+option-fn caller options fn-style zloc l-str r-str #{})))\n\n(declare fzprint-noformat)\n\n(defn fzprint-list*\n  \"Print a list, which might be a list or an anon fn.  \n  Lots of work to make a list look good, as that is typically code. \n  Presently all of the callers of this are :list or :vector-fn.\"\n  [caller l-str r-str\n   ; The options map can get re-written down a bit below, so don't get\n   ; anything with destructuring that might change with a rewritten\n   ; options map!\n   {:keys [fn-map user-fn-map one-line? fn-style no-arg1? fn-force-nl quote?],\n    :as options} ind zloc]\n  (dbg-s options\n         :next-inner\n         \"fzprint-list*: ind:\" ind\n         \"fn-style:\" fn-style\n         \"option-fn:\" (:option-fn (options caller))\n         \"rightcnt:\" (:rightcnt options))\n  (if (= (:format options) :off)\n    (fzprint-noformat l-str r-str options zloc)\n    ; We don't need to call get-respect-indent here, because all of the\n    ; callers of fzprint-list* define respect-nl?, respect-bl? and\n    ; indent-only?\n    (let [max-length (get-max-length options)\n          ; Legacy modify-zloc for compatibility, now deprecated. It was\n          ; only experimental in the first place, so we can actually delete\n          ; it at some point. This capability is now handled by extending\n          ; the option-fn mechanism to support rewriting a zipper or a\n          ; structure, in part to support specifying it in the :fn-map for\n          ; only certain functions.\n          zloc (modify-zloc-legacy caller options zloc)\n          ; zcount does (zmap identity zloc) which counts comments and the\n          ; newline after it, but no other newlines\n          len (zcount zloc)\n          zloc (if (> len max-length) (ztake-append max-length zloc '...) zloc)\n          len (zcount zloc)\n          l-str-len (count l-str)\n          indent (:indent (options caller))\n          ; NOTE WELL -- don't use arg-1-zloc (or arg-2-zloc, etc.) as\n          ; a condition, because it might well be legitimately nil when\n          ; formatting structures.\n          [pre-arg-1-style-vec arg-1-zloc arg-1-count zloc-seq :as first-data]\n            (fzprint-up-to-first-zloc caller options (+ ind l-str-len) zloc)\n          #_(prn \"fzprint-list* zloc-seq:\" (map zstring zloc-seq))\n          arg-1-coll? (not (or (zkeyword? arg-1-zloc) (zsymbol? arg-1-zloc)))\n          ; Use an alternative arg-1-indent if the fn-style is forced on\n          ; input and we don't actually have an arg-1 from which we can get\n          ; an indent. Now, we might want to allow arg-1-coll? to give us\n          ; an arg-1-indent, maybe, someday, so we could hang next to it.\n          ; But for now, this will do.\n          arg-1-indent-alt? (and arg-1-coll? fn-style)\n          ; Expand fn-str to really be the thing to look up in the fn-map\n          fn-str (if-not arg-1-coll? (zstring arg-1-zloc))\n          ; If we don't have a fn-str, then we might have a fn-type.\n          ; NOTE WELL: a fn-style is a :arg1 or something like that.  This\n          ; is called a ::fn-type in the spec! Here, a fn-type is a keyword\n          ; of the \"type\" of the fn-str, i.e. :list, :map, :vector or\n          ; :set.\n          fn-type (when-not fn-str\n                    (cond (zlist? arg-1-zloc) :list\n                          (zmap? arg-1-zloc) :map\n                          (zvector? arg-1-zloc) :vector\n                          (zset? arg-1-zloc) :set\n                          :else nil))\n          ; If we have been told that we are in a quote?, and :quote has\n          ; something to say about what we should do for formatting, then\n          ; regardless of any fn-str, we will do it.\n          [fn-style fn-str fn-type]\n            (if (and quote?\n                     (or (not= (get fn-map :quote :none) :none)\n                         (not= (get user-fn-map :quote :none) :none)))\n              [nil nil :quote]\n              [fn-style fn-str fn-type])\n          ; Look up the fn-str in both fn-maps, and then if we don't get\n          ; something, look up the fn-type in both maps.\n          fn-style (or fn-style\n                       ; This is where we would need to handle option maps\n                       ; if we are doing that.\n                       (lookup-fn-str fn-map fn-str)\n                       (lookup-fn-str user-fn-map fn-str)\n                       ; See if the \"type\" of the fn-str is defined\n                       (fn-map fn-type)\n                       (user-fn-map fn-type))\n          ; if we don't have a function style after all of that, let's see\n          ; if we can get one by removing the namespacing. This will not\n          ; interact with the fn-type because if we have a\n          ; fn-str then we don't have a fn-type!\n          fn-style (if (and (not fn-style) fn-str)\n                     (let [fn-str (last (clojure.string/split fn-str #\"/\"))]\n                       ; Fix for Issue #276 -- didn't used to use\n                       ; lookup-fn-str here.\n                       (or (lookup-fn-str fn-map fn-str)\n                           (lookup-fn-str user-fn-map fn-str)))\n                     fn-style)\n          ; If we have a fn-str and not a fn-style, see if we have a\n          ; default for functions which were not set explicitly to :none\n          fn-style (if (and fn-str (nil? fn-style))\n                     (:default-not-none fn-map)\n                     fn-style)\n          ; If we have a fn-str and not a fn-style, see if we have a\n          ; default fn-style for every function which doesn't have one\n          ; explicitly set or where it was :none\n          fn-style (if (= fn-style :none) nil fn-style)\n          fn-style (if (and fn-str (nil? fn-style)) (:default fn-map) fn-style)\n          ; Do we have a [fn-style options] vector? **** NOTE: The options\n          ; map can change here, and if it does, some of the things found\n          ; in it above would have to change too! This not only looks up\n          ; the fn-style, but also handles any vector that might be present\n          ; in the initial fn-style.\n          vector-fn-style? (vector? fn-style)\n          ; After this, it isn't a vector any more... Note that changed?\n          ; refers only zloc, l-str, or r-str!!\n          [options fn-style zloc l-str r-str changed?]\n            (fn-style+option-fn caller options fn-style zloc l-str r-str)\n          ; recalculate necessary information\n          l-str-len (if changed? (count l-str) l-str-len)\n          ; zcount is not free, so only do it if the zloc changed\n          len (if changed? (zcount zloc) len)\n          guide (or (:guide options) (guide-debug caller options))\n          ; Remove :guide and any forced :fn-style from options so they\n          ; only happen once!\n          options (dissoc options :guide :fn-style)\n          #_(println \"\\nguide after:\" guide \"\\nguide options:\" (:guide options))\n          _ (when guide (dbg-pr options \"fzprint-list* guide:\" guide))\n          ; If we messed with the options for any of two reasons, then find\n          ; new stuff.  This will probably change only zloc-seq because of\n          ; :respect-nl? or :indent-only?  But :meta {:split? true} could\n          ; change it as well.\n          ; TODO: Figure out where :indent-only? and :respect-nl? are\n          ; handled and :meta {:split? true} also, and see if we are\n          ; handling them correctly here.\n          [pre-arg-1-style-vec arg-1-zloc arg-1-count zloc-seq :as first-data]\n            (if (or changed? vector-fn-style?)\n              (fzprint-up-to-first-zloc caller options (+ ind l-str-len) zloc)\n              first-data)\n          ; Get rid of the any vector surrounding the fn-style. Don't do\n          ; this too soon, as multiple things are driven off of\n          ; (vector? fn-style), above\n          fn-style (if (vector? fn-style) (first fn-style) fn-style)\n          ; Finish finding all of the interesting stuff in the first two\n          ; elements\n          [pre-arg-2-style-vec arg-2-zloc arg-2-count _ :as second-data]\n            ; The ind is wrong, need arg-1-indent, but we don't have it\n            ; yet.\n            (fzprint-up-to-next-zloc caller\n                                     options\n                                     ;(+ ind l-str-len)\n                                     (+ ind indent)\n                                     first-data)\n          ; This len doesn't include newlines or other whitespace or\n          len (zcount-zloc-seq-nc-nws zloc-seq)\n          #_(prn \"fzprint-list* pre-arg-1-style-vec:\" pre-arg-1-style-vec\n                 \"pre-arg-2-style-vec:\" pre-arg-2-style-vec\n                 \"arg-1-zloc:\" (zstring arg-1-zloc)\n                 \"arg-2-zloc:\" (zstring arg-2-zloc)\n                 \"arg-1-count:\" arg-1-count\n                 \"arg-2-count:\" arg-2-count\n                 \"len:\" len)\n          ; If fn-style is :replace-w-string, then we have an interesting\n          ; set of things to do.\n          ;\n          [options arg-1-zloc l-str l-str-len r-str len zloc-seq]\n            (if (and (= fn-style :replace-w-string)\n                     (:replacement-string (options caller))\n                     (= len 2))\n              [(assoc (update-in options [caller] dissoc :replacement-string)\n                 :rightcnt (dec (:rightcnt options))) arg-2-zloc\n               (:replacement-string (options caller))\n               (count (:replacement-string (options caller))) \"\" 1\n               (remove-one zloc-seq arg-1-count)]\n              [options arg-1-zloc l-str l-str-len r-str len zloc-seq])\n          #_(prn \"fzprint-list*: l-str:\" l-str\n                 \"l-str-len:\" l-str-len\n                 \"len:\" len\n                 \"fn-style:\" fn-style)\n          ; Get indents which might have changed if the options map was\n          ; re-written by the function style being a vector.\n          indent (:indent (options caller))\n          indent-arg (:indent-arg (options caller))\n          indent-only? (:indent-only? (options caller))\n          ; set indent based on fn-style\n          indent (if (body-set fn-style) indent (or indent-arg indent))\n          indent (+ indent (dec l-str-len))\n          #_(prn \"fzprint-list* indent:\" indent \"indent-arg:\" indent-arg)\n          ; If we have a :guide value, then we are going to use it no\n          ; matter the fn-style we had before.  Note that we kept the\n          ; original fn-style around long enough to get the indent figured\n          ; out, immediately above.  And we went to :guided in time to\n          ; cause one-line-ok? to be false, immediately below.\n          fn-style (if guide :guided fn-style)\n          one-line-ok? (allow-one-line? options len fn-style)\n          one-line-ok? (when-not indent-only? one-line-ok?)\n          one-line-ok? (if (= fn-style :guided) nil one-line-ok?)\n          one-line-ok? (if (not= pre-arg-1-style-vec :noseq) nil one-line-ok?)\n          ; If this is :binding, then the fn-gt2-force-nl applies to\n          ; :binding for the number of things in the let (or whatever), and\n          ; the otherwise unused fn-type of :binding-vector is checked to\n          ; see if it should force us to not do one line as well.\n          one-line-ok? (if (= fn-style :binding)\n                         (and one-line-ok?\n                              (allow-one-line? options\n                                               (zcount arg-2-zloc)\n                                               :binding-vector))\n                         one-line-ok?)\n          one-line-ok? (if (:force-nl? (options caller)) nil one-line-ok?)\n          ; If we have one-line-ok? on in the options map, then override\n          ; all of the other calculations we have made.\n          one-line-ok? (if (:one-line-ok? options) true one-line-ok?)\n          ; We will get rid of :one-line-ok? in the options map below,\n          ; after we actually try to format something to see if it fits on\n          ; one line. Remove -body from fn-style if it was there\n          fn-style (or (body-map fn-style) fn-style)\n          ; Fix up :fn for multi-arity functions. If the second thing is a\n          ; list, :fn maps to :flow in this case\n          fn-style\n            (if (and (= fn-style :fn) (zlist? arg-2-zloc)) :flow fn-style)\n          ; All styles except :hang, :flow, and :flow-body and :binding\n          ; need three elements minimum. We could put this in the fn-map,\n          ; but until there are more than three (well four) exceptions,\n          ; seems like too much mechanism.\n          fn-style (if (#{:hang :flow :flow-body :binding :replace-w-string\n                          :guided :list}\n                        fn-style)\n                     fn-style\n                     (if (< len 3) nil fn-style))\n          ;fn-style (if (= fn-style :hang) fn-style (if (< len 3) nil\n          ;fn-style))\n          fn-style (if no-arg1? (or (noarg1-map fn-style) fn-style) fn-style)\n          ; no-arg? only affect one level down...\n          options (if no-arg1? (dissoc options :no-arg1?) options)\n          ; If l-str isn't one char, create an indent adjustment.  Largely\n          ; for anonymous functions, which otherwise would have their own\n          ; :anon config to parallel :list, which would be just too much\n          indent-adj (dec l-str-len)\n          ; The default indent is keyed off of whether or not the first\n          ; thing in the list is itself a list, since that list could\n          ; evaluate to a fn.  You can't replace the zlist? with\n          ; arg-1-coll?, since if you do multi-arity functions aren't done\n          ; right, since the argument vector is a coll?, and so arg-1-coll?\n          ; is set, and then you get a two space indent for multi-arity\n          ; functions, which is wrong. We could, conceivably, use zvector?\n          ; here to specifically handle multi-arity functions.  Or we could\n          ; remember we are in a defn and do something special there, or we\n          ; could at least decide that we were in code when we did this\n          ; zlist? thing, since that is all about code.  That wouldn't work\n          ; if it was the top-level form, but would otherwise.\n          default-indent (if (zlist? arg-1-zloc) indent l-str-len)\n          ; Note that much is driven from arg-1-indent, since if this is\n          ; nil the assumption is that the first argument is a collection,\n          ; and that the indent should be l-str-len.  See local-indent\n          ; below. Don't use fn-str here, as it might be old data if there\n          ; was an option-fn that returned a new zloc yielding a new\n          ; arg-1-zloc!\n          arg-1-indent (if-not arg-1-coll?\n                         (+ ind (inc l-str-len) (count (zstring arg-1-zloc))))\n          ; If we don't have an arg-1-indent, and we noticed that the\n          ; inputs justify using an alternative, then use the alternative.\n          arg-1-indent (or arg-1-indent (when arg-1-indent-alt? (+ indent ind)))\n          ; If we have anything in pre-arg-2-style-vec, then we aren't\n          ; hanging anything and we replace any existing arg-1-indent with\n          ; a normal one.\n          arg-1-indent (if (= pre-arg-2-style-vec :noseq)\n                         arg-1-indent\n                         (when arg-1-indent (+ indent ind)))\n          ; Tell people inside that we are in code. We don't catch places\n          ; where the first thing in a list is a collection or a seq which\n          ; yields a function.\n          options (if (not arg-1-coll?)\n                    ; quote? might have cancelled out fn-str, but if we\n                    ; still want to think of ourselves as in-code? then use\n                    ; (or fn-str quote?) instead of fn-str, below. This\n                    ; would affect the default map sorting and how condp is\n                    ; formatted, and probably not much else.\n                    (assoc options :in-code? fn-str)\n                    options)\n          options (assoc options :pdepth (inc (long (or (:pdepth options) 0))))\n          _ (when (:dbg-hang options)\n              (println (dots (:pdepth options)) \"fzs\" fn-str))\n          new-ind (+ indent ind)\n          one-line-ind (+ l-str-len ind)\n          options (if fn-style (dissoc options :fn-style) options)\n          ; Update the call stack with the final fn-style we used Note that\n          ; we already have a call stack frame (which may have been altered\n          ; by the option-fn), so we have to take what is there\n          ; and, possibly, change the fn-style.\n          #_#_call-stack (:call-stack options)\n          #_#_options\n            (if (not= fn-style (:fn-style (first call-stack)))\n              (assoc options\n                :call-stack (conj (next call-stack)\n                                  (assoc (first call-stack)\n                                    :fn-style fn-style)))\n              options)\n          loptions (not-rightmost options)\n          roptions options\n          l-str-vec [[l-str (zcolor-map options l-str) :left]]\n          ; Fudge the ind a bit for r-str-vec for anon fns: #()\n          r-str-vec\n            (rstr-vec options (+ ind (max 0 (dec l-str-len))) zloc r-str)\n          _ (dbg-pr\n              options\n              \"fzprint-list*:\" (zstring zloc)\n              \"fn-str\" fn-str\n              \"fn-style:\" fn-style\n              \"len:\" len\n              \"ind:\" ind\n              \"indent:\" indent\n              \"default-indent:\" default-indent\n              \"one-line-ok?\" one-line-ok?\n              \"arg-1-coll?\" arg-1-coll?\n              \"arg-1-indent:\" arg-1-indent\n              \"arg-1-zloc:\" (zstring arg-1-zloc)\n              \"pre-arg-1-style-vec:\" pre-arg-1-style-vec\n              \"l-str:\" (str \"'\" l-str \"'\")\n              \"l-str-len:\" l-str-len\n              \"r-str-vec:\" r-str-vec\n              \"indent-adj:\" indent-adj\n              \"one-line?\" one-line?\n              \"indent-only?\" indent-only?\n              \"in-code?\" (:in-code? options)\n              \"rightcnt:\" (:rightcnt options)\n              \"replacement-string:\" (:replacement-string (caller options))\n              \"force-nl?\" (:force-nl? (caller options))\n              \":ztype:\" (:ztype options))\n          one-line (if (and (zero? len) (= pre-arg-1-style-vec :noseq))\n                     :empty\n                     (when one-line-ok?\n                       (fzprint-one-line options one-line-ind zloc-seq)))\n          ; :one-line-ok? is only good for one try for the whole\n          ; expression. After that, it needs to go away whether or not we\n          ; fit it onto one line.\n          options (dissoc options :one-line-ok?)]\n      (cond\n        (= one-line :empty) (concat-no-nil l-str-vec r-str-vec)\n        indent-only? (concat-no-nil l-str-vec\n                                    (fzprint-indent caller\n                                                    l-str\n                                                    r-str\n                                                    options\n                                                    ind\n                                                    zloc\n                                                    fn-style\n                                                    arg-1-indent)\n                                    r-str-vec)\n        one-line (concat-no-nil l-str-vec one-line r-str-vec)\n        ; Don't put anything other than :guide here at the beginning before\n        ; we check one-line?\n        (= fn-style :guided)\n          (let [zloc-count (count zloc-seq)\n                ; If we have something other than a collection in the first\n                ; position, use the indent we figured out above, else use\n                ; what is probably an indent of 1\n                local-indent\n                  (if arg-1-indent indent (+ default-indent indent-adj))]\n            #_(prn \":guided!\")\n            (concat-no-nil l-str-vec\n                           (fzprint-guide caller\n                                          options\n                                          ; this is where we are w/out any\n                                          ; indent\n                                          ind\n                                          ; this is where we are with the\n                                          ; l-str\n                                          one-line-ind\n                                          local-indent\n                                          guide\n                                          zloc-seq)\n                           r-str-vec))\n        ; If we are in :one-line? mode, then either we called\n        ; fzprint-one-line, above, or it was a guide, and we just did it\n        ; and moved on.  If we get here and we are in one-line? mode, then\n        ; we have failed. Note that the (dbg ...) returns nil regardless of\n        ; whether or not it is enabled, which actually affects the control\n        ; flow!\n        one-line?\n          (dbg options \"fzprint-list*:\" fn-str \" one-line did not work!!!\")\n        ; =================================\n        ; All additional fn-styles go here\n        ; =================================\n        (dbg options \"fzprint-list*: fn-style:\" fn-style) nil\n        (and (= len 0) (= pre-arg-1-style-vec :noseq)) (concat-no-nil l-str-vec\n                                                                      r-str-vec)\n        (= len 1)\n          ; While len is one, don't assume that there is actually only one\n          ; thing to print and use fzprint*.  len only counts the\n          ; non-comment and non-nl elements, and there might be other\n          ; things to print.\n          (concat-no-nil\n            l-str-vec\n            (fzprint-flow-seq caller roptions one-line-ind zloc-seq)\n            r-str-vec)\n        ; In general, we don't have a fn-style if we have less than 3\n        ; elements. However, :binding is allowed with any number up to this\n        ; point, so we have to check here.  :binding is actually allowed\n        ; with at least two elements, the third through n are optional.\n        (and (= fn-style :binding) (> len 1) (zvector? arg-2-zloc))\n          (let [[hang-or-flow binding-style-vec]\n                  (fzprint-hang-unless-fail loptions\n                                            (or arg-1-indent (+ indent ind))\n                                            (+ indent ind)\n                                            fzprint-binding-vec\n                                            arg-2-zloc)\n                binding-style-vec (if (= hang-or-flow :hang)\n                                    (concat-no-nil [[\" \" :none :whitespace 14]]\n                                                   binding-style-vec)\n                                    binding-style-vec)]\n            (concat-no-nil l-str-vec\n                           pre-arg-1-style-vec\n                           ; TODO: get rid of inc ind\n                           (fzprint* loptions (inc ind) arg-1-zloc)\n                           pre-arg-2-style-vec\n                           binding-style-vec\n                           (concat-no-nil\n                             ; Here we use options, because\n                             ; fzprint-flow-seq will sort it out.  It will\n                             ; also handle an empty zloc-seq by returning\n                             ; :noseq, so we don't have to check for (> len\n                             ; 2) before we call it.\n                             (fzprint-hang-remaining caller\n                                                     options\n                                                     (+ indent ind)\n                                                     (+ indent ind)\n                                                     (get-zloc-seq-right\n                                                       second-data)\n                                                     :binding)\n                             r-str-vec)))\n        (= fn-style :pair-fn)\n          (let [zloc-seq-right-first (get-zloc-seq-right first-data)\n                zloc-count (count zloc-seq)]\n            (concat-no-nil l-str-vec\n                           pre-arg-1-style-vec\n                           (fzprint* loptions (inc ind) arg-1-zloc)\n                           ; Removed the assoc-in 7/26/21 since I can't\n                           ; see that it could be used.  Maybe it is left\n                           ; over from when a zloc was passed down and not\n                           ; a zloc-seq?\n                           (fzprint-hang options\n                                         #_(assoc-in options\n                                             [:pair :respect-nl?]\n                                             (:respect-nl? (caller options)))\n                                         :pair-fn\n                                         arg-1-indent\n                                         (+ indent ind)\n                                         fzprint-pairs\n                                         zloc-count\n                                         zloc-seq-right-first)\n                           r-str-vec))\n        (= fn-style :extend)\n          (let [zloc-seq-right-first (get-zloc-seq-right first-data)]\n            (concat-no-nil l-str-vec\n                           pre-arg-1-style-vec\n                           (fzprint* loptions (inc ind) arg-1-zloc)\n                           (prepend-nl options\n                                       (+ indent ind)\n                                       ; I think fzprint-pairs will sort\n                                       ; out which is and isn't the\n                                       ; rightmost because of two-up\n                                       (fzprint-extend options\n                                                       (+ indent ind)\n                                                       zloc-seq-right-first))\n                           r-str-vec))\n        ; needs (> len 2) but we already checked for that above in fn-style\n        (or (and (= fn-style :fn) (not (zlist? arg-2-zloc)))\n            (= fn-style :arg2)\n            (= fn-style :arg2-force-nl)\n            (= fn-style :arg2-fn)\n            (= fn-style :arg2-pair)\n            (= fn-style :arg2-extend))\n          (let [[pre-arg-3-style-vec arg-3-zloc arg-3-count _ :as third-data]\n                  ; The ind is wrong, need arg-1-indent, but we don't have\n                  ; it yet.\n                  (fzprint-up-to-next-zloc caller\n                                           options\n                                           ; This is probably wrong\n                                           ; (+ ind l-str-len)\n                                           (+ ind indent)\n                                           second-data)\n                #_(prn \"pre-arg-1-style-vec:\" pre-arg-1-style-vec)\n                #_(prn \"arg-1-zloc:\" (zstring arg-1-zloc))\n                #_(prn \"pre-arg-2-style-vec:\" pre-arg-2-style-vec)\n                #_(prn \"arg-2-zloc:\" (zstring arg-2-zloc))\n                #_(prn \"pre-arg-3-style-vec:\" pre-arg-3-style-vec)\n                #_(prn \"arg-3-zloc:\" (zstring arg-3-zloc))\n                zloc-seq-right-third (get-zloc-seq-right third-data)\n                second-element (fzprint-hang-one\n                                 caller\n                                 (if (not arg-3-zloc) options loptions)\n                                 ; This better not be nil\n                                 arg-1-indent\n                                 (+ indent ind)\n                                 arg-2-zloc)\n                [line-count max-width]\n                  ; arg-1-indent better not be nil here either\n                  (style-lines loptions arg-1-indent second-element)\n                first-three\n                  (when second-element\n                    (let [first-two-wo-pre-arg-1\n                            (concat-no-nil\n                              (fzprint* loptions (+ indent ind) arg-1-zloc)\n                              pre-arg-2-style-vec\n                              second-element\n                              pre-arg-3-style-vec)\n                          local-options\n                            (if (not zloc-seq-right-third) options loptions)\n                          first-two-one-line? (fzfit-one-line\n                                                local-options\n                                                (style-lines\n                                                  local-options\n                                                  (+ ind indent)\n                                                  first-two-wo-pre-arg-1))\n                          ; Add pre-arg-1-style-vec back in, which might\n                          ; push it to two lines (or many lines), but that\n                          ; doesn't matter.\n                          first-two (concat-no-nil pre-arg-1-style-vec\n                                                   first-two-wo-pre-arg-1)]\n                      (when-not first-two-one-line?\n                        (dbg-pr options\n                                \"fzprint-list*: :arg2-* first two didn't fit:\"\n                                first-two))\n                      (concat-no-nil\n                        first-two\n                        (if (or (= fn-style :arg2)\n                                (= fn-style :arg2-force-nl)\n                                (= fn-style :arg2-pair)\n                                (= fn-style :arg2-fn)\n                                (= fn-style :arg2-extend)\n                                (and (zvector? arg-3-zloc) (= line-count 1)))\n                          (fzprint-hang-one\n                            caller\n                            (if (not zloc-seq-right-third) options loptions)\n                            (if (and (= pre-arg-3-style-vec :noseq)\n                                     first-two-one-line?)\n                              ; hang it if possible\n                              max-width\n                              ; flow it\n                              (+ indent ind))\n                            (+ indent ind)\n                            arg-3-zloc)\n                          (prepend-nl options\n                                      (+ indent ind)\n                                      (fzprint* (if (not zloc-seq-right-third)\n                                                  options\n                                                  loptions)\n                                                (+ indent ind)\n                                                arg-3-zloc))))))]\n            (when first-three\n              (if (not zloc-seq-right-third)\n                ; if nothing after the third thing, means just three things\n                (concat-no-nil l-str-vec first-three r-str-vec)\n                ; more than three things\n                (concat-no-nil\n                  l-str-vec\n                  first-three\n                  (cond (= fn-style :arg2-pair)\n                          (prepend-nl options\n                                      (+ indent ind)\n                                      (fzprint-pairs options\n                                                     (+ indent ind)\n                                                     zloc-seq-right-third))\n                        (= fn-style :arg2-extend)\n                          (prepend-nl options\n                                      (+ indent ind)\n                                      (fzprint-extend options\n                                                      (+ indent ind)\n                                                      zloc-seq-right-third))\n                        :else (fzprint-hang-remaining caller\n                                                      ;options\n                                                      (if (= fn-style :arg2-fn)\n                                                        (assoc options\n                                                          :fn-style :fn)\n                                                        options)\n                                                      (+ indent ind)\n                                                      ; force flow\n                                                      (+ indent ind)\n                                                      zloc-seq-right-third\n                                                      fn-style))\n                  r-str-vec))))\n        (and (= fn-style :arg1-mixin) (> len 3))\n          (let [[pre-arg-3-style-vec arg-3-zloc arg-3-count _ :as third-data]\n                  (fzprint-up-to-next-zloc caller\n                                           options\n                                           (+ ind indent)\n                                           second-data)\n                [pre-arg-4-style-vec arg-4-zloc arg-4-count _ :as fourth-data]\n                  (fzprint-up-to-next-zloc caller\n                                           options\n                                           (+ ind indent)\n                                           third-data)\n                arg-vec-index (or (zfind-seq #(or (zvector? %)\n                                                  (when (zlist? %)\n                                                    (zvector? (zfirst %))))\n                                             zloc-seq)\n                                  0)\n                doc-string? (string? (get-sexpr-or-nil options arg-3-zloc))\n                mixin-start (if doc-string? arg-4-count arg-3-count)\n                mixin-length (- arg-vec-index mixin-start 1)\n                mixins? (pos? mixin-length)\n                doc-string (when doc-string?\n                             (fzprint-hang-one caller\n                                               loptions\n                                               (+ indent ind)\n                                               ; force flow\n                                               (+ indent ind)\n                                               arg-3-zloc))\n                #_(prn \":arg1-mixin: doc-string?\" doc-string?\n                       \"mixin-start:\" mixin-start\n                       \"mixin-length:\" mixin-length\n                       \"mixins?\" mixins?\n                       \"arg-vec-index:\" arg-vec-index\n                       \"doc-string\" doc-string\n                       \"arg-1-count:\" arg-1-count\n                       \"arg-1-zloc:\" (zstring arg-1-zloc)\n                       \"arg-2-count:\" arg-2-count\n                       \"arg-2-zloc:\" (zstring arg-2-zloc)\n                       \"arg-3-count:\" arg-3-count\n                       \"arg-3-zloc:\" (zstring arg-3-zloc)\n                       \"arg-4-count:\" arg-4-count\n                       \"arg-4-zloc:\" (zstring arg-4-zloc))\n                ; Have to deal with no arg-vec-index!!\n                mixins\n                  (when mixins?\n                    (let [mixin-sentinal (fzprint-hang-one caller\n                                                           loptions\n                                                           (+ indent ind)\n                                                           ; force flow\n                                                           (+ indent ind)\n                                                           (if doc-string?\n                                                             arg-4-zloc\n                                                             arg-3-zloc))\n                          [line-count max-width] (style-lines loptions\n                                                              (+ indent ind)\n                                                              mixin-sentinal)]\n                      (concat-no-nil\n                        (if doc-string? pre-arg-4-style-vec pre-arg-3-style-vec)\n                        mixin-sentinal\n                        (fzprint-hang-remaining\n                          caller\n                          loptions\n                          ; Apparently hang-remaining gives\n                          ; you a space after the current\n                          ; thing, so we need to account\n                          ; for it now, since max-width is\n                          ; the end of the current thing\n                          (inc max-width)\n                          (dec (+ indent indent ind))\n                          (get-zloc-seq-right\n                            (if doc-string fourth-data third-data))\n                          fn-style\n                          mixin-length))))]\n            (concat-no-nil\n              l-str-vec\n              pre-arg-1-style-vec\n              (fzprint* loptions (inc ind) arg-1-zloc)\n              pre-arg-2-style-vec\n              (fzprint-hang-one caller\n                                (if (= len 2) options loptions)\n                                arg-1-indent\n                                (+ indent ind)\n                                arg-2-zloc)\n              (cond (and doc-string? mixins?) (concat-no-nil pre-arg-3-style-vec\n                                                             doc-string\n                                                             (remove-one-newline\n                                                               mixins))\n                    doc-string? (concat-no-nil pre-arg-3-style-vec doc-string)\n                    mixins? (remove-one-newline mixins)\n                    :else :noseq)\n              (fzprint-hang-remaining\n                caller\n                (noarg1 options fn-style)\n                (+ indent ind)\n                ; force flow\n                (+ indent ind)\n                (nthnext zloc-seq\n                         (if mixins?\n                           arg-vec-index\n                           (if doc-string? arg-4-count arg-3-count)))\n                fn-style)\n              r-str-vec))\n        (or (= fn-style :arg1-pair)\n            (= fn-style :arg1)\n            (= fn-style :arg1-force-nl)\n            (= fn-style :arg1->))\n          (concat-no-nil\n            l-str-vec\n            pre-arg-1-style-vec\n            (fzprint* loptions (inc ind) arg-1-zloc)\n            pre-arg-2-style-vec\n            (fzprint-hang-one caller\n                              (if (= len 2) options loptions)\n                              arg-1-indent\n                              (+ indent ind)\n                              arg-2-zloc)\n            ; then either pair or remaining-seq\n            ; we don't do a full hanging here.\n            ; We wouldn't be here if len < 3\n            (if (= fn-style :arg1-pair)\n              (prepend-nl options\n                          (+ indent ind)\n                          (fzprint-pairs options\n                                         (+ indent ind)\n                                         (get-zloc-seq-right second-data)))\n              (fzprint-hang-remaining caller\n                                      (noarg1 options fn-style)\n                                      (+ indent ind)\n                                      ; force flow\n                                      (+ indent ind)\n                                      (get-zloc-seq-right second-data)\n                                      fn-style))\n            r-str-vec)\n        ; we know that (> len 2) if fn-style not= nil\n        (= fn-style :arg1-extend)\n          (let [zloc-seq-right-second (get-zloc-seq-right second-data)]\n            (cond (zvector? arg-2-zloc)\n                    ; This will put the second argument\n                    ; (a vector) on a different line than\n                    ; the function name.  No known uses\n                    ; for this code as of 7/20/19.  It\n                    ; does work with :respect-nl and has\n                    ; tests.\n                    (concat-no-nil\n                      l-str-vec\n                      pre-arg-1-style-vec\n                      (fzprint* loptions (+ indent ind) arg-1-zloc)\n                      pre-arg-2-style-vec\n                      (prepend-nl options\n                                  (+ indent ind)\n                                  (fzprint* loptions (+ indent ind) arg-2-zloc))\n                      (prepend-nl options\n                                  (+ indent ind)\n                                  (fzprint-extend options\n                                                  (+ indent ind)\n                                                  zloc-seq-right-second))\n                      r-str-vec)\n                  :else (concat-no-nil\n                          l-str-vec\n                          pre-arg-1-style-vec\n                          (fzprint* loptions (inc ind) arg-1-zloc)\n                          pre-arg-2-style-vec\n                          (fzprint-hang-one caller\n                                            (if (= len 2) options loptions)\n                                            arg-1-indent\n                                            (+ indent ind)\n                                            arg-2-zloc)\n                          (prepend-nl options\n                                      (+ indent ind)\n                                      (fzprint-extend options\n                                                      (+ indent ind)\n                                                      zloc-seq-right-second))\n                          r-str-vec)))\n        (or (= fn-style :wrap) (:wrap? (caller options)))\n          (let [new-ind (+ indent ind)\n                coll-print (fzprint-seq options new-ind zloc-seq)\n                _ (dbg-pr options \"fzprint-list*: :wrap coll-print:\" coll-print)\n                wrap-coll? (:wrap-coll? (caller options))]\n            ; Regular Pprocessing\n            (if (and (not wrap-coll?) (any-zcoll? options new-ind zloc))\n              (concat-no-nil l-str-vec\n                             (apply concat-no-nil\n                               (precede-w-nl options\n                                             new-ind\n                                             coll-print\n                                             :no-nl-first\n                                             (:nl-count (caller options))))\n                             r-str-vec)\n              ; Since there are either no collections in this vector or ;\n              ; set ; or ; whatever, or if there are, it is ok to wrap\n              ; them, ; print it wrapped on the same line as much as\n              ; possible:\n              ;           [a b c d e f\n              ;            g h i j]\n              (concat-no-nil l-str-vec\n                             (do (dbg-pr options\n                                         \"fzprint-list*: wrap coll-print:\"\n                                         coll-print)\n                                 (wrap-zmap caller\n                                            options\n                                            (+ ind l-str-len)\n                                            new-ind\n                                            coll-print))\n                             r-str-vec)))\n        ; This is where we want to interpret a list as just a list, and not\n        ; something with a function as the first element.  It works not\n        ; only for lists, but for vectors as well with :fn-format.\n        (or (= fn-style :list) (:list? (caller options)))\n          (let [new-ind (+ indent ind)\n                coll-print (fzprint-seq options new-ind zloc-seq)\n                _ (dbg-pr options\n                          \"fzprint-list*: :list coll-print:\"\n                          coll-print)]\n            (if (contains-nil? coll-print)\n              nil\n              (if (:nl-separator? (caller options))\n                ; If we are doing nl-separator, we are going to look at\n                ; each of the elements in coll-print, and if it is\n                ; multi-line, we will put :nl-count newlines after it\n                ; otherwise we will do 1 newline. If nl-separator? is true\n                ; (this arm of the if) and nl-count is a vector, then we\n                ; will assume 2 for the nl-count.\n                (let [nl-count (or (:nl-count (caller options)) 2)\n                      nl-count (if (vector? nl-count) 2 nl-count)\n                      nl-count-vector (create-nl-count-vec options\n                                                           new-ind\n                                                           nl-count\n                                                           coll-print)\n                      _ (dbg-s options\n                               #{:list}\n                               \"count coll-print:\" (count coll-print)\n                               \"nl-count-vector:\" nl-count-vector\n                               \"caller:\" caller\n                               \"(:nl-count caller):\" (:nl-count (caller\n                                                                  options)))]\n                  (concat-no-nil l-str-vec\n                                 (apply concat-no-nil\n                                   (precede-w-nl options\n                                                 new-ind\n                                                 coll-print\n                                                 :no-nl-first\n                                                 nl-count-vector))\n                                 r-str-vec))\n                ; nl-separator? false -- nl-count is the number of newlines\n                ; between every element in the list.  Defaults to 1 in\n                ; precede-w-nl.\n                (concat-no-nil l-str-vec\n                               (apply concat-no-nil\n                                 (precede-w-nl options\n                                               new-ind\n                                               coll-print\n                                               :no-nl-first\n                                               (:nl-count (caller options))))\n                               r-str-vec))))\n        ; Unspecified seq, might be a fn, might not.\n        ; If (first zloc) is a seq, we won't have an\n        ; arg-1-indent.  In that case, just flow it\n        ; out with remaining seq.  Since we already\n        ; know that it won't fit on one line.  If it\n        ; might be a fn, try hanging and flow and do\n        ; what we like better.  Note that default-indent\n        ; might be 1 here, which means that we are pretty\n        ; sure that the (zfirst zloc) isn't a function\n        ; and we aren't doing code.\n        ;\n        :else (concat-no-nil\n                l-str-vec\n                pre-arg-1-style-vec\n                ; Can't use arg-1-zloc here as the if test, because when\n                ; formatting structures, arg-1-zloc might well be nil!\n                (if (not (zero? len))\n                  (fzprint* loptions (+ l-str-len ind) arg-1-zloc)\n                  :noseq)\n                ; Same here -- can't use arg-1-zloc as if test!!\n                (if (not (zero? len))\n                  (let [zloc-seq-right-first (get-zloc-seq-right first-data)]\n                    (if zloc-seq-right-first\n                      ; We have something else to format after arg-1-zloc\n                      (if arg-1-indent\n                        ; Use fzprint-hang-remaining for :flow as well,\n                        ; with hindent = findent to force flow, so that\n                        ; constant pairing is done for :flow functions.\n                        (let [result (fzprint-hang-remaining\n                                       caller\n                                       (noarg1 options fn-style)\n                                       (if (= fn-style :flow)\n                                         ; If the fn-type is :flow, make\n                                         ; the hindent = findent so that it\n                                         ; will flow\n                                         (+ indent ind)\n                                         arg-1-indent)\n                                       ; Removed indent-adj because it\n                                       ; caused several problems, issue\n                                       ; #163\n                                       (+ indent ind)\n                                       ; Can't do this, because\n                                       ; hang-remaining\n                                       ; doesn't take a seq\n                                       zloc-seq-right-first\n                                       ;(znthnext zloc 0)\n                                       fn-style)]\n                          (dbg-pr options\n                                  \"fzprint-list*: r-str-vec:\" r-str-vec\n                                  \"result:\" result)\n                          result)\n                        ; This is collection as the first thing. Used to\n                        ; handle :flow here as well, but now it goes\n                        ; through fzprint-hang-remaining with hindent =\n                        ; findent so that constant pairing works for flow.\n                        (let [local-indent (+ default-indent ind indent-adj)]\n                          (concat-no-nil ;[[(str \"\\n\" (blanks\n                                         ;local-indent)) :none :indent]]\n                            (fzprint-flow-seq caller\n                                              (noarg1 options fn-style)\n                                              local-indent\n                                              ;(nthnext (zmap identity\n                                              ;zloc) 1)\n                                              zloc-seq-right-first\n                                              :force-nl\n                                              :newline-first))))\n                      ; Nothing else after arg-1-zloc\n                      :noseq))\n                  :noseq)\n                r-str-vec)))))\n\n(defn fzprint-list\n  \"Pretty print and focus style a :list element.\"\n  [options ind zloc]\n  (dbg-pr options \"fzprint-list\")\n  (fzprint-list* :list \"(\" \")\" (rightmost options) ind zloc))\n\n(defn fzprint-anon-fn\n  \"Pretty print and focus style a fn element.\"\n  [options ind zloc]\n  (dbg-pr options \"fzprint-anon-fn\")\n  (fzprint-list* :list \"#(\" \")\" (rightmost options) ind zloc))\n\n(defn any-zcoll?\n  \"Return true if there are any collections in the collection.\"\n  [options ind zloc]\n  (let [coll?-seq (zmap zcoll? zloc)] (reduce #(or %1 %2) nil coll?-seq)))\n\n;;\n;; # Put things on the same line\n;;\n\n(defn wrap-zmap\n  \"Given the output from fzprint-seq, which is a style-vec in\n  the making without spacing, but with extra [] around the elements,\n  wrap the elements to the right margin. cur-ind is where we are now,\n  and ind is where we should be after a newline.\"\n  ; Note: I think this routine assumes a \"[\" (or at least a single\n  ; character left element) at the start of the seequence, since it\n  ; adds one space to everything element other than the first.\n  [caller\n   {:keys [width rightcnt],\n    {:keys [wrap-after-multi? respect-nl? no-wrap-after]} caller,\n    :as options} cur-ind ind coll-print]\n  #_(prn \"wrap-zmap:\" coll-print)\n  (let [last-index (dec (count coll-print))\n        rightcnt (fix-rightcnt rightcnt)]\n    (loop [cur-seq coll-print\n           cur-ind cur-ind\n           index 0\n           previous-newline? false\n           ; transient here slows things down, interestingly enough\n           out []]\n      (if-not cur-seq\n        (do (dbg-pr options \"wrap-zmap: out:\" out) #_(def zmo out) out)\n        (let [next-seq (first cur-seq)]\n          (when next-seq\n            (let [multi? (> (count (first cur-seq)) 1)\n                  this-seq (first cur-seq)\n                  _ (log-lines options \"wrap-zmap:\" ind this-seq)\n                  _ (dbg-pr options \"wrap-zmap: ind:\" ind \"this-seq:\" this-seq)\n                  [linecnt max-width lines] (style-lines options ind this-seq)\n                  last-width (last lines)\n                  len (- last-width ind)\n                  len (max 0 len)\n                  ; Do we have a no-wrap element?\n                  no-wrap-element? (when no-wrap-after\n                                     (no-wrap-after (first (first this-seq))))\n                  ; If we do, then add its length to the length of the\n                  ; existing element\n                  next-len (when (and no-wrap-element? (second cur-seq))\n                             (let [[linecnt max-width lines]\n                                     (style-lines options ind (second cur-seq))\n                                   last-width (last lines)]\n                               (max 0 (- last-width ind))))\n                  ; If we have a no-wrap element, make the index the index\n                  ; of the next element, so we handle rightcnt correctly\n                  original-len len\n                  [len index] (if next-len\n                                ; Add the lengths together, and also one\n                                ; for the space\n                                [(+ len next-len 1) (inc index)]\n                                [len index])\n                  newline? (= (nth (first this-seq) 2) :newline)\n                  comment?\n                    (if respect-nl? nil (= (nth (first this-seq) 2) :comment))\n                  comment-inline? (if respect-nl?\n                                    nil\n                                    (= (nth (first this-seq) 2)\n                                       :comment-inline))\n                  width (if (= index last-index) (- width rightcnt) width)\n                  ; need to check size, and if one line and fits, should\n                  ; fit\n                  fit? (and (not newline?)\n                            (or (zero? index) (not comment?))\n                            (or (zero? index)\n                                (and (if multi? (= linecnt 1) true)\n                                     (<= (+ cur-ind len) width))))\n                  _ (when no-wrap-element?\n                      (dbg-pr options\n                              \"wrap-zmap: no-wrap-element:\" (first (first\n                                                                     this-seq))\n                              \"original-len:\" original-len\n                              \"next-len:\" next-len\n                              \"index:\" index\n                              \"rightcnt:\" rightcnt\n                              \"fit?\" fit?))\n                  new-ind (cond\n                            ; Comments cause an overflow of the size\n                            (or comment? comment-inline?) (inc width)\n                            (and multi? (> linecnt 1) (not wrap-after-multi?))\n                              width\n                            fit? (+ cur-ind len 1)\n                            newline? ind\n                            :else (+ ind len 1))]\n              #_(prn \"------ this-seq:\" this-seq)\n              #_(println\n                  \"lines:\" lines\n                  \"\\nlinecnt:\" linecnt\n                  \"\\nmulti?\" multi?\n                  \"\\nnewline?:\" newline?\n                  \"\\ncomment?\" comment?\n                  \"\\ncomment-inline?\" comment-inline?\n                  \"\\nprevious-newline?:\" previous-newline?\n                  \"\\nlinecnt:\" linecnt\n                  \"\\nmax-width:\" max-width\n                  \"\\nlast-width:\" last-width\n                  \"\\nno-wrap-element?\" no-wrap-element?\n                  \"\\nnext-len:\" next-len\n                  \"\\nlen:\" len\n                  \"\\nindex:\" index\n                  \"\\ncur-ind:\" cur-ind\n                  \"\\nnew-ind:\" new-ind\n                  \"\\nwidth:\" width\n                  \"\\nfit?\" fit?)\n              ; need to figure out what to do with a comment,\n              ; want to force next line to not fit whether or not\n              ; this line fit.  Comments are already multi-line, and\n              ; it is really not clear what multi? does in this routine\n              (recur (next cur-seq)\n                     new-ind\n                     (inc index)\n                     newline?\n                     ; TODO: concat-no-nil fails here, why?\n                     (concat\n                       out\n                       (if fit?\n                         (if (not (or previous-newline? (zero? index)))\n                           (concat-no-nil [[\" \" :none :whitespace 15]] this-seq)\n                           this-seq)\n                         (if newline?\n                           [[(str \"\\n\"\n                                  ; Fix sets and vectors to have\n                                  ; terminal right thing after a\n                                  ; comment or newline be indented\n                                  ; like other elements are.  Used\n                                  ; to just be (blanks (dec new-ind))\n                                  ; now the if checks to see if we\n                                  ; are at the end, and does new-ind,\n                                  ; which is like the other stuff.\n                                  ; But wrong for the future of where\n                                  ; we are going, as it happens.\n                                  (blanks\n                                    ; Figure out what the next thing is\n                                    (let [this-seq-next (first (next cur-seq))\n                                          newline-next?\n                                            (when this-seq-next\n                                              (= (nth (first this-seq-next) 2)\n                                                 :newline))]\n                                      ; If the next thing is a newline,\n                                      ; don't put any blanks on this line\n                                      (if newline-next? 0 new-ind)))) :none\n                             :indent 21]]\n                           ; Unclear if a prepend-nl would be useful\n                           ; here...\n                           (if previous-newline?\n                             this-seq\n                             (prepend-nl options ind this-seq)))))))))))))\n\n(defn count-comments-and-newlines\n  \"Given a seq from fzprint-seq, count the newlines and contiguous comments\n  at the beginning of the list.  A comment preceded by a newline or comment\n  doesn't count.\"\n  [coll-print]\n  (loop [cur-seq coll-print\n         previous-comment? false\n         previous-newline? false\n         comment-and-newline-count 0]\n    (if-not cur-seq\n      comment-and-newline-count\n      (let [element-type (nth (ffirst cur-seq) 2)\n            comment? (or (= element-type :comment)\n                         (= element-type :comment-inline))\n            newline? (= element-type :newline)]\n        (if-not (or newline? comment?)\n          comment-and-newline-count\n          (recur (next cur-seq)\n                 comment?\n                 newline?\n                 (if comment?\n                   (if previous-newline?\n                     ; Don't count the newline preceding a comment\n                     (dec comment-and-newline-count)\n                     comment-and-newline-count)\n                   (inc comment-and-newline-count))))))))\n\n(defn zcount-comments-and-newlines\n  \"Given a zloc-seq, count the newlines and contiguous comments\n  at the beginning of the list.  A comment preceded by a newline or comment\n  doesn't count.\"\n  [zloc-seq]\n  (loop [cur-seq zloc-seq\n         previous-comment? false\n         previous-newline? false\n         comment-and-newline-count 0]\n    (if-not cur-seq\n      comment-and-newline-count\n      (let [tag (ztag (first cur-seq))\n            comment? (= tag :comment)\n            newline? (= tag :newline)]\n        (if-not (or newline? comment?)\n          comment-and-newline-count\n          (recur (next cur-seq)\n                 comment?\n                 newline?\n                 (if comment?\n                   (if previous-newline?\n                     ; Don't count the newline preceding a comment\n                     (dec comment-and-newline-count)\n                     comment-and-newline-count)\n                   (inc comment-and-newline-count))))))))\n\n(defn inline-comment->comment\n  \"If the first thing in a guided output-seq is an inline comment, turn\n  it into a regular comment.  Output a possibly modified output-seq.\"\n  [output-seq]\n  (if (= (nth (first output-seq) 2) :comment-inline)\n    (let [[s c] (first output-seq)\n          new-first [s c :comment]]\n      (if (> (count output-seq) 1) [new-first (next output-seq)] [new-first]))\n    output-seq))\n\n(defn guided-output\n  \"Return information to be added to the output vector along\n  with other information [param-map previous-data out].  Will do an\n  fzprint* on zloc unless next-seq has data in it to use.\"\n  ; [caller options incoming-seq zloc next-guide cur-index guide-seq\n  ;  index param-map mark-map previous-data out]\n  [caller\n   {:keys [width rightcnt one-line?],\n    {:keys [wrap-after-multi? wrap-multi? respect-nl?]} caller,\n    :as options} zloc rightmost-zloc? next-guide cur-index guide-seq\n   element-index index\n   {:keys [excess-guided-newline-count align-key last-cur-index rightcnt cur-ind\n           ind indent spaces one-line-ind group-seq all-fit?],\n    :as param-map} mark-map\n   [previous-newline? previous-guided-newline? unguided-newline-out?\n    previous-comment? :as previous-data] out]\n  ; We either have a zloc or we have a group, but not both, so there\n  ; are no decisions to make about which one to use.\n  (dbg-s options :guide \"guided-output: zloc:\" (pr-str (zstring zloc)))\n  (if (and group-seq (empty? group-seq) (not zloc))\n    ; We have a group, but it is empty, so do nothing -- but be sure and\n    ; remove it, or we're going to do a lot of nothing\n    [(dissoc param-map :group-seq) previous-data out]\n    (let [group-seq (if (and (empty? group-seq) zloc) nil group-seq)\n          uneval? (= (ztag zloc) :uneval)\n          guided-newline? (= next-guide :newline)\n          ; incoming-pairs is [pair-ind pair-result]\n          do-pairs? (or (= next-guide :pair-end)\n                        (= next-guide :element-pair-group)\n                        (= next-guide :element-pair-*))\n          options (if (= next-guide :element-guide)\n                    (assoc options :guide (second guide-seq))\n                    options)\n          ; Forget incoming pairs\n          incoming-seq nil\n          ; incoming-seq is the incoming sequence, if any.  The only thing\n          ; that is incoming at present is the pair information.\n          incoming-seq (if guided-newline? [[\"\\n\" :none :newline]] incoming-seq)\n          ; Now incoming-seq is either the pair information or possibly a\n          ; newline generated because we have a :newline in the guide.\n          ;\n          ; There are two fundemental approaches here -- this-line and\n          ; next-line. We will use fzprint* to see if something fits on\n          ; this line in some cases, though not in all.  We also may have\n          ; an incoming-seq which might fit on this line and might need to\n          ; go to the next line. The pairs code looks at previous-newline?\n          ; and doesn't try the current line if it is set.\n          ;\n          ; These values are true for this and next line.\n          options (if rightmost-zloc? options (not-rightmost options))\n          align-ind (when align-key (get mark-map align-key))\n          ; If we have both align-ind and spaces, then add the spaces\n          align-ind (when align-ind (if spaces (+ align-ind spaces) align-ind))\n          ; Find out how big the incoming pairs (or guided-newline) is\n          incoming-lines (style-lines options (or (+ indent ind)) incoming-seq)\n          ; This is only true for this line, not next line.\n          align-spaces (when align-ind (max 0 (- align-ind cur-ind)))\n          ; There are two key values for the this-line and next-line calls\n          ; to fzprint*: what value to give to fzprint* for ind, and how\n          ; many spaces do we need to put on whatever is out there now to\n          ; get there.  this-ind, this-spaces, next-ind, next-spaces.\n          ;\n          ; Figure out where we are on the line now, so we can call\n          ; fzprint*. If we have previous-newline? true, then we have a\n          ; newline but no actual spaces to the right of it.  If we don't,\n          ; then we are somewhere on the line, and just have to put some\n          ; spaces between where we are and where the next thing begins.\n          ;\n          group-newline? (when group-seq (= (ztag (first group-seq)) :newline))\n          regular-space\n            (if (or previous-newline? (zero? element-index) group-newline?) 0 1)\n          additional-spaces (or align-spaces spaces 0)\n          beyond-cur-ind (max additional-spaces regular-space)\n          ; How many spaces to the right of what is already there? Note\n          ; that if we had a previous-newline, we don't really have cur-ind\n          ; spaces there at this time, so we need to account for that.\n          this-spaces\n            (if previous-newline? (+ beyond-cur-ind cur-ind) beyond-cur-ind)\n          this-ind (+ beyond-cur-ind cur-ind)\n          ; Just trying this out here for fzprint-hang-remaining\n          early-next-ind\n            (or align-ind\n                (+ (if (zero? element-index) one-line-ind (+ indent ind))\n                   (or spaces 0)))\n          this-early-next-ind early-next-ind\n          [do-hang-remaining? hang-remaining-seq]\n            (cond (or (= next-guide :element-newline-best-group)\n                      (= next-guide :element-newline-best-*))\n                    [true group-seq]\n                  (or (= next-guide :element-best)\n                      (= next-guide :element-best-first)\n                      (= next-guide :element-best-*))\n                    [true [zloc]])\n          [do-extend? extend-seq]\n            (cond (or (= next-guide :element-newline-extend-group)\n                      (= next-guide :element-newline-extend-*))\n                    [true group-seq]\n                  (or (= next-guide :element-extend)\n                      (= next-guide :element-extend-first)\n                      (= next-guide :element-extend-*))\n                    [true [zloc]])\n          [do-wrap-flow? wrap-flow-seq]\n            (cond (or (= next-guide :element-wrap-flow-group)\n                      (= next-guide :element-wrap-flow-*))\n                    [true group-seq])\n          try-this? (and (or zloc do-pairs? group-seq)\n                         (or (not previous-newline?) do-wrap-flow?)\n                         (if (or (= next-guide :element-best-first)\n                                 (= next-guide :element-extend-first))\n                           all-fit?\n                           true)\n                         (not guided-newline?)\n                         (or do-hang-remaining?\n                             do-extend?\n                             do-wrap-flow?\n                             (and (< cur-ind width) (< this-ind width))))\n          this-result\n            (when try-this?\n              (cond\n                do-pairs? (fzprint-pairs (in-hang options) this-ind group-seq)\n                do-hang-remaining? (fzprint-hang-remaining\n                                     caller\n                                     options\n                                     #_(assoc options :dbg? true)\n                                     ; This is the correct hindent, but it\n                                     ; will include a space if it hangs it.\n                                     this-ind\n                                     early-next-ind\n                                     hang-remaining-seq\n                                     nil ;fn-type\n                                   )\n                do-wrap-flow? (fzprint-one-line options this-ind wrap-flow-seq)\n                do-extend? (prepend-nl options\n                                       (+ indent ind)\n                                       (fzprint-extend options\n                                                       ; Might be this-ind?\n                                                       this-ind\n                                                       extend-seq))\n                ; We don't need to use fzprint-hang-unless-fail, because\n                ; that is pretty much what we are doing with everything.\n                (= next-guide :element-binding-vec)\n                  (fzprint-binding-vec (in-hang options) this-ind zloc)\n                (or (= next-guide :element-binding-group)\n                    (= next-guide :element-binding-*))\n                  (fzprint-pairs (in-hang options) this-ind group-seq :binding)\n                :else (fzprint* (in-hang options) this-ind zloc)))\n          ; If we did fzprint-hang-remaining and it has a single space at\n          ; the beginning, then drop that space.\n          this-result (if (and (or do-hang-remaining? do-extend?)\n                               (= (nth (first this-result) 2) :whitespace)\n                               (= (ffirst this-result) \" \"))\n                        (next this-result)\n                        this-result)\n          #_(println \"this-result:\" this-result)\n          this-lines (style-lines options this-ind this-result)\n          ; Force wrap-multi? true for this guide if we are doing binding,\n          ; regardless of its value in the options map.\n          wrap-multi? (if (or (= next-guide :element-binding-group)\n                              (= next-guide :element-binding-*))\n                        true\n                        wrap-multi?)\n          ; this-multi? says that there is more than one thing in\n          ; this-result, not that it is multi-line!!\n          this-multi? (when this-result (> (count this-result) 1))\n          ; this-linecnt has the number of lines in this-result.\n          this-linecnt (when this-lines (first this-lines))\n          ; This says that we either didn't try a this or we did and the\n          ; this didn't fit.\n          this-fit? (and (or zloc do-pairs? group-seq)\n                         (and (not (empty? this-result))\n                              (if this-multi?\n                                (or wrap-multi? (<= this-linecnt 1))\n                                true)))\n          ; output-seq is either the results of the this-line fzprint* or\n          ; the incoming sequence.\n          output-seq (or this-result incoming-seq)\n          ; Test whatever we've got for fit\n          output-newline? (= (nth (first output-seq) 2) :newline)\n          fail-fit? (or guided-newline?\n                        output-newline?\n                        (= (nth (first output-seq) 2) :indent)\n                        (= (nth (first output-seq) 2) :comment-inline)\n                        (and (not (zero? element-index))\n                             (= (nth (first output-seq) 2) :comment))\n                        ; We tried a this, and it didn't fit.\n                        (and try-this? (not this-fit?)))\n          #_(dbg-s options\n                   :guide\n                   \"guided-output: this-lines:\" this-lines\n                   \"this-multi?\" this-multi?\n                   \"this-linecnt:\" this-linecnt\n                   \"this-ind:\" this-ind\n                   \"try-this?\" try-this?\n                   \"this-fit?\" this-fit?\n                   \"fail-fit?\" fail-fit?)\n          ; If we tried it and it didn't fit, forget about any spaces\n          ; before we try it on the next line\n          spaces (when spaces (if (and try-this? (not this-fit?)) nil spaces))\n          ; If we tried it and it didn't fit, forget about any alignment\n          ; before we try it on the next line\n          align-ind (when align-ind\n                      (if (and try-this? (not this-fit?)) nil align-ind))\n          ; next-ind is the place we will base the fzprint* call on, and in\n          ; this case it is also the number of spaces we will need to put\n          ; out there before placing the return from fzprint*.\n          next-ind (or align-ind\n                       (+ (if (zero? element-index) one-line-ind (+ indent ind))\n                          (or spaces 0)))\n          ; If we have some kind of alignment, that is, align-ind or\n          ; spaces, and we didn't even try it with this-fzprint*, then we\n          ; need to see if it fits on the next line too, and if not, then\n          ; do it without any alignment for real.  But only if we aren't\n          ; already in-hang?\n          early-next-ind next-ind\n          test-fit? (and (not try-this?)\n                         (or align-ind spaces)\n                         (not (:in-hang? options)))\n          ; We are going to do something on the next line.\n          try-next? (and (or zloc do-pairs? group-seq)\n                         (not this-fit?)\n                         (not output-newline?))\n          ; If we didn't try a this-line fzprint*, and we have some kind\n          ; of slightly optional alignment, then see if it fits with the\n          ; alignment on the next line.\n          next-result (when (and test-fit? try-next?)\n                        (if do-pairs?\n                          (fzprint-pairs (in-hang options) next-ind group-seq)\n                          (fzprint* (in-hang options) next-ind zloc)))\n          first-next-result next-result\n          ; We did the test-fit? and it didn't fit, so forget any alignment\n          ; or spaces -- or not.\n          next-ind (if (and try-next? test-fit? (empty? next-result))\n                     (if (zero? element-index) one-line-ind (+ indent ind))\n                     next-ind)\n          ; See how it would fit if it were on the next line and we don't\n          ; have a this that fit (either because we didn't try the this or\n          ; because we did and the result didn't fit) Also don't flow if\n          ; the this generated a newline.\n          next-result (if (and try-next? (empty? next-result))\n                        (cond\n                          do-pairs? (fzprint-pairs options next-ind group-seq)\n                          ;   (= next-guide :element-binding-vec)\n                          ;         (fzprint-binding-vec options next-ind\n                          ;         zloc)\n                          do-hang-remaining? (fzprint-hang-remaining\n                                               caller\n                                               options\n                                               #_(assoc options :dbg? true)\n                                               ; flow it if we are doing it\n                                               ; here\n                                               next-ind\n                                               next-ind\n                                               hang-remaining-seq\n                                               nil ;fn-type\n                                             )\n                          do-wrap-flow? (fzprint-hang-remaining\n                                          caller\n                                          options\n                                          #_(assoc options :dbg? true)\n                                          ; flow it if we are doing it here\n                                          next-ind\n                                          next-ind\n                                          wrap-flow-seq\n                                          nil ;fn-type\n                                        )\n                          do-extend? (prepend-nl options\n                                                 (+ indent ind)\n                                                 (fzprint-extend options\n                                                                 ; Might be\n                                                                 ; this-ind?\n                                                                 next-ind\n                                                                 extend-seq))\n                          (= next-guide :element-binding-vec)\n                            (fzprint-binding-vec options next-ind zloc)\n                          (or (= next-guide :element-binding-group)\n                              (= next-guide :element-binding-*))\n                            (fzprint-pairs options next-ind group-seq :binding)\n                          :else (fzprint* options next-ind zloc))\n                        next-result)\n          ; If we did fzprint-hang-remaining and it has a newline at the\n          ; beginning, then we should drop that because we are going to\n          ; do it ourselves since this is the \"next\" processing.\n          #_(prn \"next-result\" next-result)\n          next-result (if (and (or do-hang-remaining?\n                                   do-extend?\n                                   do-wrap-flow?\n                                   (= next-guide :element-binding-*)\n                                   (= next-guide :element-binding-group))\n                               (= (nth (first next-result) 2) :indent)\n                               (clojure.string/starts-with? (ffirst next-result)\n                                                            \"\\n\"))\n                        (next next-result)\n                        next-result)\n          next-lines (style-lines options next-ind next-result)\n          #_(dbg-s options\n                   :guide\n                   \"guided-output: next-lines:\" next-lines\n                   \"first-next-result:\" first-next-result\n                   \"early-next-ind:\" early-next-ind\n                   \"next-ind:\" next-ind\n                   \"test-fit?\" test-fit?\n                   \"try-next?\" try-next?\n                   \"(+ indent ind):\" (+ indent ind)\n                   \"beyond-cur-ind:\" beyond-cur-ind\n                   \"cur-ind:\" cur-ind\n                   \"element-index:\" element-index)\n          output-seq (or next-result output-seq)\n          ; This says that we don't fit if we used the result from the\n          ; next line fzprint*\n          fail-fit? (or fail-fit? next-result)\n          comment? (= (nth (first output-seq) 2) :comment)\n          comment-inline? (= (nth (first output-seq) 2) :comment-inline)\n          newline? (or (and (= (nth (first output-seq) 2) :newline)\n                            (= (count output-seq) 1))\n                       guided-newline?)\n          ; Note that this isn't an :indent guide, this is an indent at\n          ; the start of the output-seq, which means a newline.\n          ; Or a newline.  In any case, this will prevent a prepend-nl.\n          indent? (or (= (nth (first output-seq) 2) :indent)\n                      (= (nth (first output-seq) 2) :newline))\n          ; output-seq might be nil, in which case several of these things\n          ; are nil multi? says that there is more than one thing in\n          ; output-seq, not it is multi-line!!\n          multi? (when output-seq (> (count output-seq) 1))\n          #_(dbg-s options\n                   :guide\n                   \"guided-output: ind:\" ind\n                   \"index:\" index\n                   \"cur-index:\" cur-index\n                   \"element-index:\" element-index)\n          ; Use whichever style-lines output makes sense, and figure the\n          ; length of the last line which will become the new cur-ind\n          ; (through new-ind, below).\n          [linecnt max-width lines] (when output-seq\n                                      (or next-lines this-lines incoming-lines))\n          last-width (last lines)\n          ; If it is multi? and (> linecnt 1), then it doesn't fit at\n          ; present. If that changed, the fzprint-seq at the beginning\n          ; would be wrong, because it says to do it at the \"beginning\".\n          ; Now, we could do what indent-only does and shift it all over,\n          ; which can work, but isn't what we are doing today. If that ever\n          ; changed, we would need to check the widest line, not just the\n          ; last line as we are doing now.  Plus, we would need check the\n          ; widest line against the width, and the last line against the\n          ; rightcnt adjusted width as well to ensure a fit.\n          ;\n          ; If one line and fits, should fit.\n          fit? (not fail-fit?)\n          ; Calculate new location on the line, which is the end of the\n          ; thing we are outputing now.\n          new-ind\n            (cond\n              ; Comments cause an overflow of the size, forcing the next\n              ; thing onto a new line\n              (or comment? comment-inline?) (inc width)\n              ; Uneval stuff with a previous newline will force the next\n              ; thing onto a new line\n              (and uneval? previous-newline?) (inc width)\n              ; If is multi-line, and we have more than one line, and\n              ; we don't allow anything after a multi-line thing on\n              ; the same line, then force the next thing onto a new line\n              (and multi? (> linecnt 1) (not wrap-after-multi?)) (inc width)\n              ; If it is multi-line, and it is more than one line, and\n              ; we *do* allow things after the last line, then the length\n              ; of the last line is the new cur-ind.\n              (and multi? (> linecnt 1)) last-width\n              ; This is the old fit?\n              fit? last-width\n              ; When this is (+ indent ind), that is part of what  makes\n              ; :spaces after a newline be \"spaces beyond the indent\", not\n              ; \"spaces instead of the indent\". Also, if (zero?\n              ; element-index), then we have put some stuff before the\n              ; first :element in the guide.  The first element should be\n              ; indented as if it were still on the same line as the l-str,\n              ; and one-line-ind is that indent.\n              ;\n              ; Just be aware that this is something of a lie, since\n              ; if we have a newline there really isn't anything on the\n              ; line after it, since we can't take the chance that we\n              ; might not have another newline next and we can't do\n              ; trailing newlines.  So the next call to guided-ouput\n              ; needs to understand that cur-ind is the number of spaces\n              ; that we wish were after a newline but aren't actually\n              ; there.\n              newline? (if (zero? element-index) one-line-ind (+ indent ind))\n              :else last-width)\n          param-map (dissoc param-map :excess-guided-newline-count)\n          param-map (assoc param-map\n                      :cur-ind new-ind\n                      :all-fit? (and fit? all-fit?))]\n      ; We used to forget about spaces here in some situations, but\n      ; really we only wanted to forget about them after :element or\n      ; :element-align or :newline (a guided one), so we do that in\n      ; fzprint-guide now.\n      (dbg-s options\n             :guide\n             \"guided-output: ------ incoming out:\"\n             (color-str ((:dzprint options)\n                          {}\n                          (into []\n                                (let [out-len (count out)\n                                      out-drop (int (* 0.8 out-len))\n                                      out-drop (if (< (- out-len out-drop) 10)\n                                                 (- out-len 10)\n                                                 out-drop)]\n                                  (condense-depth 1 out))))\n                        :blue))\n      (dbg-s-pr options :guide \"guided-output; ------ next-guide:\" next-guide)\n      (dbg-s options\n             :guide\n             \"guided-output: ------ output-seq:\"\n             (color-str ((:dzprint options) {} (condense-depth 1 output-seq))\n                        :green))\n      (dbg-s-pr options :guide \"guided-output: ------ mark-map:\" mark-map)\n      ;\"(first cur-seq)\" (first cur-seq)\n      (dbg-s\n        options\n        :guide \"guided-output:\"\n        \"\\ncaller:\" caller\n        \"\\nindex:\" index\n        \"\\nzloc?\" (not (empty? zloc))\n        \"\\ngroup-seq-len:\" (count group-seq)\n        \"\\ngroup-newline?\" group-newline?\n        \"\\ncur-index:\" cur-index\n        \"\\nelement-index:\" element-index\n        \"\\nrightmost-zloc?\" rightmost-zloc?\n        \"\\none-line?\" one-line?\n        \"\\ndo-pairs?\" do-pairs?\n        \"\\nindent?\" indent?\n        \"\\nnewline?\" newline?\n        \"\\nguided-newline?\" guided-newline?\n        \"\\noutput-newline?\" output-newline?\n        \"\\nexcess-guided-newline-count:\" excess-guided-newline-count\n        \"\\nprevious-newline?\" previous-newline?\n        \"\\nunguided-newline-out?\" unguided-newline-out?\n        \"\\nprevious-comment?\" previous-comment?\n        \"\\nalign-key:\" align-key\n        \"\\nalign-ind:\" align-ind\n        \"\\nalign-spaces:\" align-spaces\n        \"\\nspaces:\" spaces\n        \"\\nTHIS:\" \"\"\n        \"\\n this-lines:\" this-lines\n        \"\\n this-ind:\" this-ind\n        \"\\n this-early-next-ind:\" this-early-next-ind\n        \"\\n this-spaces:\" this-spaces\n        \"\\n this-multi?\" this-multi?\n        \"\\n this-linecnt:\" this-linecnt\n        \"\\n try-this?\" try-this?\n        \"\\n this-fit?\" this-fit?\n        \"\\n fail-fit?\" fail-fit?\n        \"\\n do-hang-remaining?\" do-hang-remaining?\n        \"\\n do-extend?\" do-extend?\n        \"\\n do-wrap-flow?\" do-wrap-flow?\n        \"\\n regular-space:\" regular-space\n        \"\\n additional-spaces:\" additional-spaces\n        \"\\n beyond-cur-ind:\" beyond-cur-ind\n        \"\\nNEXT:\" \"\"\n        \"\\n next-lines:\" next-lines\n        \"\\n test-fit?\" test-fit?\n        \"\\n try-next?\" try-next?\n        \"\\n early-next-ind:\" early-next-ind\n        \"\\n next-ind:\" next-ind\n        \"\\n (+ indent ind):\" (+ indent ind)\n        \"\\nmulti?\" multi?\n        \"\\nwrap-multi?\" wrap-multi?\n        \"\\nlines:\" lines\n        \"\\nlinecnt:\" linecnt\n        \"\\nmax-width:\" max-width\n        \"\\nlast-width:\" last-width\n        \"\\nind:\" ind\n        \"\\nindent:\" indent\n        \"\\ncur-ind:\" cur-ind\n        \"\\nnew-ind:\" new-ind\n        \"\\nwidth:\" width\n        \"\\nfit?\" fit?\n        \"\\nall-fit?\" all-fit?\n        \"\\nfail-fit?\" fail-fit?)\n      [;\n       ; param-map\n       ;\n       ; Get rid of one-time parameters and update things that have\n       ; changed\n       param-map\n       ;\n       ; previous-data\n       ;\n       [; previous-newline?\n        newline?\n        ; previous-guided-newline?\n        guided-newline?\n        ; unguided-newline-out?\n        (and (not guided-newline?)\n             (not (and previous-comment? newline?))\n             (and (not fit?) (or newline? #_(not previous-newline?))))\n        ; previous-comment?\n        (or comment? comment-inline?)]\n       ;\n       ; out\n       ;\n       (let [guided-output-out\n               (if fit?\n                 ; Note that newlines don't fit\n                 (if (not (zero? index))\n                   (concat-no-nil [[(blanks this-spaces) :none :whitespace 25]]\n                                  output-seq)\n                   ; This might be nil, but that's ok\n                   output-seq)\n                 (if newline?\n                   (concat-no-nil\n                     ; If we have excess-guided-newline-count, then\n                     ; output it now.  These newlines have no spaces\n                     ; after them, so they should not be used to start\n                     ; a line with something else on it!  We dec because\n                     ; the next thing is a guarenteed newline.\n                     (if (and excess-guided-newline-count\n                              (pos? (dec excess-guided-newline-count)))\n                       (repeat (dec excess-guided-newline-count)\n                               [\"\\n\" :indent 22])\n                       :noseq)\n                     [[(str \"\\n\") :none :indent 21]])\n                   ; This doesn't fit, and isn't a newline\n                   ; Do we need a newline, or do we already have one\n                   ; we could use?\n                   ;\n                   ; This will be a problem, as the simple case says\n                   ; \"Sure, we can use a guided newline here.\"\n                   ; Don't let a comment come after a guided-newline\n                   (if (and previous-newline?\n                            (not (and comment? previous-guided-newline?)))\n                     ; We have just done a newline that we can use.\n                     (do (dbg-s options\n                                :guide\n                                \"guided-output: previous-newline? etc.\")\n                         ; If output-seq starts with an inline-comment,\n                         ; make it a regular comment, since it isn't inline\n                         ; with anything amymore.\n                         (concat-no-nil [[(blanks next-ind) :none :whitespace\n                                          16]]\n                                        (inline-comment->comment output-seq)))\n                     ; Do we already have a newline at the beginning of a\n                     ; bunch of output, or is this the very first thing?\n                     (if (or indent? (zero? element-index))\n                       ; Yes, don't prepend another newline\n                       output-seq\n                       (do (dbg-s options :guide \"guided-output: prepend-nl:\")\n                           (prepend-nl\n                             options\n                             ; This code is related to the code under fit?\n                             ; above, but without previous-newline?, as\n                             ; that is assumed since we are calling\n                             ; prepend-nl.\n                             ;\n                             ; Note that this is largely for ensuring\n                             ; that non-inline comments end up indented\n                             ; to match the indentation of the next\n                             ; :element or :elment-align\n                             next-ind\n                             output-seq))))))]\n         (dbg-s options\n                :guide\n                (color-str (str \"guided-output returned additional out:\"\n                                (when (nil? guided-output-out)\n                                  (str \" - ALTOGETHER FAILED TO FIT!\"\n                                       (when one-line? \"\\n *** ONE-LINE ***\"))))\n                           :bright-blue)\n                ((:dzprint options) {:color? true} guided-output-out))\n         ; If we have a nil guided-output-out, we don't add it on, we\n         ; return a nil which will stop everything!\n         (when guided-output-out (concat out guided-output-out)))])))\n\n(defn comment-or-newline?\n  \"Is this element in the output from fzprint-seq a comment or a newline?\"\n  ; Should this include :indent?  Maybe not, as it looks like it is used\n  ; only for constant pairing?\n  [element]\n  (let [element-type (nth (first element) 2)]\n    (or (= element-type :comment)\n        (= element-type :comment-inline)\n        (= element-type :newline))))\n\n(defn guide-here\n  \"Given the param map, return the location for here.\"\n  [param-map mark-map]\n  (max (or (when (:align-key param-map)\n             (max 0\n                  (- (+ (get mark-map (:align-key param-map))\n                        (or (:spaces param-map) 0))\n                     (:ind param-map))))\n           0)\n       (- (+ (:cur-ind param-map) (or (:spaces param-map) 1))\n          (:ind param-map))))\n\n\n(defn fzprint-guide\n  \"Given a zloc-seq wrap the elements to the right margin \n  and be guided by the guide seq.\"\n  [caller\n   {:keys [width rightcnt one-line?],\n    {:keys [wrap-after-multi? respect-nl? indent]} caller,\n    :as options} ind cur-ind local-indent guide zloc-seq]\n  (dbg-s options\n         :guide (color-str (str \"fzprint-guide: entry: \"\n                                (zstring (first zloc-seq)))\n                           :purple)\n         \"caller:\" caller\n         \"ind:\" ind\n         \"cur-ind:\" cur-ind\n         \"local-indent:\" local-indent\n         \"guide:\" (color-str ((:dzprint options) {:style :guideguide} guide)\n                             :blue))\n  ; If it is one-line? and we have any :newlines in the guide, we are\n  ; finished now\n  (if (and one-line? (some #{:newline} guide))\n    ; We clearly aren't going to output a single line\n    (do (dbg-s options\n               :guide\n               \"fzprint-guide: returned nil - one-line? is true and guide\"\n               \"has :newline!\")\n        nil)\n    (let [rightcnt (fix-rightcnt rightcnt)\n          last-cur-index (dec (count zloc-seq))]\n      (when-not guide\n        (throw (#?(:clj Exception.\n                   :cljs js/Error.)\n                (str \"No guide but fn-style is :guide for this sequence: \"\n                     (mapv zstring zloc-seq)))))\n      (loop [cur-zloc zloc-seq\n             cur-index 0\n             guide-seq guide\n             element-index 0\n             index 0\n             param-map {:cur-ind cur-ind,\n                        :ind ind,\n                        :one-line-ind cur-ind,\n                        :indent local-indent,\n                        :last-cur-index last-cur-index,\n                        :rightcnt rightcnt,\n                        :initial-options options,\n                        :all-fit? true}\n             mark-map {}\n             [previous-newline? previous-guided-newline? unguided-newline-out?\n              previous-comment? :as previous-data]\n               nil\n             options options\n             out []]\n        ; We can't just check for cur-seq here, or any groups we might be\n        ; accumulating will be lost, since :group-end has to come beyond\n        ; the last :element that finished cur-seq\n        ;(if-not (or guide-seq cur-seq))\n        (if (or (not (or guide-seq cur-zloc (:guided-newline-count param-map)))\n                (nil? out))\n          (do (dbg-s options\n                     :guide\n                     (color-str \"fzprint-guide: out:\" :bright-red)\n                     ((:dzprint options) {} (into [] (condense-depth 1 out))))\n              out)\n          (if (> index 3000)\n            (throw (#?(:clj Exception.\n                       :cljs js/Error.)\n                    (str \"When processing a guide\"\n                           \" the iteration limit of 3000 was\"\n                         \" reached!\" (first guide-seq))))\n            (let [first-guide-seq (first guide-seq)\n                  _ (dbg-s\n                      options\n                      :guide\n                      \"\\n\\nfzprint-guide: =====> (first guide-seq):\"\n                        first-guide-seq\n                      \"\\nfzprint-guide: initial param-map:\"\n                        ((:dzprint options)\n                          {}\n                          (assoc (dissoc param-map :group-seq :initial-options)\n                            :group-seq-len (count (:group-seq param-map)))))\n                  ; If we are out of guide-seq, but we still have cur-seq\n                  ; which we must because of the if-not above, then keep\n                  ; doing elements in guide-seq for as long as we have\n                  ; cur-seq\n                  ;\n                  ; TODO: Change this to [:element], or it will fail when\n                  ; the guide-seq runs out.  But it can be nice to have it\n                  ; fail for debugging.\n                  _ (when (empty? guide-seq)\n                      (dbg-s options\n                             :guide\n                             \"fzprint-guide: guide ran out! guide:\"\n                               (color-str ((:dzprint options)\n                                            {:vector {:wrap? false}}\n                                            guide)\n                                          :bright-red)\n                             \"\\nexpression:\" ((:dzprint options)\n                                               {:vector {:wrap? false}}\n                                               (into []\n                                                     (map zstring zloc-seq)))))\n                  ; Sometimes we come through here when we have\n                  ; (:guided-newline-count param-map)\n                  ; and that's ok.\n                  guide-seq (or guide-seq [:element-*])\n                  ; First, look into what we have coming up in the sequence\n                  ; we are formatting\n                  comment? (= (ztag (first cur-zloc)) :comment)\n                  ; always used together\n                  comment-inline? comment?\n                  next-newline? (= (ztag (first cur-zloc)) :newline)\n                  uneval? (= (ztag (first cur-zloc)) :uneval)]\n              (cond\n                (and (:group-seq param-map) (:grouping? param-map))\n                  ; we are accumulating elements from cur-zloc\n                  ; and we only accept :element between :group-begin and\n                  ; :group-end\n                  ;\n                  ; First, split off any comments or newlines or uneval\n                  ; off of the front of zloc-seq\n                  (cond\n                    (= first-guide-seq :group-end)\n                      ; It is entirely possible tha the group is empty, but\n                      ; if it is, that will be handled by the -group call\n                      ; to guided-output, which will notice the existence\n                      ; of group-seq, and that it is empty, and gracefully\n                      ; do nothing.\n                      (do (dbg-s options\n                                 :guide\n                                 (color-str\n                                   \"fzprint-guide: === end accumulating a group\"\n                                   :bright-red))\n                          (recur cur-zloc\n                                 cur-index\n                                 (next guide-seq)\n                                 element-index\n                                 (inc index)\n                                 (assoc param-map :grouping? nil)\n                                 mark-map\n                                 previous-data\n                                 options\n                                 out))\n                    (= first-guide-seq :element)\n                      (let [[comments-or-newlines-cur-zloc remaining-cur-zloc]\n                              (split-with pair-element? cur-zloc)\n                            group-seq (:group-seq param-map)\n                            ; Add the comments and newlines from cur-zloc\n                            ; to group-seq\n                            group-seq (into []\n                                            (concat\n                                              group-seq\n                                              comments-or-newlines-cur-zloc))\n                            next-zloc (first remaining-cur-zloc)\n                            ; Do one more :element off of zloc-seq, if any\n                            group-seq (if next-zloc\n                                        (conj group-seq\n                                              (first remaining-cur-zloc))\n                                        group-seq)]\n                        (dbg-s options\n                               :guide\n                               (color-str\n                                 \"fzprint-guide: === save a group element\"\n                                 :bright-red))\n                        (recur\n                          (next remaining-cur-zloc)\n                          (+ cur-index (count comments-or-newlines-cur-zloc) 1)\n                          (next guide-seq)\n                          element-index\n                          (inc index)\n                          (assoc param-map :group-seq group-seq)\n                          mark-map\n                          previous-data\n                          options\n                          out))\n                    :else (throw (#?(:clj Exception.\n                                     :cljs js/Error.)\n                                  (str\n                                    \"When processing a guide and accumulating a\"\n                                    \" group only :element is allowed,\"\n                                    \" but encountered: '\"\n                                    first-guide-seq\n                                    \"' instead!\"))))\n                ;\n                ; process things that absorb information out of guide-seq\n                ; without changing next-seq\n                ;\n                (and (= first-guide-seq :newline) unguided-newline-out?)\n                  ; skip a guided newline if we had an unguided-newline-out\n                  ; on the last output\n                  (do (dbg-s options\n                             :guide\n                             (color-str \"fzprint-guide: === skip guided newline\"\n                                        :bright-red)\n                             \"since we had unguided-newline-out on last output\")\n                      (recur cur-zloc\n                             cur-index\n                             (next guide-seq)\n                             element-index\n                             (inc index)\n                             ; Forget spaces on every guided :newline\n                             (dissoc param-map :spaces :align-key)\n                             mark-map\n                             [previous-newline? previous-guided-newline?\n                              ;unguided-newline-out?\n                              nil previous-comment?]\n                             options\n                             out))\n                (= first-guide-seq :mark)\n                  ; put the cur-ind plus spaces into the mark map with\n                  ; key from the next guide-seq\n                  (do (dbg-s\n                        options\n                        :guide\n                        (color-str \"fzprint-guide: === :mark key:\" :bright-red)\n                        (first (next guide-seq))\n                        \"value:\"\n                        (+ (:cur-ind param-map) (or (:spaces param-map) 1)))\n                      (recur cur-zloc\n                             cur-index\n                             ; skip an extra to account for the mark key\n                             (nnext guide-seq)\n                             element-index\n                             (inc index)\n                             param-map\n                             (assoc mark-map\n                               (first (next guide-seq))\n                                 (+ (:cur-ind param-map)\n                                    (or (:spaces param-map) 1)))\n                             previous-data\n                             options\n                             out))\n                (= first-guide-seq :mark-at)\n                  ; put the cur-ind plus spaces into the mark map with\n                  ; key from the next guide-seq\n                  (do (dbg-s options\n                             :guide\n                             (color-str \"fzprint-guide: === :mark-at key:\"\n                                        :bright-red)\n                             (first (next guide-seq))\n                             \"value:\"\n                             (+ (:one-line-ind param-map)\n                                (first (nnext guide-seq))))\n                      (recur cur-zloc\n                             cur-index\n                             ; skip two to account for the mark key and the\n                             ; spaces count\n                             (nthnext guide-seq 3)\n                             element-index\n                             (inc index)\n                             param-map\n                             (assoc mark-map\n                               (first (next guide-seq))\n                                 (+ (:one-line-ind param-map)\n                                    (first (nnext guide-seq))))\n                             previous-data\n                             options\n                             out))\n                (= first-guide-seq :mark-at-indent)\n                  ; put the cur-ind plus spaces into the mark map with\n                  ; key from the next guide-seq\n                  (do (dbg-s options\n                             :guide\n                             (color-str\n                               \"fzprint-guide: === :mark-at-indent key:\"\n                               :bright-red)\n                             (first (next guide-seq))\n                             \"value:\"\n                             (+ (:ind param-map)\n                                (:indent param-map)\n                                (first (nnext guide-seq))))\n                      (recur cur-zloc\n                             cur-index\n                             ; skip two to account for the mark key and the\n                             ; spaces count\n                             (nthnext guide-seq 3)\n                             element-index\n                             (inc index)\n                             param-map\n                             (assoc mark-map\n                               (first (next guide-seq))\n                                 (+ (:indent param-map)\n                                    (:ind param-map)\n                                    (first (nnext guide-seq))))\n                             previous-data\n                             options\n                             out))\n                (= first-guide-seq :spaces)\n                  ; save the spaces for when we actually do output\n                  ; note that spaces after a newline are beyond the indent\n                  ; also note that spaces are additive, they do not replace\n                  ; any previous spaces\n                  (do (dbg-s options\n                             :guide\n                             (color-str \"fzprint-guide: === spaces\" :bright-red)\n                             (first (next guide-seq)))\n                      (recur cur-zloc\n                             cur-index\n                             ; skip an extra to account for the spaces\n                             ; count\n                             (nnext guide-seq)\n                             element-index\n                             (inc index)\n                             (assoc param-map\n                               :spaces (+ (first (next guide-seq))\n                                          (or (:spaces param-map) 0)))\n                             mark-map\n                             previous-data\n                             options\n                             out))\n                (= first-guide-seq :indent)\n                  ; save a new indent value in param-map\n                  (do (dbg-s options\n                             :guide\n                             \"fzprint-guide: === :indent\"\n                             (first (next guide-seq)))\n                      (recur cur-zloc\n                             cur-index\n                             ; skip an extra to account for the indent\n                             ; value\n                             (nnext guide-seq)\n                             element-index\n                             (inc index)\n                             (assoc param-map :indent (first (next guide-seq)))\n                             mark-map\n                             previous-data\n                             options\n                             out))\n                (= first-guide-seq :indent-here)\n                  ; save a new indent value in param-map\n                  (do\n                    (dbg-s options\n                           :guide \"fzprint-guide: === :indent-here\"\n                           \"align-key:\" (:align-key param-map)\n                           \"align-ind:\" (when (:align-key param-map)\n                                          (get mark-map (:align-key param-map)))\n                           \"cur-ind:\" (:cur-ind param-map)\n                           \"spaces:\" (:spaces param-map))\n                    (recur cur-zloc\n                           cur-index\n                           (next guide-seq)\n                           element-index\n                           (inc index)\n                           ;   (assoc param-map :indent (first (next\n                           ;   guide-seq)))\n                           (assoc param-map\n                             :indent\n                               ; This needs to be the alignment if we\n                               ; have some, or the cur-ind + spaces\n                               ; if we have some.  Not always adding it to\n                               ; spaces.  Note that the align-key value\n                               ; from mark-map - cur-ind is the number\n                               ; of spaces we need, not the indent.\n                               ; The indent would be the align value - the\n                               ; ind.\n                               (guide-here param-map mark-map)) ; assoc\n                                                                ; :indent\n                           mark-map\n                           previous-data\n                           options\n                           out))\n                (= first-guide-seq :indent-align)\n                  ; save a new indent value in param-map\n                  (let [align-key (first (next guide-seq))\n                        _ (dbg-s options\n                                 :guide (color-str\n                                          \"fzprint-guide: === :indent-align\"\n                                          :bright-red)\n                                 \"key:\" align-key\n                                 \"value:\" (get mark-map align-key)\n                                 \"cur-ind:\" (:cur-ind param-map))]\n                    (recur cur-zloc\n                           cur-index\n                           ; skip an extra to account for the align-key\n                           (nnext guide-seq)\n                           element-index\n                           (inc index)\n                           (assoc param-map\n                             :indent\n                               ; Note that the align-key value from\n                               ; mark-map - cur-ind is the number of spaces\n                               ; we need, not the indent.  The indent\n                               ; would be the align value - the ind.\n                               (or (when (get mark-map align-key)\n                                     (max 0\n                                          (- (get mark-map align-key)\n                                             (:ind param-map))))\n                                   ; If no align-key, don't change the\n                                   ; indent\n                                   (:indent param-map))) ; assoc :indent\n                           mark-map\n                           previous-data\n                           options\n                           out))\n                (= first-guide-seq :indent-reset)\n                  ; put the indent back where it was originally\n                  (do (dbg-s options\n                             :guide\n                             (color-str \"fzprint-guide: === :indent-reset\"\n                                        :bright-red))\n                      (recur cur-zloc\n                             cur-index\n                             (next guide-seq)\n                             element-index\n                             (inc index)\n                             (assoc param-map :indent local-indent)\n                             mark-map\n                             previous-data\n                             options\n                             out))\n                (= first-guide-seq :options)\n                  ; Start using an updated options map\n                  (let [[merged-option-map _] (internal-config-and-validate\n                                                options\n                                                (first (next guide-seq))\n                                                \"fzprint-guide: options:\"\n                                                ; Don't validate because\n                                                ; these were either\n                                                ; validated on return from\n                                                ; option-fn or when read in\n                                                ; the options map\n                                                nil)\n                        _ (dbg-s options\n                                 :guide\n                                 (color-str \"fzprint-guide: === :options\"\n                                            :bright-red)\n                                 (first (next guide-seq)))]\n                    (recur cur-zloc\n                           cur-index\n                           ; skip an extra to account for the options map\n                           (nnext guide-seq)\n                           element-index\n                           (inc index)\n                           param-map\n                           mark-map\n                           previous-data\n                           merged-option-map\n                           out))\n                (= first-guide-seq :options-reset)\n                  ; put the options map back to where it was when we\n                  ; started\n                  (do (dbg-s options\n                             :guide\n                             (color-str \"fzprint-guide: === :options-reset\"\n                                        :bright-red))\n                      (recur cur-zloc\n                             cur-index\n                             (next guide-seq)\n                             element-index\n                             (inc index)\n                             param-map\n                             mark-map\n                             previous-data\n                             (:initial-options param-map)\n                             out))\n                (= first-guide-seq :align)\n                  ; Set up for an alignment on the next :element\n                  ; Find the align-key, and save it in the param-map\n                  (let [align-key (first (next guide-seq))\n                        _ (dbg-s options\n                                 :guide (color-str \"fzprint-guide: === :align\"\n                                                   :bright-red)\n                                 \"key:\" align-key\n                                 \"value:\" (get mark-map align-key))]\n                    (recur cur-zloc\n                           cur-index\n                           ; skip an extra to account for the align-key\n                           (nnext guide-seq)\n                           element-index\n                           (inc index)\n                           ; remember the align-key, forget spaces when\n                           ; we get :align\n                           (assoc (dissoc param-map :spaces)\n                             :align-key align-key)\n                           mark-map\n                           previous-data\n                           options\n                           out))\n                (:guided-newline-count param-map)\n                  ; we are currently counting newlines, see if we have more\n                  ; or if we should output any excess that we have counted\n                  (if (or (= first-guide-seq :newline)\n                          (= first-guide-seq :newline-force))\n                    ; we have another :newline, just count it\n                    (do (dbg-s options\n                               :guide\n                               (color-str\n                                 \"fzprint-guide: === counting guided newlines:\"\n                                 :bright-red)\n                               (inc (:guided-newline-count param-map)))\n                        (recur cur-zloc\n                               cur-index\n                               (next guide-seq)\n                               element-index\n                               (inc index)\n                               (dissoc (assoc param-map\n                                         :guided-newline-count\n                                           ; Only count them if we have\n                                           ; real cur-zloc or this is a\n                                           ; :newline-force\n                                           (if (or cur-zloc\n                                                   (= first-guide-seq\n                                                      :newline-force))\n                                             (inc (:guided-newline-count\n                                                    param-map))\n                                             (:guided-newline-count param-map))\n                                         :cur-ind (+ (:indent param-map)\n                                                     (:ind param-map)))\n                                 :spaces\n                                 :align-key)\n                               mark-map\n                               previous-data\n                               options\n                               out))\n                    ; we are counting guided-newlines, and we have found a\n                    ; guide that is not a :newline, so we need to determine\n                    ; the number of excess guided-newlines we have, by\n                    ; counting the actual newlines and comparing them\n                    (let\n                      [_ (dbg-s\n                           options\n                           :guide\n                             (color-str\n                               \"fzprint-guide: === finished counting newlines\"\n                               :bright-red)\n                           \":guided-newline-count:\" (:guided-newline-count\n                                                      param-map))\n                       comment-and-newline-count (zcount-comments-and-newlines\n                                                   cur-zloc)\n                       guided-newline-count (:guided-newline-count param-map)\n                       excess-guided-newline-count\n                         (max 0\n                              (- guided-newline-count\n                                 comment-and-newline-count))\n                       param-map (dissoc param-map :guided-newline-count)\n                       ; Since we expect a newline or equivalent sometime\n                       ; soon, as in next, let's fix up the cur-ind to\n                       ; represent that.\n                       param-map (assoc param-map\n                                   :cur-ind (+ (:indent param-map)\n                                               (:ind param-map)))\n                       param-map (if (pos? excess-guided-newline-count)\n                                   (assoc param-map\n                                     :excess-guided-newline-count\n                                       excess-guided-newline-count)\n                                   param-map)\n                       ; If we have excess-guided-newline-count then do\n                       ; output right now, fake a guided newline to make\n                       ; this happen\n                       [new-param-map new-previous-data new-out]\n                         (if (pos? excess-guided-newline-count)\n                           (do\n                             (dbg-s\n                               options\n                               :guide\n                               (color-str\n                                 \"fzprint-guide === excess-guided-newline-count:\"\n                                 :bright-red)\n                               excess-guided-newline-count)\n                             (guided-output\n                               caller\n                               options\n                               nil ; zloc\n                               nil ; rightmost-zloc?\n                               :newline ;guide-seq\n                               cur-index\n                               guide-seq\n                               element-index\n                               index\n                               param-map\n                               mark-map\n                               previous-data\n                               out))\n                           [param-map previous-data out])]\n                      (recur cur-zloc\n                             cur-index\n                             ; don't move forward, as we were dealing with\n                             ; the end of a previous set of :newlines\n                             guide-seq\n                             element-index\n                             (inc index)\n                             new-param-map\n                             mark-map\n                             new-previous-data\n                             options\n                             new-out)))\n                (or (= first-guide-seq :newline)\n                    (= first-guide-seq :newline-force))\n                  ; start counting guided newlines\n                  (do (dbg-s\n                        options\n                        :guide\n                        (color-str\n                          \"fzprint-guide: === start counting guided newlines\"\n                          :bright-red))\n                      (recur cur-zloc\n                             cur-index\n                             (next guide-seq)\n                             element-index\n                             (inc index)\n                             ; Forget spaces on every guided :newline\n                             ; TODO: PROTOTYPE\n                             (if (or (not (empty? cur-zloc))\n                                     (= first-guide-seq :newline-force))\n                               (dissoc (assoc param-map\n                                         :guided-newline-count 1\n                                         :cur-ind (+ (:ind param-map)\n                                                     (:indent param-map)))\n                                 :spaces\n                                 :align-key)\n                               param-map)\n                             mark-map\n                             previous-data\n                             options\n                             out))\n                ; :pair-begin has to come after the newline handling\n                ; :group-begin has to come after the newline handling\n                (= first-guide-seq :group-begin)\n                  ; create an empty seq to accumulate zlocs\n                  (do (dbg-s options\n                             :guide\n                             (color-str\n                               \"fzprint-guide: === start accumulating a group\"\n                               :bright-red))\n                      (recur cur-zloc\n                             cur-index\n                             (next guide-seq)\n                             element-index\n                             (inc index)\n                             (assoc param-map\n                               :group-seq []\n                               :grouping? true)\n                             mark-map\n                             previous-data\n                             options\n                             out))\n                ; :element-newline-best-* also has to come after\n                ; newline handling\n                (or (= first-guide-seq :element-newline-best-*)\n                    (= first-guide-seq :element-newline-extend-*)\n                    (= first-guide-seq :element-wrap-flow-*)\n                    (= first-guide-seq :element-binding-*)\n                    (= first-guide-seq :element-pair-*))\n                  ; Consider everything else for a -* command. If we ree\n                  ; already accumulating a group, that's ok (though\n                  ; unnecessary).\n                  (let [_ (dbg-s options\n                                 :guide (color-str (str \"fzprint-guide: === \"\n                                                        first-guide-seq)\n                                                   :bright-red)\n                                 \"rightcnt:\" (:rightcnt options))\n                        ; Is this the last thing in guide-seq?\n                        _ (when-not (empty? (next guide-seq))\n                            (throw (#?(:clj Exception.\n                                       :cljs js/Error.)\n                                    (str\n                                      first-guide-seq\n                                      \"not the last command in the guide!\"))))\n                        ; Get a place to put the pairs\n                        param-map (if (:group-seq param-map)\n                                    param-map\n                                    (assoc param-map :group-seq []))\n                        ; Pick up all of the remaining cur-zloc\n                        param-map (assoc param-map\n                                    :group-seq (concat (:group-seq param-map)\n                                                       cur-zloc))\n                        _ (dbg-s options\n                                 :guide\n                                 \"fzprint-guide: === \" first-guide-seq\n                                 \" group-seq:\" (pr-str (map zstring\n                                                         (:group-seq\n                                                           param-map))))]\n                    (if (empty? (:group-seq param-map))\n                      ; Nothing to do, nothing left in the zloc-seq!\n                      (recur cur-zloc\n                             cur-index\n                             (next guide-seq)\n                             element-index\n                             (inc index)\n                             (dissoc param-map :group-seq :grouping?)\n                             mark-map\n                             previous-data\n                             options\n                             out)\n                      ; we have zlocs to process\n                      (let [[new-param-map new-previous-data new-out]\n                              (guided-output caller\n                                             options\n                                             nil ; zloc\n                                             true ; rightmost-zloc?\n                                             first-guide-seq\n                                             cur-index\n                                             guide-seq\n                                             element-index\n                                             index\n                                             param-map\n                                             mark-map\n                                             previous-data\n                                             out)]\n                        (recur nil ; we finished them off\n                               (+ cur-index (count cur-zloc)) ; same here\n                               (next guide-seq)\n                               element-index\n                               (inc index)\n                               (dissoc new-param-map :group-seq :grouping)\n                               mark-map\n                               new-previous-data\n                               options\n                               new-out))))\n                ;\n                ;  Start looking at cur-seq\n                ;\n                ; At this point, the only guide left is :element, soo we\n                ; must be sitting on it. All of the others are (and must\n                ; be) processed above.\n                ;\n                ; Anything left in cur-zloc?\n                (and (nil? cur-zloc) (empty? (:group-seq param-map)))\n                  ; No, nothing left in cur-zloc.  This isn't a failure,\n                  ; because we might be accumulating pairs or just have\n                  ; made too long a guide.  Just keep going and eat up\n                  ; the guide-seq.\n                  (do (dbg-s options\n                             :guide\n                             (color-str \"fzprint-guide: === ran out of cur-zloc\"\n                                        :bright-red))\n                      (recur (next cur-zloc)\n                             (inc cur-index)\n                             (next guide-seq)\n                             element-index\n                             (inc index)\n                             param-map\n                             mark-map\n                             previous-data\n                             options\n                             out))\n                (or comment? comment-inline? uneval? next-newline?)\n                  ; Do unguided output, moving cur-zloc without changing\n                  ; guide-seq\n                  (let\n                    [_ (dbg-s\n                         options\n                         :guide\n                           (color-str\n                             \"fzprint-guide: === process comments, newlines, uneval\"\n                             :bright-red)\n                         \"comment?\" comment?\n                         \"comment-inline?\" comment-inline?\n                         \"uneval?\" uneval?\n                         \"next-newline?\" next-newline?)\n                     [new-param-map new-previous-data new-out]\n                       (guided-output caller\n                                      options\n                                      (first cur-zloc)\n                                      (empty? (next cur-zloc))\n                                      nil ; unknown\n                                      cur-index\n                                      guide-seq\n                                      element-index\n                                      index\n                                      param-map\n                                      mark-map\n                                      previous-data\n                                      out)]\n                    (recur (next cur-zloc)\n                           (inc cur-index)\n                           ; We may have used information from guide-seq,\n                           ; but we didn't \"consume\" it yet.\n                           guide-seq\n                           element-index\n                           (inc index)\n                           new-param-map\n                           mark-map\n                           new-previous-data\n                           options\n                           new-out))\n                (or (= first-guide-seq :element)\n                    (= first-guide-seq :element-guide)\n                    (= first-guide-seq :element-best)\n                    (= first-guide-seq :element-extend)\n                    (= first-guide-seq :element-best-first)\n                    (= first-guide-seq :element-extend-first)\n                    (= first-guide-seq :element-best-*)\n                    (= first-guide-seq :element-extend-*)\n                    (= first-guide-seq :element-*)\n                    (= first-guide-seq :element-binding-vec))\n                  ; Do basic guided output, moving both cur-seq and\n                  ; guide-seq\n                  (let [_ (dbg-s options\n                                 :guide\n                                 (color-str (str \"fzprint-guide: === \"\n                                                 first-guide-seq)\n                                            :bright-red))\n                        _ (when (and (or (= first-guide-seq :element-*)\n                                         (= first-guide-seq :element-best-*)\n                                         (= first-guide-seq :element-extend-*))\n                                     (not (empty? (next guide-seq))))\n                            (throw (#?(:clj Exception.\n                                       :cljs js/Error.)\n                                    (str\n                                      first-guide-seq\n                                      \" is not the last command in guide!\"))))\n                        [new-param-map new-previous-data new-out]\n                          (guided-output caller\n                                         options\n                                         (first cur-zloc)\n                                         (empty? (next cur-zloc))\n                                         first-guide-seq\n                                         cur-index\n                                         guide-seq\n                                         element-index\n                                         index\n                                         param-map\n                                         mark-map\n                                         previous-data\n                                         out)]\n                    (recur (next cur-zloc)\n                           (inc cur-index)\n                           (cond (= first-guide-seq :element-guide)\n                                   ; Make sure to consume the guide too\n                                   (nnext guide-seq)\n                                 (or (= first-guide-seq :element-*)\n                                     (= first-guide-seq :element-best-*)\n                                     (= first-guide-seq :element-extend-*))\n                                   ; We just stay \"stuck\" on last command\n                                   ; in guide-seq for :element-* and\n                                   ; :element-best-*\n                                   guide-seq\n                                 :else (next guide-seq))\n                           (inc element-index)\n                           (inc index)\n                           ; forget spaces or alignment after :element\n                           (dissoc new-param-map :spaces :align-key)\n                           mark-map\n                           new-previous-data\n                           options\n                           new-out))\n                (or (= first-guide-seq :element-newline-best-group)\n                    (= first-guide-seq :element-newline-extend-group)\n                    (= first-guide-seq :element-wrap-flow-group)\n                    (= first-guide-seq :element-pair-group)\n                    (= first-guide-seq :element-binding-group))\n                  ; Operate on previously grouped elements\n                  (let [_ (dbg-s options\n                                 :guide\n                                 (color-str (str \"fzprint-guide: === \"\n                                                 first-guide-seq)\n                                            :bright-red))\n                        [new-param-map new-previous-data new-out]\n                          (guided-output caller\n                                         options\n                                         ; Use previously created group\n                                         nil\n                                         (empty? cur-zloc)\n                                         first-guide-seq\n                                         cur-index\n                                         guide-seq\n                                         element-index\n                                         index\n                                         param-map\n                                         mark-map\n                                         previous-data\n                                         out)]\n                    (recur cur-zloc\n                           cur-index\n                           (next guide-seq)\n                           element-index\n                           (inc index)\n                           ; forget spaces or alignment after :element\n                           ; also forget the group, a we have used it up\n                           (dissoc new-param-map :spaces :align-key :group-seq)\n                           mark-map\n                           new-previous-data\n                           options\n                           new-out))\n                ;\n                ; Something we didn't expect is going on here\n                ; TODO: Fix this for realistic error reporting\n                ;\n                :else (throw (#?(:clj Exception.\n                                 :cljs js/Error.)\n                              (str \"Unknown values: guide-seq: '\"\n                                   first-guide-seq\n                                   \"' \"\n                                   \"\\ncur-zloc:\"\n                                   (zstring (first cur-zloc)))))))))))))\n\n(defn remove-nl\n  \"Remove any [_ _ :newline] from the seq.\"\n  [coll]\n  (remove #(= (nth (first %) 2) :newline) coll))\n\n(defn comment-in-zloc-seq?\n  \"If there are any comments at the top level of the zloc-seq, return true,\n  else nil.\"\n  [zloc-seq]\n  (reduce #(when (= (ztag %2) :comment) (reduced true)) false zloc-seq))\n\n(defn fzprint-vec*\n  \"Print basic stuff like a vector or a set or an array.  Several options \n  for how to print them.\"\n  [caller l-str r-str\n   {:keys [rightcnt in-code?],\n    {:keys [wrap-coll? wrap? binding? option-fn-first option-fn sort?\n            sort-in-code? fn-format indent force-nl?]}\n      caller,\n    :as options} ind zloc]\n  (dbg options\n       \"fzprint-vec* ind:\" ind\n       \"indent:\" indent\n       \"caller:\" caller\n       \"ztag:\" (ztag zloc))\n  (if (= (:format options) :off)\n    (fzprint-noformat l-str r-str options zloc)\n    (if (and binding? (= (:depth options) 1))\n      (fzprint-binding-vec options ind zloc)\n      (let [[respect-nl? respect-bl? indent-only?]\n              (get-respect-indent options caller :vector)\n            #_#_options\n              (assoc options\n                :call-stack (conj\n                              (:call-stack options)\n                              {:tag (ztag zloc), :caller caller, :zloc zloc}))\n            options (if (and (= caller :prefix-tags) (= :quote (ztag zloc)))\n                      (assoc options :quote? true)\n                      options)\n            [options new-options]\n              (if option-fn-first\n                (call-option-fn-first caller options option-fn-first zloc)\n                [options nil])\n            _ (when option-fn-first\n                (dbg-pr options\n                        \"fzprint-vec* option-fn-first new options\"\n                        new-options))\n            ; Fix this to handle new returns.\n            [options zloc l-str r-str]\n              (if option-fn\n                (call-option-fn caller options option-fn zloc l-str r-str)\n                [options zloc l-str r-str])\n            ; Do this after call-option-fn in case anything changed.\n            l-str-len (count l-str)\n            l-str-vec [[l-str (zcolor-map options l-str) :left]]\n            r-str-vec\n              (rstr-vec options (+ ind (max 0 (dec l-str-len))) zloc r-str)\n            len (zcount zloc)\n            #_(when option-fn\n                (dbg-pr options\n                        \"fzprint-vec* option-fn new options\"\n                        new-options))\n            {{:keys [wrap-coll? wrap? binding? respect-bl? respect-nl? sort?\n                     fn-format sort-in-code? indent indent-only?]}\n               caller,\n             :as options}\n              options\n            ; If we are doing indent-only, we aren't doing guides\n            guide (when (not indent-only?)\n                    (or (:guide options) (guide-debug caller options)))\n            options (dissoc options :guide)\n            _ (when guide (dbg-pr options \"fzprint-vec* guide:\" guide))\n            zloc-seq (cond (or respect-nl? indent-only?) (zmap-w-nl identity\n                                                                    zloc)\n                           respect-bl? (zmap-w-bl identity zloc)\n                           :else (zmap identity zloc))]\n        (cond\n          guide (concat-no-nil l-str-vec\n                               (fzprint-guide\n                                 ; TODO: FIX THIS\n                                 :vector\n                                 options\n                                 ; this is where we are w/out any indent\n                                 ind\n                                 ; this is where we are with the l-str\n                                 (+ l-str-len ind)\n                                 indent\n                                 guide\n                                 zloc-seq)\n                               r-str-vec)\n          fn-format\n            ; If we have fn-format, move immediately to fzprint-list* and\n            ; let :vector-fn configuration drive what we do (e.g.,\n            ; indent-only, ; or whatever).  That is to say that\n            ; :indent-only? in :vector doesn't override option-fn-first\n            ; or option-fn\n            (fzprint-list* :vector-fn\n                           l-str\n                           r-str\n                           ; This could (dissoc options [:fn-format\n                           ; :vector])\n                           ;    (assoc-in\n                           (assoc options :fn-style fn-format)\n                           ;    [:vector :fn-format] nil)\n                           ind\n                           zloc)\n          :else\n            (let [; If sort? is true, then respect-nl? and respect-bl? make\n                  ; no sense.  And vice versa. If respect-nl? or\n                  ; respect-bl?, then no sort. If we have comments, then no\n                  ; sort, because we'll lose the comment context.\n                  indent (or indent (count l-str))\n                  new-ind (if indent-only? ind (+ indent ind))\n                  _ (dbg-pr options\n                            \"fzprint-vec*:\" (zstring zloc)\n                            \"new-ind:\" new-ind)\n                  zloc-seq (if (and sort?\n                                    (if in-code? sort-in-code? true)\n                                    (not (comment-in-zloc-seq? zloc-seq))\n                                    (not respect-nl?)\n                                    (not respect-bl?)\n                                    (not indent-only?))\n                             (order-out caller options identity zloc-seq)\n                             zloc-seq)\n                  coll-print (if (zero? len)\n                               [[[\"\" :none :whitespace 17]]]\n                               (fzprint-seq options new-ind zloc-seq))\n                  _ (dbg-pr options \"fzprint-vec*: coll-print:\" coll-print)\n                  ; If we got any nils from fzprint-seq\n                  ; and we were in :one-line mode then\n                  ; give up -- it didn't fit on one line.\n                  coll-print (if-not (contains-nil? coll-print) coll-print)\n                  one-line (when coll-print\n                             ; should not be necessary with contains-nil?\n                             ; above\n                             (apply concat-no-nil\n                               (interpose [[\" \" :none :whitespace 18]]\n                                 ; This causes single line things to\n                                 ; also respect-nl when it is enabled.\n                                 ; Could be separately controlled\n                                 ; instead of with :respect-nl? if desired.\n                                 (if (or respect-nl? :respect-bl? indent-only?)\n                                   coll-print\n                                   (remove-nl coll-print)))))\n                  _ (log-lines options \"fzprint-vec*:\" new-ind one-line)\n                  _ (dbg-pr options\n                            \"fzprint-vec*: new-ind:\" new-ind\n                            \"force-nl?\" force-nl?\n                            \"one-line:\" one-line)\n                  one-line-lines (style-lines options new-ind one-line)]\n              (if (zero? len)\n                (concat-no-nil l-str-vec r-str-vec)\n                (when one-line-lines\n                  (if (and (not force-nl?)\n                           (fzfit-one-line options one-line-lines))\n                    (concat-no-nil l-str-vec one-line r-str-vec)\n                    (if indent-only?\n                      ; Indent Only\n                      (concat-no-nil l-str-vec\n                                     (indent-zmap caller\n                                                  options\n                                                  ind\n                                                  ; actual-ind\n                                                  (+ ind l-str-len)\n                                                  coll-print\n                                                  indent)\n                                     r-str-vec)\n                      ; Regular Pprocessing\n                      (if (or (and (not wrap-coll?)\n                                   (any-zcoll? options new-ind zloc))\n                              (not wrap?)\n                              force-nl?)\n                        (concat-no-nil l-str-vec\n                                       (apply concat-no-nil\n                                         (precede-w-nl options\n                                                       new-ind\n                                                       coll-print\n                                                       :no-nl-first\n                                                       (:nl-count (caller\n                                                                    options))))\n                                       r-str-vec)\n                        ; Since there are either no collections in this\n                        ; vector or set or whatever, or if there are, it is\n                        ; ok to wrap them, print it wrapped on the same\n                        ; line as much as possible:\n                        ;           [a b c d e f\n                        ;            g h i j]\n                        (concat-no-nil l-str-vec\n                                       (do (dbg-pr\n                                             options\n                                             \"fzprint-vec*: wrap coll-print:\"\n                                             coll-print)\n                                           (wrap-zmap caller\n                                                      options\n                                                      new-ind\n                                                      new-ind\n                                                      coll-print))\n                                       r-str-vec))))))))))))\n\n(defn fzprint-vec\n  [options ind zloc]\n  (fzprint-vec* :vector \"[\" \"]\" (rightmost options) ind zloc))\n\n(defn fzprint-array\n  [options ind zloc]\n  (fzprint-vec* :array \"[\" \"]\" (rightmost options) ind zloc))\n\n(defn fzprint-set\n  \"Pretty print and focus style a :set element.\"\n  [options ind zloc]\n  (fzprint-vec* :set \"#{\" \"}\" (rightmost options) ind zloc))\n\n; not clear transient helps here\n(defn interpose-either\n  \"Do the same as interpose, but different seps depending on pred?.\n  If sep-nil is nil, then when pred? is false we don't interpose\n  anything!\"\n  [sep-true sep-nil pred? coll]\n  (loop [coll coll\n         out (transient [])\n         interpose? nil]\n    (if (empty? coll)\n      (persistent! out)\n      (recur (next coll)\n             (if interpose?\n               (conj-it! out sep-true (first coll))\n               (if (or (zero? (count out)) (nil? sep-nil))\n                 (conj! out (first coll))\n                 (conj-it! out sep-nil (first coll))))\n             (pred? (first coll))))))\n\n(defn precede-w-nl\n  \"Move through a sequence of style vecs and ensure that at least\n  one newline (actually an indent) appears before each element.  If\n  a newline in the style-vecs is where we wanted one, well and good.\n  Comments are now not recognized as different, increasing our\n  appreciation of diversity.  If not-first? is truthy, then don't\n  put a newline before the first element.  nl-count is the count\n  of newlines after the first.  If it is nil, assume 1.  It may be\n  a vector of newlines, and the next element of the vector is used after\n  any non-comment non-newline is processed.  The last element of the\n  vector is used once it runs out.\"\n  [options ind coll not-first? nl-count]\n  (dbg-pr options\n          \"precede-w-nl: (count coll)\" (count coll)\n          \"not-first?\" not-first?\n          \"nl-count:\" nl-count)\n  (let [nl-count (or nl-count 1)\n        ; If it isn't a vector, make it one\n        nl-count (if (vector? nl-count) nl-count [nl-count])\n        nl-count (into [1] nl-count)]\n    (loop [coll coll\n           ind-seq (if (coll? ind) ind (vector ind))\n           out (transient [])\n           added-nl? not-first?\n           ; We only do one nl at the beginning, regardless of nl-count\n           num-nl (if not-first? (first nl-count) (dec (first nl-count)))\n           nl-count-vec nl-count]\n      (if (empty? coll)\n        (let [result (persistent! out)\n              _ (dbg-pr options \"precede-w-nl: exit:\" result)\n              ; If the thing before the last was a comment, then remove the\n              ; last thing (which must be a newline, though we didn't put\n              ; it there)\n              previous-element-index (- (count result) 2)\n              previous-type (when (not (neg? previous-element-index))\n                              (nth (first (nth result previous-element-index))\n                                   2))]\n          result)\n        (let [[[s color what] :as element] (first coll)\n              ; This element may have many things in it, or sometimes\n              ; just one.\n              ;\n              ; I believe that if the first thing is a newline then they\n              ; must all be newlines.  We could check the last, or all of\n              ; them here, I suppose.  But these have to come from\n              ; fzprint-newline, to the best of my knowledge, and that is\n              ; how it works.\n              indent (first ind-seq)\n              newline? (= what :newline)\n              ; Don't pick up embedded comments\n              comment? (= what :comment)\n              comment-inline? (= what :comment-inline)\n              ; Let's make sure about the last\n              last-what (nth (last element) 2)]\n          (dbg-pr options\n                  \"precede-w-nl: element:\" element\n                  \"added-nl?\" added-nl?\n                  \"num-nl:\" num-nl\n                  \"comment?\" comment?)\n          (recur\n            (next coll)\n            ; Move along ind-seq until we reach the last one, then just\n            ; keep using the last one.\n            (if-let [next-ind (next ind-seq)]\n              next-ind\n              ind-seq)\n            (if newline?\n              ; It is a :newline, so just use it as it is. Except if the\n              ; next thing out is also a newline, we'll have trailing\n              ; spaces after this newline, which we need to prevent. The\n              ; next thing coming along could be a newline, or we could be\n              ; going to output a newline ourselves.  Either means that we\n              ; should not be doing spaces after a newline now.\n              (let [next-coll (next coll)]\n                (if (empty? next-coll)\n                  (conj! out element)\n                  (let [[[_ _ next-what]] (first next-coll)\n                        next-nl-count-vec nl-count-vec]\n                    (dbg-pr options\n                            \"precede-w-nl next-what:\" next-what\n                            \"(inc num-nl):\" (inc num-nl)\n                            \"(first next-nl-count-vec):\" (first\n                                                           next-nl-count-vec))\n                    (if (or (= next-what :newline)\n                            (< (inc num-nl) (first next-nl-count-vec)))\n                      ; don't put out a newline with spaces before another\n                      ; newline -- note that what == :newline here\n                      (conj! out [[\"\\n\" color :newline 3]])\n                      (conj! out element)))))\n              ; It is not a :newline, so we want to make sure we have\n              ; the proper number of newlines in front of it.\n              (if (>= num-nl (first nl-count-vec))\n                ; We already have enough newlines in front of it\n                (conj! out element)\n                ; We need some newlines and the element\n                (conj-it! out\n                          [[(str (apply str\n                                   (repeat (- (first nl-count-vec) num-nl)\n                                           \"\\n\"))\n                                 (blanks indent)) :none :indent 28]]\n                          element)))\n            ; Is there a newline as the last thing we just did?\n            ; Two ways for that to happen. (which are???)\n            newline?\n            ; Count the newlines we have output\n            (if newline?\n              (inc num-nl)\n              (if comment? (dec (first nl-count-vec)) 0))\n            ; Move along nl-count-vec until we reach the last one,\n            ; then just keep using the last one.  Don't move if it is a\n            ; newline or either type of comment.\n            (if (or newline? comment? comment-inline?)\n              nl-count-vec\n              (if (next nl-count-vec) (next nl-count-vec) nl-count-vec))))))))\n\n(defn count-newline-types\n  \"Analyze a style-vec which contains only newlines, and return the count \n  of newlines in the style vec.  We assume that each :newline style-vec \n  contains one newline (i.e., it was generated by fzprint-newlines).\"\n  [newline-style-vec]\n  (let [count-of-types (count (distinct (map #(nth % 2) newline-style-vec)))]\n    #_(prn \"count-newline-types: \" count-of-types\n           \" style-vec:\" newline-style-vec)\n    (when (or (not= count-of-types 1)\n              (not= (nth (first newline-style-vec) 2) :newline))\n      (throw\n        (#?(:clj Exception.\n            :cljs js/Error.)\n         (str \"Internal Error!  Please submit an issue with an example\"\n                \" of how to reproduce this error!\"\n              \" count-newline-types: more than one type or wrong type! count: \"\n                count-of-types\n              \" style-vec: \" newline-style-vec))))\n    (count newline-style-vec)))\n\n(defn count-right-blanks\n  \"Count the number of blanks at the right end of a string.\"\n  [s]\n  (loop [i (count s)]\n    (if (neg? i)\n      (count s)\n      (if (clojure.string/ends-with? (subs s 0 i) \" \")\n        (recur (dec i))\n        (- (count s) i)))))\n\n(defn trimr-blanks\n  \"Trim only blanks off the right end of a string.\"\n  [s]\n  (loop [i (count s)]\n    (if (neg? i)\n      \"\"\n      (if (clojure.string/ends-with? (subs s 0 i) \" \")\n        (recur (dec i))\n        (subs s 0 i)))))\n\n(defn repeat-style-vec-nl\n  \"Given a count n, and style vec that ends with a newline and an associated\n  indent of some number of spaces, return a sequence of n of those style vecs\n  but remove spaces from all but the last of them.\"\n  [n style-vec]\n  (let [no-space-n (max (dec n) 0)]\n    (if (zero? no-space-n)\n      style-vec\n      (let [[s color what] (last style-vec)\n            no-space-element [(trimr-blanks s) color what]\n            no-space-style-vec\n              (into [] (concat (butlast style-vec) no-space-element))]\n        (into [] (concat (repeat no-space-n no-space-style-vec) style-vec))))))\n\n(defn trimr-blanks-element\n  \"Given an element, trim the blanks out of the string.\"\n  [[s color what]]\n  [(trimr-blanks s) color what])\n\n(defn trimr-blanks-style-vec\n  \"Given a style-vec, trim the blanks out of each element.\"\n  [style-vec]\n  (mapv trimr-blanks-element style-vec))\n\n(defn repeat-element-nl\n  \"Given a count n, and single element from a style-vec which\n  contains a newline and an indent of some number of spaces, return\n  a sequence of n of those style vecs but remove spaces from all\n  but the last of them.  This is so that we don't have trailing spaces\n  on lines.\"\n  [n element]\n  #_(prn \"repeat-element-nl: n:\" n \"element:\" element)\n  (let [no-space-n (max (dec n) 0)]\n    (if (zero? no-space-n)\n      [element]\n      (let [[s color what] element\n            no-space-element [(trimr-blanks s) color what]\n            result\n              (into [] (concat (repeat no-space-n no-space-element) [element]))]\n        #_(prn \"repeat-element-nl: result:\" result)\n        result))))\n\n(defn next-non-comment-nl\n  \"Given a coll of [hangflow style-vec] pairs, return the \n  [hangflow style-vec] pair where the style-vec is not a \n  :comment, :comment-inline, :newline or :indent.\"\n  [coll]\n  (loop [coll coll]\n    (if (empty? coll)\n      nil\n      (let [[_ style-vec] (first coll)\n            [_ _ what] (first style-vec)]\n        (if (or (= what :comment)\n                (= what :comment-inline)\n                (= what :indent)\n                (= what :newline))\n          (recur (next coll))\n          (first coll))))))\n\n; transient helped a lot here\n\n(defn interpose-either-nl-hf\n  \"Do very specialized interpose, but different seps depending on pred-fn\n  return and nl-separator? and nl-separator-all?. This assumes that \n  sep-* does one line, and sep-*-nl does two lines. coll is\n  a series of [[:flow [['\\n  ' :none :newline 2]]] \n               [:flow [['ZprintType' :black :element] ...]]] fragments from\n  fzprint-map-two-up.\"\n  [sep-comma sep-comma-nl sep sep-nl\n   {:keys [nl-separator? nl-separator-all?], :as suboptions} ;nl-separator?\n   comma? coll]\n  #_(prn \"ienf: sep:\" sep \"comma?\" comma? \"coll:\" coll)\n  (loop [coll coll\n         out (transient [])\n         previous-needs-comma? nil\n         add-nl? nil\n         first? true\n         newline-count 0]\n    (if (empty? coll)\n      (apply concat-no-nil\n        (persistent!\n          ; Handle final newlines, if any\n          (if (zero? newline-count)\n            out\n            (conj-it! out (repeat-element-nl newline-count (first sep))))))\n      (let [[hangflow style-vec] (first coll)\n            [_ _ what] (first style-vec)]\n        #_(prn \"====>>>>>>>> interpose-either-nl-hf: style-vec:\" style-vec)\n        (cond\n          (= what :newline)\n            ; We have one or more newlines.  We are going to keep\n            ; track of what we've seen and will actually output things\n            ; later, when we know what we actually have.\n            ; For now, just increase the count and don't do anything\n            ; else.  If we have anything in addition to newlines, we have a\n            ; problem because we will lose them as the style-vec\n            ; goes away, which is why count-newline-types will throw\n            ; an exception if it encounters this.\n            (do #_(prn \"interpose-either-nl-hf: hangflow: \" hangflow)\n                (recur (next coll)\n                       out\n                       previous-needs-comma?\n                       add-nl?\n                       first?\n                       (+ newline-count (count-newline-types style-vec))))\n          :else\n            ; We have a normal style-vec that we will process.  This one\n            ; may have plenty of newlines, but there isn't one first. But\n            ; we might have seen plenty of newlines before this -- or not.\n            (let [[interpose-style-vec interpose-count]\n                    (if previous-needs-comma?\n                      (if add-nl? [sep-comma-nl 2] [sep-comma 1])\n                      (if add-nl? [sep-nl 2] [sep 1]))\n                  ; if first? we assume that we get one newline from caller\n                  interpose-count (if first? 1 interpose-count)\n                  addtl-nl-needed (max (- newline-count interpose-count) 0)]\n              ; Here is where we need to figure out if two newlines are\n              ; coming out in order, and ensure that the first ones don't\n              ; have any spaces after them.\n              #_(prn \"ienf: interpose-style-vec:\" interpose-style-vec)\n              (recur\n                (next coll)\n                (if first?\n                  (if (zero? addtl-nl-needed)\n                    (conj! out style-vec)\n                    (conj-it! out\n                              (repeat-element-nl addtl-nl-needed (first sep))\n                              style-vec))\n                  (if (zero? addtl-nl-needed)\n                    (conj-it! out interpose-style-vec style-vec)\n                    (conj-it! out\n                              (trimr-blanks-style-vec interpose-style-vec)\n                              (repeat-element-nl addtl-nl-needed (first sep))\n                              style-vec)))\n                (and comma?\n                     ; We got rid of newlines above\n                     (not= what :comment)\n                     (not= what :comment-inline)\n                     ; Is there a non comment or non newline/indent element\n                     ; left in coll, or is this the last one? This returns\n                     ; the [hangflow style-vec], but we are not using the\n                     ; data, just the existence of the thing here\n                     ; Fix for Issue #137.\n                     (next-non-comment-nl (next coll)))\n                ; should we put an extra new-line before the next element?\n                ; Two styles here:\n                ;  o  always put one if the previous pair contained a\n                ;  new-line\n                ;     which could be (but is not) the default\n                ;     To do this you would do:\n                ;       (and nl-separator? (not (single-line? style-vec)))\n                ;  o  put one only if the previous right hand part of\n                ;  the\n                ;     pair did a flow (which is the current default) To do\n                ;     this, you look for whether or not the return\n                ;     from fzprint-map-two-up said it was a flow\n                (or (and nl-separator? (= hangflow :flow)) nl-separator-all?)\n                nil ;first?\n                0 ;newline-count\n              )))))))\n\n(defn interpose-nl-hf\n  \"Put a single or double line between pairs returned from\n  fzprint-map-two-up.  The second argument is the map resulting\n  from (:map options) or (:pair options) or whatever.  It should\n  have :nl-separator? and :nl-separator-all? in it.\"\n  [suboptions ind coll]\n  (interpose-either-nl-hf nil\n                          nil\n                          [[(str \"\\n\" (blanks ind)) :none :indent 29]]\n                          [[(str \"\\n\") :none :indent 30]\n                           [(str \"\\n\" (blanks ind)) :none :indent 31]]\n                          suboptions\n                          nil ; comma?\n                          coll))\n\n(defn fzprint-map*\n  [caller l-str r-str\n   {:keys [one-line? ztype map-depth in-code?],\n    {:keys [comma? key-ignore key-ignore-silent nl-separator? force-nl? lift-ns?\n            lift-ns-in-code? indent],\n     :as map-options}\n      caller,\n    :as options} ind zloc ns]\n  (if (= (:format options) :off)\n    (fzprint-noformat\n      ; Fix Issue #275\n      (if ns (str \"#\" ns l-str) l-str)\n      r-str\n      options\n      zloc)\n    (let [[respect-nl? respect-bl? indent-only?]\n            (get-respect-indent options caller :map)]\n      (dbg-pr options \"fzprint-map* caller:\" caller)\n      (if indent-only?\n        (let [options (assoc options :map-depth (inc map-depth))\n              ; Put a namespaced map back together\n              l-str (if ns (str \"#\" ns l-str) l-str)\n              l-str-vec [[l-str (zcolor-map options l-str) :left]]\n              r-str-vec (rstr-vec options ind zloc r-str)]\n          (if (zero? (zcount zloc))\n            (concat-no-nil l-str-vec r-str-vec)\n            (concat-no-nil l-str-vec\n                           (fzprint-indent caller\n                                           l-str\n                                           r-str\n                                           options\n                                           ind\n                                           zloc\n                                           nil ;fn-style\n                                           nil) ;arg-1-indent, will prevent\n                                                ;hang\n                           r-str-vec)))\n        (let [options (assoc options :map-depth (inc map-depth))\n              zloc (if (and (= ztype :sexpr) (or key-ignore key-ignore-silent))\n                     (map-ignore caller options zloc)\n                     zloc)\n              ; TODO: fix this?\n              #_#_options\n                (assoc options\n                  :call-stack (conj\n                                (:call-stack options)\n                                {:tag (ztag zloc), :caller caller, :zloc zloc}))\n              [no-sort? pair-seq] (partition-all-2-nc\n                                    caller\n                                    (no-max-length options)\n                                    (cond respect-nl? (zseqnws-w-nl zloc)\n                                          respect-bl? (zseqnws-w-bl zloc)\n                                          :else (zseqnws zloc)))\n              _ (dbg-s options\n                       :justify\n                       \"fzprint-map* pair-seq:\"\n                       (mapv #(vector (count %) (mapv (comp pr-str zstring) %))\n                         pair-seq))\n              #_(dbg-pr \"fzprint-map* pair-seq:\"\n                        (map (comp zstring first) pair-seq))\n              ; don't sort if we are doing respect-nl?\n              no-sort? (or no-sort? respect-nl? respect-bl?)\n              [ns lift-pair-seq]\n                (zlift-ns (assoc map-options :in-code? in-code?) pair-seq ns)\n              _ (dbg-pr options\n                        \"fzprint-map* zlift-ns ns:\" ns\n                        \"no-sort?\" no-sort?)\n              l-str (if ns (str \"#\" ns l-str) l-str)\n              pair-seq (or lift-pair-seq pair-seq)\n              pair-seq\n                (if no-sort? pair-seq (order-out caller options first pair-seq))\n              ; This is where you might put max-length\n              max-length (get-max-length options)\n              pair-count (count pair-seq)\n              pair-seq (if (> pair-count max-length)\n                         (concat (take max-length pair-seq)\n                                 (list (list (zdotdotdot))))\n                         pair-seq)\n              indent (count l-str)\n              l-str-vec [[l-str (zcolor-map options l-str) :left]]\n              r-str-vec (rstr-vec options ind zloc r-str)]\n          (if (empty? pair-seq)\n            (concat-no-nil l-str-vec r-str-vec)\n            (let [_ (dbg-pr options\n                            \"fzprint-map*:\" (zstring zloc)\n                            \"ind:\" ind\n                            \"comma?\" comma?\n                            \"rightcnt:\" (:rightcnt options))\n                  ; A possible one line representation of this map, but\n                  ; this is optimistic and needs to be validated.\n                  pair-print-one-line\n                    (fzprint-map-two-up\n                      caller\n                      ; that will turn off justification\n                      ; If one-line? isn't set, then set it.\n                      (if one-line? options (assoc options :one-line? true))\n                      (+ indent ind)\n                      comma?\n                      pair-seq)\n                  pair-print-one-line (remove-hangflow pair-print-one-line)\n                  _ (when pair-print-one-line\n                      (dbg-s options\n                             :ppol\n                             \"pair-print-one-line:\"\n                             ((:dzprint options) {} pair-print-one-line)))\n                  ; Assume it fits on one line, and if it doesn't then\n                  ; we will find out about it pretty soon now\n                  one-line (when pair-print-one-line\n                             (apply concat-no-nil\n                               (interpose-either\n                                 [[\",\" (zcolor-map options :comma) :whitespace\n                                   19] [\" \" :none :whitespace 23]]\n                                 [[\" \" :none :whitespace 20]]\n                                 (constantly comma?)\n                                 pair-print-one-line)))\n                  one-line-lines (style-lines options (+ indent ind) one-line)\n                  one-line (when (fzfit-one-line options one-line-lines)\n                             one-line)]\n              (if one-line\n                (concat-no-nil l-str-vec one-line r-str-vec)\n                ; It didn't fit on one line.\n                (when (not one-line?)\n                  ; We weren't required to fit it on one line\n                  (let [pair-print (fzprint-map-two-up caller\n                                                       options\n                                                       (+ indent ind)\n                                                       comma?\n                                                       pair-seq)]\n                    (concat-no-nil\n                      l-str-vec\n                      ; Use (+ indent ind) to make sure the indent is\n                      ; correct.  Issue #274.\n                      (interpose-either-nl-hf\n                        ; comma? true\n                        [[\",\" (zcolor-map options :comma) :whitespace 21]\n                         [(str \"\\n\" (blanks (+ indent ind))) :none :indent 32]]\n                        [[\",\" (zcolor-map options :comma) :whitespace 22]\n                         ; Fix issue #59 -- don't put blanks to indent\n                         ; before the next \\n\n                         [\"\\n\" :none :indent 33]\n                         [(str \"\\n\" (blanks (+ indent ind))) :none :indent 34]]\n                        ; comma? nil\n                        [[(str \"\\n\" (blanks (+ indent ind))) :none :indent 35]]\n                        [[\"\\n\" :none :indent 36]\n                         [(str \"\\n\" (blanks (+ indent ind))) :none :indent 37]]\n                        (:map options) ;nl-separator?\n                        comma?\n                        pair-print)\n                      r-str-vec)))))))))))\n\n(defn fzprint-map\n  \"Format a real map.\"\n  [options ind zloc]\n  (let [[ns lifted-map]\n          (when (znamespacedmap? zloc)\n            ; Only true when operating on zippers\n            (let [zloc-seq (zmap identity zloc)]\n              (dbg-pr options \"fzprint-map: zloc-seq\" (map zstring zloc-seq))\n              [(zstring (first zloc-seq)) (second zloc-seq)]))]\n    (dbg-pr options\n            \"fzprint-map: ns:\" ns\n            \"indent:\" (:indent (:map options))\n            \"map-options:\" (dissoc (:map options) :key-value-options))\n    (if ns\n      (fzprint-map* :map \"{\" \"}\" (rightmost options) ind lifted-map ns)\n      (fzprint-map* :map \"{\" \"}\" (rightmost options) ind zloc nil))))\n\n(defn object-str?\n  \"Return true if the string starts with #object[\"\n  [s]\n  (re-find #\"^#object\\[\" s))\n\n(defn fzprint-object\n  \"Print something that looks like #object[...] in a way\n  that will acknowledge the structure inside of the [...]\"\n  ([options ind zloc zloc-value]\n   (fzprint-vec* :object\n                 \"#object[\"\n                 \"]\"\n                 options\n                 ind\n                 (zobj-to-vec zloc zloc-value)))\n  ([options ind zloc]\n   (fzprint-vec* :object \"#object[\" \"]\" options ind (zobj-to-vec zloc))))\n\n(defn hash-identity-str\n  \"Find the hash-code identity for an object.\"\n  [obj]\n  #?(:bb (str (hash obj))\n     :clj (Integer/toHexString (System/identityHashCode obj))\n     :cljs (str (hash obj))))\n\n; (with-out-str\n;    (printf \"%08x\" (System/identityHashCode obj))))\n\n(defn fzprint-atom\n  [{{:keys [object?]} :atom, :as options} ind zloc]\n  (if (and object? (object-str? (zstring zloc)))\n    (fzprint-object options ind zloc (zderef zloc))\n    (let [l-str \"#<\"\n          r-str \">\"\n          indent (count l-str)\n          l-str-vec [[l-str (zcolor-map options l-str) :left]]\n          r-str-vec (rstr-vec options ind zloc r-str)\n          arg-1 (str \"Atom@\" (hash-identity-str zloc))\n          arg-1-indent (+ ind indent 1 (count arg-1))]\n      (dbg-pr options\n              \"fzprint-atom: arg-1:\" arg-1\n              \"zstring arg-1:\" (zstring zloc))\n      (concat-no-nil l-str-vec\n                     [[arg-1 (zcolor-map options :none) :element]]\n                     (fzprint-hang-one :unknown\n                                       (rightmost options)\n                                       arg-1-indent\n                                       (+ indent ind)\n                                       (zderef zloc))\n                     r-str-vec))))\n\n(defn fzprint-future-promise-delay-agent\n  \"Print out a future or a promise or a delay.  These can only be \n  sexpressions, since they don't exist in a textual representation \n  of code (or data for that matter).  That means that we can use \n  regular sexpression operations on zloc.\"\n  [options ind zloc]\n  (let [zloc-type (cond (zfuture? zloc) :future\n                        (zpromise? zloc) :promise\n                        (zdelay? zloc) :delay\n                        (zagent? zloc) :agent\n                        :else (throw (#?(:clj Exception.\n                                         :cljs js/Error.)\n                                      \"Not a future, promise, or delay:\"\n                                      (zstring zloc))))]\n    (if (and (:object? (options zloc-type)) (object-str? (zstring zloc)))\n      (if (or (= zloc-type :agent) (realized? zloc))\n        (fzprint-object options ind zloc (zderef zloc))\n        (fzprint-object options ind zloc))\n      (let [l-str \"#<\"\n            r-str \">\"\n            indent (count l-str)\n            l-str-vec [[l-str (zcolor-map options l-str) :left]]\n            r-str-vec (rstr-vec options ind zloc r-str)\n            type-str (case zloc-type\n                       :future \"Future@\"\n                       :promise \"Promise@\"\n                       :delay \"Delay@\"\n                       :agent \"Agent@\")\n            arg-1 (str type-str (hash-identity-str zloc))\n            #?@(:bb [_ nil]\n                :clj [arg-1\n                      (if (and (= zloc-type :agent) (agent-error zloc))\n                        (str arg-1 \" FAILED\")\n                        arg-1)])\n              arg-1-indent\n            (+ ind indent 1 (count arg-1)) zloc-realized?\n            (if (= zloc-type :agent) true (realized? zloc)) value\n            (if zloc-realized?\n              (zderef zloc)\n              (case zloc-type\n                :future \"pending\"\n                :promise \"not-delivered\"\n                :delay \"pending\"))\n              options\n            (if zloc-realized? options (assoc options :string-str? true))]\n        (dbg-pr options\n                \"fzprint-fpda: arg-1:\" arg-1\n                \"zstring arg-1:\" (zstring zloc))\n        (concat-no-nil l-str-vec\n                       [[arg-1 (zcolor-map options :none) :element]]\n                       (fzprint-hang-one :unknown\n                                         (rightmost options)\n                                         arg-1-indent\n                                         (+ indent ind)\n                                         value)\n                       r-str-vec)))))\n\n(defn fzprint-fn-obj\n  \"Print a function object, what you get when you put a function in\n  a collection, for instance.  This doesn't do macros, you will notice.\n  It also can't be invoked when zloc is a zipper.\"\n  [{{:keys [object?]} :fn-obj, :as options} ind zloc]\n  (if (and object? (object-str? (zstring zloc)))\n    (fzprint-object options ind zloc)\n    (let [l-str \"#<\"\n          r-str \">\"\n          indent (count l-str)\n          l-str-vec [[l-str (zcolor-map options :fn) :left]]\n          r-str-vec (rstr-vec options ind zloc r-str :fn)\n          arg-1-left \"Fn@\"\n          arg-1-right (hash-identity-str zloc)\n          arg-1-indent (+ ind indent 1 (count arg-1-left) (count arg-1-right))\n          class-str (pr-str #?(:clj (class zloc)\n                               :cljs (type zloc)))\n          #?@(:clj [[class-name & more]\n                    (s/split (s/replace-first class-str #\"\\$\" \"/\") #\"\\$\") color\n                    (if (re-find #\"clojure\" class-name)\n                      (zcolor-map options :fn)\n                      :none) arg-2 (str class-name (when more \"[fn]\"))]\n              :cljs [name-js (str (.-name zloc)) color\n                     (if (or (re-find #\"^clojure\" name-js)\n                             (re-find #\"^cljs\" name-js))\n                       (zcolor-map options :fn)\n                       :none) name-split (clojure.string/split name-js #\"\\$\")\n                     arg-2\n                     (str (apply str (interpose \".\" (butlast name-split)))\n                          \"/\"\n                          (last name-split))])]\n      (dbg-pr options\n              \"fzprint-fn-obj: arg-1:\"\n              arg-1-left\n              arg-1-right\n              \"zstring arg-1:\"\n              (zstring zloc))\n      (concat-no-nil l-str-vec\n                     [[arg-1-left (zcolor-map options :fn) :element]]\n                     [[arg-1-right (zcolor-map options :none) :element]]\n                     (fzprint-hang-one :unknown\n                                       (rightmost (assoc options\n                                                    :string-str? true\n                                                    :string-color color))\n                                       arg-1-indent\n                                       (+ indent ind)\n                                       arg-2)\n                     r-str-vec))))\n\n(defn fzprint-ns\n  [options ind zloc]\n  (let [l-str \"#<\"\n        r-str \">\"\n        indent (count l-str)\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options ind zloc r-str)\n        arg-1 \"Namespace\"\n        arg-1-indent (+ ind indent 1 (count arg-1))]\n    (dbg-pr options \"fzprint-ns: arg-1:\" arg-1 \"zstring arg-1:\" (zstring zloc))\n    (concat-no-nil l-str-vec\n                   [[arg-1 (zcolor-map options :none) :element]]\n                   (fzprint-hang-one :unknown\n                                     (rightmost options)\n                                     arg-1-indent\n                                     (+ indent ind)\n                                     (ns-name zloc))\n                   r-str-vec)))\n\n(defn dec-depth\n  \"Given an options map, decrement the :depth value and return the result.\"\n  [options]\n  (when options (assoc options :depth (dec (or (:depth options) 1)))))\n\n(defn fzprint-record\n  [{{:keys [record-type? to-string?]} :record, :as options} ind zloc]\n  (if to-string?\n    (fzprint* options ind (. zloc toString))\n    (if-not record-type?\n      ; if not printing as record-type, turn it into map\n      (fzprint* options ind (into {} zloc))\n      (let [l-str \"#\"\n            r-str \"\"\n            indent (count l-str)\n            l-str-vec [[l-str (zcolor-map options l-str) :left]]\n            r-str-vec (rstr-vec options ind zloc r-str)\n            arg-1 #?(:clj (pr-str (class zloc))\n                     :cljs\n                       (clojure.string/replace (pr-str (type zloc)) \"/\" \".\"))\n            arg-1 (let [tokens (clojure.string/split arg-1 #\"\\.\")]\n                    (apply str (into [] (interpose \".\" tokens))))\n            arg-1-indent (+ ind indent 1 (count arg-1))]\n        (dbg-pr options\n                \"fzprint-record: arg-1:\" arg-1\n                \"zstring zloc:\" (zstring zloc))\n        (concat-no-nil l-str-vec\n                       [[arg-1 (zcolor-map options :none) :element]]\n                       (fzprint-hang-one :record\n                                         (dec-depth options)\n                                         ;(rightmost options)\n                                         arg-1-indent\n                                         (+ indent ind)\n                                         ; this only works because\n                                         ; we never actually get here\n                                         ; with a zipper, just an sexpr\n                                         (into {} zloc))\n                       r-str-vec)))))\n\n(defn drop-thru-first-non-whitespace\n  \"Drop elements of the sequence up to and including the first element\n  that is not zwhitespace?\"\n  [coll]\n  (let [no-whitespace (drop-while zwhitespace? coll)] (drop 1 no-whitespace)))\n\n(defn take-thru-first-non-whitespace\n  \"Take all elements of the sequence up to and including the first element\n  that is not zwhitespace?\"\n  [coll]\n  (loop [coll coll\n         out []]\n    (if coll\n      (let [element (first coll)]\n        (if (not (zwhitespace? element))\n          (conj out element)\n          (recur (next coll) (conj out element))))\n      out)))\n\n(defn fzprint-meta\n  \"Print the two items in a meta node.  Different because it doesn't print\n  a single collection, so it doesn't do any indent or rightmost.  It also\n  uses a different approach to calling fzprint-flow-seq with the\n  results zmap, so that it prints all of the seq, not just the rightmost.\"\n  [options ind zloc]\n  (let [l-str \"^\"\n        r-str \"\"\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options ind zloc r-str)\n        ; i224\n        zloc-seq (fzprint-get-zloc-seq :list options zloc)\n        zloc-seq (if (:split? (:meta options))\n                   ; If we are splitting the meta, we already pulled out\n                   ; everything but the first thing into the outer zloc-seq\n                   ; in fzprint-split-meta-in-seq prior to calling this\n                   ; routine.\n                   (take-thru-first-non-whitespace zloc-seq)\n                   zloc-seq)]\n    (dbg-pr options\n            \"fzprint-meta: zloc:\" (zstring zloc)\n            \"zloc-seq\" (map zstring zloc-seq))\n    (concat-no-nil l-str-vec\n                   (if (:indent-only? (:list options))\n                     ; Since l-str isn't a \"pair\" and shouldn't be\n                     ; considered in the indent, we don't tell\n                     ; fzprint-indent about it.\n                     (fzprint-indent :vector\n                                     l-str\n                                     \"\"\n                                     options\n                                     ind\n                                     zloc\n                                     nil\n                                     nil\n                                     :first-indent-only?)\n                     (fzprint-flow-seq\n                       :meta\n                       ; No rightmost, because this isn't\n                       ; a collection.  This is essentially\n                       ; two separate things.\n                       options\n                       ; no indent for second line, as the\n                       ; leading ^ is not a normal\n                       ; collection beginning.\n                       ; Generate a separate indent for the\n                       ; first thing, and use ind for the\n                       ; remaining.\n                       (apply vector\n                         (+ (count l-str) ind)\n                         (repeat (dec (count zloc-seq)) ind))\n                       zloc-seq))\n                   r-str-vec)))\n\n(defn fzprint-reader-macro\n  \"Print a reader-macro, often a reader-conditional. Adapted for differences\n  in parsing #?@ between rewrite-clj and rewrite-cljs.  Also adapted for\n  the rewrite-clj not parsing namespaced maps in the version presently\n  used.\"\n  [options ind zloc]\n  (let [zstr (zstring (zfirst zloc))\n        ; rewrite-cljs parses #?@ differently from rewrite-clj.  In\n        ; rewrite-cljs zfirst is ?@, not ?, so deal with that.\n        ; Not clear which is correct, I could see it go either way.\n        alt-at? (and (= (count zstr) 2) (= (subs zstr 1 2) \"@\"))\n        reader-cond? (= (subs zstr 0 1) \"?\")\n        ; are we dealing with a namespaced map? 5/30/19 I don't know if we\n        ; ever encounter this anymore... Was unable to get namespaced? to\n        ; be true despite running all 616 tests and some repl testing as\n        ; well.\n        namespaced? (= (subs zstr 0 1) \":\")\n        at? (or (= (ztag (zsecond zloc)) :deref) alt-at?)\n        ; If :reader-cond doesn't have these things, then let :map govern\n        [respect-nl? respect-bl? indent-only?]\n          (get-respect-indent options :reader-cond :map)\n        l-str (cond (and reader-cond? at?) \"#?@\"\n                    (and reader-cond? (zcoll? (zsecond zloc))) \"#?\"\n                    reader-cond?\n                      (throw (#?(:clj Exception.\n                                 :cljs js/Error.)\n                              (str \"Unknown reader macro: '\" (zstring zloc)\n                                   \"' zfirst zloc: \" (zstring (zfirst zloc)))))\n                    namespaced? (str \"#\" zstr)\n                    :else \"#\")\n        r-str \"\"\n        ; Error to debug zpst\n        _ (when (:dbg-bug? options)\n            #?(:clj (+ \"a\" \"b\")\n               :cljs nil))\n        indent (count l-str)\n        ; we may want to color this based on something other than\n        ; its actual character string\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options ind zloc r-str)\n        floc\n          (if (and at? (not alt-at?)) (zfirst (zsecond zloc)) (zsecond zloc))]\n    (dbg-pr options\n            \"fzprint-reader-macro: zloc:\" (zstring zloc)\n            \"floc:\" (zstring floc)\n            \"l-str:\" l-str\n            \"reader-cond?\" reader-cond?)\n    ; This isn't really all that correct, but does yield the right output.\n    ; Question about whether or not it does the right stuff for focus.\n    ; Maybe there is some way to call fzprint-indent with just the\n    ; #? and \"\", and let it deal with the underlying list. I don't know\n    ; if that would be possible, though maybe if we carefully positioned\n    ; the floc for that case.  But could we hack in the [\"\" :none :element]\n    ; in that case? At present documented that focus and :indent-only\n    ; don't work together..\n    (if indent-only?\n      (let [l-str-io (if reader-cond? (str l-str \"(\") l-str)\n            r-str-io (if reader-cond? \")\" \"\")\n            l-str-vec-io [[l-str-io (zcolor-map options l-str-io) :left]]\n            r-str-vec-io (rstr-vec options ind zloc r-str-io)]\n        (concat-no-nil l-str-vec-io\n                       (if reader-cond?\n                         (fzprint-indent :map\n                                         l-str-io\n                                         r-str-io\n                                         (rightmost options)\n                                         ind\n                                         floc\n                                         nil ;fn-style\n                                         nil) ;arg-1-indent, will prevent\n                                              ;hang\n                         (fzprint-indent\n                           :map\n                           l-str-io\n                           r-str-io\n                           (rightmost options)\n                           ind\n                           (if namespaced? (znextnws-w-nl zloc) zloc)\n                           nil ; fn-style\n                           nil) ;arg-1-indent\n                       )\n                       r-str-vec-io))\n      (concat-no-nil\n        l-str-vec\n        ; Because there is a token here in the zipper,\n        ; we need something to make the focus\n        ; positioning come out right.\n        [[\"\" :none :element]]\n        (if reader-cond?\n          ; yes rightmost, this is a collection\n          (fzprint-map* :reader-cond\n                        \"(\"\n                        \")\"\n                        (rightmost options)\n                        ; Here is where we might adjust the\n                        ; indent, but if we do it here\n                        ; (since this looks like a list),\n                        ; we also have to deal with it when\n                        ; the map code is doing the next\n                        ; thing (like :cljs after  :clj).\n                        ; If you just (dec indent) here\n                        ; you break 14 tests.\n                        (+ indent ind)\n                        floc\n                        nil)\n          ; not reader-cond?\n          (fzprint-pairs options\n                         (+ indent ind)\n                         (let [zloc-seq\n                                 (cond respect-nl? (zmap-w-nl identity zloc)\n                                       respect-bl? (zmap-w-bl identity zloc)\n                                       :else (zmap identity zloc))]\n                           (if namespaced? (next zloc-seq) zloc-seq))\n                         :tagged-literal))\n        r-str-vec))))\n\n(defn fzprint-newline\n  \"Given an element which contains newlines, split it up into individual\n  newline elements.\"\n  [options ind zloc]\n  (let [zstr (zstring zloc)\n        [newline-count _] (newline-vec zstr)]\n    (dbg-pr options\n            \"fzprint-newline: zloc:\" (zstring zloc)\n            \"newline-count:\" newline-count\n            \"ind:\" ind)\n    (into []\n          (repeat newline-count [(str \"\\n\" (blanks ind)) :none :newline 2]))))\n\n(def prefix-tags\n  {:quote \"'\",\n   :syntax-quote \"`\",\n   :unquote \"~\",\n   :unquote-splicing \"~@\",\n   :deref \"@\",\n   :var \"#'\",\n   :uneval \"#_\"})\n\n(defn prefix-options\n  \"Change options as necessary based on prefix tag.\"\n  [options prefix-tag]\n  (cond (= prefix-tag :uneval) (assoc options\n                                 :color-map (:color-map (:uneval options)))\n        (= prefix-tag :syntax-quote)\n          (-> options\n              (assoc-in [:color-map :paren]\n                        (:syntax-quote-paren (:color-map options)))\n              (assoc-in [:color-map :hash-paren]\n                        (:syntax-quote-paren (:color-map options))))\n        :else options))\n\n(defn make-caller\n  \"Sometime we need to give a caller to a routine, and there isn't\n  a specific caller in the configuration.  So, we will use the configuration\n  from some other caller and make up a new one just for this situation.\n  The key-seq is the series of keys to both look up and create.  The\n  caller is the new caller, and the existing-caller is the one from which\n  we we will extract the information. This returns a new options map with\n  the new-caller in it.\"\n  [options new-caller existing-caller key-seq]\n  (update-in options\n             (concat [new-caller] key-seq)\n             #(do % (get-in options (concat [existing-caller] key-seq)))))\n\n;; Fix fzprint* to look at cursor to see if there is one, and\n;; fzprint to set cursor with binding.  If this works, might pass\n;; it around.  Maybe pass ctx to everyone and they can look at it\n;; or something.  But for testing, let's just do this.\n\n(defn integrate-next-inner\n  \"If the value of :next-inner is a map, then config-and-validate it. If\n  the value of :next-inner is a vector of maps, then config-and-validate\n  each of the maps in turn.\"\n  [options]\n  (dbg-pr options \"integrate-next-inner:\")\n  (let [next-inner (:next-inner options :unset)]\n    (cond (map? next-inner) (first (zprint.config/config-and-validate\n                                     \"next-inner:\"\n                                     nil\n                                     (dissoc options :next-inner)\n                                     next-inner\n                                     nil ; validate?\n                                   ))\n          (vector? next-inner) (reduce #(first\n                                          (zprint.config/config-and-validate\n                                            \"next-inner-vector\"\n                                            nil\n                                            %1\n                                            %2\n                                            nil))\n                                 (dissoc options :next-inner)\n                                 next-inner)\n          (= next-inner :unset) options\n          :else options)))\n\n;;\n;; Print exactly as we got it, but colorize (or :hiccup or :html) it.\n;;\n;; Except, remove any spaces prior to newlines.\n;;\n\n(defn remove-spaces-pre-nl\n  \"Take a style vec and remove any :whitespace element prior to a :newline\n  or an :indent element.\"\n  [svec]\n  (loop [nvec svec\n         out []]\n    (if (empty? nvec)\n      out\n      (let [[_ _ this-what :as this-vec] (first nvec)\n            [_ _ next-what :as next-vec] (second nvec)]\n        (recur (next nvec)\n               (if (and (= this-what :whitespace)\n                        (or (= next-what :newline) (= next-what :indent)))\n                 out\n                 (conj out this-vec)))))))\n\n(defn fzprint-noformat\n  \"Take a collection, and map fzprint* across it to get it colorized, but\n  take every single whitespace and everything.  It should come out just like\n  it went in, but with colors (or whatever).\"\n  [l-str r-str options zloc]\n  (let [l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options 0 zloc r-str)\n        len (zcount zloc)\n        _ (dbg-s-pr options\n                    :noformat\n                    \"fzprint-noformat zloc\" (zstring zloc)\n                    \"len:\" len)\n        fzprint*-seq (zmap-all-nl-comment (partial fzprint* options 0) zloc)\n        _ (dbg-s-pr options\n                    :noformat\n                    \"fzprint-noformat fzprint*-seq:\"\n                    fzprint*-seq)\n        concat-vec\n          (if (zero? len)\n            (concat-no-nil l-str-vec r-str-vec)\n            (concat-no-nil l-str-vec (apply concat fzprint*-seq) r-str-vec))\n        _ (dbg-s-pr options :noformat \"fzprint-noformat concat-vec:\" concat-vec)\n        remove-spaces-vec (remove-spaces-pre-nl concat-vec)\n        _ (dbg-s-pr options\n                    :noformat\n                    \"fzprint-noformat remove-spaces-vec:\"\n                    remove-spaces-vec)]\n    remove-spaces-vec))\n;;\n;; # The center of the zprint universe\n;;\n;; Looked into alternative ways to dispatch this, but at the end of\n;; the day, this looked like the best.\n;;\n\n; memoize\n#_(declare fzprint*-actual)\n; memoize\n#_(defn fzprint*\n    [& args]\n    (let [memoize-atom (:memoize-atom (first args))]\n      (if memoize-atom\n        (if-let [e (find @memoize-atom args)]\n          (val e)\n          (let [ret (apply fzprint*-actual args)]\n            (swap! memoize-atom assoc args ret)\n            ret))\n        (apply fzprint*-actual args))))\n\n(defn fzprint*\n  \"The pretty print part of fzprint.\"\n  [{:keys [width rightcnt hex? shift-seq dbg? dbg-print? dbg-s in-hang?\n           one-line? string-str? string-color depth max-depth trim-comments?\n           in-code? max-hang-depth max-hang-span max-hang-count next-inner],\n    :as options} indent zloc]\n  (let [avail (- width indent)\n        ; note that depth affects how comments are printed, toward the end\n        options (assoc options :depth (inc depth))\n        ; Can't use dbg-s directly here, as it is also a local value!\n        _ (dbg-s-pr options\n                    :next-inner\n                    \"fzprint* \" (pr-str (zstring zloc))\n                    \" next-inner:\" (:next-inner options))\n        options (if next-inner\n                  ; There are two kinds of next-inner maps.  The normal\n                  ; kind is something to add to the current options map,\n                  ; and to do that, we will use config-and-validate for\n                  ; reasons explained below.  The other kind is a map that\n                  ; was saved and we are just restoring it, and that will\n                  ; entirely replace the current options map.\n                  (integrate-next-inner options)\n                  options)\n        options (if (or dbg? dbg-print? dbg-s)\n                  (assoc options\n                    :dbg-indent (str (get options :dbg-indent \"\")\n                                     (cond one-line? \"o\"\n                                           in-hang? \"h\"\n                                           :else \".\")))\n                  options)\n        _ (dbg-s-pr options\n                    :next-inner\n                    \"fzprint* **** rightcnt:\"\n                    rightcnt\n                    \"depth:\"\n                    depth\n                    \"indent:\"\n                    indent\n                    \"in-hang?:\"\n                    in-hang?\n                    \":next-inner:\"\n                    (:next-inner options)\n                    (pr-str (zstring zloc)))\n        dbg-data @fzprint-dbg\n        dbg-focus? (and dbg? (= dbg-data (second (zfind-path zloc))))\n        options (if dbg-focus? (assoc options :dbg :on) options)\n        _ (if dbg-focus? (println \"fzprint dbg-data:\" dbg-data))]\n    #_(def zlocx zloc)\n    ; We don't check depth if it is not a collection.  We might have\n    ; just not incremented depth if it wasn't a collection, but this\n    ; may be equivalent.\n    (cond\n      (and (zcoll? zloc)\n           (or (>= depth max-depth) (zero? (get-max-length options))))\n        (if (= zloc (zdotdotdot))\n          [[\"...\" (zcolor-map options :none) :element]]\n          [[(:max-depth-string options) (zcolor-map options :keyword)\n            :element]])\n      ; Try to fix up runaway exponential time increases with very deep\n      ; strucures.  Note this is typically only affects maps, but it would\n      ; affect lists that were not code.\n      (and in-hang?\n           (not one-line?)\n           (not in-code?)\n           ;(> (/ indent width) 0.3)\n           (or (> (- depth in-hang?) max-hang-span)\n               (and (not one-line?)\n                    (> (zcount zloc) max-hang-count)\n                    (> depth max-hang-depth))))\n        nil\n      (zrecord? zloc) (fzprint-record options indent zloc)\n      (zlist? zloc) (fzprint-list options indent zloc)\n      (zvector? zloc) (fzprint-vec options indent zloc)\n      (or (zmap? zloc) (znamespacedmap? zloc)) (fzprint-map options indent zloc)\n      (zset? zloc) (fzprint-set options indent zloc)\n      (zanonfn? zloc) (fzprint-anon-fn options indent zloc)\n      (zfn-obj? zloc) (fzprint-fn-obj options indent zloc)\n      (zarray? zloc) (if (:object? (:array options))\n                       (fzprint-object options indent zloc)\n                       (fzprint-array #?(:clj (if (:hex? (:array options))\n                                                (assoc options\n                                                  :hex? (:hex? (:array options))\n                                                  :shift-seq\n                                                    (zarray-to-shift-seq zloc))\n                                                options)\n                                         :cljs options)\n                                      indent\n                                      (zexpandarray zloc)))\n      (zatom? zloc) (fzprint-atom options indent zloc)\n      (zmeta? zloc) (fzprint-meta options indent zloc)\n      (prefix-tags (ztag zloc))\n        (fzprint-vec* :prefix-tags\n                      (prefix-tags (ztag zloc))\n                      \"\"\n                      ; Pick up the :indent-only?, :respect-nl?, and\n                      ; respect-bl? config from :list. Note that the\n                      ; routine get-respect-indent exists, and its use in\n                      ; fzprint-vec* and fzprint-map* also\n                      ; solves a similar problem\n                      (-> (prefix-options options (ztag zloc))\n                          (make-caller :prefix-tags :list [:indent-only?])\n                          (make-caller :prefix-tags :list [:respect-nl?])\n                          (make-caller :prefix-tags :list [:respect-bl?]))\n                      indent\n                      zloc)\n      (zns? zloc) (fzprint-ns options indent zloc)\n      (or (zpromise? zloc) (zfuture? zloc) (zdelay? zloc) (zagent? zloc))\n        (fzprint-future-promise-delay-agent options indent zloc)\n      (zreader-macro? zloc) (fzprint-reader-macro options indent zloc)\n      ; This is needed to not be there for newlines in parse-string-all,\n      ; but is needed for respect-nl? support.\n      ;(and (= (ztag zloc) :newline) (> depth 0)) [[\"\\n\" :none :newline]]\n      (and (= (ztag zloc) :newline) (> depth 0))\n        (fzprint-newline options indent zloc)\n      :else\n        (let [zstr (zstring zloc)\n              overflow-in-hang? (and in-hang?\n                                     (> (+ (count zstr) indent (or rightcnt 0))\n                                        width))]\n          (cond\n            (and (zcomment? zloc) (not (some #{\\;} zstr)))\n              ; We should remvoe them when we get zutil fixed.\n              (fzprint-newline options indent zloc)\n            (zcomment? zloc)\n              (let [zcomment\n                      ; trim-comments? is true for parse-string-all\n                      (if (and (zero? depth) (not trim-comments?))\n                        zstr\n                        ; Remove trailing newlines and spaces\n                        (clojure.string/trimr zstr))\n                    ; Only check for inline comments if we are doing them\n                    ; otherwise we get left with :comment-inline element\n                    ; types that don't go away\n                    inline-comment-vec (when (:inline? (:comment options))\n                                         (inlinecomment? zloc))]\n                (dbg options\n                     \"fzprint* trim-comments?:\" trim-comments?\n                     \"inline-comment-vec:\" inline-comment-vec)\n                (if (and (:count? (:comment options)) overflow-in-hang?)\n                  (do (dbg options \"fzprint*: overflow comment ========\") nil)\n                  (if inline-comment-vec\n                    [[zcomment (zcolor-map options :comment) :comment-inline\n                      (first inline-comment-vec) (second inline-comment-vec)]]\n                    [[zcomment (zcolor-map options :comment) :comment]])))\n            (= (ztag zloc) :comma) [[zstr (zcolor-map options :comma) :comma]]\n            #?@(:cljs [(and (= (ztag zloc) :whitespace)\n                            (clojure.string/includes? zstr \",\"))])\n              #?@(:cljs [[[\",\" (zcolor-map options :comma) :comma]]])\n            ; Really just testing for whitespace, comments filtered above\n            (zwhitespaceorcomment? zloc) [[zstr :none :whitespace 24]]\n            ; At this point, having filtered out whitespace and\n            ; comments above, now we expect zsexpr will work for all of\n            ; the remaining things.\n            ;\n            ; If we are going to overflow, and we are doing a hang, let's\n            ; stop now!\n            overflow-in-hang? (do (dbg options \"fzprint*: overflow <<<<<<<<<<\")\n                                  nil)\n            (zkeyword? zloc) [[zstr (zcolor-map options :keyword) :element]]\n            :else (let [zloc-sexpr (get-sexpr options zloc)]\n                    (cond (string? zloc-sexpr) [[(if string-str?\n                                                   (str zloc-sexpr)\n                                                   ; zstr\n                                                   (zstring zloc))\n                                                 (if string-color\n                                                   string-color\n                                                   (zcolor-map options :string))\n                                                 :element]]\n                          (showfn? options zloc-sexpr)\n                            [[zstr (zcolor-map options :fn) :element]]\n                          (show-user-fn? options zloc-sexpr)\n                            [[zstr (zcolor-map options :user-fn) :element]]\n                          (number? zloc-sexpr)\n                            [[(if hex? (znumstr zloc hex? shift-seq) zstr)\n                              (zcolor-map options :number) :element]]\n                          (symbol? zloc-sexpr)\n                            [[zstr (zcolor-map options :symbol) :element]]\n                          (nil? zloc-sexpr) [[zstr (zcolor-map options :nil)\n                                              :element]]\n                          (true? zloc-sexpr) [[zstr (zcolor-map options :true)\n                                               :element]]\n                          (false? zloc-sexpr) [[zstr (zcolor-map options :false)\n                                                :element]]\n                          (char? zloc-sexpr) [[zstr (zcolor-map options :char)\n                                               :element]]\n                          (or (instance? #?(:clj java.util.regex.Pattern\n                                            :cljs (type #\"regex\"))\n                                         zloc-sexpr)\n                              (re-find #\"^#\\\".*\\\"$\" zstr))\n                            [[zstr (zcolor-map options :regex) :element]]\n                          :else [[zstr (zcolor-map options :none)\n                                  :element]])))))))\n\n;;\n;; # External interface to all fzprint functions\n;;\n\n(defn fzprint\n  \"The pretty print part of fzprint.\"\n  [options indent zloc]\n  #_(def opt options)\n  (dbg options \"fzprint: indent:\" indent \"(:indent options)\" (:indent options))\n  ; if we are doing specs, find the docstring and modify it with\n  ; the spec output.\n  #_(println \"fn-name:\" (:fn-name options))\n  #_(println \"spec:\" (:value (:spec options)))\n  (let [zloc (if-not (and (= (:ztype options) :zipper) (:value (:spec options)))\n               zloc\n               (add-spec-to-docstring zloc (:value (:spec options))))\n        style-vec (fzprint* (assoc options\n                              :depth 0\n                              :map-depth 0\n                              ; Add a map of zfns to the options for use\n                              ; by guides that need them.\n                              :zfn-map (zfn-map))\n                            indent\n                            zloc)]\n    #_(def fsv style-vec)\n    style-vec))\n\n;    (if (= (:ztype options) :sexpr)\n;      style-vec\n;      (if (:wrap? (:comment options))\n;        (fzprint-wrap-comments options style-vec)\n;        style-vec))))\n\n;;\n;; # Basic functions for testing results -- used only for tests\n;;\n\n(defn line-count \"Count lines in a string.\" [s] (inc (count (re-seq #\"\\n\" s))))\n\n(defn line-widths\n  \"Return a vector the lengths of lines.\"\n  [s]\n  (map count (clojure.string/split s #\"\\n\")))\n\n(defn max-width\n  \"Split a string into lines, and figure the max width.\"\n  [s]\n  (reduce max (line-widths s)))\n\n;;\n;; # Tab Expansion\n;;\n\n(defn expand-tabs\n  \"Takes a string, and expands tabs inside of the string based\n  on a tab-size argument.\"\n  ([tab-size s]\n   ; If we don't have tabs, don't do anything.\n   (if (clojure.string/includes? s \"\\t\")\n     (apply str\n       (loop [char-seq (seq s)\n              cur-len (long 0)\n              out (transient [])]\n         (if (empty? char-seq)\n           (persistent! out)\n           (let [this-char (first char-seq)\n                 tab-expansion (if (= this-char \\tab)\n                                 (- tab-size (mod cur-len tab-size))\n                                 nil)]\n             (recur (rest char-seq)\n                    (if (= this-char \\newline)\n                      0\n                      (+ cur-len (long (or tab-expansion 1))))\n                    (if tab-expansion\n                      (apply conj-it! out (repeat tab-expansion \\space))\n                      (conj! out this-char)))))))\n     s))\n  ([s] (expand-tabs 8 s)))\n\n;;\n;; # Line Endings\n;;\n\n(defn determine-ending-split-lines\n  \"Given a string, find the line ending that is predominent in the beginning\n  of the string, and split the string into separate lines.  Returns \n  [line-ending-string vector-of-lines]\"\n  [s]\n  (if (clojure.string/includes? s \"\\r\")\n    ; Figure out the line endings\n    (let [lines (clojure.string/split s #\"\\r\\n|\\r|\\n\" -1)\n          first-lines (clojure.string/split (subs s 0 (min (count s) 2000))\n                                            #\"\\r\")\n          #_(prn \"first-lines:\" first-lines)\n          nl-count\n            (reduce #(if (clojure.string/starts-with? %2 \"\\n\") (inc %1) %1)\n              0\n              first-lines)\n          #_(prn \"nl-count:\" nl-count)\n          line-ending (if (>= nl-count (/ (count first-lines) 2)) \"\\r\\n\" \"\\r\")]\n      [line-ending lines])\n    ; If no \\r, then we assume \\n line endings\n    [\"\\n\" (clojure.string/split s #\"\\n\" -1)]))\n\n;;\n;; # Needed for expectations testing\n;;\n;; Seems defrecord doesn't work in test environment, which is pretty odd.\n;;\n\n(defrecord r [left right])\n(defn make-record [left right] (new r left right))\n\n;;\n;; End of testing functions\n;;\n"],"x_google_ignoreList":[0]}