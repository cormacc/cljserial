{"version":3,"sources":["zprint/range.cljc"],"mappings":"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","names":["zprint.range/in-row?","n","row","zprint.range/row-before?","row-a","row-b","zprint.range/between-rows?","linenumber","cljs.core/map?","zprint.range/scan-for-row","row-vec","row-vec-index","max-tries","current-index","previous-index","tries","cljs.core.get","row-or-direction","next-index","next-row","var_args","G__79972","zprint.range/find-row","js/Error","dbg?","scan-size","cljs.core.println","size","cljs.core/count","maybe-index","cljs.core._EQ_","G__79979","G__79980","fexpr__79978","cljs.core/-","cljs.core/+","zprint.util/local-abs","zprint.range.find_row","zprint.range/next-non-blank-line","line-vec","index","max-idx","idx","line","cljs.core.nth","cljs.core/empty?","clojure.string/trim","zprint.range/previous-non-blank-line","zprint.range/expand-range-to-top-level","filestring","lines","start","end","line-count","rewrite-clj.parser/parse-string-all","rewrite-clj.node/children","cljs.core.remove","rewrite-clj.node/whitespace?","p1__79985#","rewrite-clj.node/tag","cljs.core.mapv","cljs.core/meta","_","cljs.core.prn","start-row-idx","x__5087__auto__","y__5088__auto__","actual-start","end-row-idx","actual-end","end-row","zprint.range/split-out-range","before","range","after","before-lines","cljs.core.into","cljs.core.take","range-lines","cljs.core.drop","after-lines","cljs.core.conj","zprint.range/reassemble-range","before-str","clojure.string.join","after-str","zprint.range/comment-api?","s","clojure.string/starts-with?","s-onesemi","clojure.string/replace","zprint.range/get-comment-api","cljs.core/filterv","zprint.range/wrap-comment-api","comment-api-lines","cljs.core.concat","zprint.range/drop-lines","drop-count","clojure.string.split","remaining-lines","out-str"],"sourcesContent":["(ns ^:no-doc zprint.range\n  (:require [clojure.string :as s]\n            [zprint.util :refer [local-abs]]\n            [zprint.config]\n            [rewrite-clj.parser :as p]\n            [rewrite-clj.node :as n]\n            [rewrite-clj.zip :as z]))\n\n;;\n;; # Handle range specification\n;;\n\n(defn in-row?\n  \"If a line number n is in a particular row, return the row map.\n  If it is not in the row, return +1 or -1 to indicate which direction\n  to look.\"\n  [n row]\n  #_(println \"n:\" n \"row:\" row)\n  (when row\n    (if (<= (:row row) n (:end-row row)) row (if (< n (:row row)) -1 +1))))\n\n(defn row-before?\n  \"Given two rows, is the first before the second?\"\n  [row-a row-b]\n  #_(println \"row-before? row-a:\" row-a \"row-b:\" row-b)\n  (< (:end-row row-a) (:row row-b)))\n\n(defn between-rows?\n  \"Given two rows, if the linenumber is between the rows, return true, else\n  nil.\"\n  [linenumber row-a row-b]\n  #_(println \"between-rows? linenumber:\" linenumber\n             \"row-a:\" row-a\n             \"row-b:\" row-b)\n  (when (and (map? row-a) (map? row-b))\n    (if (row-before? row-a row-b)\n      (< (:end-row row-a) linenumber (:row row-b))\n      (< (:end-row row-b) linenumber (:row row-a)))))\n\n(defn scan-for-row\n  \"Given a row-vec, and a current index into the row-vec, if the\n  linenumber is within that row, return the index to that row.   If\n  the linenumber is not in that row, then scan either way for\n  max-tries looking for a match for this linenumber.  Return the\n  row index if a row is found containing this linenumber. If it is\n  between two rows, return the row after.  If we fall off the either\n  end of the row-vec, then return :before-beginning or :beyone-end.  \n  If we don't find anything after trying for max-tries, :before or\n  :after, depending on which way we should try next.\"\n  [row-vec row-vec-index linenumber max-tries]\n  (loop [current-index row-vec-index\n         previous-index nil\n         tries 0]\n    (let [row (get row-vec current-index)\n          row-or-direction (in-row? linenumber row)]\n      #_(println \"scan-for-row current-index:\" current-index\n                 \"previous-index:\" previous-index\n                 \"tries:\" tries\n                 \"row:\" row\n                 \"row-or-direction\" row-or-direction)\n      (cond (map? row-or-direction) current-index ; in this row\n            (nil? row-or-direction)\n              (if (pos? current-index) :beyond-end :before-beginning)\n            :else (if (>= tries max-tries)\n                    ; tell caller where to look next\n                    (if (pos? row-or-direction) :after :before)\n                    (let [next-index (+ current-index row-or-direction)\n                          next-row (get row-vec next-index)\n                          row-or-direction (in-row? linenumber next-row)]\n                      (cond (map? row-or-direction) next-index ; we are in the\n                                                               ; row,\n                                                               ; return its\n                                                               ; index\n                            (nil? row-or-direction) (if (pos? next-index)\n                                                      :beyond-end\n                                                      :before-beginning)\n                            :else (if (between-rows? linenumber row next-row)\n                                    ; We are between rows, return later one\n                                    (if (row-before? row next-row)\n                                      next-index\n                                      current-index)\n                                    ; Keep looking\n                                    (recur (+ current-index row-or-direction)\n                                           current-index\n                                           (inc tries))))))))))\n\n(defn find-row\n  \"Given a vector of rows, find the row that contains a line number,\n  linenumber, and return the number of that row in the vector.\n  row-vec looks like this: \n  [{:col 1, :end-col 21, :end-row 7, :row 2}\n   {:col 1, :end-col 6, :end-row 18, :row 9}\n   {:col 1, :end-col 6, :end-row 29, :row 20}]\n  If none exists, return the next row. Note that line numbers are\n  1 based, not zero based for this routine and the information in\n  row-vec, but the index into row-vec that this routine returns is\n  zero based.  Uses a binary search. If the line number is before\n  the first information in the row-vec, returns :before-beginning,\n  and if it is after the last information in the row-vec, returns\n  :beyond-end. Note that find-row returns an index into row-vec,\n  and it must be the row-vec that has had nils removed from it (or\n  this routine would do that for you).\"\n  ([row-vec linenumber dbg? scan-size]\n   (when dbg?\n     (println \"find-row: linenumber:\" linenumber \"scan-size:\" scan-size))\n   (let [size (count row-vec)]\n     ; We are 1 based, because edamame row numbers are 1 based.\n     (loop [row-vec-index (int (/ size 2))\n            previous-index 0\n            tries 0]\n       #_(println \"\\n\\n================== row-vec-index:\" row-vec-index)\n       (if (> tries 10)\n         :fail\n         (let [maybe-index\n                 (scan-for-row row-vec row-vec-index linenumber scan-size)]\n           ; If it is a number, that is the row-vec-index to return\n           ; If it is :before, we ran off the beginning, :after the end\n           ; nil means that we didn't find it, but can keep looking\n           #_(println \"maybe-index:\" maybe-index)\n           (cond (number? maybe-index) maybe-index ; we found something to\n                                                   ; return\n                 ; is it in this row?\n                 (or (= maybe-index :before-beginning)\n                     (= maybe-index :beyond-end))\n                   maybe-index\n                 :else ; Has to be :before or :after\n                   (do #_(println \"find-row: maybe-index:\" maybe-index\n                                  \"row-vec-index:\" row-vec-index\n                                  \"previous-index:\" previous-index\n                                  \"abs:\" (local-abs (- row-vec-index\n                                                       previous-index)))\n                       (recur ((if (= maybe-index :before) - +)\n                                row-vec-index\n                                (int (/ (local-abs (- row-vec-index\n                                                      previous-index))\n                                        2)))\n                              row-vec-index\n                              (inc tries)))))))))\n  ([row-vec n dbg?] (find-row row-vec n dbg? 4)))\n\n(defn next-non-blank-line\n  \"Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first non-blank line including or after that\n  starting line index.\"\n  [line-vec index]\n  (let [max-idx (dec (count line-vec))]\n    (loop [idx index]\n      (let [line (nth line-vec idx)]\n        ; Return current idx if it is non-blank or the last line\n        (if (or (not (empty? (clojure.string/trim line))) (>= idx max-idx))\n          idx\n          (recur (inc idx)))))))\n\n(defn previous-non-blank-line\n  \"Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first previous non-blank line including or before\n  that starting line index.  Returns -1 if no non-blank line found.\"\n  [line-vec index]\n  (loop [idx index]\n    (let [line (nth line-vec idx)]\n      ; Return current idx if it is non-blank\n      (cond (not (empty? (clojure.string/trim line))) idx\n            ; if the first line is not non-blank, then we didn't find one\n            (zero? idx) -1\n            ; keep looking for a non-blank line\n            :else (recur (dec idx))))))\n\n(defn expand-range-to-top-level\n  \"Given a string which contains lines and a vector of those lines,\n  and a range of lines inside of them, expand the range such that\n  it covers everything from the first non-blank line beyond the\n  previous top level expression before the start to the end of the\n  top level expression containing the end of the range.  Returns\n  [actual-start actual-end].  Note that start, end, actual-start\n  and actual-end are all zero based line numbers.\"\n  ; But also note that parse-string-all (and thus row-vec) and\n  ; find-row all operate with one-based line numbers!!!\n  [filestring lines start end dbg?]\n  (when dbg? (println \"expand-range-to-top-level: start:\" start \"end:\" end))\n  (let [line-count (count lines)\n        start (if (number? start) start 0)\n        end (if (number? end) end line-count)\n        ; If end is before start, make them the same\n        end (if (< end start) start end)\n        ; Get a vector of maps describing all top level expressions using\n        ; one based line numbers.  For example: [{:col 1, :end-col 21,\n        ; :end-row 7, :row 2}\n        ;  {:col 1, :end-col 6, :end-row 20, :row 11}\n        ;  {:col 1, :end-col 70, :end-row 26, :row 22}\n        ;  {:col 1, :end-col 48, :end-row 29, :row 27}]\n        row-vec (->> (p/parse-string-all filestring)\n                     n/children\n                     (remove n/whitespace?)\n                     (remove #(= (n/tag %) :comment))\n                     (mapv meta))\n        _ (when dbg? (prn row-vec))\n        ; Figure out which expression start falls within, after making\n        ; it a one-based line number.  -idx are indexes into row-vec,\n        ; *not* linenumbers\n        start-row-idx (if row-vec (find-row row-vec (inc start) dbg?) :fail)\n        _ (when dbg?\n            (println \"expand-range-to-top-level start-row-idx:\"\n                     start-row-idx\n                     (if (number? start-row-idx)\n                       (str \"row:\" (nth row-vec start-row-idx)\n                            \" previous row:\" (nth row-vec\n                                                  (max 0 (dec start-row-idx))))\n                       \"\")))\n        actual-start\n          ; -1 is a signal to not start at the beginning unless the end is\n          ; also -1, in which case it is a signal to put everything in the\n          ; before\n          (cond (= start-row-idx :fail) -1\n                (and (= start-row-idx :before-beginning) (not (neg? start))) 0\n                (= start-row-idx :before-beginning) -1\n                (= start-row-idx 0) 0\n                (= start-row-idx :beyond-end) -1\n                ; normal case -- the line beyond the previous form where\n                ; (dec start-row-idx) is presumably the previous form\n                :else (:end-row (get row-vec (dec start-row-idx))))\n        ; Now, move actual-start to the first non-blank line after or equal\n        ; to actual-start.  But not if it is zero or negative, since we\n        ; don't want to mess with the range if it encompasses the beginning\n        ; of the file.\n        ;\n        ; The point of this is to make sure that we catch any comments that\n        ; might contain zprint directives in them, so ultimately we are\n        ; setting actual-start to the first non-blank line after the end of\n        ; the previous top-level form.\n        actual-start (if (or (< actual-start 1) (>= actual-start line-count))\n                       actual-start\n                       (next-non-blank-line lines actual-start))\n        end-row-idx (if row-vec (find-row row-vec (inc end) dbg?) :fail)\n        _ (when dbg?\n            (println \"expand-range-to-top-level end-row-idx:\"\n                     end-row-idx\n                     (if (number? end-row-idx)\n                       (str \"row:\" (nth row-vec end-row-idx))\n                       \"\")))\n        actual-end (cond (or (= end-row-idx :fail) (= end-row-idx :beyond-end))\n                           ; We are beyond the end or it didn't parse, say\n                           ; the end is beyond the last line, unless the\n                           ; start was also beyond the last line, in which\n                           ; case we will do nothing.\n                           (if (= start-row-idx :beyond-end) -1 line-count)\n                         (= end-row-idx :before-beginning)\n                           ; Someone is confused here too, say the end is\n                           ; the start.\n                           :do-nothing\n                         :else (let [end-row (get row-vec end-row-idx)]\n                                 ; end-row-idx is either the row in which\n                                 ; end falls or the next row if it was\n                                 ; between rows. Note: :row is the start\n                                 ; line of a row-map\n                                 ;\n                                 ; Does end fall between two top-level\n                                 ; expressions?\n                                 (if (< (inc end) (:row end-row))\n                                   ; Yes -- are start and end in same gap\n                                   ; between expressions?\n                                   (if (= end-row-idx start-row-idx)\n                                     ; Yes, do nothing\n                                     :do-nothing\n                                     ; No, work backward to the first\n                                     ; non-blank line prior to the end\n                                     (previous-non-blank-line lines end))\n                                   ; No, end falls inside of an expression,\n                                   ; so use the end of that expression.\n                                   ; Make it zero based.\n                                   (dec (:end-row end-row)))))\n        actual-start (if (= actual-end :do-nothing) -1 actual-start)\n        actual-end (if (= actual-end :do-nothing) -1 actual-end)]\n    [actual-start actual-end]))\n\n;;\n;; # Take apart a series of lines based on a range\n;;\n\n(defn split-out-range\n  \"Given lines, a sequence of lines, and a start and end of a range,\n  split the sequence of lines into three parts: [before-lines range\n  after-lines].  If any of these collections would be empty, return\n  an empty sequence. End must be equal to or greater than start. If\n  end is neg?, there will be no range. Note that for begin and range\n  if they have something after them, we will add a null string to them,\n  so that a join will have a newline on the end of it.\"\n  [lines start end]\n  (let [start (max start 0)\n        before start\n        range (if (neg? end) 0 (inc (- end start)))\n        after (- (dec (count lines)) end)\n        before-lines (into [] (take before lines))\n        range-lines (into [] (take range (drop before lines)))\n        after-lines (take after (drop (+ before range) lines))\n        ; Fix up newlines at the end of before and range as\n        ; needed to ensure their last lines are terminated.\n        before-lines\n          (if (not (empty? range-lines)) (conj before-lines \"\") before-lines)\n        range-lines\n          (if (not (empty? after-lines)) (conj range-lines \"\") range-lines)]\n    #_(println \"before:\" before \"range:\" range \"after:\" after)\n    [before-lines range-lines after-lines]))\n\n(defn reassemble-range\n  \"Given before-lines, range, and after-lines where before-lines\n  and after-lines are sequences of lines, and range is a string\n  which has been formatted, reassemble these three chunks into a\n  single string.  Because split-out-range worked hard to figure\n  out how to terminate before-lines and range with a newline,\n  this is really pretty simple.\"\n  [before-lines range after-lines]\n  (let [before-str (clojure.string/join \"\\n\" before-lines)\n        after-str (clojure.string/join \"\\n\" after-lines)]\n    (str before-str range after-str)))\n\n;;\n;; # Comment API Selection\n;;\n\n(defn comment-api?\n  \"Predicate to detect !zprint comments.\"\n  [s]\n  (when (clojure.string/starts-with? s \";\")\n    (let [s-onesemi (clojure.string/replace s #\"^;+\" \";\")]\n      (clojure.string/starts-with? s \";!zprint \"))))\n\n(defn get-comment-api\n  \"Given the lines from split-out-range, scan through the before-lines\n  and all of the ;!zprint comment API lines and return all of them\n  unchanged. Don't look at the option maps, so there can't be errors.\n  Returns [lines].\"\n  [before-lines]\n  (filterv comment-api? before-lines))\n\n(defn wrap-comment-api\n  \"When the previous comment-api lines are being processed by process-form\n  it has to know to ignore {:format :next} {:format :skip}.  It has to know\n  that these are previous comment-api lines, and the way it will know is\n  that we will prepend a ;!zprint {:!zprint-elide-skip-next? true}\n  and we will append a ;!zprint {:!zprint-elide-skip-next? false} to these\n  lines -- but only if there are any.\"\n  [before-lines]\n  (let [comment-api-lines (get-comment-api before-lines)]\n    (if (not (empty? comment-api-lines))\n      (into []\n            (concat [\";!zprint {:!zprint-elide-skip-next? true}\"]\n                    comment-api-lines\n                    [\";!zprint {:!zprint-elide-skip-next? false}\"]))\n      [])))\n\n(defn drop-lines\n  \"Given a count of lines to drop and a string from which to drop them,\n  return a new string with this many lines less. Assumes that we are\n  working with canonical line endings in s, that is all line endings\n  are \\n in s.\"\n  [drop-count s]\n  (let [lines (clojure.string/split s #\"\\n\" -1)\n        remaining-lines (drop drop-count lines)\n        out-str (clojure.string/join \"\\n\" remaining-lines)]\n    out-str))\n\n"],"x_google_ignoreList":[0]}