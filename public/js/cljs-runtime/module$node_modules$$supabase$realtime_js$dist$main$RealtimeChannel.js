shadow$provide.module$node_modules$$supabase$realtime_js$dist$main$RealtimeChannel = function(global, require, module, exports) {
  var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {enumerable:!0, get:function() {
        return m[k];
      }};
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    o[k2] = m[k];
  }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {enumerable:!0, value:v});
  } : function(o, v) {
    o["default"] = v;
  });
  global = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) {
      return mod;
    }
    var result = {};
    if (null != mod) {
      for (var k in mod) {
        "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      }
    }
    __setModuleDefault(result, mod);
    return result;
  };
  module = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {"default":mod};
  };
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.REALTIME_CHANNEL_STATES = exports.REALTIME_SUBSCRIBE_STATES = exports.REALTIME_LISTEN_TYPES = exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = void 0;
  const constants_1 = require("module$node_modules$$supabase$realtime_js$dist$main$lib$constants"), push_1 = module(require("module$node_modules$$supabase$realtime_js$dist$main$lib$push")), timer_1 = module(require("module$node_modules$$supabase$realtime_js$dist$main$lib$timer")), RealtimePresence_1 = module(require("module$node_modules$$supabase$realtime_js$dist$main$RealtimePresence")), Transformers = global(require("module$node_modules$$supabase$realtime_js$dist$main$lib$transformers")), transformers_1 = 
  require("module$node_modules$$supabase$realtime_js$dist$main$lib$transformers");
  (function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL = "*";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT = "INSERT";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE = "UPDATE";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE = "DELETE";
  })(exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
  (function(REALTIME_LISTEN_TYPES) {
    REALTIME_LISTEN_TYPES.BROADCAST = "broadcast";
    REALTIME_LISTEN_TYPES.PRESENCE = "presence";
    REALTIME_LISTEN_TYPES.POSTGRES_CHANGES = "postgres_changes";
    REALTIME_LISTEN_TYPES.SYSTEM = "system";
  })(exports.REALTIME_LISTEN_TYPES || (exports.REALTIME_LISTEN_TYPES = {}));
  var REALTIME_SUBSCRIBE_STATES;
  (function(REALTIME_SUBSCRIBE_STATES) {
    REALTIME_SUBSCRIBE_STATES.SUBSCRIBED = "SUBSCRIBED";
    REALTIME_SUBSCRIBE_STATES.TIMED_OUT = "TIMED_OUT";
    REALTIME_SUBSCRIBE_STATES.CLOSED = "CLOSED";
    REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR = "CHANNEL_ERROR";
  })(REALTIME_SUBSCRIBE_STATES = exports.REALTIME_SUBSCRIBE_STATES || (exports.REALTIME_SUBSCRIBE_STATES = {}));
  exports.REALTIME_CHANNEL_STATES = constants_1.CHANNEL_STATES;
  class RealtimeChannel {
    constructor(topic, params = {config:{}}, socket) {
      this.topic = topic;
      this.params = params;
      this.socket = socket;
      this.bindings = {};
      this.state = constants_1.CHANNEL_STATES.closed;
      this.joinedOnce = !1;
      this.pushBuffer = [];
      this.subTopic = topic.replace(/^realtime:/i, "");
      this.params.config = Object.assign({broadcast:{ack:!1, self:!1}, presence:{key:""}, private:!1}, params.config);
      this.timeout = this.socket.timeout;
      this.joinPush = new push_1.default(this, constants_1.CHANNEL_EVENTS.join, this.params, this.timeout);
      this.rejoinTimer = new timer_1.default(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
      this.joinPush.receive("ok", () => {
        this.state = constants_1.CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach(pushEvent => pushEvent.send());
        this.pushBuffer = [];
      });
      this._onClose(() => {
        this.rejoinTimer.reset();
        this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
        this.state = constants_1.CHANNEL_STATES.closed;
        this.socket._remove(this);
      });
      this._onError(reason => {
        this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, reason), this.state = constants_1.CHANNEL_STATES.errored, this.rejoinTimer.scheduleTimeout());
      });
      this.joinPush.receive("timeout", () => {
        this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout), this.state = constants_1.CHANNEL_STATES.errored, this.rejoinTimer.scheduleTimeout());
      });
      this._on(constants_1.CHANNEL_EVENTS.reply, {}, (payload, ref) => {
        this._trigger(this._replyEventName(ref), payload);
      });
      this.presence = new RealtimePresence_1.default(this);
      this.broadcastEndpointURL = (0,transformers_1.httpEndpointURL)(this.socket.endPoint) + "/api/broadcast";
      this.private = this.params.config.private || !1;
    }
    subscribe(callback, timeout = this.timeout) {
      var _a, _b;
      this.socket.isConnected() || this.socket.connect();
      if (this.joinedOnce) {
        throw "tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance";
      }
      const {config:{broadcast, presence, private:isPrivate}} = this.params;
      this._onError(e => null === callback || void 0 === callback ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));
      this._onClose(() => null === callback || void 0 === callback ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));
      const accessTokenPayload = {}, config = {broadcast, presence, postgres_changes:null !== (_b = null === (_a = this.bindings.postgres_changes) || void 0 === _a ? void 0 : _a.map(r => r.filter)) && void 0 !== _b ? _b : [], private:isPrivate};
      this.socket.accessTokenValue && (accessTokenPayload.access_token = this.socket.accessTokenValue);
      this.updateJoinPayload(Object.assign({config}, accessTokenPayload));
      this.joinedOnce = !0;
      this._rejoin(timeout);
      this.joinPush.receive("ok", async({postgres_changes}) => {
        var _a;
        this.socket.setAuth();
        if (void 0 === postgres_changes) {
          null === callback || void 0 === callback || callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
        } else {
          const clientPostgresBindings = this.bindings.postgres_changes, bindingsLen = null !== (_a = null === clientPostgresBindings || void 0 === clientPostgresBindings ? void 0 : clientPostgresBindings.length) && void 0 !== _a ? _a : 0;
          _a = [];
          for (let i = 0; i < bindingsLen; i++) {
            const clientPostgresBinding = clientPostgresBindings[i], {filter:{event, schema, table, filter}} = clientPostgresBinding, serverPostgresFilter = postgres_changes && postgres_changes[i];
            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {
              _a.push(Object.assign(Object.assign({}, clientPostgresBinding), {id:serverPostgresFilter.id}));
            } else {
              this.unsubscribe();
              null === callback || void 0 === callback || callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, Error("mismatch between server and client bindings for postgres changes"));
              return;
            }
          }
          this.bindings.postgres_changes = _a;
          callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
        }
      }).receive("error", error => {
        null === callback || void 0 === callback || callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, Error(JSON.stringify(Object.values(error).join(", ") || "error")));
      }).receive("timeout", () => {
        null === callback || void 0 === callback || callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
      });
      return this;
    }
    presenceState() {
      return this.presence.state;
    }
    async track(payload, opts = {}) {
      return await this.send({type:"presence", event:"track", payload}, opts.timeout || this.timeout);
    }
    async untrack(opts = {}) {
      return await this.send({type:"presence", event:"untrack"}, opts);
    }
    on(type, filter, callback) {
      return this._on(type, filter, callback);
    }
    async send(args, opts = {}) {
      var _a, _b;
      if (this._canPush() || "broadcast" !== args.type) {
        return new Promise(resolve => {
          var _a, _b, _c;
          const push = this._push(args.type, args, opts.timeout || this.timeout);
          "broadcast" !== args.type || (null === (_c = null === (_b = null === (_a = this.params) || void 0 === _a ? void 0 : _a.config) || void 0 === _b ? void 0 : _b.broadcast) || void 0 === _c ? 0 : _c.ack) || resolve("ok");
          push.receive("ok", () => resolve("ok"));
          push.receive("error", () => resolve("error"));
          push.receive("timeout", () => resolve("timed out"));
        });
      }
      const {event, payload:endpoint_payload} = args, options = {method:"POST", headers:{Authorization:this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "", apikey:this.socket.apiKey ? this.socket.apiKey : "", "Content-Type":"application/json"}, body:JSON.stringify({messages:[{topic:this.subTopic, event, payload:endpoint_payload, private:this.private}]})};
      try {
        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, null !== (_a = opts.timeout) && void 0 !== _a ? _a : this.timeout);
        await (null === (_b = response.body) || void 0 === _b ? void 0 : _b.cancel());
        return response.ok ? "ok" : "error";
      } catch (error) {
        return "AbortError" === error.name ? "timed out" : "error";
      }
    }
    updateJoinPayload(payload) {
      this.joinPush.updatePayload(payload);
    }
    unsubscribe(timeout = this.timeout) {
      this.state = constants_1.CHANNEL_STATES.leaving;
      const onClose = () => {
        this.socket.log("channel", `leave ${this.topic}`);
        this._trigger(constants_1.CHANNEL_EVENTS.close, "leave", this._joinRef());
      };
      this.rejoinTimer.reset();
      this.joinPush.destroy();
      return new Promise(resolve => {
        const leavePush = new push_1.default(this, constants_1.CHANNEL_EVENTS.leave, {}, timeout);
        leavePush.receive("ok", () => {
          onClose();
          resolve("ok");
        }).receive("timeout", () => {
          onClose();
          resolve("timed out");
        }).receive("error", () => {
          resolve("error");
        });
        leavePush.send();
        this._canPush() || leavePush.trigger("ok", {});
      });
    }
    async _fetchWithTimeout(url, options, timeout) {
      const controller = new AbortController();
      timeout = setTimeout(() => controller.abort(), timeout);
      url = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {signal:controller.signal}));
      clearTimeout(timeout);
      return url;
    }
    _push(event, payload, timeout = this.timeout) {
      if (!this.joinedOnce) {
        throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
      }
      event = new push_1.default(this, event, payload, timeout);
      this._canPush() ? event.send() : (event.startTimeout(), this.pushBuffer.push(event));
      return event;
    }
    _onMessage(_event, payload, _ref) {
      return payload;
    }
    _isMember(topic) {
      return this.topic === topic;
    }
    _joinRef() {
      return this.joinPush.ref;
    }
    _trigger(type, payload, ref) {
      var _a, _b;
      const typeLower = type.toLocaleLowerCase(), {close, error, leave, join} = constants_1.CHANNEL_EVENTS;
      type = [close, error, leave, join];
      if (!(ref && 0 <= type.indexOf(typeLower) && ref !== this._joinRef())) {
        var handledPayload = this._onMessage(typeLower, payload, ref);
        if (payload && !handledPayload) {
          throw "channel onMessage callbacks must return the payload, modified or unmodified";
        }
        ["insert", "update", "delete"].includes(typeLower) ? null === (_a = this.bindings.postgres_changes) || void 0 === _a || _a.filter(bind => {
          var _a, _b, _c;
          return "*" === (null === (_a = bind.filter) || void 0 === _a ? void 0 : _a.event) || (null === (_c = null === (_b = bind.filter) || void 0 === _b ? void 0 : _b.event) || void 0 === _c ? void 0 : _c.toLocaleLowerCase()) === typeLower;
        }).map(bind => bind.callback(handledPayload, ref)) : null === (_b = this.bindings[typeLower]) || void 0 === _b || _b.filter(bind => {
          var _a, _b, _c, _e, _f;
          if (["broadcast", "presence", "postgres_changes"].includes(typeLower)) {
            if ("id" in bind) {
              var _d = bind.id;
              bind = null === (_a = bind.filter) || void 0 === _a ? void 0 : _a.event;
              return _d && (null === (_b = payload.ids) || void 0 === _b ? void 0 : _b.includes(_d)) && ("*" === bind || (null === bind || void 0 === bind ? void 0 : bind.toLocaleLowerCase()) === (null === (_c = payload.data) || void 0 === _c ? void 0 : _c.type.toLocaleLowerCase()));
            }
            _a = null === (_e = null === (_d = null === bind || void 0 === bind ? void 0 : bind.filter) || void 0 === _d ? void 0 : _d.event) || void 0 === _e ? void 0 : _e.toLocaleLowerCase();
            return "*" === _a || _a === (null === (_f = null === payload || void 0 === payload ? void 0 : payload.event) || void 0 === _f ? void 0 : _f.toLocaleLowerCase());
          }
          return bind.type.toLocaleLowerCase() === typeLower;
        }).map(bind => {
          if ("object" === typeof handledPayload && "ids" in handledPayload) {
            const postgresChanges = handledPayload.data, {schema, table, commit_timestamp, type, errors} = postgresChanges;
            handledPayload = Object.assign(Object.assign({}, {schema, table, commit_timestamp, eventType:type, new:{}, old:{}, errors}), this._getPayloadRecords(postgresChanges));
          }
          bind.callback(handledPayload, ref);
        });
      }
    }
    _isClosed() {
      return this.state === constants_1.CHANNEL_STATES.closed;
    }
    _isJoined() {
      return this.state === constants_1.CHANNEL_STATES.joined;
    }
    _isJoining() {
      return this.state === constants_1.CHANNEL_STATES.joining;
    }
    _isLeaving() {
      return this.state === constants_1.CHANNEL_STATES.leaving;
    }
    _replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    _on(type, filter, callback) {
      type = type.toLocaleLowerCase();
      filter = {type, filter, callback};
      this.bindings[type] ? this.bindings[type].push(filter) : this.bindings[type] = [filter];
      return this;
    }
    _off(type, filter) {
      const typeLower = type.toLocaleLowerCase();
      this.bindings[typeLower] = this.bindings[typeLower].filter(bind => {
        var _a;
        return !((null === (_a = bind.type) || void 0 === _a ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
      });
      return this;
    }
    static isEqual(obj1, obj2) {
      if (Object.keys(obj1).length !== Object.keys(obj2).length) {
        return !1;
      }
      for (const k in obj1) {
        if (obj1[k] !== obj2[k]) {
          return !1;
        }
      }
      return !0;
    }
    _rejoinUntilConnected() {
      this.rejoinTimer.scheduleTimeout();
      this.socket.isConnected() && this._rejoin();
    }
    _onClose(callback) {
      this._on(constants_1.CHANNEL_EVENTS.close, {}, callback);
    }
    _onError(callback) {
      this._on(constants_1.CHANNEL_EVENTS.error, {}, reason => callback(reason));
    }
    _canPush() {
      return this.socket.isConnected() && this._isJoined();
    }
    _rejoin(timeout = this.timeout) {
      this._isLeaving() || (this.socket._leaveOpenTopic(this.topic), this.state = constants_1.CHANNEL_STATES.joining, this.joinPush.resend(timeout));
    }
    _getPayloadRecords(payload) {
      const records = {new:{}, old:{}};
      if ("INSERT" === payload.type || "UPDATE" === payload.type) {
        records.new = Transformers.convertChangeData(payload.columns, payload.record);
      }
      if ("UPDATE" === payload.type || "DELETE" === payload.type) {
        records.old = Transformers.convertChangeData(payload.columns, payload.old_record);
      }
      return records;
    }
  }
  exports.default = RealtimeChannel;
};

//# sourceMappingURL=module$node_modules$$supabase$realtime_js$dist$main$RealtimeChannel.js.map
