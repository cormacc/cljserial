shadow$provide.module$node_modules$$supabase$auth_js$dist$main$lib$locks = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.processLock = exports.navigatorLock = exports.ProcessLockAcquireTimeoutError = exports.NavigatorLockAcquireTimeoutError = exports.LockAcquireTimeoutError = exports.internals = void 0;
  global = require("module$node_modules$$supabase$auth_js$dist$main$lib$helpers");
  exports.internals = {debug:!!(globalThis && (0,global.supportsLocalStorage)() && globalThis.localStorage && "true" === globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug"))};
  class LockAcquireTimeoutError extends Error {
    constructor(message) {
      super(message);
      this.isAcquireTimeout = !0;
    }
  }
  exports.LockAcquireTimeoutError = LockAcquireTimeoutError;
  class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {
  }
  exports.NavigatorLockAcquireTimeoutError = NavigatorLockAcquireTimeoutError;
  class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {
  }
  exports.ProcessLockAcquireTimeoutError = ProcessLockAcquireTimeoutError;
  exports.navigatorLock = async function(name, acquireTimeout, fn) {
    exports.internals.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", name, acquireTimeout);
    const abortController = new globalThis.AbortController();
    0 < acquireTimeout && setTimeout(() => {
      abortController.abort();
      exports.internals.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", name);
    }, acquireTimeout);
    return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, 0 === acquireTimeout ? {mode:"exclusive", ifAvailable:!0} : {mode:"exclusive", signal:abortController.signal}, async lock => {
      if (lock) {
        exports.internals.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", name, lock.name);
        try {
          return await fn();
        } finally {
          exports.internals.debug && console.log("@supabase/gotrue-js: navigatorLock: released", name, lock.name);
        }
      } else {
        if (0 === acquireTimeout) {
          throw exports.internals.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", name), new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);
        }
        if (exports.internals.debug) {
          try {
            const result = await globalThis.navigator.locks.query();
            console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(result, null, "  "));
          } catch (e) {
            console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", e);
          }
        }
        console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request");
        return await fn();
      }
    }));
  };
  const PROCESS_LOCKS = {};
  exports.processLock = async function(name, acquireTimeout, fn) {
    var _a;
    const previousOperation = null !== (_a = PROCESS_LOCKS[name]) && void 0 !== _a ? _a : Promise.resolve();
    _a = Promise.race([previousOperation.catch(() => null), 0 <= acquireTimeout ? new Promise((_, reject) => {
      setTimeout(() => {
        reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name "${name}" timed out`));
      }, acquireTimeout);
    }) : null].filter(x => x)).catch(e => {
      if (e && e.isAcquireTimeout) {
        throw e;
      }
      return null;
    }).then(async() => await fn());
    PROCESS_LOCKS[name] = _a.catch(async e => {
      if (e && e.isAcquireTimeout) {
        return await previousOperation, null;
      }
      throw e;
    });
    return await _a;
  };
};

//# sourceMappingURL=module$node_modules$$supabase$auth_js$dist$main$lib$locks.js.map
