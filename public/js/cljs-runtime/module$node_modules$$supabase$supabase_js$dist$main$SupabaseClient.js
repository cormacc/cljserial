shadow$provide.module$node_modules$$supabase$supabase_js$dist$main$SupabaseClient = function(global, require, module, exports) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", {value:!0});
  const functions_js_1 = require("module$node_modules$$supabase$functions_js$dist$main$index"), postgrest_js_1 = require("module$node_modules$$supabase$postgrest_js$dist$cjs$index"), realtime_js_1 = require("module$node_modules$$supabase$realtime_js$dist$main$index"), storage_js_1 = require("module$node_modules$$supabase$storage_js$dist$main$index"), constants_1 = require("module$node_modules$$supabase$supabase_js$dist$main$lib$constants"), fetch_1 = require("module$node_modules$$supabase$supabase_js$dist$main$lib$fetch"), 
  helpers_1 = require("module$node_modules$$supabase$supabase_js$dist$main$lib$helpers"), SupabaseAuthClient_1 = require("module$node_modules$$supabase$supabase_js$dist$main$lib$SupabaseAuthClient");
  class SupabaseClient {
    constructor(supabaseUrl, supabaseKey, options) {
      var _a, _b, _c;
      this.supabaseUrl = supabaseUrl;
      this.supabaseKey = supabaseKey;
      if (!supabaseUrl) {
        throw Error("supabaseUrl is required.");
      }
      if (!supabaseKey) {
        throw Error("supabaseKey is required.");
      }
      supabaseUrl = (0,helpers_1.stripTrailingSlash)(supabaseUrl);
      this.realtimeUrl = `${supabaseUrl}/realtime/v1`.replace(/^http/i, "ws");
      this.authUrl = `${supabaseUrl}/auth/v1`;
      this.storageUrl = `${supabaseUrl}/storage/v1`;
      this.functionsUrl = `${supabaseUrl}/functions/v1`;
      var defaultStorageKey = `sb-${(new URL(this.authUrl)).hostname.split(".")[0]}-auth-token`;
      defaultStorageKey = {db:constants_1.DEFAULT_DB_OPTIONS, realtime:constants_1.DEFAULT_REALTIME_OPTIONS, auth:Object.assign(Object.assign({}, constants_1.DEFAULT_AUTH_OPTIONS), {storageKey:defaultStorageKey}), global:constants_1.DEFAULT_GLOBAL_OPTIONS};
      options = (0,helpers_1.applySettingDefaults)(null !== options && void 0 !== options ? options : {}, defaultStorageKey);
      this.storageKey = null !== (_a = options.auth.storageKey) && void 0 !== _a ? _a : "";
      this.headers = null !== (_b = options.global.headers) && void 0 !== _b ? _b : {};
      options.accessToken ? (this.accessToken = options.accessToken, this.auth = new Proxy({}, {get:(_, prop) => {
        throw Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
      }})) : this.auth = this._initSupabaseAuthClient(null !== (_c = options.auth) && void 0 !== _c ? _c : {}, this.headers, options.global.fetch);
      this.fetch = (0,fetch_1.fetchWithAuth)(supabaseKey, this._getAccessToken.bind(this), options.global.fetch);
      this.realtime = this._initRealtimeClient(Object.assign({headers:this.headers, accessToken:this._getAccessToken.bind(this)}, options.realtime));
      this.rest = new postgrest_js_1.PostgrestClient(`${supabaseUrl}/rest/v1`, {headers:this.headers, schema:options.db.schema, fetch:this.fetch});
      options.accessToken || this._listenForAuthEvents();
    }
    get functions() {
      return new functions_js_1.FunctionsClient(this.functionsUrl, {headers:this.headers, customFetch:this.fetch});
    }
    get storage() {
      return new storage_js_1.StorageClient(this.storageUrl, this.headers, this.fetch);
    }
    from(relation) {
      return this.rest.from(relation);
    }
    schema(schema) {
      return this.rest.schema(schema);
    }
    rpc(fn, args = {}, options = {}) {
      return this.rest.rpc(fn, args, options);
    }
    channel(name, opts = {config:{}}) {
      return this.realtime.channel(name, opts);
    }
    getChannels() {
      return this.realtime.getChannels();
    }
    removeChannel(channel) {
      return this.realtime.removeChannel(channel);
    }
    removeAllChannels() {
      return this.realtime.removeAllChannels();
    }
    _getAccessToken() {
      var _a, _b;
      return __awaiter(this, void 0, void 0, function*() {
        if (this.accessToken) {
          return yield this.accessToken();
        }
        const {data} = yield this.auth.getSession();
        return null !== (_b = null === (_a = data.session) || void 0 === _a ? void 0 : _a.access_token) && void 0 !== _b ? _b : null;
      });
    }
    _initSupabaseAuthClient({autoRefreshToken, persistSession, detectSessionInUrl, storage, storageKey, flowType, lock, debug}, headers, fetch) {
      return new SupabaseAuthClient_1.SupabaseAuthClient({url:this.authUrl, headers:Object.assign(Object.assign({}, {Authorization:`Bearer ${this.supabaseKey}`, apikey:`${this.supabaseKey}`}), headers), storageKey, autoRefreshToken, persistSession, detectSessionInUrl, storage, flowType, lock, debug, fetch, hasCustomAuthorizationHeader:"Authorization" in this.headers});
    }
    _initRealtimeClient(options) {
      return new realtime_js_1.RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), {params:Object.assign({apikey:this.supabaseKey}, null === options || void 0 === options ? void 0 : options.params)}));
    }
    _listenForAuthEvents() {
      return this.auth.onAuthStateChange((event, session) => {
        this._handleTokenChanged(event, "CLIENT", null === session || void 0 === session ? void 0 : session.access_token);
      });
    }
    _handleTokenChanged(event, source, token) {
      "TOKEN_REFRESHED" !== event && "SIGNED_IN" !== event || this.changedAccessToken === token ? "SIGNED_OUT" === event && (this.realtime.setAuth(), "STORAGE" == source && this.auth.signOut(), this.changedAccessToken = void 0) : this.changedAccessToken = token;
    }
  }
  exports.default = SupabaseClient;
};

//# sourceMappingURL=module$node_modules$$supabase$supabase_js$dist$main$SupabaseClient.js.map
