{"version":3,"sources":["extend_clj/core.cljc"],"mappings":"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","names":["extend-clj$core$IAtom3$deref_impl$dyn","x__5350__auto__","m__5351__auto__","extend-clj.core/deref-impl","goog/typeOf","m__5349__auto__","cljs.core/missing-protocol","extend-clj$core$IAtom3$compare_and_set_impl$dyn","extend-clj.core/compare-and-set-impl","extend-clj$core$IAtom3$validate$dyn","extend-clj.core/validate","extend-clj$core$IAtom3$notify_watches$dyn","extend-clj.core/notify-watches","extend-clj$core$IAtom3$swap_STAR_$dyn","extend-clj.core/swap*","extend-clj.core/IAtom3","this","oldv","newv","validator","value","f","args"],"sourcesContent":["(ns extend-clj.core\n  (:require\n    [clojure.string :as str])\n  #?(:cljs\n     (:require-macros\n       [extend-clj.core])))\n\n(defprotocol IAtom3\n  (deref-impl [this])\n  (compare-and-set-impl [this oldv newv])\n  \n  (validate [this validator value])\n  (notify-watches [this oldv newv])\n  (swap* [this f args])\n  )\n\n#?(:clj\n   (defn- cljs-env? [env]\n     (boolean (:ns env))))\n\n#?(:clj\n   (defmacro deftype-atom\n     \"Allows you to declare new type that will behave like native Clojure Atom,\n      but with custom `deref` and `compare-and-set` behaviors. Rest of swap!/reset!/\n      swap-vals!/reset-vals! will be implemented through these two.\n      \n      Supports meta/validator/watches and ILookup for fields.\n      \n      Syntax:\n      \n          (deftype-atom <name> [<field> ...]\n            (deref-impl [this]\n              <impl>)\n            (compare-and-set-impl [this oldv newv]\n              <impl>))\n      \n      To use this structure, use `(-><name> <field> ...)` function. E.g. if you\n      \n          (deftype-atom X [a b c])\n      \n      then create instances like\n      \n          (->X a b c)\n      \n      You can add more interfaces after deref-impl/compare-and-set-impl and implement them as you wish:\n      \n          (deftype-atom <name> [<field> ...]\n            (deref-impl [this]\n              <impl>)\n      \n            (compare-and-set-impl [this oldv newv]\n              <impl>)\n            \n            clojure.lang.Counted\n            (count [this]\n              7)\n            \n            clojure.lang.IBlockingDeref\n            (deref [this ms timeout]\n              (.deref this)))\n      \n      Warning: swap-vals! and reset-vals! don\u2019t work in ClojureScript.\"\n     [name fields & methods]\n     (if (cljs-env? &env)\n       (let [->name    (symbol (str \"->\" name))\n             validator 'validator\n             watches   'watches\n             meta      'meta]\n         `(do\n            (deftype ~name [~@fields ~validator ~watches ~meta]\n              ~'Object\n              (~'equiv [this# other#]\n                (cljs.core/-equiv this# other#))\n\n              cljs.core/IEquiv\n              (cljs.core/-equiv [o# other#]\n                (identical? o# other#))\n\n              cljs.core/IDeref\n              (cljs.core/-deref [this#]\n                (deref-impl this#))\n           \n              cljs.core/IReset\n              (cljs.core/-reset! [this# newv#]\n                (nth (swap* this# (constantly newv#) ()) 1))\n           \n              cljs.core/ISwap\n              (cljs.core/-swap! [this# f#]\n                (nth (swap* this# f# ()) 1))\n           \n              (cljs.core/-swap! [this# f# a#]\n                (nth (swap* this# f# (list a#)) 1))\n           \n              (cljs.core/-swap! [this# f# a# b#]\n                (nth (swap* this# f# (list a# b#)) 1))\n           \n              (cljs.core/-swap! [this# f# a# b# xs#]\n                (nth (swap* this# f# (cons a# (cons b# xs#))) 1))\n\n              cljs.core/IMeta\n              (cljs.core/-meta [this#]\n                ~meta)\n\n              cljs.core/IWatchable\n              (cljs.core/-notify-watches [this# oldv# newv#]\n                (doseq [[k# f#] ~watches]\n                  (f# k# this# oldv# newv#)))\n           \n              (cljs.core/-add-watch [this# key# f#]\n                (set! (.-watches this#) (assoc ~watches key# f#))\n                this#)\n           \n              (cljs.core/-remove-watch [this# key#]\n                (set! (.-watches this#) (dissoc ~watches key#)))\n\n              cljs.core/IHash\n              (cljs.core/-hash [this#]\n                (goog/getUid this#))\n              \n              cljs.core/ILookup\n              (cljs.core/-lookup [this# k#]\n                (cljs.core/-lookup this# k# nil))\n\n              (cljs.core/-lookup [this# k# not-found#]\n                (case k#\n                  ~@(mapcat identity\n                      (for [field fields]\n                        [(keyword (str field))\n                         field]))\n                  not-found#))\n              \n              IAtom3\n              (validate [this# validator# value#]\n                (when (some? validator#)\n                  (when-not (validator# value#)\n                    (throw (ex-info \"Invalid reference state\" {:value value#})))))\n\n              (notify-watches [this# oldv# newv#]\n                (doseq [[k# w#] ~watches]\n                  (w# k# this# oldv# newv#)))\n\n              (swap* [this# f# args#]\n                (let [oldv# (deref this#)\n                      newv# (apply f# oldv# args#)]\n                  (validate this# ~validator newv#)\n                  (compare-and-set-impl this# oldv# newv#)\n                  (notify-watches this# oldv# newv#)\n                  [oldv# newv#]))\n              \n              ~@methods)\n            (defn ~(with-meta ->name {:declared true})\n              ([~@fields]\n               (new ~name ~@fields nil {} {}))\n              ([~@fields & rest#]\n               (let [opts# (apply array-map rest#)\n                     ref#  (new ~name ~@fields nil {} {})]\n                 (when-some [validator# (:validator opts#)]\n                   (validate ref# validator# @ref#)\n                   (set! (.-validator ref#) validator#))\n                 (when-some [meta# (:meta opts#)]\n                   (reset-meta! ref# meta#))\n                 ref#)))\n            ~name))\n\n       (let [->name      (symbol (str \"->\" name))\n             class       (symbol (str (clojure.string/replace (str *ns*) \"-\" \"_\") \".\" name))\n             __validator '__validator\n             __watches   '__watches\n             __meta      '__meta\n             interfaces  (->> methods\n                           (filter symbol?)\n                           (map #(if (var? (resolve %)) \n                                   (:on (deref (resolve %)))\n                                   %)))\n             methods     (remove symbol? methods)]\n         `(do\n            (deftype* ~(symbol (str *ns*) (str name)) ~class\n              [~@fields\n               ~(with-meta __validator {:volatile-mutable true})\n               ~(with-meta __watches {:volatile-mutable true})\n               ~(with-meta __meta {:unsynchronized-mutable true})\n               __extmap\n               ^:unsynchronized-mutable ^int __hash\n               ^:unsynchronized-mutable ^int __hasheq]\n              :implements [clojure.lang.IMeta\n                           clojure.lang.IReference\n                           clojure.lang.IDeref\n                           clojure.lang.IRef\n                           clojure.lang.IAtom\n                           clojure.lang.IAtom2\n                           extend_clj.core.IAtom3\n                           clojure.lang.ILookup\n                           clojure.lang.IKeywordLookup\n                           ~@interfaces]\n              ~@methods\n       \n              ; clojure.lang.IMeta\n              (meta [this#]\n                ~__meta)\n  \n              ; clojure.lang.IReference\n              (alterMeta [this# alter# args#]\n                (locking this#\n                  (.resetMeta this# (apply alter# ~__meta args#))))\n      \n              (resetMeta [this# m#]\n                (locking this#\n                  (set! ~__meta m#)\n                  m#))\n\n              ; clojure.lang.IDeref\n              (deref [this#]\n                (.deref-impl this#))\n\n              ; clojure.lang.IRef\n              (setValidator [this# vf#]\n                (.validate this# vf# (.deref this#))\n                (set! ~__validator vf#))\n\n              (getValidator [this#]\n                ~__validator)\n\n              (getWatches [this#]\n                ~__watches)\n\n              (addWatch [this# key# callback#]\n                (locking this#\n                  (set! ~__watches (assoc ~__watches key# callback#))\n                  this#))\n\n              (removeWatch [this# key#]\n                (locking this#\n                  (set! ~__watches (dissoc ~__watches key#))\n                  this#))\n  \n              ; clojure.lang.IAtom\n              (swap [this# f#]\n                (nth (.swap* this# f# ()) 1))\n  \n              (swap [this# f# arg#]\n                (nth (.swap* this# f# (list arg#)) 1))\n  \n              (swap [this# f# arg1# arg2#]\n                (nth (.swap* this# f# (list arg1# arg2#)) 1))\n  \n              (swap [this# f# arg1# arg2# rest#]\n                (nth (.swap* this# f# (cons arg1# (cons arg2# rest#))) 1))\n\n              (compareAndSet [this# oldv# newv#]\n                (.validate this# ~__validator newv#)\n                (if (.compare-and-set-impl this# oldv# newv#)\n                  (do\n                    (.notify-watches this# oldv# newv#)\n                    true)\n                  false))\n\n              (reset [this# newv#]\n                (nth (.resetVals this# newv#) 1))\n  \n              ; clojure.lang.IAtom2\n              (swapVals [this# f#]\n                (.swap* this# f# ()))\n  \n              (swapVals [this# f# arg#]\n                (.swap* this# f# (list arg#)))\n  \n              (swapVals [this# f# arg1# arg2#]\n                (.swap* this# f# (list arg1# arg2#)))\n  \n              (swapVals [this# f# arg1# arg2# rest#]\n                (.swap* this# f# (cons arg1# (cons arg2# rest#))))\n\n              (resetVals [this# newv#]\n                (.validate this# ~__validator newv#)\n                (loop []\n                  (let [oldv# (.deref this#)]\n                    (if (.compare-and-set-impl this# oldv# newv#)\n                      (do\n                        (.notify-watches this# oldv# newv#)\n                        [oldv# newv#])\n                      (recur)))))\n\n              ; IAtom3\n              (validate [this# validator# value#]\n                (when (some? validator#)\n                  (when-not (validator# value#)\n                    (throw (ex-info \"Invalid reference state\" {:value value#})))))\n\n              (notify-watches [this# oldv# newv#]\n                (doseq [[k# w#] ~__watches]\n                  (w# k# this# oldv# newv#)))\n\n              (swap* [this# f# args#]\n                (loop []\n                  (let [oldv# (.deref this#)\n                        newv# (apply f# oldv# args#)]\n                    (if (.compareAndSet this# oldv# newv#)\n                      [oldv# newv#]\n                      (recur)))))\n  \n              ; clojure.lang.ILookup\n              (valAt [this# key#]\n                (.valAt this# key# nil))\n\n              (valAt [this# key# else#]\n                (case key#\n                  ~@(mapcat identity\n                      (for [field fields]\n                        [(keyword (clojure.core/name field)) (with-meta field {})]))\n                  else#))\n         \n              ; clojure.lang.IKeywordLookup\n              ~(let [gclass  (gensym \"gclass\")\n                     gtarget (gensym \"gtarget\")] \n                 `(getLookupThunk [this# k#]\n                    (let [~gclass (class this#)]\n                      (case k#\n                        ~@(mapcat identity\n                            (for [field fields]\n                              [(keyword (clojure.core/name field))\n                               `(reify clojure.lang.ILookupThunk\n                                  (get [thunk# ~gtarget]\n                                    (if (identical? (class ~gtarget) ~gclass)\n                                      (. ~(with-meta gtarget {:tag name}) ~(symbol (str \"-\" (str field))))\n                                      thunk#)))]))\n                        nil)))))\n       \n            (import ~class)\n       \n            (defn ~->name\n              ([~@fields]\n               (new ~name ~@fields nil {}))\n              ([~@fields & rest#]\n               (let [opts# (apply array-map rest#)\n                     ref#  (new ~name ~@fields nil {})]\n                 (when-some [validator# (:validator opts#)]\n                   (.setValidator ref# validator#))\n                 (when-some [meta# (:meta opts#)]\n                   (.resetMeta ref# meta#))\n                 ref#)))\n\n            ~class)))))\n"],"x_google_ignoreList":[0]}