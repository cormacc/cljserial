{"version":3,"sources":["rewrite_clj/zip/seqz.cljc"],"mappings":"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","names":["rewrite-clj.zip.seqz/seq?","zloc","cljs.core/contains?","rewrite-clj.zip.base/tag","rewrite-clj.zip.seqz/list?","cljs.core._EQ_","rewrite-clj.zip.seqz/vector?","rewrite-clj.zip.seqz/set?","rewrite-clj.zip.seqz/map?","rewrite-clj.zip.seqz/namespaced-map?","js/Error","rewrite-clj.zip.seqz/map-seq","f","temp__5821__auto__","zloc-n0","rewrite-clj.zip.move/down","G__69836","cljs.core/iterate","loc","temp__5823__auto__","zloc-n","rewrite-clj.zip.move/right","cljs.core.take_while","cljs.core/identity","cljs.core/last","rewrite-clj.zip.move/up","rewrite-clj.zip.seqz/map-vals*","map-loc","parent","cljs.core/not","and__5000__auto__","rewrite-clj.custom-zipper.core/node","zloc-map-value","new-zloc-map-value","rewrite-clj.zip.seqz/map-loc","rewrite-clj.zip.move/rightmost","rewrite-clj.zip.seqz/container-loc","rewrite-clj.zip.seqz/map-vals","rewrite-clj.zip.seqz/map-keys*","zloc-map-key","rewrite-clj.zip.seqz/map-keys","rewrite-clj.zip.seqz/map","rewrite-clj.zip.seqz/get","k","cljs.core/integer?","G__69906","rewrite_clj.zip.findz.find_value","G__69913","cljs.core.nth","G__69915","rewrite-clj.zip.seqz/assoc","v","value-loc","rewrite-clj.zip.editz/replace","rewrite-clj.zip.insert/append-child","cljs.core.ex_info"],"sourcesContent":["(ns ^:no-doc rewrite-clj.zip.seqz\n  (:refer-clojure :exclude [map get assoc seq? vector? list? map? set?])\n  (:require [rewrite-clj.custom-zipper.core :as zraw]\n            [rewrite-clj.zip.base :as base]\n            [rewrite-clj.zip.editz :as e]\n            [rewrite-clj.zip.findz :as f]\n            [rewrite-clj.zip.insert :as i]\n            [rewrite-clj.zip.move :as m]))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; ## Predicates\n\n(defn seq?\n  \"Returns true if current node in `zloc` is a sequence.\"\n  [zloc]\n  (contains?\n   #{:forms :list :vector :set :map :namespaced-map}\n   (base/tag zloc)))\n\n(defn list?\n  \"Returns true if current node in `zloc` is a list.\"\n  [zloc]\n  (= (base/tag zloc) :list))\n\n(defn vector?\n  \"Returns true if current node in `zloc` is a vector.\"\n  [zloc]\n  (= (base/tag zloc) :vector))\n\n(defn set?\n  \"Returns true if current node in `zloc` is a set.\"\n  [zloc]\n  (= (base/tag zloc) :set))\n\n(defn map?\n  \"Returns true if current node in `zloc` is a map.\"\n  [zloc]\n  (= (base/tag zloc) :map))\n\n(defn namespaced-map?\n  \"Returns true if the current node in `zloc` is a namespaced map.\"\n  [zloc]\n  (= (base/tag zloc) :namespaced-map))\n\n;; ## Map Operations\n\n(defn- map-seq\n  [f zloc]\n  {:pre [(seq? zloc)]}\n  (if-let [zloc-n0 (m/down zloc)]\n    (some->> (f zloc-n0)\n             (iterate\n              (fn [loc]\n                (when-let [zloc-n (m/right loc)]\n                  (f zloc-n))))\n             (take-while identity)\n             (last)\n             (m/up))\n    zloc))\n\n(defn- map-vals* [f map-loc]\n  (loop [loc (m/down map-loc)\n         parent map-loc]\n    (if-not (and loc (zraw/node loc))\n      parent\n      (if-let [zloc-map-value (m/right loc)]\n        (if-let [new-zloc-map-value (f zloc-map-value)]\n          (recur (m/right new-zloc-map-value) (m/up new-zloc-map-value))\n          (recur (m/right zloc-map-value) parent))\n        parent))))\n\n(defn- map-loc [zloc]\n  (if (namespaced-map? zloc)\n    (-> zloc m/down m/rightmost)\n    zloc))\n\n(defn- container-loc [zloc map-loc]\n  (if (namespaced-map? zloc)\n    (-> map-loc m/up)\n    map-loc))\n\n(defn map-vals\n  \"Returns `zloc` with function `f` applied to each value node of the current node.\n   Current node must be map node.\n\n  `zloc` location is unchanged.\n\n  `f` arg is zloc positioned at value node and should return:\n  - an updated zloc with zloc positioned at value node\n  - a falsey value to leave value node unchanged\n\n  Folks typically use [[edit]] for `f`.\"\n  [f zloc]\n  {:pre [(or (map? zloc) (namespaced-map? zloc))]}\n  (container-loc zloc\n                 (map-vals* f (map-loc zloc))))\n\n(defn- map-keys* [f map-loc]\n  (loop [loc (m/down map-loc)\n         parent map-loc]\n    (if-not (and loc (zraw/node loc))\n      parent\n      (if-let [zloc-map-key (f loc)]\n        (recur (m/right (m/right zloc-map-key)) (m/up zloc-map-key))\n        (recur (m/right (m/right loc)) parent)))))\n\n(defn map-keys\n  \"Returns `zloc` with function `f` applied to all key nodes of the current node.\n   Current node must be map node.\n\n  `zloc` location is unchanged.\n\n  `f` arg is zloc positioned at key node and should return:\n  - an updated zloc with zloc positioned at key node\n  - a falsey value to leave value node unchanged\n\n  Folks typically use [[rewrite-clj.zip/edit]] for `f`.\"\n  [f zloc]\n  {:pre [(or (map? zloc) (namespaced-map? zloc))]}\n  (container-loc zloc\n                 (map-keys* f (map-loc zloc))))\n\n(defn map\n  \"Returns `zloc` with function `f` applied to all nodes of the current node.\n  Current node must be a sequence node. Equivalent to [[rewrite-clj.zip/map-vals]] for maps.\n\n  `zloc` location is unchanged.\n\n  `f` arg is zloc positioned at\n  - value nodes for maps\n  - each element of a seq\n  and is should return:\n  - an updated zloc with zloc positioned at edited node\n  - a falsey value to leave value node unchanged\n\n  Folks typically use [[edit]] for `f`.\"\n  [f zloc]\n  {:pre [(seq? zloc)]}\n  (if (or (map? zloc) (namespaced-map? zloc))\n    (map-vals f zloc)\n    (map-seq f zloc)))\n\n;; ## Get/Assoc\n\n(defn get\n  \"Returns `zloc` located to map key node's sexpr value matching `k` else `nil`.\n\n  `k` should be:\n  - a key for maps\n  - a zero-based index for sequences\n\n  NOTE: `k` will be compared against resolved keywords in maps.\n  See docs for sexpr behavior on [namespaced elements](/doc/01-user-guide.adoc#namespaced-elements).\"\n  [zloc k]\n  {:pre [(or (map? zloc) (namespaced-map? zloc) (and (seq? zloc) (integer? k)))]}\n  (cond\n    (map? zloc)\n    (some-> zloc m/down (f/find-value k) m/right)\n\n    (namespaced-map? zloc)\n    (some-> zloc m/down m/rightmost m/down (f/find-value k) m/right)\n\n    :else\n    (nth\n     (some->> (m/down zloc)\n              (iterate m/right)\n              (take-while identity))\n     k)))\n\n(defn assoc\n  \"Returns `zloc` with current node's `k` set to value `v`.\n\n  `zloc` location is unchanged.\n\n  `k` should be:\n  - a key for maps\n  - a zero-based index for sequences, an exception is thrown if index is out of bounds\n\n  NOTE: `k` will be compared against resolved keywords in maps.\n  See docs for sexpr behavior on [namespaced elements](/doc/01-user-guide.adoc#namespaced-elements).\"\n  [zloc k v]\n  (container-loc zloc\n                 (if-let [value-loc (get zloc k)]\n                   (-> value-loc (e/replace v) m/up)\n                   (if (or (map? zloc) (namespaced-map? zloc))\n                     (-> (map-loc zloc)\n                         (i/append-child k)\n                         (i/append-child v))\n                     (throw\n                      (ex-info (str \"index out of bounds: \" k) {}))))))\n"],"x_google_ignoreList":[0]}