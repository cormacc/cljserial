{"version":3,"sources":["preo/core.cljc"],"mappings":";AAMA,8BAAA,9BAAMA,oEAAcC;AAApB,AAEW,MAAO,KAAAC,UAAeD;;AAEjC,yBAAA,zBAAOO,0DAASC,KAAKC,IAAIC;AAAzB,AAAA,OAAAR,iDAAA,AAAAC,cAAA,AAAAC,sDAAA,KAAAC,eAAA,KAAA,AAAA,wEAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,KAAA,AAAAC,cAAA,AAAAJ,iDAAA,AAAAC,cAAA,AAAAC,+CAAA,KAAAC,eAAA,KAAA,AAAA,qFAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,KAAA,AAAAH,iDAAA,AAAAC,cAAA,AAAAC,+CAAA,KAAAC,eAAA,KAAA,AAAA,0FAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,KAAA,AAAAH,iDAAA,AAAAC,cAAA,AAAAC,sDAAA,KAAAC,eAAA,KAAA,AAAA,wFAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,UAAA,KAAA,IAAA,yDAAA,KAAAA,eAAA,SAAA,KAAA,IAAA,eAAA,KAAA,IAAA,UAAA,KAAA,IAAA,WAAA,KAAA,IAAA,yDAAA,KAAAA,eAAA,KAAA,AAAAH,iDAAA,AAAAC,cAAA,AAAAC,sDAAA,KAAAC,eAAA,KAAA,AAAA,qDAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,KAAA,AAAAH,iDAAA,AAAAC,cAAA,AAAAC,sDAAA,KAAAC,eAAA,KAAA,AAAA,+FAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,KAAA,AAAA,qFAAA,KAAA,IAAA,yDAAA,KAAAA,eAAA,KAAA,WAAA,KAAA,IAAA,eAAA,KAAA,IAAA,yDAAA,KAAAA,eAAA,KAAA,KAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,KAAA,AAAAH,iDAAA,AAAAC,cAAA,AAAAC,+CAAA,KAAAC,eAAA,KAAA,AAAA,2FAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,KAAA,AAAAH,iDAAA,AAAAC,cAAA,AAAAC,sDAAA,KAAAC,eAAA,KAAA,AAAA,yEAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,YAAA,KAAA,IAAA,yDAAA,KAAAA,eAAA,KAAA,KAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,KAAA,AAAA,qFAAA,KAAA,IAAA,eAAA,KAAA,IAAA,UAAA,KAAA,IAAA,eAAA,KAAA,IAAA,x5DAC8CG,gGAAMC,ugDAGzBC","names":["preo.core/throw-error!","msg","js/TypeError","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","cljs.core/vec","preo.core/assert!","pred","val","prefix"],"sourcesContent":["(ns preo.core\n  (:require [clojure.spec.alpha :as s]\n            [clojure.string :as str]\n            [expound.alpha :as expound])\n  #?(:cljs (:require-macros [preo.core :refer [arg! ret!]])))\n\n(defn throw-error! [msg]\n  #?(:clj (throw (AssertionError. msg))\n     :cljs (throw (js/TypeError. msg))))\n\n(defn- assert! [pred val prefix]\n  `(let [msg# (with-out-str (expound/expound ~pred ~val))]\n     (if (str/includes? msg# \"Success!\")\n       true\n       (throw-error! (str ~prefix \"\\n\" msg#)))))\n\n#?(:clj\n   (defmacro arg!\n     \"Assert argument value in :pre hook. `pred` can be predicate fn or spec.\"\n     [pred val]\n     (assert! pred val (str \"Invalid argument: \" val))))\n\n#?(:clj\n   (defmacro ret!\n     \"Assert return value in :post hook. `pred` can be predicate fn or spec.\"\n     [pred val]\n     (assert! pred val (str \"Invalid return value\"))))\n"],"x_google_ignoreList":[0]}