shadow$provide.module$node_modules$$supabase$postgrest_js$dist$cjs$PostgrestFilterBuilder = function(global, require, module, exports) {
  global = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {"default":mod};
  };
  Object.defineProperty(exports, "__esModule", {value:!0});
  require = global(require("module$node_modules$$supabase$postgrest_js$dist$cjs$PostgrestTransformBuilder"));
  class PostgrestFilterBuilder extends require.default {
    eq(column, value) {
      this.url.searchParams.append(column, `eq.${value}`);
      return this;
    }
    neq(column, value) {
      this.url.searchParams.append(column, `neq.${value}`);
      return this;
    }
    gt(column, value) {
      this.url.searchParams.append(column, `gt.${value}`);
      return this;
    }
    gte(column, value) {
      this.url.searchParams.append(column, `gte.${value}`);
      return this;
    }
    lt(column, value) {
      this.url.searchParams.append(column, `lt.${value}`);
      return this;
    }
    lte(column, value) {
      this.url.searchParams.append(column, `lte.${value}`);
      return this;
    }
    like(column, pattern) {
      this.url.searchParams.append(column, `like.${pattern}`);
      return this;
    }
    likeAllOf(column, patterns) {
      this.url.searchParams.append(column, `like(all).{${patterns.join(",")}}`);
      return this;
    }
    likeAnyOf(column, patterns) {
      this.url.searchParams.append(column, `like(any).{${patterns.join(",")}}`);
      return this;
    }
    ilike(column, pattern) {
      this.url.searchParams.append(column, `ilike.${pattern}`);
      return this;
    }
    ilikeAllOf(column, patterns) {
      this.url.searchParams.append(column, `ilike(all).{${patterns.join(",")}}`);
      return this;
    }
    ilikeAnyOf(column, patterns) {
      this.url.searchParams.append(column, `ilike(any).{${patterns.join(",")}}`);
      return this;
    }
    is(column, value) {
      this.url.searchParams.append(column, `is.${value}`);
      return this;
    }
    in(column, values) {
      values = Array.from(new Set(values)).map(s => "string" === typeof s && RegExp("[,()]").test(s) ? `"${s}"` : `${s}`).join(",");
      this.url.searchParams.append(column, `in.(${values})`);
      return this;
    }
    contains(column, value) {
      "string" === typeof value ? this.url.searchParams.append(column, `cs.${value}`) : Array.isArray(value) ? this.url.searchParams.append(column, `cs.{${value.join(",")}}`) : this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
      return this;
    }
    containedBy(column, value) {
      "string" === typeof value ? this.url.searchParams.append(column, `cd.${value}`) : Array.isArray(value) ? this.url.searchParams.append(column, `cd.{${value.join(",")}}`) : this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
      return this;
    }
    rangeGt(column, range) {
      this.url.searchParams.append(column, `sr.${range}`);
      return this;
    }
    rangeGte(column, range) {
      this.url.searchParams.append(column, `nxl.${range}`);
      return this;
    }
    rangeLt(column, range) {
      this.url.searchParams.append(column, `sl.${range}`);
      return this;
    }
    rangeLte(column, range) {
      this.url.searchParams.append(column, `nxr.${range}`);
      return this;
    }
    rangeAdjacent(column, range) {
      this.url.searchParams.append(column, `adj.${range}`);
      return this;
    }
    overlaps(column, value) {
      "string" === typeof value ? this.url.searchParams.append(column, `ov.${value}`) : this.url.searchParams.append(column, `ov.{${value.join(",")}}`);
      return this;
    }
    textSearch(column, query, {config, type} = {}) {
      let typePart = "";
      "plain" === type ? typePart = "pl" : "phrase" === type ? typePart = "ph" : "websearch" === type && (typePart = "w");
      this.url.searchParams.append(column, `${typePart}fts${void 0 === config ? "" : `(${config})`}.${query}`);
      return this;
    }
    match(query) {
      Object.entries(query).forEach(([column, value]) => {
        this.url.searchParams.append(column, `eq.${value}`);
      });
      return this;
    }
    not(column, operator, value) {
      this.url.searchParams.append(column, `not.${operator}.${value}`);
      return this;
    }
    or(filters, {foreignTable, referencedTable = foreignTable} = {}) {
      this.url.searchParams.append(referencedTable ? `${referencedTable}.or` : "or", `(${filters})`);
      return this;
    }
    filter(column, operator, value) {
      this.url.searchParams.append(column, `${operator}.${value}`);
      return this;
    }
  }
  exports.default = PostgrestFilterBuilder;
};

//# sourceMappingURL=module$node_modules$$supabase$postgrest_js$dist$cjs$PostgrestFilterBuilder.js.map
