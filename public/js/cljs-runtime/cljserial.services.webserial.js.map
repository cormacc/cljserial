{"version":3,"sources":["cljserial/services/webserial.cljs"],"mappings":"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","names":["cljserial.services.webserial/serial-event-interceptors","G__56517","cljserial.utils.dbfx/path","cljserial.utils.dbfx/inject-cofx","p__56519","map__56520","cljs.core/--destructure-map","cljs.core.get","cljserial.services.webserial/append-event","events","timestamp","event-type","bytes","cljs.core.assoc","G__56523","G__56524","G__56525","cljserial.utils.dbfx/reg-event-fx","p__56527","p__56528","map__56529","vec__56530","cljs.core.nth","db","_","G__56535","G__56536","G__56537","p__56539","p__56540","map__56541","vec__56542","_event_id","js/goog.debug.LOGGING_ENABLED","lambdaisland.glogi.log","cljs.core/identity","prev-event","cljs.core/last","cljs.core/vals","ongoing","cljs.core._EQ_","ts","data","G__56550","G__56551","cljserial.utils.dbfx/reg-sub","G__56553","G__56554","G__56555","G__56556","serial-state","cljserial.services.webserial/default-context","cljserial.utils.webserial/DEFAULTS","cljserial.services.webserial/controller","G__56563","statecharts.core/machine","G__56567","statecharts.core/assign","ctx","e","G__56576","cljserial.utils.dbfx/dispatch","G__56578","p__56580","map__56581","key","cljs.core/first","value-text","cljs.core/second","value","cljs.core/re-matches","cljs.core.keyword","cljs.core/assoc-in","G__56596","cljserial.utils.webserial/is-supported?","G__56600","port","G__56606","cljserial.utils.webserial.open_port","G__56611","G__56612","G__56616","port-id","cljserial.utils.webserial/describe-port","p1__56562#","cljserial.utils.webserial/go-read-text","G__56619","p__56620","map__56622","context","map__56623","line-terminator","cmd","cljserial.utils.webserial/write","port-info","cljserial.utils.webserial.forget_port","G__56625","cljserial.services.webserial/init","cljserial.utils.hsm/register"],"sourcesContent":["(ns cljserial.services.webserial\n  (:require\n   [lambdaisland.glogi :as log]\n   [statecharts.core :as hsm]\n   [cljserial.utils.dbfx :as dbfx :refer [reg-event-fx inject-cofx reg-sub]]\n   [cljserial.utils.hsm :as hsm-dbfx]\n   [cljserial.utils.webserial :as wsi]))\n\n\n;; == Schema =====================================================================\n;; -- see cljserial.utils.term\n\n;; ============================================================================\n;; re-fx events and subscriptions\n\n;; TODO: Inject the db path during initialisation instead maybe?\n\n;; Define a standard set of interceptors for all serial port events\n(def serial-event-interceptors\n  ;; \"path\" interceptor: Update specified subsection of db rather than entire db\n  [(dbfx/path [:serial-term :events])\n   ;; Provide event timestamp as coeffect so our event handlers can be pure functions\n   (inject-cofx :timestamp)])\n\n(defn append-event [events {:keys [timestamp event-type bytes]}]\n  (assoc events timestamp {:timestamp timestamp\n                           :event-type event-type\n                           :event-data {:byte-encoding :text\n                                        :bytes bytes}}))\n\n;; Clients transmit a :serial-tx event containg commands/data to be transmitted\n;; This logs it to the app database, then generates an internal :webserial-tx event\n;; that triggers the statemachine to transmit data via the port\n;;\n;; N.B. this may need adaptation to allow for coexistence with a bluetooth serial\n;; connection.... TBD\n(reg-event-fx\n :serial-tx\n serial-event-interceptors\n (fn [{:keys [db timestamp]} [_ bytes]]\n   ;;DB effect: Append entry to the serial event database\n   {:db (append-event db {:timestamp timestamp\n                          :event-type :tx\n                          :bytes bytes})\n    ;;Coeffect - pass the request on to the statemachine to transmit\n    :fx [[:dispatch [:webserial-tx bytes]]]}))\n\n(reg-event-fx\n :serial-rx\n serial-event-interceptors\n (fn [{:keys [db timestamp]} [_event_id bytes]]\n   ;;Append to an ongoing rx event...\n   ;;As long data streams can be read over multiple rx events, if the previous recorded\n   ;;comms event is rx, we assume this is an ongoing event and consolidate.\n   ;;\n   ;;N.B. This does NOT do any command terminator parsing -- that's a higher level concern\n   ;;     to be dealt with by any subscribers to :webserial-rx\n   (log/info :wsm/serial-rx bytes)\n   (let [prev-event (last (vals db))\n         ongoing (and (some? prev-event) (= (:event-type prev-event prev-event) :rx))\n         ts (if ongoing (:timestamp prev-event) timestamp)\n         data (if ongoing (str (:bytes (:event-data prev-event)) bytes) bytes)]\n     ;;DB effect: Append entry to the serial event database\n     {:db (append-event db {:timestamp ts\n                            :event-type :rx\n                            :bytes data})\n      ;;Coeffect: Notify any downstream listeners (e.g. CD handlers) that new rx data has been added to the DB\n      :fx [[:dispatch [:webserial-rx nil]]]})))\n\n(reg-sub\n :serial-data\n (fn [db _]\n   (:serial-term db))) ;;\n\n(reg-sub\n :serial-events\n :<- [:serial-data]\n (fn [serial-state _]\n   (:events serial-state))) ;;\n\n\n;; ============================================================================\n;; Controller - a statemachine\n;; See https://lucywang000.github.io/clj-statecharts/\n\n;;Initial context...\n;; TODO Write a Schema?\n;; ... also consider including event store in context here rather than separately in the refx db\n\n(def default-context {:port nil\n                      :serial-options wsi/DEFAULTS\n                      :line-terminator \"\\r\"})\n\n(def controller\n  (hsm/machine\n   {:id :usb-serial\n    :initial :disconnected\n    :context default-context\n\n    :states\n\n    {;; TOP-LEVEL STATE\n     :disconnected\n     {:initial :webserial_pending\n      :entry (hsm/assign (fn [ctx e]\n                           (log/info :state/entry \"Resetting port assignment\")\n                           (dbfx/dispatch [:webserial-disconnected])\n                           (assoc ctx :port nil)))\n      :on {:webserial-option {:actions\n                              (hsm/assign\n                               (fn [ctx {:keys [data]}]\n                                 (let [key (first data)\n                                       value-text (second data)\n                                       ;; TODO: Use malli coercion here instead?\n                                       value (if (re-matches #\"\\d+\" value-text)\n                                               (int value-text)\n                                               (keyword value-text))]\n                                   (log/debug :option/set (str key \" : \" value))\n                                   (assoc-in ctx [:serial-options key] value))))}\n\n           ;;FIXME: Some duplication here with webserial-has-port handler below...\n           ;; :webserial-port-connected {:actions (hsm/assign (fn [ctx e]\n           ;;                                                   (let [port (first (:data e))]\n           ;;\n           ;;                                                     (assoc ctx :port port))))\n           ;;                            ;; :target :opening_port\n           ;;                            }\n           :webserial-port-opened :connected}\n      :states\n      {:webserial_pending\n       {:entry (fn [ctx e]\n                 (log/debug :state/entry (str \"HSM INIT\" ctx e))\n                 (dbfx/dispatch [(if (wsi/is-supported?)\n                                   :webserial-check-passed\n                                   :webserial-check-failed)]))\n        :on {:webserial-check-passed :port-pending\n             :webserial-check-failed :no-webserial}}\n       :no-webserial {}\n       :port-pending\n       {:entry (fn [ctx e]\n                  ;; Ideally we'd do this, however webserial port request must be initiated via ui element click\n                  ;; (wsi/await-port\n                  ;;  :on-success #(dbfx/dispatch [:ui/event :webserial-has-port %1])\n                  ;;  :on-failure #(dbfx/dispatch [:ui/event :webserial-no-port]))\n                 (log/debug :state/entry (str \"PORT PENDING\" ctx e)))\n        :on {:webserial-has-port {:actions (hsm/assign (fn [ctx e]\n                                                         ;;The ports get passed through as a sequence...\n                                                         (let [port (first (:data e))]\n                                                           ;;TODO: Does this stack? I.e. end up with multiple triggering on disconnection/reconnection?\n                                                           ;; (.addEventListener port \"connect\" #(dbfx/dispatch [:webserial-port-connected port]))\n                                                           (.addEventListener port \"disconnect\" #(dbfx/dispatch [:webserial-port-disconnected port]))\n\n                                                           (assoc ctx :port port))))\n                                  :target :opening_port}\n;;\n             }}\n       :opening_port\n       {:entry (fn [ctx e]\n                 (log/debug :state/entry (str \"WAITING TO OPEN PORT\" ctx))\n                 (wsi/open-port (:port ctx)\n                                :options (:serial-options ctx)\n                                :on-success #(dbfx/dispatch [:webserial-port-opened])\n                                :on-failure #(dbfx/dispatch [:webserial-port-open-failure])))\n        :on {:webserial-port-open-failure {:actions (fn [ctx e] (log/error :port/open e))}}}}}\n\n     ;; TOP-LEVEL STATE\n     :connected\n     {:entry (fn [ctx e]\n               (dbfx/dispatch [:webserial-connected])\n               (let [port (:port ctx)\n                     port-id (wsi/describe-port port)]\n                 (log/info :read/spawn-loop {:port-id port-id})\n                 (wsi/go-read-text port #(dbfx/dispatch [:serial-rx %]))))\n      :on {:webserial-tx\n           {:actions (fn [context {:keys [data]}]\n                       (let [{:keys [port line-terminator]} context\n                             ;; The event parameters are wrapped in a vector - get first element\n                             cmd (first data)]\n                         (log/info :write/text cmd)\n                         (wsi/write port (str cmd line-terminator))))}\n           :webserial-forget-port :disconnecting\n           :webserial-port-disconnected :disconnected}}\n\n     ;; TOP-LEVEL STATE\n     :disconnecting\n     {:entry (fn [ctx e]\n               (log/info :port/forget \"TODO: Forget request received - IMPLEMENT ME\")\n               (let [port (:port ctx)\n                     port-info (wsi/describe-port port)]\n                 (wsi/forget-port port {:on-success #(dbfx/dispatch [:webserial-port-forgotten])\n                                        :on-failure #(log/error :port/forget (str \"Failed to forget \" port-info))})))\n      :on {:webserial-port-forgotten :disconnected}}\n\n;; END TOP-LEVEL STATES\n     }}))\n\n(defn init []\n  (hsm-dbfx/register controller))\n"]}