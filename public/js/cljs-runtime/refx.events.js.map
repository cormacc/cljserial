{"version":3,"sources":["refx/events.cljc"],"mappings":";AAQA,mBAAA,nBAAKA;AAEL;;;;;sCAAA,tCAAOC,oFAIJC,GAAGC;AAJN,AAKE,iBAAA,WAAAC,xBAAMC;AAAN,2EAA0BC,3EAAQ,2EAAA,kBAAAF,tFAACG,+CAAOC;;AAA1C,AACE,GAAA,GAAQC;AACN,OAACJ,WAAWF;;AACZ,AACE,GAAU,AAACO,sBAAMP;AAAjB;AAAA,AACE,sGAAA,sBAAA,5HAACQ,yHAA6BT,mDAAmDC;;;AACnF,IAAMS,QAAM,AAACP,WAAWF;AAAxB,AACE,GAAM,AAACU,uBAAOD;AAAd,AACE,sGAAA,sBAAA,5HAACD,yHAA6BT;;AADhC;;AAEA,IAAAY,2BAAiB,AAACE,gBAAM,AAACT,+CAAOU,oCAAyBL;AAAzD,AAAA,oBAAAE;AAAA,AAAA,kBAAAA,dAAWC;AAAX,AACE,sGAAA,sBAAA,5HAACJ,yHAA6BT,uCAAuCa;;AADvE;;AAEAH;;;AAEV;;;;;;;;;;uBAAA,vBAAMM,sDASHhB,GAAGC;AATN,AAUE,OAACgB,wBAAcnB,iBAAKE,GAAG,AAACD,oCAAwBC,GAAGC;;AAIrD,mCAAA,nCAAeiB;AAEf;;;;qBAAA,rBAAMC,kDAGHC;AAHH,AAIE,IAAMC,WAAS,AAACC,2BAAgBF;AAAhC,AACE,IAAAR,qBAAwB,AAACW,mDAAgBzB,iBAAKuB;AAA9C,AAAA,oBAAAT;AAAA,AAAA,mBAAAA,fAAWX;AAAX,AACE,oBAAIiB;AACF,6GAAA,kDAAA,yCAAA,jMAACT,uHAA2BS,kEAA4CE;;AAExE,IAAAI,uCAAUN;IAAVO,uCAAsBL;AAAtB,AAAA,oCAAAK,nCAAUP;;AAAV,IAAA,AACE,OAACQ,yBAAoBN,QAAQnB;UAD/B,AAAA,oCAAAuB,nCAAUN;;;AAJd;;;AASJ;;;;;;;;;;;;;yCAAA,zCAAMS,0FAYHC;AAZH,AAaE,gIAAA,kDAAA,gEAAA,3OAACC,qSAEQ,qEACGC;AADH,AAEE,IAAAC,aAAyB,AAACK,4DAAaN;IAAvCC,iBAAA,AAAAC,4BAAAD;SAAA,AAAAE,4CAAAF,eAAA,hEAAcG;YAAd,AAAAD,4CAAAF,eAAA,nEAAiBI;AAAjB,6FACO,CAACP,2CAAAA,qDAAAA,ZAAWM,kCAAAA,/BAAGC,kCAAAA,vNACf,6CAAA,tCAACE,8BAAaP;;;AAElC;;;;;;;;;;;;;;yCAAA,zCAAMQ,0FAaHV;AAbH,AAcE,gIAAA,kDAAA,iEAAA,5OAACC,sSAEQ,qEACGC;AADH,AAEE,IAAAS,aAAoC,AAACH,4DAAaN;IAAlDS,iBAAA,AAAAP,4BAAAO;gBAAAA,ZAAyBC;YAAzB,AAAAP,4CAAAM,eAAA,nEAAcJ;AAAd,wHACO,CAACP,2CAAAA,4DAAAA,nBAAWY,yCAAAA,/BAAUL,yCAAAA,hQACtB,6DAAA,tDAACM,8CAAMX;;;AAE3B;;;;;;;;0CAAA,1CAAMY,4FAOHd;AAPH,AAQE,gIAAA,kDAAA,oEAAA,/OAACC,ySAEQ,uEACGC;AADH,AAEE,QAACF,2CAAAA,oDAAAA,XAAWE,iCAAAA","names":["refx.events/kind","refx.events/flatten-and-remove-nils","id","interceptors","p1__86454#","make-chain","cljs.core/flatten","cljs.core.remove","cljs.core/nil?","refx.interop/debug-enabled?","cljs.core/coll?","refx.log.error","chain","cljs.core/empty?","temp__5823__auto__","not-i","cljs.core/first","refx.interceptor/interceptor?","refx.events/register","refx.registry/add!","refx.events/*handling*","refx.events/handle","event-v","event-id","refx.utils/first-in-vector","refx.registry.lookup","*handling*-orig-val__86487","*handling*-temp-val__86488","refx.interceptor/execute","refx.events/db-handler->interceptor","handler-fn","refx.interceptor.__GT_interceptor","context","map__86503","cljs.core/--destructure-map","cljs.core.get","db","event","refx.interceptor.get_coeffect","refx.interceptor/assoc-effect","refx.events/fx-handler->interceptor","map__86507","coeffects","cljs.core.assoc","refx.events/ctx-handler->interceptor"],"sourcesContent":["(ns refx.events\n  (:require [refx.interceptor :as interceptor :refer [->interceptor\n                                                     assoc-effect get-coeffect]]\n            [refx.interop :refer [debug-enabled?]]\n            [refx.log :as log]\n            [refx.registry :as registry]\n            [refx.utils :refer [first-in-vector]]))\n\n(def kind :event)\n\n(defn- flatten-and-remove-nils\n  \"`interceptors` might have nested collections, and contain nil elements.\n  return a flat collection, with all nils removed.\n  This function is 9/10 about giving good error messages.\"\n  [id interceptors]\n  (let [make-chain  #(->> % flatten (remove nil?))]\n    (if-not debug-enabled?\n      (make-chain interceptors)\n      (do\n        (when-not (coll? interceptors)\n          (log/error \"when registering\" id \", expected a collection of interceptors, got:\" interceptors))\n        (let [chain (make-chain interceptors)]\n          (when (empty? chain)\n            (log/error \"when registering\" id \", given an empty interceptor chain\"))\n          (when-let [not-i (first (remove interceptor/interceptor? chain))]\n            (log/error \"when registering\" id \", expected interceptors, but got:\" not-i))\n          chain)))))\n\n(defn register\n  \"Associate the given event `id` with the given collection of `interceptors`.\n\n   `interceptors` may contain nested collections and there may be nils\n   at any level,so process this structure into a simple, nil-less vector\n   before registration.\n\n   Typically, an `event handler` will be at the end of the chain (wrapped\n   in an interceptor).\"\n  [id interceptors]\n  (registry/add! kind id (flatten-and-remove-nils id interceptors)))\n\n;; --- handle event -----------------------------------------------------------\n\n(def ^:dynamic *handling* nil)\n\n(defn handle\n  \"Given an event vector `event-v`, look up the associated interceptor chain,\n   and execute it.\"\n  [event-v]\n  (let [event-id (first-in-vector event-v)]\n    (when-let [interceptors (registry/lookup kind event-id)]\n      (if *handling*\n        (log/error \"while handling\" *handling* \", dispatch-sync was called for\" event-v\n                   \". You can't call dispatch-sync within an event handler.\")\n        (binding [*handling*  event-v]\n          (interceptor/execute event-v interceptors))))))\n\n;; --- handler->interceptor ---------------------------------------------------\n\n(defn db-handler->interceptor\n  \"Returns an interceptor which wraps the kind of event handler given to `reg-event-db`.\n\n  These handlers take two arguments;  `db` and `event`, and they return `db`.\n\n      (fn [db event]\n         ....)\n\n  So, the interceptor wraps the given handler:\n     1. extracts two `:coeffects` keys: db and event\n     2. calls handler-fn\n     3. stores the db result back into context's `:effects`\"\n  [handler-fn]\n  (->interceptor\n   :id     :db-handler\n   :before (fn db-handler-before\n             [context]\n             (let [{:keys [db event]} (get-coeffect context)]\n               (->> (handler-fn db event)\n                    (assoc-effect context :db))))))\n\n(defn fx-handler->interceptor\n  \"Returns an interceptor which wraps the kind of event handler given to `reg-event-fx`.\n\n  These handlers take two arguments;  `coeffects` and `event`, and they return `effects`.\n\n      (fn [coeffects event]\n         {:db ...\n          :fx ...})\n\n   Wrap handler in an interceptor so it can be added to (the RHS) of a chain:\n     1. extracts `:coeffects`\n     2. call handler-fn giving coeffects\n     3. stores the result back into the `:effects`\"\n  [handler-fn]\n  (->interceptor\n   :id     :fx-handler\n   :before (fn fx-handler-before\n             [context]\n             (let [{:keys [event] :as coeffects} (get-coeffect context)]\n               (->> (handler-fn coeffects event)\n                    (assoc context :effects))))))\n\n(defn ctx-handler->interceptor\n  \"Returns an interceptor which wraps the kind of event handler given to `reg-event-ctx`.\n  These advanced handlers take one argument: `context` and they return a modified `context`.\n  Example:\n\n      (fn [context]\n         (enqueue context [more interceptors]))\"\n  [handler-fn]\n  (->interceptor\n   :id     :ctx-handler\n   :before (fn ctx-handler-before\n             [context]\n             (handler-fn context))))\n"],"x_google_ignoreList":[0]}