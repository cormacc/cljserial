shadow$provide.module$node_modules$$supabase$auth_js$dist$main$lib$fetch = function(global, require, module, exports) {
  async function handleError(error) {
    var _a;
    if (!(0,helpers_1.looksLikeFetchResponse)(error)) {
      throw new errors_1.AuthRetryableFetchError(_getErrorMessage(error), 0);
    }
    if (NETWORK_ERROR_CODES.includes(error.status)) {
      throw new errors_1.AuthRetryableFetchError(_getErrorMessage(error), error.status);
    }
    let data;
    try {
      data = await error.json();
    } catch (e) {
      throw new errors_1.AuthUnknownError(_getErrorMessage(e), e);
    }
    let errorCode = void 0;
    const responseAPIVersion = (0,helpers_1.parseResponseAPIVersion)(error);
    responseAPIVersion && responseAPIVersion.getTime() >= constants_1.API_VERSIONS["2024-01-01"].timestamp && "object" === typeof data && data && "string" === typeof data.code ? errorCode = data.code : "object" === typeof data && data && "string" === typeof data.error_code && (errorCode = data.error_code);
    if (errorCode) {
      if ("weak_password" === errorCode) {
        throw new errors_1.AuthWeakPasswordError(_getErrorMessage(data), error.status, (null === (_a = data.weak_password) || void 0 === _a ? void 0 : _a.reasons) || []);
      }
      if ("session_not_found" === errorCode) {
        throw new errors_1.AuthSessionMissingError();
      }
    } else {
      if ("object" === typeof data && data && "object" === typeof data.weak_password && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i) => a && "string" === typeof i, !0)) {
        throw new errors_1.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);
      }
    }
    throw new errors_1.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);
  }
  async function _handleRequest(fetcher, method, url, options, parameters, body) {
    {
      const params = {method, headers:(null === options || void 0 === options ? void 0 : options.headers) || {}};
      "GET" === method ? method = params : (params.headers = Object.assign({"Content-Type":"application/json;charset\x3dUTF-8"}, null === options || void 0 === options ? void 0 : options.headers), params.body = JSON.stringify(body), method = Object.assign(Object.assign({}, params), parameters));
    }
    let result;
    try {
      result = await fetcher(url, Object.assign({}, method));
    } catch (e) {
      throw console.error(e), new errors_1.AuthRetryableFetchError(_getErrorMessage(e), 0);
    }
    result.ok || await handleError(result);
    if (null === options || void 0 === options ? 0 : options.noResolveJson) {
      return result;
    }
    try {
      return await result.json();
    } catch (e) {
      await handleError(e);
    }
  }
  function _sessionResponse(data) {
    var _a;
    let session = null;
    data.access_token && data.refresh_token && data.expires_in && (session = Object.assign({}, data), data.expires_at || (session.expires_at = (0,helpers_1.expiresAt)(data.expires_in)));
    const user = null !== (_a = data.user) && void 0 !== _a ? _a : data;
    return {data:{session, user}, error:null};
  }
  var __rest = this && this.__rest || function(s, e) {
    var t = {}, p;
    for (p in s) {
      Object.prototype.hasOwnProperty.call(s, p) && 0 > e.indexOf(p) && (t[p] = s[p]);
    }
    if (null != s && "function" === typeof Object.getOwnPropertySymbols) {
      var i = 0;
      for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        0 > e.indexOf(p[i]) && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
      }
    }
    return t;
  };
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports._noResolveJsonResponse = exports._generateLinkResponse = exports._ssoResponse = exports._userResponse = exports._sessionResponsePassword = exports._sessionResponse = exports._request = exports.handleError = void 0;
  const constants_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$constants"), helpers_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$helpers"), errors_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$errors"), _getErrorMessage = err => err.msg || err.message || err.error_description || err.error || JSON.stringify(err), NETWORK_ERROR_CODES = [502, 503, 504];
  exports.handleError = handleError;
  exports._request = async function(fetcher, method, url, options) {
    var _a;
    const headers = Object.assign({}, null === options || void 0 === options ? void 0 : options.headers);
    headers[constants_1.API_VERSION_HEADER_NAME] || (headers[constants_1.API_VERSION_HEADER_NAME] = constants_1.API_VERSIONS["2024-01-01"].name);
    if (null === options || void 0 === options ? 0 : options.jwt) {
      headers.Authorization = `Bearer ${options.jwt}`;
    }
    const qs = null !== (_a = null === options || void 0 === options ? void 0 : options.query) && void 0 !== _a ? _a : {};
    if (null === options || void 0 === options ? 0 : options.redirectTo) {
      qs.redirect_to = options.redirectTo;
    }
    _a = Object.keys(qs).length ? "?" + (new URLSearchParams(qs)).toString() : "";
    fetcher = await _handleRequest(fetcher, method, url + _a, {headers, noResolveJson:null === options || void 0 === options ? void 0 : options.noResolveJson}, {}, null === options || void 0 === options ? void 0 : options.body);
    return (null === options || void 0 === options ? 0 : options.xform) ? null === options || void 0 === options ? void 0 : options.xform(fetcher) : {data:Object.assign({}, fetcher), error:null};
  };
  exports._sessionResponse = _sessionResponse;
  exports._sessionResponsePassword = function(data) {
    const response = _sessionResponse(data);
    !response.error && data.weak_password && "object" === typeof data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && "string" === typeof data.weak_password.message && data.weak_password.reasons.reduce((a, i) => a && "string" === typeof i, !0) && (response.data.weak_password = data.weak_password);
    return response;
  };
  exports._userResponse = function(data) {
    var _a;
    return {data:{user:null !== (_a = data.user) && void 0 !== _a ? _a : data}, error:null};
  };
  exports._ssoResponse = function(data) {
    return {data, error:null};
  };
  exports._generateLinkResponse = function(data) {
    const {action_link, email_otp, hashed_token, redirect_to, verification_type} = data;
    var rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
    data = {action_link, email_otp, hashed_token, redirect_to, verification_type};
    rest = Object.assign({}, rest);
    return {data:{properties:data, user:rest}, error:null};
  };
  exports._noResolveJsonResponse = function(data) {
    return data;
  };
};

//# sourceMappingURL=module$node_modules$$supabase$auth_js$dist$main$lib$fetch.js.map
