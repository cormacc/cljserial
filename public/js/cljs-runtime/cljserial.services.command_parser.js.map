{"version":3,"sources":["cljserial/services/command_parser.cljs"],"mappings":";AAgBA,gDAAA,hDAAOA,wGAAaC,SAASC;AAA7B,AACE,OAACC,gBAAM,+CAAA,WAAAC,1DAACC;AAAD,AAAS,OAACC,qBAAW,AAAA,yFAAAF,kBAAaF;GAASD;;AAGpD,2DAAA,3DAAMM,8HAAwBC;AAA9B,AACE,IAAAC,WAAA;IAAAC,WAECG;IAFDF,WAGC,WAAAG,SAAAC;AAAA,AAAA,IAAAC,aAAAF;IAAAE,iBAAA,AAAAC,4BAAAD;SAAA,AAAAE,4CAAAF,eAAA,hEAAaK;gBAAb,AAAAH,4CAAAF,eAAA,vEAAgBM;IAAhBH,aAAAJ;QAAA,AAAAK,4CAAAD,WAAA,IAAA,/DAA8BI;YAA9B,AAAAH,4CAAAD,WAAA,IAAA,nEAAgCI;AAAhC,AAEE,IAAAC,gNAA8BH,xBACA,oBAAA,pBAACK,7DACD,AAACC,4CAAIC,1JACL,4CAAA,5CAACD;cAH/B,AAAAP,4CAAAI,WAAA,IAAA,rEAAOtB;eAAP,AAAAkB,4CAAAI,WAAA,IAAA,tEAAeC;IAKTI,qBAAa,CAACrB,wDAAAA,0EAAAA,pBAAkBN,uDAAAA,/CAAQuB,uDAAAA;AAL9C,AAAA,kDAAA,kDAAA,mFAQQ,sCAAA,AAAA,mFAAA,6DAAA,mFAAA,6EAAA,2CAAA,wEAAA,mEAAA,+FAAA,zlBAAMI,6aACsCP,qEACFpB,sEACCuB;;AAhBtD,AAAA,0IAAAhB,SAAAC,SAAAC,yDAAAF,SAAAC,SAAAC,/NAACC,kEAAAA,8FAAAA;;AAiCH,iDAAA,jDAAMkB,0GAAc7B,SAAS8B;AAA7B,AACE,IAAAC,WAAA;IAAAC,WAAA,mFAEE,iBAAAG,WAAA,mFAAYL;AAAZ,AAAA,0HAAAK,iDAAAA,nKAACC,0DAAAA,oEAAAA;;IAFHH,WAGC,cAAAI,HAAKjB;AAAL,AAAA,IAAAkB,aAAAD;QAAA,AAAAlB,4CAAAmB,WAAA,IAAA,/DAAShB;gBAAT,AAAAH,4CAAAmB,WAAA,IAAA,vEAAWC;AAAX,AACE,IAAAC,aAAiCD;IAAjCC,iBAAA,AAAAxB,4BAAAwB;cAAA,AAAAvB,4CAAAuB,eAAA,rEAAcvC;eAAd,AAAAgB,4CAAAuB,eAAA,tEAAsBhB;IAChBiB,WAAS,AAAA,qFAAQxC;IACjByC,YAAU,AAAA,qFAAQlB;IAClBmB,cAAY,AAAC5C,8CAAYC,SAASyC;IAElCG,YAAU,+BAAA,bAAMD,aAAY,iBAAAE,eAAC,AAAA,0GAAkBF;AAAnB,AAAA,QAAAE,6CAAAA,2DAAAA,hBAAgCzB,wCAAAA,rCAAGsB,wCAAAA;KAArD;AALhB,AAOE,IAAAI,mBAAIF;AAAJ,AAAA,oBAAAE;AAAAA;;AAAc1B;;;AAXnB,AAAA,0IAAAW,SAAAC,SAAAC,yDAAAF,SAAAC,SAAAC,/NAACC,kEAAAA,8FAAAA","names":["cljserial.services.command-parser/get-handler","handlers","command","cljs.core/first","p1__56665#","cljs.core.filter","cljs.core/re-matches","cljserial.services.command-parser/set-exchange-tokeniser","command-complete?","G__56675","G__56676","G__56677","cljserial.utils.dbfx/reg-event-fx","cljserial.services.webserial/serial-event-interceptors","p__56681","p__56682","map__56683","cljs.core/--destructure-map","cljs.core.get","vec__56684","cljs.core.nth","db","timestamp","_","vec__56687","response","cljs.core/take-last","cljs.core.map","cljs.core/second","is-complete?","cljserial.services.command-parser/set-handlers","db-path-base","G__56704","G__56705","G__56706","cljserial.utils.dbfx/reg-event-db","G__56707","cljserial.utils.dbfx/path","p__56712","vec__56715","new-entry","map__56725","cmd-text","resp-text","cmd-handler","db-update","fexpr__56726","or__5045__auto__"],"sourcesContent":["(ns cljserial.services.command-parser\n  (:require\n   [malli.core :as m]\n   [lambdaisland.glogi :as log]\n   [cljserial.utils.dbfx :as dbfx]\n   [cljserial.utils.term :as term]\n   [cljserial.services.webserial :as wss]))\n\n\n;;---------------------------------------------------------------------------------------\n;; Schema\n;; .... see cljserial.utils.term\n\n;;---------------------------------------------------------------------------------------\n;; Implementation\n\n(defn- get-handler [handlers command]\n  (first (filter #(re-matches (:matcher %) command) handlers)))\n\n;; 1. When webserial module announces new data received, identify/announce a completed command/response transaction\n(defn set-exchange-tokeniser [command-complete?]\n  (dbfx/reg-event-fx\n   :webserial-rx ;;FIXME: Hard coded assumption that we're only handling webserial events -- allow for bluetooth, most likely by adding event id as an input parameter\n   wss/serial-event-interceptors\n   (fn [{:keys [db timestamp]}  [_ _]]\n     ;; 1. Construct a command-response pair from the last two serial events...\n     (let [[command response] (->> db\n                                   (take-last 2) ;; ... last two event map entries (each of form [<key>timestamp <value>event]\n                                   (map second)  ;; ... discard the key\n                                   (map :event-data)) ;; ... and dig into event data\n           ;; 2. Check if the response is complete using the provided callback fn\n           is-complete? (command-complete? command response)]\n       ;; 3. If complete, publish the command-response pair for downstream parsing\n       ;;    This uses the :dispatch coeffect built-in to refx (and also reframe)\n       {:fx [(when is-complete?\n               [:dispatch [:command-response {:timestamp timestamp\n                                              :command command\n                                              :response response}]])]}))))\n\n;; FIXME: Can't have two handlers for same event\n;; If we want this, rework so that this is the event handler and the parser subscribes\n;; to the history db....\n;; 2 (optional). When a command/response pair is announced, append it to the command history\n;; (defn retain-history []\n;;   (dbfx/reg-event-db\n;;    :command-response\n;;    [(dbfx/path [:command-history])]\n;;    (fn [history [_ new-entry]]\n;;      {:pre [(m/validate Exchange new-entry)]}\n;;      (log/info :model/command-history new-entry)\n;;      (assoc history (:timestamp new-entry) new-entry))))\n\n;; 3. When a command/response pair is announced, look up a handler to parse the response and\n;;    update application state\n(defn set-handlers [handlers db-path-base]\n  (dbfx/reg-event-db\n   :command-response\n   [(dbfx/path [db-path-base])]\n   (fn [db [_ new-entry]]\n     (let [{:keys [command response]} new-entry\n           cmd-text (:bytes command)\n           resp-text (:bytes response)\n           cmd-handler (get-handler handlers cmd-text)\n           ;;TODO: Implement support for the :db-subpath entry of the handler map\n           db-update (when cmd-handler ((:response-parser cmd-handler) db resp-text))]\n       ;; return updated db, but only if non-nil\n       (or db-update db)))))\n"]}