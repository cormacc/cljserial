{"version":3,"sources":["stack/services/command_parser.cljs"],"mappings":";AAaA,4CAAA,5CAAOA,gGAAaC,SAASC;AAA7B,AACE,OAACC,gBAAM,+CAAA,WAAAC,1DAACC;AAAD,AAAS,OAACC,qBAAW,AAAA,yFAAAF,kBAAaF;GAASD;;AAGpD,uDAAA,vDAAMM,sHAAwBC;AAA9B,AACE,IAAAC,WAAA;IAAAC,WAAA,yGAAA,mFAAA,4DAAA,rKAGEG;IAHFF,WAIC,WAAAG,SAAAC;AAAA,AAAA,IAAAC,aAAAF;IAAAE,iBAAA,AAAAC,4BAAAD;SAAA,AAAAE,4CAAAF,eAAA,hEAAaK;gBAAb,AAAAH,4CAAAF,eAAA,vEAAgBM;IAAhBH,aAAAJ;QAAA,AAAAK,4CAAAD,WAAA,IAAA,/DAA8BI;YAA9B,AAAAH,4CAAAD,WAAA,IAAA,nEAAgCI;AAAhC,AAEE,IAAAC,gNAA8BH,xBACA,oBAAA,pBAACK,7DACD,AAACC,4CAAIC,1JACL,4CAAA,5CAACD;cAH/B,AAAAP,4CAAAI,WAAA,IAAA,rEAAOtB;eAAP,AAAAkB,4CAAAI,WAAA,IAAA,tEAAeC;IAKTI,qBAAa,CAACrB,wDAAAA,0EAAAA,pBAAkBN,uDAAAA,/CAAQuB,uDAAAA;AAL9C,AAAA,kDAAA,kDAAA,mFAQQ,sCAAA,AAAA,mFAAA,6DAAA,mFAAA,6EAAA,2CAAA,wEAAA,mEAAA,+FAAA,zlBAAMI,6aACsCP,qEACFpB,sEACCuB;;AAjBtD,AAAA,kIAAAhB,SAAAC,SAAAC,qDAAAF,SAAAC,SAAAC,nNAACC,8DAAAA,0FAAAA;;AAkCH,6CAAA,7CAAMkB,kGAAc7B,SAAS8B;AAA7B,AACE,IAAAC,WAAA;IAAAC,WAAA,mFAEE,iBAAAG,WAAA,mFAAYL;AAAZ,AAAA,kHAAAK,6CAAAA,vJAACvB,sDAAAA,gEAAAA;;IAFHqB,WAGC,cAAAG,HAAKhB;AAAL,AAAA,IAAAiB,aAAAD;QAAA,AAAAjB,4CAAAkB,WAAA,IAAA,/DAASf;gBAAT,AAAAH,4CAAAkB,WAAA,IAAA,vEAAWC;AAAX,AACE,IAAAC,aAAiCD;IAAjCC,iBAAA,AAAAvB,4BAAAuB;cAAA,AAAAtB,4CAAAsB,eAAA,rEAActC;eAAd,AAAAgB,4CAAAsB,eAAA,tEAAsBf;IAChBgB,WAAS,AAAA,qFAAQvC;IACjBwC,YAAU,AAAA,qFAAQjB;IAClBkB,cAAY,AAAC3C,0CAAYC,SAASwC;IAElCG,YAAU,+BAAA,bAAMD,aAAY,iBAAAE,eAAC,AAAA,0GAAkBF;AAAnB,AAAA,QAAAE,6CAAAA,2DAAAA,hBAAgCxB,wCAAAA,rCAAGqB,wCAAAA;KAArD;AALhB,AAOE,IAAAI,mBAAIF;AAAJ,AAAA,oBAAAE;AAAAA;;AAAczB;;;AAXnB,AAAA,kIAAAW,SAAAC,SAAAC,qDAAAF,SAAAC,SAAAC,nNAACC,8DAAAA,0FAAAA","names":["stack.services.command-parser/get-handler","handlers","command","cljs.core/first","p1__94494#","cljs.core.filter","cljs.core/re-matches","stack.services.command-parser/set-exchange-tokeniser","command-complete?","G__94502","G__94503","G__94504","stack.utils.dbfx/reg-event-fx","stack.utils.dbfx/path","p__94506","p__94507","map__94508","cljs.core/--destructure-map","cljs.core.get","vec__94509","cljs.core.nth","db","timestamp","_","vec__94513","response","cljs.core/take-last","cljs.core.map","cljs.core/second","is-complete?","stack.services.command-parser/set-handlers","db-path-base","G__94522","G__94523","G__94524","stack.utils.dbfx/reg-event-db","G__94525","p__94530","vec__94532","new-entry","map__94535","cmd-text","resp-text","cmd-handler","db-update","fexpr__94537","or__5002__auto__"],"sourcesContent":["(ns stack.services.command-parser\n  (:require\n   [taoensso.telemere :as t]\n   [malli.core :as m]\n   [stack.utils.dbfx :as dbfx]))\n\n;;---------------------------------------------------------------------------------------\n;; Schema\n;; .... see stack.utils.term\n\n;;---------------------------------------------------------------------------------------\n;; Implementation\n\n(defn- get-handler [handlers command]\n  (first (filter #(re-matches (:matcher %) command) handlers)))\n\n;; 1. When webserial module announces new data received, identify/announce a completed command/response transaction\n(defn set-exchange-tokeniser [command-complete?]\n  (dbfx/reg-event-fx\n   :webserial-rx ;;FIXME: Hard coded assumption that we're only handling webserial events -- allow for bluetooth, most likely by adding event id as an input parameter\n   ;; wss/serial-event-interceptors\n   [dbfx/path [:services :webserial]]\n   (fn [{:keys [db timestamp]}  [_ _]]\n     ;; 1. Construct a command-response pair from the last two serial events...\n     (let [[command response] (->> db\n                                   (take-last 2) ;; ... last two event map entries (each of form [<key>timestamp <value>event]\n                                   (map second)  ;; ... discard the key\n                                   (map :event-data)) ;; ... and dig into event data\n           ;; 2. Check if the response is complete using the provided callback fn\n           is-complete? (command-complete? command response)]\n       ;; 3. If complete, publish the command-response pair for downstream parsing\n       ;;    This uses the :dispatch effect built-in to refx (and also reframe)\n       {:fx [(when is-complete?\n               [:dispatch [:command-response {:timestamp timestamp\n                                              :command command\n                                              :response response}]])]}))))\n\n;; FIXME: Can't have two handlers for same event\n;; If we want this, rework so that this is the event handler and the parser subscribes\n;; to the history db....\n;; 2 (optional). When a command/response pair is announced, append it to the command history\n;; (defn retain-history []\n;;   (dbfx/reg-event-db\n;;    :command-response\n;;    [(dbfx/path [:command-history])]\n;;    (fn [history [_ new-entry]]\n;;      {:pre [(m/validate Exchange new-entry)]}\n;;      (t/log! :info (str new-entry))\n;;      (assoc history (:timestamp new-entry) new-entry))))\n\n;; 3. When a command/response pair is announced, look up a handler to parse the response and\n;;    update application state\n(defn set-handlers [handlers db-path-base]\n  (dbfx/reg-event-db\n   :command-response\n   [(dbfx/path [db-path-base])]\n   (fn [db [_ new-entry]]\n     (let [{:keys [command response]} new-entry\n           cmd-text (:bytes command)\n           resp-text (:bytes response)\n           cmd-handler (get-handler handlers cmd-text)\n           ;;TODO: Implement support for the :db-subpath entry of the handler map\n           db-update (when cmd-handler ((:response-parser cmd-handler) db resp-text))]\n       ;; return updated db, but only if non-nil\n       (or db-update db)))))\n"]}